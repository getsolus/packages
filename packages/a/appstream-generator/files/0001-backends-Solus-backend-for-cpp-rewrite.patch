From 4576aeec0972f053833dba48b19288e3e4eaee8c Mon Sep 17 00:00:00 2001
From: Joey Riches <josephriches@gmail.com>
Date: Wed, 17 Sep 2025 13:47:40 +0100
Subject: [PATCH 1/1] backends: WIP Solus backend for cpp rewrite

---
 src/backends/meson.build             |   1 +
 src/backends/solus/eopkgpkg.cpp      | 504 +++++++++++++++++++++++++++
 src/backends/solus/eopkgpkg.h        | 108 ++++++
 src/backends/solus/eopkgpkgindex.cpp | 423 ++++++++++++++++++++++
 src/backends/solus/eopkgpkgindex.h   |  99 ++++++
 src/backends/solus/meson.build       |   6 +
 src/config.cpp                       |   4 +
 src/config.h                         |   3 +-
 src/engine.cpp                       |   4 +
 9 files changed, 1151 insertions(+), 1 deletion(-)
 create mode 100644 src/backends/solus/eopkgpkg.cpp
 create mode 100644 src/backends/solus/eopkgpkg.h
 create mode 100644 src/backends/solus/eopkgpkgindex.cpp
 create mode 100644 src/backends/solus/eopkgpkgindex.h
 create mode 100644 src/backends/solus/meson.build

diff --git a/src/backends/meson.build b/src/backends/meson.build
index a412424..1cce1ac 100644
--- a/src/backends/meson.build
+++ b/src/backends/meson.build
@@ -9,3 +9,4 @@ subdir('alpinelinux')
 subdir('archlinux')
 subdir('rpmmd')
 subdir('freebsd')
+subdir('solus')
diff --git a/src/backends/solus/eopkgpkg.cpp b/src/backends/solus/eopkgpkg.cpp
new file mode 100644
index 0000000..1d0f1c1
--- /dev/null
+++ b/src/backends/solus/eopkgpkg.cpp
@@ -0,0 +1,504 @@
+/*
+ * Copyright (C) 2025 Solus Developers <copyright@getsol.us>
+ *
+ * Licensed under the GNU Lesser General Public License Version 3
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the license, or
+ * (at your option) any later version.
+ *
+ * This software is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this software.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "eopkgpkg.h"
+
+#include <random>
+#include <filesystem>
+#include <cstring>
+
+#include <libxml/parser.h>
+
+#include "../../config.h"
+#include "../../logging.h"
+#include "../../zarchive.h"
+#include "../../downloader.h"
+#include "../../utils.h"
+#include "../../utils.h"
+
+namespace ASGenerator
+{
+
+namespace fs = std::filesystem;
+
+static std::string getXmlStrAttr(xmlNodePtr elem, const std::string &name)
+{
+    if (!elem || !elem->properties)
+        return {};
+
+    for (xmlAttrPtr attr = elem->properties; attr; attr = attr->next) {
+        if (attr->name && std::strcmp(reinterpret_cast<const char *>(attr->name), name.c_str()) == 0) {
+            if (attr->children && attr->children->content)
+                return reinterpret_cast<const char *>(attr->children->content);
+        }
+    }
+    return {};
+}
+
+static std::string getXmlElemText(xmlNodePtr elem)
+{
+    if (!elem)
+        return {};
+
+    for (xmlNodePtr child = elem->children; child; child = child->next) {
+        if (child->type == XML_TEXT_NODE && child->content)
+            return reinterpret_cast<const char *>(child->content);
+    }
+    return {};
+}
+
+EopkgPackage::EopkgPackage()
+    : m_metadataExtracted(false)
+{
+}
+
+EopkgPackage::~EopkgPackage()
+{
+    finish();
+}
+
+std::string EopkgPackage::name() const
+{
+    return m_pkgname;
+}
+
+std::string EopkgPackage::ver() const
+{
+    return m_pkgver;
+}
+
+std::string EopkgPackage::arch() const
+{
+    return m_pkgarch;
+}
+
+std::string EopkgPackage::maintainer() const
+{
+    return m_pkgmaintainer;
+}
+
+const std::unordered_map<std::string, std::string> &EopkgPackage::description() const
+{
+    return m_description;
+}
+
+const std::unordered_map<std::string, std::string> &EopkgPackage::summary() const
+{
+    return m_summary;
+}
+
+void EopkgPackage::setName(const std::string &s)
+{
+    m_pkgname = s;
+}
+
+void EopkgPackage::setVersion(const std::string &s)
+{
+    m_pkgver = s;
+}
+
+void EopkgPackage::setArch(const std::string &s)
+{
+    m_pkgarch = s;
+}
+
+void EopkgPackage::setMaintainer(const std::string &maint)
+{
+    m_pkgmaintainer = maint;
+}
+
+void EopkgPackage::setFilename(const std::string &fname)
+{
+    m_pkgFname = fname;
+}
+
+void EopkgPackage::setDescription(const std::string &text, const std::string &locale)
+{
+    m_description[locale] = text;
+}
+
+void EopkgPackage::setSummary(const std::string &text, const std::string &locale)
+{
+    m_summary[locale] = text;
+}
+
+void EopkgPackage::setContents(const std::vector<std::string> &contents)
+{
+    m_contentsL = contents;
+}
+
+std::string EopkgPackage::downloadIfNecessary()
+{
+    if (!m_localPkgFname.empty())
+        return m_localPkgFname;
+
+    if (Utils::isRemote(m_pkgFname)) {
+        std::lock_guard<std::mutex> lock(m_mutex);
+        const auto &conf = Config::get();
+        auto &dl = Downloader::get();
+
+        // Handle eopkg format: name-version-release-distribution-arch.eopkg
+        // Format a temporary filename that keeps the package identity but is unique
+        fs::path path = fs::path(conf.getTmpDir()) / (m_pkgname + "-" + m_pkgver + "-1-1-" + m_pkgarch + ".eopkg.tmp");
+
+        try {
+            dl.downloadFile(m_pkgFname, path.string());
+        } catch (const std::exception &e) {
+            logError("Unable to download: {}, reason {}", m_pkgFname, e.what());
+            throw;
+        }
+        m_localPkgFname = path.string();
+        return m_localPkgFname;
+    } else {
+        m_localPkgFname = m_pkgFname;
+        return m_pkgFname;
+    }
+}
+
+std::string EopkgPackage::getFilename()
+{
+    return downloadIfNecessary();
+}
+
+void EopkgPackage::extractMetadata()
+{
+    if (m_metadataExtracted)
+        return;
+
+    if (!m_archive) {
+        m_archive = std::make_unique<ArchiveDecompressor>();
+        m_archive->open(getFilename());
+    }
+
+    try {
+        // Get the metadata XML
+        auto metadataXml = m_archive->readData("metadata.xml");
+        auto filesXml = m_archive->readData("files.xml");
+
+        // Parse the metadata using libxml2
+        xmlDocPtr metadataDoc = xmlParseMemory(reinterpret_cast<const char*>(metadataXml.data()), static_cast<int>(metadataXml.size()));
+        if (!metadataDoc) {
+            throw std::runtime_error("Failed to parse metadata.xml");
+        }
+
+        xmlDocPtr filesDoc = xmlParseMemory(reinterpret_cast<const char*>(filesXml.data()), static_cast<int>(filesXml.size()));
+        if (!filesDoc) {
+            xmlFreeDoc(metadataDoc);
+            throw std::runtime_error("Failed to parse files.xml");
+        }
+
+        // Check for PISI root element
+        xmlNodePtr pisiNode = xmlDocGetRootElement(metadataDoc);
+        if (!pisiNode || std::strcmp(reinterpret_cast<const char *>(pisiNode->name), "PISI") != 0) {
+            xmlFreeDoc(metadataDoc);
+            xmlFreeDoc(filesDoc);
+            throw std::runtime_error("PISI root element not found in metadata.xml");
+        }
+
+        // Extract package information - find the Package node
+        xmlNodePtr packageNode = nullptr;
+        for (xmlNodePtr node = pisiNode->children; node; node = node->next) {
+            if (node->type == XML_ELEMENT_NODE && std::strcmp(reinterpret_cast<const char *>(node->name), "Package") == 0) {
+                packageNode = node;
+                break;
+            }
+        }
+
+        if (!packageNode) {
+            xmlFreeDoc(metadataDoc);
+            xmlFreeDoc(filesDoc);
+            throw std::runtime_error("Package node not found in metadata.xml");
+        }
+
+        // Try to get the maintainer information from the package's Source section first
+        xmlNodePtr sourceNode = nullptr;
+        for (xmlNodePtr node = packageNode->children; node; node = node->next) {
+            if (node->type == XML_ELEMENT_NODE && std::strcmp(reinterpret_cast<const char *>(node->name), "Source") == 0) {
+                sourceNode = node;
+                break;
+            }
+        }
+
+        if (sourceNode) {
+            xmlNodePtr packagerNode = nullptr;
+            for (xmlNodePtr node = sourceNode->children; node; node = node->next) {
+                if (node->type == XML_ELEMENT_NODE && std::strcmp(reinterpret_cast<const char *>(node->name), "Packager") == 0) {
+                    packagerNode = node;
+                    break;
+                }
+            }
+            if (packagerNode) {
+                for (xmlNodePtr node = packagerNode->children; node; node = node->next) {
+                    if (node->type == XML_ELEMENT_NODE && std::strcmp(reinterpret_cast<const char *>(node->name), "Email") == 0) {
+                        std::string email = getXmlElemText(node);
+                        if (!email.empty()) {
+                            setMaintainer(email);
+                        }
+                        break;
+                    }
+                }
+            }
+        }
+
+        // If maintainer wasn't found, try the top-level Source element
+        if (m_pkgmaintainer.empty()) {
+            for (xmlNodePtr node = pisiNode->children; node; node = node->next) {
+                if (node->type == XML_ELEMENT_NODE && std::strcmp(reinterpret_cast<const char *>(node->name), "Source") == 0) {
+                    sourceNode = node;
+                    break;
+                }
+            }
+            if (sourceNode) {
+                xmlNodePtr packagerNode = nullptr;
+                for (xmlNodePtr node = sourceNode->children; node; node = node->next) {
+                    if (node->type == XML_ELEMENT_NODE && std::strcmp(reinterpret_cast<const char *>(node->name), "Packager") == 0) {
+                        packagerNode = node;
+                        break;
+                    }
+                }
+                if (packagerNode) {
+                    for (xmlNodePtr node = packagerNode->children; node; node = node->next) {
+                        if (node->type == XML_ELEMENT_NODE && std::strcmp(reinterpret_cast<const char *>(node->name), "Email") == 0) {
+                            std::string email = getXmlElemText(node);
+                            if (!email.empty()) {
+                                setMaintainer(email);
+                            }
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+
+        // Default maintainer if still not found
+        if (m_pkgmaintainer.empty()) {
+            setMaintainer("solus@getsol.us");
+        }
+
+        // Get name, version, and architecture
+        for (xmlNodePtr node = packageNode->children; node; node = node->next) {
+            if (node->type != XML_ELEMENT_NODE)
+                continue;
+
+            const char* nodeName = reinterpret_cast<const char *>(node->name);
+            if (std::strcmp(nodeName, "Name") == 0) {
+                std::string name = getXmlElemText(node);
+                if (!name.empty()) {
+                    setName(name);
+                }
+            } else if (std::strcmp(nodeName, "History") == 0) {
+                // Find the first Update element
+                for (xmlNodePtr updateNode = node->children; updateNode; updateNode = updateNode->next) {
+                    if (updateNode->type == XML_ELEMENT_NODE && std::strcmp(reinterpret_cast<const char *>(updateNode->name), "Update") == 0) {
+                        std::string release = getXmlStrAttr(updateNode, "release");
+                        if (release.empty()) release = "1";
+
+                        // Find Version element
+                        for (xmlNodePtr versionNode = updateNode->children; versionNode; versionNode = versionNode->next) {
+                            if (versionNode->type == XML_ELEMENT_NODE && std::strcmp(reinterpret_cast<const char *>(versionNode->name), "Version") == 0) {
+                                std::string version = getXmlElemText(versionNode);
+                                if (!version.empty()) {
+                                    setVersion(version + "-" + release);
+                                }
+                                break;
+                            }
+                        }
+                        break;
+                    }
+                }
+            } else if (std::strcmp(nodeName, "Architecture") == 0) {
+                std::string arch = getXmlElemText(node);
+                if (!arch.empty()) {
+                    setArch(arch);
+                }
+            } else if (std::strcmp(nodeName, "Summary") == 0) {
+                std::string lang = getXmlStrAttr(node, "xml:lang");
+                if (lang.empty()) lang = "en";
+                std::string summary = getXmlElemText(node);
+                if (!summary.empty()) {
+                    setSummary(summary, lang);
+                }
+            } else if (std::strcmp(nodeName, "Description") == 0) {
+                std::string lang = getXmlStrAttr(node, "xml:lang");
+                if (lang.empty()) lang = "en";
+                std::string description = getXmlElemText(node);
+                if (!description.empty()) {
+                    setDescription(description, lang);
+                }
+            }
+        }
+
+        // Extract file list from files.xml
+        xmlNodePtr filesRootNode = xmlDocGetRootElement(filesDoc);
+        if (!filesRootNode || std::strcmp(reinterpret_cast<const char *>(filesRootNode->name), "Files") != 0) {
+            xmlFreeDoc(metadataDoc);
+            xmlFreeDoc(filesDoc);
+            throw std::runtime_error("Files root element not found in files.xml");
+        }
+
+        std::vector<std::string> contents;
+        for (xmlNodePtr fileNode = filesRootNode->children; fileNode; fileNode = fileNode->next) {
+            if (fileNode->type == XML_ELEMENT_NODE && std::strcmp(reinterpret_cast<const char *>(fileNode->name), "File") == 0) {
+                // Find Path element
+                for (xmlNodePtr pathNode = fileNode->children; pathNode; pathNode = pathNode->next) {
+                    if (pathNode->type == XML_ELEMENT_NODE && std::strcmp(reinterpret_cast<const char *>(pathNode->name), "Path") == 0) {
+                        std::string path = getXmlElemText(pathNode);
+                        if (!path.empty()) {
+                            // Ensure path starts with a slash
+                            if (path[0] != '/') {
+                                path = "/" + path;
+                            }
+                            contents.push_back(path);
+                        }
+                        break;
+                    }
+                }
+            }
+        }
+
+        setContents(contents);
+        m_metadataExtracted = true;
+
+        xmlFreeDoc(metadataDoc);
+        xmlFreeDoc(filesDoc);
+
+    } catch (const std::exception &e) {
+        logError("Failed to parse eopkg metadata: {}", e.what());
+        throw;
+    }
+}
+
+const std::vector<std::string> &EopkgPackage::contents()
+{
+    if (m_contentsL.empty()) {
+        extractMetadata();
+    }
+    return m_contentsL;
+}
+
+std::vector<std::uint8_t> EopkgPackage::getFileData(const std::string &fname)
+{
+    if (!m_archive) {
+        m_archive = std::make_unique<ArchiveDecompressor>();
+        m_archive->open(getFilename());
+    }
+
+    try {
+        // All other files are in install.tar.xz
+        // We need to extract install.tar.xz and then read files from it
+        const auto &conf = Config::get();
+
+        // Generate a random number for unique temp directory
+        std::random_device rd;
+        std::mt19937 gen(rd());
+        std::uniform_int_distribution<int> dis(0, INT32_MAX);
+
+        fs::path tempDir = fs::path(conf.getTmpDir()) / ("eopkg-" + m_pkgname + "-" + m_pkgver + "-" + std::to_string(dis(gen)));
+
+        // Ensure temp dir exists
+        if (!fs::exists(tempDir)) {
+            fs::create_directories(tempDir);
+        }
+
+        // Use RAII for cleanup
+        struct TempDirCleanup {
+            fs::path path;
+            ~TempDirCleanup() {
+                try {
+                    if (fs::exists(path)) {
+                        fs::remove_all(path);
+                    }
+                } catch (...) {
+                    // Ignore cleanup errors
+                }
+            }
+        } cleanup{tempDir};
+
+        // Extract install.tar.xz to the temp directory
+        fs::path tarPath = tempDir / "install.tar.xz";
+        bool extracted = m_archive->extractFileTo("install.tar.xz", tarPath.string());
+        if (!extracted) {
+            logError("Failed to extract install.tar.xz from package");
+            return {};
+        }
+
+        // Open the extracted tarball
+        auto tarArchive = std::make_unique<ArchiveDecompressor>();
+        tarArchive->open(tarPath.string());
+
+        // Remove any leading slash in the file path
+        std::string actualPath = fname;
+        if (!actualPath.empty() && actualPath[0] == '/') {
+            actualPath = actualPath.substr(1);
+        }
+
+        // Try to read the file from the tarball
+        try {
+            return tarArchive->readData(actualPath);
+        } catch (const std::exception &e) {
+            logWarning("File '{}' not found in install.tar.xz: {}", actualPath, e.what());
+            return {};
+        }
+
+    } catch (const std::exception &e) {
+        logError("Failed to extract file '{}' from package: {}", fname, e.what());
+        return {};
+    }
+}
+
+void EopkgPackage::cleanupTemp()
+{
+    std::lock_guard<std::mutex> lock(m_mutex);
+    if (m_archive) {
+        m_archive.reset();
+    }
+}
+
+void EopkgPackage::cleanupTempDir(const fs::path &path)
+{
+    try {
+        if (fs::exists(path)) {
+            fs::remove_all(path);
+        }
+    } catch (const std::exception &e) {
+        // Ignore errors when cleaning up
+        logDebug("Unable to remove temporary directory: {} ({})", path.string(), e.what());
+    }
+}
+
+void EopkgPackage::finish()
+{
+    std::lock_guard<std::mutex> lock(m_mutex);
+    if (m_archive) {
+        m_archive.reset();
+    }
+
+    try {
+        if (Utils::isRemote(m_pkgFname) && !m_localPkgFname.empty() && fs::exists(m_localPkgFname)) {
+            logDebug("Deleting temporary package file {}", m_localPkgFname);
+            fs::remove(m_localPkgFname);
+            m_localPkgFname.clear();
+        }
+    } catch (const std::exception &e) {
+        // we ignore any error
+        logDebug("Unable to remove temporary package: {} ({})", m_localPkgFname, e.what());
+    }
+}
+
+} // namespace ASGenerator
diff --git a/src/backends/solus/eopkgpkg.h b/src/backends/solus/eopkgpkg.h
new file mode 100644
index 0000000..268a735
--- /dev/null
+++ b/src/backends/solus/eopkgpkg.h
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2025 Solus Developers <copyright@getsol.us>
+ *
+ * Licensed under the GNU Lesser General Public License Version 3
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the license, or
+ * (at your option) any later version.
+ *
+ * This software is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this software.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#pragma once
+
+#include <string>
+#include <vector>
+#include <unordered_map>
+#include <memory>
+#include <mutex>
+#include <optional>
+
+#include "../interfaces.h"
+#include "../../utils.h"
+
+namespace ASGenerator
+{
+
+class ArchiveDecompressor;
+
+/**
+ * Represents an eopkg package in the Solus distribution.
+ * An eopkg package is a zip archive that contains metadata.xml and files.xml
+ * describing the package, as well as an archive called install.tar.xz which contains the actual files.
+ */
+class EopkgPackage : public Package
+{
+public:
+    EopkgPackage();
+    ~EopkgPackage() override;
+
+    // Package interface implementation
+    std::string name() const override;
+    std::string ver() const override;
+    std::string arch() const override;
+    std::string maintainer() const override;
+
+    const std::unordered_map<std::string, std::string> &description() const override;
+    const std::unordered_map<std::string, std::string> &summary() const override;
+
+    std::string getFilename() override;
+    const std::vector<std::string> &contents() override;
+    std::vector<std::uint8_t> getFileData(const std::string &fname) override;
+
+    void cleanupTemp() override;
+    void finish() override;
+
+    // Eopkg-specific methods
+    void setName(const std::string &s);
+    void setVersion(const std::string &s);
+    void setArch(const std::string &s);
+    void setMaintainer(const std::string &maint);
+    void setFilename(const std::string &fname);
+    void setDescription(const std::string &text, const std::string &locale);
+    void setSummary(const std::string &text, const std::string &locale);
+    void setContents(const std::vector<std::string> &contents);
+
+    /**
+     * Extract and parse metadata from the eopkg file.
+     * In eopkg, the metadata is stored in metadata.xml and files.xml files in the root of the archive.
+     */
+    void extractMetadata();
+
+private:
+    std::string m_pkgname;
+    std::string m_pkgver;
+    std::string m_pkgarch;
+    std::string m_pkgmaintainer;
+    std::unordered_map<std::string, std::string> m_description;
+    std::unordered_map<std::string, std::string> m_summary;
+
+    std::string m_pkgFname;
+    std::string m_localPkgFname;
+    std::vector<std::string> m_contentsL;
+
+    std::unique_ptr<ArchiveDecompressor> m_archive;
+    bool m_metadataExtracted;
+
+    mutable std::mutex m_mutex;
+
+    /**
+     * Clean up a temporary directory, ignoring any errors
+     */
+    void cleanupTempDir(const fs::path &path);
+
+    /**
+     * Download package file if it's remote
+     */
+    std::string downloadIfNecessary();
+};
+
+} // namespace ASGenerator
diff --git a/src/backends/solus/eopkgpkgindex.cpp b/src/backends/solus/eopkgpkgindex.cpp
new file mode 100644
index 0000000..7711a0e
--- /dev/null
+++ b/src/backends/solus/eopkgpkgindex.cpp
@@ -0,0 +1,423 @@
+/*
+ * Copyright (C) 2025 Solus Developers <copyright@getsol.us>
+ *
+ * Licensed under the GNU Lesser General Public License Version 3
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the license, or
+ * (at your option) any later version.
+ *
+ * This software is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this software.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "eopkgpkgindex.h"
+#include "eopkgpkg.h"
+
+
+#include <fstream>
+#include <sstream>
+#include <filesystem>
+#include <iostream>
+#include <cstring>
+
+#include <libxml/parser.h>
+
+#include "../../config.h"
+#include "../../logging.h"
+#include "../../downloader.h"
+#include "../../zarchive.h"
+#include "../../datastore.h"
+
+namespace ASGenerator
+{
+
+namespace fs = std::filesystem;
+
+static std::string getXmlStrAttr(xmlNodePtr elem, const std::string &name)
+{
+    if (!elem || !elem->properties)
+        return {};
+
+    for (xmlAttrPtr attr = elem->properties; attr; attr = attr->next) {
+        if (attr->name && std::strcmp(reinterpret_cast<const char *>(attr->name), name.c_str()) == 0) {
+            if (attr->children && attr->children->content)
+                return reinterpret_cast<const char *>(attr->children->content);
+        }
+    }
+    return {};
+}
+
+static std::string getXmlElemText(xmlNodePtr elem)
+{
+    if (!elem)
+        return {};
+
+    for (xmlNodePtr child = elem->children; child; child = child->next) {
+        if (child->type == XML_TEXT_NODE && child->content)
+            return reinterpret_cast<const char *>(child->content);
+    }
+    return {};
+}
+
+EopkgPackageIndex::EopkgPackageIndex(const std::string &dir)
+    : m_rootDir(dir)
+{
+    if (!Utils::isRemote(dir) && !fs::exists(dir)) {
+        throw std::runtime_error("Directory '" + dir + "' does not exist.");
+    }
+
+    const auto &conf = Config::get();
+    m_tmpRootDir = (conf.getTmpDir() / fs::path(dir).filename()).string();
+}
+
+void EopkgPackageIndex::release()
+{
+    std::lock_guard<std::mutex> lock(m_mutex);
+    m_pkgCache.clear();
+}
+
+std::string EopkgPackageIndex::downloadIfNecessary(const std::string &fname, const std::string &tempDir)
+{
+    if (!Utils::isRemote(fname)) {
+        return fname;
+    }
+
+    const auto &conf = Config::get();
+    std::string actualTempDir = tempDir.empty() ? conf.getTmpDir().string() : tempDir;
+
+    if (!fs::exists(actualTempDir)) {
+        fs::create_directories(actualTempDir);
+    }
+
+    auto &dl = Downloader::get();
+    fs::path path = fs::path(actualTempDir) / fs::path(fname).filename();
+
+    try {
+        dl.downloadFile(fname, path.string());
+    } catch (const std::exception &e) {
+        logError("Unable to download: {}", e.what());
+        throw;
+    }
+
+    return path.string();
+}
+
+std::string EopkgPackageIndex::getIndexPath(const std::string &rootDir, const std::string &suite)
+{
+    std::string indexPath;
+
+    if (Utils::isRemote(rootDir)) {
+        // For remote repositories, prefer the compressed version to save bandwidth
+        indexPath = rootDir + "/" + suite + "/eopkg-index.xml.xz";
+    } else {
+        // For local repositories, try the uncompressed version first
+        indexPath = rootDir + "/" + suite + "/eopkg-index.xml";
+
+        // If the uncompressed file doesn't exist locally, try the compressed version
+        if (!fs::exists(indexPath)) {
+            indexPath = rootDir + "/" + suite + "/eopkg-index.xml.xz";
+        }
+    }
+    return indexPath;
+}
+
+std::string EopkgPackageIndex::getIndexContent(const std::string &indexFname)
+{
+    if (indexFname.ends_with(".xz")) {
+        return decompressFile(indexFname);
+    } else {
+        std::ifstream file(indexFname, std::ios::binary);
+        if (!file) {
+            throw std::runtime_error("Cannot open index file: " + indexFname);
+        }
+
+        std::ostringstream buffer;
+        buffer << file.rdbuf();
+        return buffer.str();
+    }
+}
+
+std::vector<std::shared_ptr<EopkgPackage>> EopkgPackageIndex::loadPackages(
+    const std::string &suite,
+    const std::string &section,
+    const std::string &arch)
+{
+    auto indexPath = getIndexPath(m_rootDir, suite);
+
+    std::string indexFname;
+    {
+        //std::lock_guard<std::mutex> lock(m_mutex);
+        indexFname = downloadIfNecessary(indexPath, m_tmpRootDir);
+    }
+
+    auto indexContent = getIndexContent(indexFname);
+
+    // Parse XML index file using libxml2
+    xmlDocPtr doc = xmlParseMemory(indexContent.c_str(), static_cast<int>(indexContent.length()));
+    if (!doc) {
+        logError("Failed to parse repository index XML");
+        return {};
+    }
+
+    std::vector<std::shared_ptr<EopkgPackage>> packages;
+
+    // Find PISI root element
+    xmlNodePtr pisiNode = xmlDocGetRootElement(doc);
+    if (!pisiNode || std::strcmp(reinterpret_cast<const char *>(pisiNode->name), "PISI") != 0) {
+        logError("Repository index does not contain a PISI root element");
+        xmlFreeDoc(doc);
+        return packages;
+    }
+
+    // Process all Package elements in the index
+    for (xmlNodePtr packageNode = pisiNode->children; packageNode; packageNode = packageNode->next) {
+        if (packageNode->type != XML_ELEMENT_NODE || std::strcmp(reinterpret_cast<const char *>(packageNode->name), "Package") != 0)
+            continue;
+
+        auto pkg = std::make_shared<EopkgPackage>();
+
+        // Extract basic package information
+        std::string currentPkgName;
+        xmlNodePtr nameNode = nullptr;
+
+        for (xmlNodePtr node = packageNode->children; node; node = node->next) {
+            if (node->type == XML_ELEMENT_NODE && std::strcmp(reinterpret_cast<const char *>(node->name), "Name") == 0) {
+                nameNode = node;
+                break;
+            }
+        }
+
+        if (nameNode) {
+            currentPkgName = getXmlElemText(nameNode);
+        }
+
+        if (currentPkgName.empty()) {
+            logWarning("Skipping package entry without a name.");
+            continue; // Cannot process without a name
+        }
+
+        // Optimization: Skip -devel and -dbginfo subpackages, they'll never contain anything
+        //               interesting.
+        if (currentPkgName.ends_with("-devel") || currentPkgName.ends_with("-dbginfo")) {
+            logDebug("Skipping development/debug package: {}", currentPkgName);
+            continue;
+        }
+
+        // Set the package name if it's not skipped
+        pkg->setName(currentPkgName);
+
+        // Process all child elements of the package
+        for (xmlNodePtr child = packageNode->children; child; child = child->next) {
+            if (child->type != XML_ELEMENT_NODE)
+                continue;
+
+            const char* childName = reinterpret_cast<const char *>(child->name);
+
+            if (std::strcmp(childName, "History") == 0) {
+                // Find the first Update element
+                for (xmlNodePtr updateNode = child->children; updateNode; updateNode = updateNode->next) {
+                    if (updateNode->type == XML_ELEMENT_NODE && std::strcmp(reinterpret_cast<const char *>(updateNode->name), "Update") == 0) {
+                        std::string release = getXmlStrAttr(updateNode, "release");
+                        if (release.empty()) release = "1";
+
+                        // Find Version element
+                        for (xmlNodePtr versionNode = updateNode->children; versionNode; versionNode = versionNode->next) {
+                            if (versionNode->type == XML_ELEMENT_NODE && std::strcmp(reinterpret_cast<const char *>(versionNode->name), "Version") == 0) {
+                                std::string version = getXmlElemText(versionNode);
+                                if (!version.empty()) {
+                                    pkg->setVersion(version + "-" + release);
+                                }
+                                break;
+                            }
+                        }
+                        break;
+                    }
+                }
+            } else if (std::strcmp(childName, "Architecture") == 0) {
+                std::string archStr = getXmlElemText(child);
+                if (!archStr.empty()) {
+                    pkg->setArch(archStr);
+                }
+            } else if (std::strcmp(childName, "PackageURI") == 0) {
+                std::string packageURI = getXmlElemText(child);
+                if (!packageURI.empty()) {
+                    // The PackageURI in eopkg-index.xml contains the relative path to the package
+                    // We need to preserve this path structure
+                    std::string pkgPath = m_rootDir + "/" + suite + "/" + packageURI;
+                    pkg->setFilename(pkgPath);
+                    logDebug("Package path: {}", pkgPath);
+                }
+            } else if (std::strcmp(childName, "Summary") == 0) {
+                std::string lang = getXmlStrAttr(child, "xml:lang");
+                if (lang.empty()) lang = "en";
+                std::string summary = getXmlElemText(child);
+                if (!summary.empty()) {
+                    pkg->setSummary(summary, lang);
+                }
+            } else if (std::strcmp(childName, "Description") == 0) {
+                std::string lang = getXmlStrAttr(child, "xml:lang");
+                if (lang.empty()) lang = "en";
+                std::string description = getXmlElemText(child);
+                if (!description.empty()) {
+                    pkg->setDescription(description, lang);
+                }
+            } else if (std::strcmp(childName, "Source") == 0) {
+                // Get maintainer information
+                xmlNodePtr packagerNode = nullptr;
+                for (xmlNodePtr node = child->children; node; node = node->next) {
+                    if (node->type == XML_ELEMENT_NODE && std::strcmp(reinterpret_cast<const char *>(node->name), "Packager") == 0) {
+                        packagerNode = node;
+                        break;
+                    }
+                }
+                if (packagerNode) {
+                    for (xmlNodePtr node = packagerNode->children; node; node = node->next) {
+                        if (node->type == XML_ELEMENT_NODE && std::strcmp(reinterpret_cast<const char *>(node->name), "Email") == 0) {
+                            std::string email = getXmlElemText(node);
+                            if (!email.empty()) {
+                                pkg->setMaintainer(email);
+                            }
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+
+        // Set default maintainer if not found
+        if (pkg->maintainer().empty()) {
+            pkg->setMaintainer("solus@getsol.us");
+        }
+
+        // Add the package to our list if it's valid
+        if (pkg->isValid()) {
+            packages.push_back(pkg);
+        } else {
+            logError("Found an invalid package entry for '{}' (name, architecture or version is missing). Skipping it.", pkg->name());
+        }
+    }
+
+    xmlFreeDoc(doc);
+    return packages;
+}
+
+std::vector<std::shared_ptr<Package>> EopkgPackageIndex::packagesFor(
+    const std::string &suite,
+    const std::string &section,
+    const std::string &arch,
+    bool withLongDescs)
+{
+    std::string id = suite + "-" + section + "-" + arch;
+
+    {
+        std::lock_guard<std::mutex> lock(m_mutex);
+        if (m_pkgCache.find(id) == m_pkgCache.end()) {
+            auto pkgs = loadPackages(suite, section, arch);
+            std::vector<std::shared_ptr<Package>> genericPkgs;
+            genericPkgs.reserve(pkgs.size());
+
+            for (auto &pkg : pkgs) {
+                genericPkgs.push_back(std::static_pointer_cast<Package>(pkg));
+            }
+
+            m_pkgCache[id] = std::move(genericPkgs);
+        }
+    }
+
+    return m_pkgCache[id];
+}
+
+std::shared_ptr<Package> EopkgPackageIndex::packageForFile(
+    const std::string &fname,
+    const std::string &suite,
+    const std::string &section)
+{
+    // Only handle .eopkg files
+    if (!fname.ends_with(".eopkg")) {
+        return nullptr;
+    }
+
+    if (!fs::exists(fname)) {
+        return nullptr;
+    }
+
+    try {
+        // Create a new package for this file
+        auto pkg = std::make_shared<EopkgPackage>();
+        pkg->setFilename(fname);
+
+        // Extract metadata to populate fields
+        pkg->extractMetadata();
+
+        return std::static_pointer_cast<Package>(pkg);
+    } catch (const std::exception &e) {
+        logError("Failed to process package file '{}': {}", fname, e.what());
+        return nullptr;
+    }
+}
+
+bool EopkgPackageIndex::hasChanges(
+    std::shared_ptr<DataStore> dstore,
+    const std::string &suite,
+    const std::string &section,
+    const std::string &arch)
+{
+    auto indexPath = getIndexPath(m_rootDir, suite);
+
+    std::string indexFname;
+    {
+        std::lock_guard<std::mutex> lock(m_mutex);
+        indexFname = downloadIfNecessary(indexPath, m_tmpRootDir);
+    }
+
+    auto indexContent = getIndexContent(indexFname);
+
+    // Get file modification time
+    auto ftime = fs::last_write_time(indexFname);
+    auto currentTime = std::chrono::duration_cast<std::chrono::seconds>(ftime.time_since_epoch()).count();
+
+    auto repoInfo = dstore->getRepoInfo(suite, section, arch);
+
+    // Check if we have stored mtime information
+    bool hasStoredMtime = false;
+    int64_t pastTime = 0;
+
+    try {
+        auto mtimeIt = repoInfo.data.find("mtime");
+        if (mtimeIt != repoInfo.data.end()) {
+            if (std::holds_alternative<std::int64_t>(mtimeIt->second)) {
+                pastTime = std::get<std::int64_t>(mtimeIt->second);
+                hasStoredMtime = true;
+            }
+        }
+    } catch (const std::exception &e) {
+        logDebug("Failed to parse stored mtime: {}", e.what());
+        hasStoredMtime = false;
+    }
+
+    // Update stored mtime
+    repoInfo.data["mtime"] = currentTime;
+    dstore->setRepoInfo(suite, section, arch, repoInfo);
+
+    if (!hasStoredMtime) {
+        m_indexChanged[indexFname] = true;
+        return true;
+    }
+
+    if (pastTime != currentTime) {
+        m_indexChanged[indexFname] = true;
+        return true;
+    }
+
+    m_indexChanged[indexFname] = false;
+    return false;
+}
+
+} // namespace ASGenerator
diff --git a/src/backends/solus/eopkgpkgindex.h b/src/backends/solus/eopkgpkgindex.h
new file mode 100644
index 0000000..9b4ec7c
--- /dev/null
+++ b/src/backends/solus/eopkgpkgindex.h
@@ -0,0 +1,99 @@
+/*
+ * Copyright (C) 2025 Solus Developers <copyright@getsol.us>
+ *
+ * Licensed under the GNU Lesser General Public License Version 3
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the license, or
+ * (at your option) any later version.
+ *
+ * This software is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this software.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#pragma once
+
+#include <string>
+#include <vector>
+#include <unordered_map>
+#include <memory>
+#include <mutex>
+
+#include "../interfaces.h"
+#include "../../utils.h"
+
+namespace ASGenerator
+{
+
+class EopkgPackage;
+
+/**
+ * Index implementation for Solus eopkg packages.
+ * The eopkg index is an XML file that lists all packages in a repository.
+ */
+class EopkgPackageIndex : public PackageIndex
+{
+public:
+    explicit EopkgPackageIndex(const std::string &dir);
+    ~EopkgPackageIndex() override = default;
+
+    // PackageIndex interface implementation
+    void release() override;
+
+    std::vector<std::shared_ptr<Package>> packagesFor(
+        const std::string &suite,
+        const std::string &section,
+        const std::string &arch,
+        bool withLongDescs = true) override;
+
+    std::shared_ptr<Package> packageForFile(
+        const std::string &fname,
+        const std::string &suite = "",
+        const std::string &section = "") override;
+
+    bool hasChanges(
+        std::shared_ptr<DataStore> dstore,
+        const std::string &suite,
+        const std::string &section,
+        const std::string &arch) override;
+
+private:
+    std::string m_rootDir;
+    std::string m_tmpRootDir;
+    std::unordered_map<std::string, std::vector<std::shared_ptr<Package>>> m_pkgCache;
+    std::unordered_map<std::string, bool> m_indexChanged;
+
+    mutable std::mutex m_mutex;
+
+    /**
+     * Download a file if it's remote, or return the local path if it's already local.
+     */
+    std::string downloadIfNecessary(const std::string &fname, const std::string &tempDir = "");
+
+    /**
+     * Get the path to the index file for a given suite
+     */
+    std::string getIndexPath(const std::string &rootDir, const std::string &suite);
+
+    /**
+     * Get the content of an index file, decompressing if necessary
+     */
+    std::string getIndexContent(const std::string &indexFname);
+
+    /**
+     * Load packages from the eopkg repository index.
+     * In Solus, the index is contained in an eopkg-index.xml.xz file.
+     */
+    std::vector<std::shared_ptr<EopkgPackage>> loadPackages(
+        const std::string &suite,
+        const std::string &section,
+        const std::string &arch);
+};
+
+} // namespace ASGenerator
\ No newline at end of file
diff --git a/src/backends/solus/meson.build b/src/backends/solus/meson.build
new file mode 100644
index 0000000..7f0be18
--- /dev/null
+++ b/src/backends/solus/meson.build
@@ -0,0 +1,6 @@
+backend_solus_src = files(
+  'eopkgpkg.cpp',
+  'eopkgpkgindex.cpp',
+)
+
+backends_src += backend_solus_src
diff --git a/src/config.cpp b/src/config.cpp
index 1ee92d8..5e4223a 100644
--- a/src/config.cpp
+++ b/src/config.cpp
@@ -300,6 +300,10 @@ void Config::loadFromFile(
         backendName = "FreeBSD";
         backend = Backend::FreeBSD;
         metadataType = DataType::XML;
+    } else if (backendId == "solus") {
+        backendName = "Solus";
+        backend = Backend::Solus;
+        metadataType = DataType::XML;
     }
 
     // override the backend's default metadata type if requested by user
diff --git a/src/config.h b/src/config.h
index ec5d5fe..d5ef183 100644
--- a/src/config.h
+++ b/src/config.h
@@ -79,7 +79,8 @@ enum class Backend {
     Archlinux,
     RpmMd,
     Alpinelinux,
-    FreeBSD
+    FreeBSD,
+    Solus
 };
 
 /**
diff --git a/src/engine.cpp b/src/engine.cpp
index 1722449..9974621 100644
--- a/src/engine.cpp
+++ b/src/engine.cpp
@@ -58,6 +58,7 @@
 #include "backends/archlinux/alpkgindex.h"
 #include "backends/rpmmd/rpmpkgindex.h"
 #include "backends/freebsd/fbsdpkgindex.h"
+#include "backends/solus/eopkgpkgindex.h"
 
 namespace ASGenerator
 {
@@ -96,6 +97,9 @@ Engine::Engine()
     case Backend::FreeBSD:
         m_pkgIndex = std::make_unique<FreeBSDPackageIndex>(m_conf->archiveRoot);
         break;
+    case Backend::Solus:
+        m_pkgIndex = std::make_unique<EopkgPackageIndex>(m_conf->archiveRoot);
+        break;
     default:
         throw std::runtime_error("No backend specified, can not continue!");
     }
-- 
2.52.0

