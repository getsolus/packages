From: Sergey Sharybin <sergey@blender.org>
Date: Thu, 3 Nov 2016 14:18:28 +0100
Subject: fix_OpenJPEG2_build

Temp branch for quick testing.
Keep this until OpenImageIO add support and
we can add the changes back to master.
---
 build_files/cmake/Modules/FindOpenJPEG.cmake |     5 +-
 extern/libopenjpeg/CMakeLists.txt            |    30 +-
 extern/libopenjpeg/bio.c                     |    95 +-
 extern/libopenjpeg/bio.h                     |    47 +-
 extern/libopenjpeg/cidx_manager.c            |   228 +-
 extern/libopenjpeg/cidx_manager.h            |    18 +-
 extern/libopenjpeg/cio.c                     |   704 +-
 extern/libopenjpeg/cio.h                     |   378 +-
 extern/libopenjpeg/dwt.c                     |   761 +-
 extern/libopenjpeg/dwt.h                     |    33 +-
 extern/libopenjpeg/event.c                   |    75 +-
 extern/libopenjpeg/event.h                   |    58 +-
 extern/libopenjpeg/fix.h                     |    64 -
 extern/libopenjpeg/function_list.c           |   119 +
 extern/libopenjpeg/function_list.h           |   131 +
 extern/libopenjpeg/image.c                   |   163 +-
 extern/libopenjpeg/image.h                   |    28 +-
 extern/libopenjpeg/indexbox_manager.h        |    44 +-
 extern/libopenjpeg/int.h                     |   119 -
 extern/libopenjpeg/invert.c                  |   294 +
 extern/libopenjpeg/invert.h                  |    64 +
 extern/libopenjpeg/j2k.c                     | 12514 ++++++++++++++++++++-----
 extern/libopenjpeg/j2k.h                     |   804 +-
 extern/libopenjpeg/j2k_lib.c                 |    59 -
 extern/libopenjpeg/j2k_lib.h                 |    54 -
 extern/libopenjpeg/jp2.c                     |  3331 +++++--
 extern/libopenjpeg/jp2.h                     |   485 +-
 extern/libopenjpeg/jpt.c                     |   155 -
 extern/libopenjpeg/jpt.h                     |    75 -
 extern/libopenjpeg/license.txt               |    30 -
 extern/libopenjpeg/mct.c                     |   249 +-
 extern/libopenjpeg/mct.h                     |    75 +-
 extern/libopenjpeg/mqc.c                     |   230 +-
 extern/libopenjpeg/mqc.h                     |    67 +-
 extern/libopenjpeg/openjpeg.c                |   951 +-
 extern/libopenjpeg/openjpeg.h                |  1289 ++-
 extern/libopenjpeg/opj_clock.c               |    64 +
 extern/libopenjpeg/opj_clock.h               |    59 +
 extern/libopenjpeg/opj_codec.h               |   165 +
 extern/libopenjpeg/opj_config.h              |    42 +-
 extern/libopenjpeg/opj_config_private.h      |     6 +
 extern/libopenjpeg/opj_includes.h            |    99 +-
 extern/libopenjpeg/opj_intmath.h             |   178 +
 extern/libopenjpeg/opj_inttypes.h            |    48 +
 extern/libopenjpeg/opj_malloc.h              |    20 +
 extern/libopenjpeg/opj_stdint.h              |    52 +
 extern/libopenjpeg/phix_manager.c            |   113 +-
 extern/libopenjpeg/pi.c                      |  2057 ++--
 extern/libopenjpeg/pi.h                      |   166 +-
 extern/libopenjpeg/ppix_manager.c            |   113 +-
 extern/libopenjpeg/raw.c                     |    28 +-
 extern/libopenjpeg/raw.h                     |    36 +-
 extern/libopenjpeg/t1.c                      |  2190 +++--
 extern/libopenjpeg/t1.h                      |    70 +-
 extern/libopenjpeg/t1_generate_luts.c        |   282 +
 extern/libopenjpeg/t1_luts.h                 |    14 +-
 extern/libopenjpeg/t2.c                      |  1973 ++--
 extern/libopenjpeg/t2.h                      |    86 +-
 extern/libopenjpeg/tcd.c                     |  3568 ++++---
 extern/libopenjpeg/tcd.h                     |   354 +-
 extern/libopenjpeg/tgt.c                     |   456 +-
 extern/libopenjpeg/tgt.h                     |    68 +-
 extern/libopenjpeg/thix_manager.c            |   102 +-
 extern/libopenjpeg/tpix_manager.c            |   164 +-
 source/blender/imbuf/intern/IMB_filetype.h   |     5 +-
 source/blender/imbuf/intern/filetype.c       |     2 +-
 source/blender/imbuf/intern/jp2.c            |   494 +-
 67 files changed, 26480 insertions(+), 10420 deletions(-)
 delete mode 100644 extern/libopenjpeg/fix.h
 create mode 100644 extern/libopenjpeg/function_list.c
 create mode 100644 extern/libopenjpeg/function_list.h
 delete mode 100644 extern/libopenjpeg/int.h
 create mode 100644 extern/libopenjpeg/invert.c
 create mode 100644 extern/libopenjpeg/invert.h
 delete mode 100644 extern/libopenjpeg/j2k_lib.c
 delete mode 100644 extern/libopenjpeg/j2k_lib.h
 delete mode 100644 extern/libopenjpeg/jpt.c
 delete mode 100644 extern/libopenjpeg/jpt.h
 delete mode 100644 extern/libopenjpeg/license.txt
 create mode 100644 extern/libopenjpeg/opj_clock.c
 create mode 100644 extern/libopenjpeg/opj_clock.h
 create mode 100644 extern/libopenjpeg/opj_codec.h
 create mode 100644 extern/libopenjpeg/opj_config_private.h
 create mode 100644 extern/libopenjpeg/opj_intmath.h
 create mode 100644 extern/libopenjpeg/opj_inttypes.h
 create mode 100644 extern/libopenjpeg/opj_stdint.h
 create mode 100644 extern/libopenjpeg/t1_generate_luts.c

diff --git a/build_files/cmake/Modules/FindOpenJPEG.cmake b/build_files/cmake/Modules/FindOpenJPEG.cmake
index d765103..1f82591 100644
--- a/build_files/cmake/Modules/FindOpenJPEG.cmake
+++ b/build_files/cmake/Modules/FindOpenJPEG.cmake
@@ -41,13 +41,14 @@ FIND_PATH(OPENJPEG_INCLUDE_DIR
   HINTS
     ${_openjpeg_SEARCH_DIRS}
   PATH_SUFFIXES
+    openjpeg-2.3
+    include/openjpeg-2.3
     include
-    include/openjpeg-1.5
 )
 
 FIND_LIBRARY(OPENJPEG_LIBRARY
   NAMES
-    openjpeg
+    openjp2
   HINTS
     ${_openjpeg_SEARCH_DIRS}
   PATH_SUFFIXES
diff --git a/extern/libopenjpeg/CMakeLists.txt b/extern/libopenjpeg/CMakeLists.txt
index ad49eee..0af2a90 100644
--- a/extern/libopenjpeg/CMakeLists.txt
+++ b/extern/libopenjpeg/CMakeLists.txt
@@ -31,49 +31,56 @@ set(INC_SYS
 
 )
 
-add_definitions(${OPENJPEG_DEFINES})
+add_definitions(${OPENJPEG_DEFINES} -DUSE_JPIP)
 
 set(SRC
 	bio.c
+	cidx_manager.c
 	cio.c
 	dwt.c
 	event.c
+	function_list.c
 	image.c
+	invert.c
 	j2k.c
-	j2k_lib.c
 	jp2.c
-	jpt.c
 	mct.c
 	mqc.c
 	openjpeg.c
+	opj_clock.c
+	phix_manager.c
 	pi.c
+	ppix_manager.c
 	raw.c
 	t1.c
+	t1_generate_luts.c
 	t2.c
 	tcd.c
 	tgt.c
-	cidx_manager.c
-	phix_manager.c
-	ppix_manager.c
 	thix_manager.c
 	tpix_manager.c
 
 	bio.h
+	cidx_manager.h
 	cio.h
 	dwt.h
 	event.h
-	fix.h
+	function_list.h
 	image.h
-	int.h
+	indexbox_manager.h
+	invert.h
 	j2k.h
-	j2k_lib.h
 	jp2.h
-	jpt.h
 	mct.h
 	mqc.h
 	openjpeg.h
+	opj_clock.h
+	opj_codec.h
 	opj_includes.h
+	opj_intmath.h
+	opj_inttypes.h
 	opj_malloc.h
+	opj_stdint.h
 	pi.h
 	raw.h
 	t1.h
@@ -81,9 +88,6 @@ set(SRC
 	t2.h
 	tcd.h
 	tgt.h
-	cidx_manager.h
-	indexbox_manager.h
-	opj_config.h
 )
 
 blender_add_lib(extern_openjpeg "${SRC}" "${INC}" "${INC_SYS}")
diff --git a/extern/libopenjpeg/bio.c b/extern/libopenjpeg/bio.c
index f04f3e5..5d49580 100644
--- a/extern/libopenjpeg/bio.c
+++ b/extern/libopenjpeg/bio.c
@@ -1,9 +1,15 @@
 /*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2001-2003, David Janssens
  * Copyright (c) 2002-2003, Yannick Verschueren
- * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * Copyright (c) 2003-2014, Antonin Descampe
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
  * All rights reserved.
  *
@@ -42,25 +48,25 @@ Write a bit
 @param bio BIO handle
 @param b Bit to write (0 or 1)
 */
-static void bio_putbit(opj_bio_t *bio, unsigned int b);
+static void opj_bio_putbit(opj_bio_t *bio, OPJ_UINT32 b);
 /**
 Read a bit
 @param bio BIO handle
 @return Returns the read bit
 */
-static int bio_getbit(opj_bio_t *bio);
+static OPJ_UINT32 opj_bio_getbit(opj_bio_t *bio);
 /**
 Write a byte
 @param bio BIO handle
-@return Returns 0 if successful, returns 1 otherwise
+@return Returns OPJ_TRUE if successful, returns OPJ_FALSE otherwise
 */
-static int bio_byteout(opj_bio_t *bio);
+static OPJ_BOOL opj_bio_byteout(opj_bio_t *bio);
 /**
 Read a byte
 @param bio BIO handle
-@return Returns 0 if successful, returns 1 otherwise
+@return Returns OPJ_TRUE if successful, returns OPJ_FALSE otherwise
 */
-static int bio_bytein(opj_bio_t *bio);
+static OPJ_BOOL opj_bio_bytein(opj_bio_t *bio);
 
 /*@}*/
 
@@ -72,37 +78,37 @@ static int bio_bytein(opj_bio_t *bio);
 ==========================================================
 */
 
-static int bio_byteout(opj_bio_t *bio) {
+OPJ_BOOL opj_bio_byteout(opj_bio_t *bio) {
 	bio->buf = (bio->buf << 8) & 0xffff;
 	bio->ct = bio->buf == 0xff00 ? 7 : 8;
 	if (bio->bp >= bio->end) {
-		return 1;
+		return OPJ_FALSE;
 	}
-	*bio->bp++ = (unsigned char)(bio->buf >> 8);
-	return 0;
+	*bio->bp++ = (OPJ_BYTE)(bio->buf >> 8);
+	return OPJ_TRUE;
 }
 
-static int bio_bytein(opj_bio_t *bio) {
+OPJ_BOOL opj_bio_bytein(opj_bio_t *bio) {
 	bio->buf = (bio->buf << 8) & 0xffff;
 	bio->ct = bio->buf == 0xff00 ? 7 : 8;
 	if (bio->bp >= bio->end) {
-		return 1;
+		return OPJ_FALSE;
 	}
 	bio->buf |= *bio->bp++;
-	return 0;
+	return OPJ_TRUE;
 }
 
-static void bio_putbit(opj_bio_t *bio, unsigned int b) {
+void opj_bio_putbit(opj_bio_t *bio, OPJ_UINT32 b) {
 	if (bio->ct == 0) {
-		bio_byteout(bio);
+		opj_bio_byteout(bio); /* MSD: why not check the return value of this function ? */
 	}
 	bio->ct--;
 	bio->buf |= b << bio->ct;
 }
 
-static int bio_getbit(opj_bio_t *bio) {
+OPJ_UINT32 opj_bio_getbit(opj_bio_t *bio) {
 	if (bio->ct == 0) {
-		bio_bytein(bio);
+		opj_bio_bytein(bio); /* MSD: why not check the return value of this function ? */
 	}
 	bio->ct--;
 	return (bio->buf >> bio->ct) & 1;
@@ -114,22 +120,22 @@ static int bio_getbit(opj_bio_t *bio) {
 ==========================================================
 */
 
-opj_bio_t* bio_create(void) {
+opj_bio_t* opj_bio_create(void) {
 	opj_bio_t *bio = (opj_bio_t*)opj_malloc(sizeof(opj_bio_t));
 	return bio;
 }
 
-void bio_destroy(opj_bio_t *bio) {
+void opj_bio_destroy(opj_bio_t *bio) {
 	if(bio) {
 		opj_free(bio);
 	}
 }
 
-int bio_numbytes(opj_bio_t *bio) {
-	return (int)(bio->bp - bio->start);
+ptrdiff_t opj_bio_numbytes(opj_bio_t *bio) {
+	return (bio->bp - bio->start);
 }
 
-void bio_init_enc(opj_bio_t *bio, unsigned char *bp, int len) {
+void opj_bio_init_enc(opj_bio_t *bio, OPJ_BYTE *bp, OPJ_UINT32 len) {
 	bio->start = bp;
 	bio->end = bp + len;
 	bio->bp = bp;
@@ -137,7 +143,7 @@ void bio_init_enc(opj_bio_t *bio, unsigned char *bp, int len) {
 	bio->ct = 8;
 }
 
-void bio_init_dec(opj_bio_t *bio, unsigned char *bp, int len) {
+void opj_bio_init_dec(opj_bio_t *bio, OPJ_BYTE *bp, OPJ_UINT32 len) {
 	bio->start = bp;
 	bio->end = bp + len;
 	bio->bp = bp;
@@ -145,43 +151,44 @@ void bio_init_dec(opj_bio_t *bio, unsigned char *bp, int len) {
 	bio->ct = 0;
 }
 
-void bio_write(opj_bio_t *bio, int v, int n) {
-	int i;
-	for (i = n - 1; i >= 0; i--) {
-		bio_putbit(bio, (v >> i) & 1);
+void opj_bio_write(opj_bio_t *bio, OPJ_UINT32 v, OPJ_UINT32 n) {
+	OPJ_UINT32 i;
+	for (i = n - 1; i < n; i--) {
+		opj_bio_putbit(bio, (v >> i) & 1);
 	}
 }
 
-int bio_read(opj_bio_t *bio, int n) {
-	int i, v;
+OPJ_UINT32 opj_bio_read(opj_bio_t *bio, OPJ_UINT32 n) {
+	OPJ_UINT32 i;
+    OPJ_UINT32 v;
 	v = 0;
-	for (i = n - 1; i >= 0; i--) {
-		v += bio_getbit(bio) << i;
+	for (i = n - 1; i < n; i--) {
+		v += opj_bio_getbit(bio) << i;
 	}
 	return v;
 }
 
-int bio_flush(opj_bio_t *bio) {
+OPJ_BOOL opj_bio_flush(opj_bio_t *bio) {
 	bio->ct = 0;
-	if (bio_byteout(bio)) {
-		return 1;
+	if (! opj_bio_byteout(bio)) {
+		return OPJ_FALSE;
 	}
 	if (bio->ct == 7) {
 		bio->ct = 0;
-		if (bio_byteout(bio)) {
-			return 1;
+		if (! opj_bio_byteout(bio)) {
+			return OPJ_FALSE;
 		}
 	}
-	return 0;
+	return OPJ_TRUE;
 }
 
-int bio_inalign(opj_bio_t *bio) {
+OPJ_BOOL opj_bio_inalign(opj_bio_t *bio) {
 	bio->ct = 0;
 	if ((bio->buf & 0xff) == 0xff) {
-		if (bio_bytein(bio)) {
-			return 1;
+		if (! opj_bio_bytein(bio)) {
+			return OPJ_FALSE;
 		}
 		bio->ct = 0;
 	}
-	return 0;
+	return OPJ_TRUE;
 }
diff --git a/extern/libopenjpeg/bio.h b/extern/libopenjpeg/bio.h
index 764d7cb..fba2428 100644
--- a/extern/libopenjpeg/bio.h
+++ b/extern/libopenjpeg/bio.h
@@ -1,9 +1,15 @@
 /*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2001-2003, David Janssens
  * Copyright (c) 2002-2003, Yannick Verschueren
- * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * Copyright (c) 2003-2014, Antonin Descampe
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
  * All rights reserved.
  *
@@ -31,6 +37,9 @@
 
 #ifndef __BIO_H
 #define __BIO_H
+
+#include <stddef.h> /* ptrdiff_t */
+
 /** 
 @file bio.h
 @brief Implementation of an individual bit input-output (BIO)
@@ -46,15 +55,15 @@ Individual bit input-output stream (BIO)
 */
 typedef struct opj_bio {
 	/** pointer to the start of the buffer */
-	unsigned char *start;
+	OPJ_BYTE *start;
 	/** pointer to the end of the buffer */
-	unsigned char *end;
+	OPJ_BYTE *end;
 	/** pointer to the present position in the buffer */
-	unsigned char *bp;
+	OPJ_BYTE *bp;
 	/** temporary place where each byte is read or written */
-	unsigned int buf;
+	OPJ_UINT32 buf;
 	/** coder : number of bits free to write. decoder : number of bits read */
-	int ct;
+	OPJ_UINT32 ct;
 } opj_bio_t;
 
 /** @name Exported functions */
@@ -64,58 +73,58 @@ typedef struct opj_bio {
 Create a new BIO handle 
 @return Returns a new BIO handle if successful, returns NULL otherwise
 */
-opj_bio_t* bio_create(void);
+opj_bio_t* opj_bio_create(void);
 /**
 Destroy a previously created BIO handle
 @param bio BIO handle to destroy
 */
-void bio_destroy(opj_bio_t *bio);
+void opj_bio_destroy(opj_bio_t *bio);
 /**
 Number of bytes written.
 @param bio BIO handle
 @return Returns the number of bytes written
 */
-int bio_numbytes(opj_bio_t *bio);
+ptrdiff_t opj_bio_numbytes(opj_bio_t *bio);
 /**
 Init encoder
 @param bio BIO handle
 @param bp Output buffer
 @param len Output buffer length 
 */
-void bio_init_enc(opj_bio_t *bio, unsigned char *bp, int len);
+void opj_bio_init_enc(opj_bio_t *bio, OPJ_BYTE *bp, OPJ_UINT32 len);
 /**
 Init decoder
 @param bio BIO handle
 @param bp Input buffer
 @param len Input buffer length 
 */
-void bio_init_dec(opj_bio_t *bio, unsigned char *bp, int len);
+void opj_bio_init_dec(opj_bio_t *bio, OPJ_BYTE *bp, OPJ_UINT32 len);
 /**
 Write bits
 @param bio BIO handle
 @param v Value of bits
 @param n Number of bits to write
 */
-void bio_write(opj_bio_t *bio, int v, int n);
+void opj_bio_write(opj_bio_t *bio, OPJ_UINT32 v, OPJ_UINT32 n);
 /**
 Read bits
 @param bio BIO handle
 @param n Number of bits to read 
 @return Returns the corresponding read number
 */
-int bio_read(opj_bio_t *bio, int n);
+OPJ_UINT32 opj_bio_read(opj_bio_t *bio, OPJ_UINT32 n);
 /**
 Flush bits
 @param bio BIO handle
-@return Returns 1 if successful, returns 0 otherwise
+@return Returns OPJ_TRUE if successful, returns OPJ_FALSE otherwise
 */
-int bio_flush(opj_bio_t *bio);
+OPJ_BOOL opj_bio_flush(opj_bio_t *bio);
 /**
 Passes the ending bits (coming from flushing)
 @param bio BIO handle
-@return Returns 1 if successful, returns 0 otherwise
+@return Returns OPJ_TRUE if successful, returns OPJ_FALSE otherwise
 */
-int bio_inalign(opj_bio_t *bio);
+OPJ_BOOL opj_bio_inalign(opj_bio_t *bio);
 /* ----------------------------------------------------------------------- */
 /*@}*/
 
diff --git a/extern/libopenjpeg/cidx_manager.c b/extern/libopenjpeg/cidx_manager.c
index f3b251f..ff2dbda 100644
--- a/extern/libopenjpeg/cidx_manager.c
+++ b/extern/libopenjpeg/cidx_manager.c
@@ -1,8 +1,8 @@
 /*
  * $Id: cidx_manager.c 897 2011-08-28 21:43:57Z Kaori.Hagihara@gmail.com $
  *
- * Copyright (c) 2002-2011, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2011, Professor Benoit Macq
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2003-2004, Yannick Verschueren
  * Copyright (c) 2010-2011, Kaori Hagihara
  * All rights reserved.
@@ -39,39 +39,24 @@
  * @param[in] clen length of j2k codestream
  * @param[in] cio  file output handle
  */
-void write_cptr(int coff, int clen, opj_cio_t *cio);
 
+void opj_write_cptr(int coff, int clen, opj_stream_private_t *cio,
+              opj_event_mgr_t * p_manager );
 
-/* 
- * Write main header index table (box)
- *
- * @param[in] coff offset of j2k codestream
- * @param[in] cstr_info codestream information
- * @param[in] cio  file output handle
- * @return         length of mainmhix box
- */
-int write_mainmhix( int coff, opj_codestream_info_t cstr_info, opj_cio_t *cio);
 
 
-/* 
- * Check if EPH option is used
- *
- * @param[in] coff    offset of j2k codestream
- * @param[in] markers marker information
- * @param[in] marknum number of markers
- * @param[in] cio     file output handle
- * @return            true if EPH is used
- */
-opj_bool check_EPHuse( int coff, opj_marker_info_t *markers, int marknum, opj_cio_t *cio);
 
 
-int write_cidx( int offset, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t cstr_info, int j2klen)
+int opj_write_cidx( int offset, opj_stream_private_t *cio, opj_codestream_info_t cstr_info, int j2klen,
+              opj_event_mgr_t * p_manager )
 {
-  int len, i, lenp;
+  int i;
+  OPJ_OFF_T lenp;
+  OPJ_UINT32 len;
   opj_jp2_box_t *box;
   int num_box = 0;
-  opj_bool  EPHused;
-  (void)image; /* unused ? */
+  OPJ_BOOL  EPHused;
+  OPJ_BYTE l_data_header [4];
 
   lenp = -1;
   box = (opj_jp2_box_t *)opj_calloc( 32, sizeof(opj_jp2_box_t));
@@ -79,133 +64,176 @@ int write_cidx( int offset, opj_cio_t *cio, opj_image_t *image, opj_codestream_i
   for (i=0;i<2;i++){
   
     if(i)
-      cio_seek( cio, lenp);
+      opj_stream_seek(cio,lenp,p_manager);
+
 
-    lenp = cio_tell( cio);
+    lenp = opj_stream_tell (cio);
 
-    cio_skip( cio, 4);              /* L [at the end] */
-    cio_write( cio, JPIP_CIDX, 4);  /* CIDX           */
-    write_cptr( offset, cstr_info.codestream_size, cio);
+    opj_stream_skip(cio, 4, p_manager); /* L [at the end] */
 
-    write_manf( i, num_box, box, cio);
+    opj_write_bytes(l_data_header,JPIP_CIDX,4); /* CIDX */
+    opj_stream_write_data(cio,l_data_header,4,p_manager);
+
+    opj_write_cptr( offset, cstr_info.codestream_size, cio,p_manager);
+
+    opj_write_manf( i, num_box, box, cio,p_manager);
     
     num_box = 0;
-    box[num_box].length = write_mainmhix( offset, cstr_info, cio);
+    box[num_box].length = (OPJ_UINT32)opj_write_mainmhix( offset, cstr_info, cio,p_manager);
     box[num_box].type = JPIP_MHIX;
     num_box++;
 
-    box[num_box].length = write_tpix( offset, cstr_info, j2klen, cio);
+    box[num_box].length = (OPJ_UINT32)opj_write_tpix( offset, cstr_info, j2klen, cio,p_manager);
     box[num_box].type = JPIP_TPIX;
     num_box++;
       
-    box[num_box].length = write_thix( offset, cstr_info, cio);
+    box[num_box].length = (OPJ_UINT32)opj_write_thix( offset, cstr_info, cio, p_manager);
     box[num_box].type = JPIP_THIX;
     num_box++;
 
-    EPHused = check_EPHuse( offset, cstr_info.marker, cstr_info.marknum, cio);
+    EPHused = opj_check_EPHuse( offset, cstr_info.marker, cstr_info.marknum, cio,p_manager);
       
-    box[num_box].length = write_ppix( offset, cstr_info, EPHused, j2klen, cio);
+    box[num_box].length = (OPJ_UINT32)opj_write_ppix( offset, cstr_info, EPHused, j2klen, cio,p_manager);
     box[num_box].type = JPIP_PPIX;
     num_box++;
     
-    box[num_box].length = write_phix( offset, cstr_info, EPHused, j2klen, cio);
+    box[num_box].length = (OPJ_UINT32)opj_write_phix( offset, cstr_info, EPHused, j2klen, cio,p_manager);
     box[num_box].type = JPIP_PHIX;
     num_box++;
       
-    len = cio_tell( cio)-lenp;
-    cio_seek( cio, lenp);
-    cio_write( cio, len, 4);        /* L             */
-    cio_seek( cio, lenp+len);
+    len = (OPJ_UINT32) (opj_stream_tell(cio)-lenp);
+    opj_stream_seek(cio, lenp,p_manager);
+    opj_write_bytes(l_data_header,len,4);/* L  */
+    opj_stream_write_data(cio,l_data_header,4,p_manager);
+    opj_stream_seek(cio, lenp+len,p_manager);
   }
 
   opj_free( box);
   
-  return len;
+  return (int)len;
 }
 
-void write_cptr(int coff, int clen, opj_cio_t *cio)
+
+
+void opj_write_cptr(int coff, int clen, opj_stream_private_t *cio,
+              opj_event_mgr_t * p_manager )
 {
-  int len, lenp;
-
-  lenp = cio_tell( cio);
-  cio_skip( cio, 4);               /* L [at the end]     */
-  cio_write( cio, JPIP_CPTR, 4);   /* T                  */
-  cio_write( cio, 0, 2);           /* DR  A PRECISER !!  */
-  cio_write( cio, 0, 2);           /* CONT               */
-  cio_write( cio, coff, 8);    /* COFF A PRECISER !! */
-  cio_write( cio, clen, 8);    /* CLEN               */
-  len = cio_tell( cio) - lenp;
-  cio_seek( cio, lenp);
-  cio_write( cio, len, 4);         /* L                  */
-  cio_seek( cio, lenp+len);
+  OPJ_BYTE l_data_header [3*8];
+  OPJ_UINT32 len;
+  OPJ_OFF_T lenp;
+
+
+  lenp = opj_stream_tell(cio);
+  opj_stream_skip( cio, 4, p_manager);               /* L [at the end]     */
+  opj_write_bytes( l_data_header, JPIP_CPTR, 4);   /* T                  */
+  opj_write_bytes( l_data_header+4, 0, 2);           /* DR  A PRECISER !!  */
+  opj_write_bytes( l_data_header+6, 0, 2);           /* CONT               */
+  opj_write_bytes( l_data_header+8, (OPJ_UINT32)coff, 8);    /* COFF A PRECISER !! */
+  opj_write_bytes( l_data_header+16, (OPJ_UINT32)clen, 8);    /* CLEN               */
+  opj_stream_write_data(cio,l_data_header,3*8,p_manager);
+
+  len = (OPJ_UINT32) (opj_stream_tell(cio) - lenp);
+  opj_stream_seek(cio,lenp,p_manager);
+  opj_write_bytes(l_data_header, len, 4);         /* L                  */
+  opj_stream_write_data(cio,l_data_header,4,p_manager);
+  opj_stream_seek(cio, lenp+len,p_manager);
+
 }
 
-void write_manf(int second, int v, opj_jp2_box_t *box, opj_cio_t *cio)
+
+
+void opj_write_manf(int second, 
+                    int v, 
+                    opj_jp2_box_t *box, 
+                    opj_stream_private_t *cio,
+                    opj_event_mgr_t * p_manager )
 {
-  int len, lenp, i;
+  OPJ_BYTE l_data_header [4];
+  int i;
+  OPJ_UINT32 len;
+  OPJ_OFF_T lenp;
   
-  lenp = cio_tell( cio); 
-  cio_skip( cio, 4);                         /* L [at the end]                    */
-  cio_write( cio, JPIP_MANF,4);              /* T                                 */
+  lenp = opj_stream_tell(cio);
+  opj_stream_skip( cio, 4, p_manager);             /* L [at the end]     */
+  opj_write_bytes( l_data_header, JPIP_MANF, 4);   /* T                  */
+  opj_stream_write_data(cio,l_data_header,4,p_manager);
 
   if (second){                          /* Write only during the second pass */
     for( i=0; i<v; i++){
-      cio_write( cio, box[i].length, 4);  /* Box length                     */ 
-      cio_write( cio, box[i].type, 4); /* Box type                       */
+      opj_write_bytes( l_data_header, box[i].length, 4); /* Box length                     */
+      opj_stream_write_data(cio,l_data_header,4,p_manager);
+      opj_write_bytes( l_data_header, box[i].type, 4); /* Box type                       */
+      opj_stream_write_data(cio,l_data_header,4,p_manager);
     }
   }
 
-  len = cio_tell( cio) - lenp;
-  cio_seek( cio, lenp);
-  cio_write( cio, len, 4);                   /* L                                 */
-  cio_seek( cio, lenp+len);
+  len = (OPJ_UINT32) (opj_stream_tell(cio) - lenp);
+  opj_stream_seek(cio,lenp,p_manager);
+  opj_write_bytes(l_data_header, len, 4);/* L                                 */
+  opj_stream_write_data(cio,l_data_header,4,p_manager);
+  opj_stream_seek(cio,lenp+len,p_manager);
 }
 
-int write_mainmhix( int coff, opj_codestream_info_t cstr_info, opj_cio_t *cio)
+
+int opj_write_mainmhix( int coff, opj_codestream_info_t cstr_info, opj_stream_private_t *cio,
+              opj_event_mgr_t * p_manager )
 {
-  int i;
-  int len, lenp;
+  OPJ_BYTE l_data_header [8];
+  OPJ_UINT32 i;
+  OPJ_UINT32 len;
+  OPJ_OFF_T lenp;
   
-  lenp = cio_tell( cio);
-  cio_skip( cio, 4);                               /* L [at the end]                    */
-  cio_write( cio, JPIP_MHIX, 4);                   /* MHIX                              */
-
-  cio_write( cio, cstr_info.main_head_end-cstr_info.main_head_start+1, 8);        /* TLEN                              */
-
-  for(i = 1; i < cstr_info.marknum; i++){    /* Marker restricted to 1 apparition, skip SOC marker */
-    cio_write( cio, cstr_info.marker[i].type, 2);
-    cio_write( cio, 0, 2);
-    cio_write( cio, cstr_info.marker[i].pos-coff, 8);
-    cio_write( cio, cstr_info.marker[i].len, 2);
+  lenp = opj_stream_tell (cio);
+  opj_stream_skip(cio, 4, p_manager);               /* L [at the end]                    */
+  opj_write_bytes(l_data_header,JPIP_MHIX,4);       /* MHIX                              */
+  opj_stream_write_data(cio,l_data_header,4,p_manager);
+
+  opj_write_bytes(l_data_header, (OPJ_UINT32)(cstr_info.main_head_end-cstr_info.main_head_start+1), 8);        /* TLEN                              */
+  opj_stream_write_data(cio,l_data_header,8,p_manager);
+
+  for(i = 1; i < (OPJ_UINT32)cstr_info.marknum; i++){    /* Marker restricted to 1 apparition, skip SOC marker */
+    opj_write_bytes( l_data_header, cstr_info.marker[i].type, 2);
+    opj_write_bytes( l_data_header+2, 0, 2);
+    opj_stream_write_data(cio,l_data_header,4,p_manager);
+    opj_write_bytes( l_data_header,(OPJ_UINT32) (cstr_info.marker[i].pos-coff), 8);
+    opj_stream_write_data(cio,l_data_header,8,p_manager);
+    opj_write_bytes( l_data_header, (OPJ_UINT32)cstr_info.marker[i].len, 2);
+    opj_stream_write_data(cio,l_data_header,2,p_manager);
   }
 
-  len = cio_tell( cio) - lenp;
-  cio_seek( cio, lenp);
-  cio_write( cio, len, 4);        /* L           */
-  cio_seek( cio, lenp+len);
+  len = (OPJ_UINT32) (opj_stream_tell(cio)-lenp);
+  opj_stream_seek(cio, lenp,p_manager);
+  opj_write_bytes(l_data_header,len,4);/* L  */
+  opj_stream_write_data(cio,l_data_header,4,p_manager);
+  opj_stream_seek(cio, lenp+len,p_manager);
   
-  return len;
+  return (int)len;
 }
 
-opj_bool check_EPHuse( int coff, opj_marker_info_t *markers, int marknum, opj_cio_t *cio)
+OPJ_BOOL opj_check_EPHuse( int coff, opj_marker_info_t *markers, int marknum, opj_stream_private_t *cio,
+              opj_event_mgr_t * p_manager )
 {
-  opj_bool EPHused = OPJ_FALSE;
+  OPJ_BYTE l_data_header [4];
+  OPJ_BOOL EPHused = OPJ_FALSE;
   int i=0;
-  int org_pos;
+  OPJ_OFF_T org_pos;
   unsigned int Scod;
 
-  for(i = 0; i < marknum; i++){
-    if( markers[i].type == J2K_MS_COD){
-      org_pos = cio_tell( cio);
-      cio_seek( cio, coff+markers[i].pos+2);
-      
-      Scod = cio_read( cio, 1);
+  for(i = 0; i < marknum; i++)
+    {
+    if( markers[i].type == J2K_MS_COD)
+      {
+      org_pos = opj_stream_tell(cio);
+      opj_stream_seek(cio, coff+markers[i].pos+2,p_manager);
+
+      opj_stream_read_data(cio,l_data_header,1,p_manager);
+      opj_read_bytes(l_data_header,&Scod,1);
       if( ((Scod >> 2) & 1))
-	EPHused = OPJ_TRUE;
-      cio_seek( cio, org_pos);
+        EPHused = OPJ_TRUE;
+      opj_stream_seek( cio, org_pos, p_manager);
 
       break;
-    }
-  }    
+      }
+    }    
   return EPHused;
 }
diff --git a/extern/libopenjpeg/cidx_manager.h b/extern/libopenjpeg/cidx_manager.h
index 23eebd5..d0bbef8 100644
--- a/extern/libopenjpeg/cidx_manager.h
+++ b/extern/libopenjpeg/cidx_manager.h
@@ -1,8 +1,8 @@
 /*
  * $Id: cidx_manager.h 897 2011-08-28 21:43:57Z Kaori.Hagihara@gmail.com $
  *
- * Copyright (c) 2002-2011, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2011, Professor Benoit Macq
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2003-2004, Yannick Verschueren
  * Copyright (c) 2010-2011, Kaori Hagihara
  * All rights reserved.
@@ -50,7 +50,19 @@
  * @param[in] j2klen    length of j2k codestream
  * @return              length of cidx box
  */
-int write_cidx( int offset, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t cstr_info, int j2klen);
+int opj_write_cidx( int offset, opj_stream_private_t *cio, opj_codestream_info_t cstr_info, int j2klen,
+              opj_event_mgr_t * p_manager );
 
+/* 
+ * Check if EPH option is used
+ *
+ * @param[in] coff    offset of j2k codestream
+ * @param[in] markers marker information
+ * @param[in] marknum number of markers
+ * @param[in] cio     file output handle
+ * @return            true if EPH is used
+ */
+OPJ_BOOL opj_check_EPHuse( int coff, opj_marker_info_t *markers, int marknum, opj_stream_private_t *cio,
+              opj_event_mgr_t * p_manager );
 
 #endif      /* !CIDX_MANAGER_H_ */
diff --git a/extern/libopenjpeg/cio.c b/extern/libopenjpeg/cio.c
index 97cccea..1fc2393 100644
--- a/extern/libopenjpeg/cio.c
+++ b/extern/libopenjpeg/cio.c
@@ -1,10 +1,18 @@
 /*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2001-2003, David Janssens
  * Copyright (c) 2002-2003, Yannick Verschueren
- * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * Copyright (c) 2003-2014, Antonin Descampe
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR 
+ * Copyright (c) 2012, CS Systemes d'Information, France
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -30,170 +38,608 @@
  */
 
 #include "opj_includes.h"
-#include <assert.h>
 
 /* ----------------------------------------------------------------------- */
 
-opj_cio_t* OPJ_CALLCONV opj_cio_open(opj_common_ptr cinfo, unsigned char *buffer, int length) {
-	opj_cp_t *cp = NULL;
-	opj_cio_t *cio = (opj_cio_t*)opj_malloc(sizeof(opj_cio_t));
-	if(!cio) return NULL;
-	cio->cinfo = cinfo;
-	if(buffer && length) {
-		/* wrap a user buffer containing the encoded image */
-		cio->openmode = OPJ_STREAM_READ;
-		cio->buffer = buffer;
-		cio->length = length;
-	}
-	else if(!buffer && !length && cinfo) {
-		/* allocate a buffer for the encoded image */
-		cio->openmode = OPJ_STREAM_WRITE;
-		switch(cinfo->codec_format) {
-			case CODEC_J2K:
-				cp = ((opj_j2k_t*)cinfo->j2k_handle)->cp;
-				break;
-			case CODEC_JP2:
-				cp = ((opj_jp2_t*)cinfo->jp2_handle)->j2k->cp;
-				break;
-			default:
-				opj_free(cio);
-				return NULL;
-		}
-		cio->length = (unsigned int) (0.1625 * cp->img_size + 2000); /* 0.1625 = 1.3/8 and 2000 bytes as a minimum for headers */
-		cio->buffer = (unsigned char *)opj_malloc(cio->length);
-		if(!cio->buffer) {
-			opj_event_msg(cio->cinfo, EVT_ERROR, "Error allocating memory for compressed bitstream\n");
-			opj_free(cio);
-			return NULL;
-		}
+
+/* ----------------------------------------------------------------------- */
+
+void opj_write_bytes_BE (OPJ_BYTE * p_buffer, OPJ_UINT32 p_value, OPJ_UINT32 p_nb_bytes)
+{
+	const OPJ_BYTE * l_data_ptr = ((const OPJ_BYTE *) &p_value) + p_nb_bytes;
+
+	assert(p_nb_bytes > 0 && p_nb_bytes <=  sizeof(OPJ_UINT32));
+
+	memcpy(p_buffer,l_data_ptr,p_nb_bytes);
+}
+
+void opj_write_bytes_LE (OPJ_BYTE * p_buffer, OPJ_UINT32 p_value, OPJ_UINT32 p_nb_bytes)
+{
+	const OPJ_BYTE * l_data_ptr = ((const OPJ_BYTE *) &p_value) + p_nb_bytes - 1;
+	OPJ_UINT32 i;
+
+	assert(p_nb_bytes > 0 && p_nb_bytes <= sizeof(OPJ_UINT32));
+
+	for	(i=0;i<p_nb_bytes;++i) {
+		*(p_buffer++) = *(l_data_ptr--);
+	}
+}
+
+void opj_read_bytes_BE(const OPJ_BYTE * p_buffer, OPJ_UINT32 * p_value, OPJ_UINT32 p_nb_bytes)
+{
+	OPJ_BYTE * l_data_ptr = ((OPJ_BYTE *) p_value);
+
+	assert(p_nb_bytes > 0 && p_nb_bytes <= sizeof(OPJ_UINT32));
+
+	*p_value = 0;
+	memcpy(l_data_ptr+4-p_nb_bytes,p_buffer,p_nb_bytes);
+}
+
+void opj_read_bytes_LE(const OPJ_BYTE * p_buffer, OPJ_UINT32 * p_value, OPJ_UINT32 p_nb_bytes)
+{
+	OPJ_BYTE * l_data_ptr = ((OPJ_BYTE *) p_value) + p_nb_bytes-1;
+	OPJ_UINT32 i;
+
+	assert(p_nb_bytes > 0 && p_nb_bytes <= sizeof(OPJ_UINT32));
+
+	*p_value = 0;
+	for (i=0;i<p_nb_bytes;++i) {
+		*(l_data_ptr--) = *(p_buffer++);
+	}
+}
+
+void opj_write_double_BE(OPJ_BYTE * p_buffer, OPJ_FLOAT64 p_value)
+{
+	const OPJ_BYTE * l_data_ptr = ((const OPJ_BYTE *) &p_value);
+	memcpy(p_buffer,l_data_ptr,sizeof(OPJ_FLOAT64));
+}
+
+void opj_write_double_LE(OPJ_BYTE * p_buffer, OPJ_FLOAT64 p_value)
+{
+	const OPJ_BYTE * l_data_ptr = ((const OPJ_BYTE *) &p_value) + sizeof(OPJ_FLOAT64) - 1;
+	OPJ_UINT32 i;
+	for	(i=0;i<sizeof(OPJ_FLOAT64);++i) {
+		*(p_buffer++) = *(l_data_ptr--);
+	}
+}
+
+void opj_read_double_BE(const OPJ_BYTE * p_buffer, OPJ_FLOAT64 * p_value)
+{
+	OPJ_BYTE * l_data_ptr = ((OPJ_BYTE *) p_value);
+	memcpy(l_data_ptr,p_buffer,sizeof(OPJ_FLOAT64));
+}
+
+void opj_read_double_LE(const OPJ_BYTE * p_buffer, OPJ_FLOAT64 * p_value)
+{
+	OPJ_BYTE * l_data_ptr = ((OPJ_BYTE *) p_value) + sizeof(OPJ_FLOAT64)-1;
+	OPJ_UINT32 i;
+	for (i=0;i<sizeof(OPJ_FLOAT64);++i) {
+		*(l_data_ptr--) = *(p_buffer++);
+	}
+}
+
+void opj_write_float_BE(OPJ_BYTE * p_buffer, OPJ_FLOAT32 p_value)
+{
+	const OPJ_BYTE * l_data_ptr = ((const OPJ_BYTE *) &p_value);
+	memcpy(p_buffer,l_data_ptr,sizeof(OPJ_FLOAT32));
+}
+
+void opj_write_float_LE(OPJ_BYTE * p_buffer, OPJ_FLOAT32 p_value)
+{
+	const OPJ_BYTE * l_data_ptr = ((const OPJ_BYTE *) &p_value) + sizeof(OPJ_FLOAT32) - 1;
+	OPJ_UINT32 i;
+	for	(i=0;i<sizeof(OPJ_FLOAT32);++i) {
+		*(p_buffer++) = *(l_data_ptr--);
+	}
+}
+
+void opj_read_float_BE(const OPJ_BYTE * p_buffer, OPJ_FLOAT32 * p_value)
+{
+	OPJ_BYTE * l_data_ptr = ((OPJ_BYTE *) p_value);
+	memcpy(l_data_ptr,p_buffer,sizeof(OPJ_FLOAT32));
+}
+
+void opj_read_float_LE(const OPJ_BYTE * p_buffer, OPJ_FLOAT32 * p_value)
+{
+	OPJ_BYTE * l_data_ptr = ((OPJ_BYTE *) p_value) + sizeof(OPJ_FLOAT32)-1;
+	OPJ_UINT32 i;
+	for	(i=0;i<sizeof(OPJ_FLOAT32);++i) {
+		*(l_data_ptr--) = *(p_buffer++);
+	}
+}
+
+opj_stream_t* OPJ_CALLCONV opj_stream_create(OPJ_SIZE_T p_buffer_size,OPJ_BOOL l_is_input)
+{
+	opj_stream_private_t * l_stream = 00;
+	l_stream = (opj_stream_private_t*) opj_malloc(sizeof(opj_stream_private_t));
+	if (! l_stream) {
+		return 00;
+	}
+
+	memset(l_stream,0,sizeof(opj_stream_private_t));
+	l_stream->m_buffer_size = p_buffer_size;
+	l_stream->m_stored_data = (OPJ_BYTE *) opj_malloc(p_buffer_size);
+	if (! l_stream->m_stored_data) {
+		opj_free(l_stream);
+		return 00;
+	}
+
+	l_stream->m_current_data = l_stream->m_stored_data;
+
+	if (l_is_input) {
+		l_stream->m_status |= opj_stream_e_input;
+		l_stream->m_opj_skip = opj_stream_read_skip;
+		l_stream->m_opj_seek = opj_stream_read_seek;
 	}
 	else {
-		opj_free(cio);
-		return NULL;
+		l_stream->m_status |= opj_stream_e_output;
+		l_stream->m_opj_skip = opj_stream_write_skip;
+		l_stream->m_opj_seek = opj_stream_write_seek;
 	}
 
-	/* Initialize byte IO */
-	cio->start = cio->buffer;
-	cio->end = cio->buffer + cio->length;
-	cio->bp = cio->buffer;
+	l_stream->m_read_fn = opj_stream_default_read;
+	l_stream->m_write_fn = opj_stream_default_write;
+	l_stream->m_skip_fn = opj_stream_default_skip;
+	l_stream->m_seek_fn = opj_stream_default_seek;
 
-	return cio;
+	return (opj_stream_t *) l_stream;
 }
 
-void OPJ_CALLCONV opj_cio_close(opj_cio_t *cio) {
-	if(cio) {
-		if(cio->openmode == OPJ_STREAM_WRITE) {
-			/* destroy the allocated buffer */
-			opj_free(cio->buffer);
+opj_stream_t* OPJ_CALLCONV opj_stream_default_create(OPJ_BOOL l_is_input)
+{
+	return opj_stream_create(OPJ_J2K_STREAM_CHUNK_SIZE,l_is_input);
+}
+
+void OPJ_CALLCONV opj_stream_destroy(opj_stream_t* p_stream)
+{
+	opj_stream_private_t* l_stream = (opj_stream_private_t*) p_stream;
+	
+	if (l_stream) {
+		if (l_stream->m_free_user_data_fn) {
+			l_stream->m_free_user_data_fn(l_stream->m_user_data);
 		}
-		/* destroy the cio */
-		opj_free(cio);
+		opj_free(l_stream->m_stored_data);
+		l_stream->m_stored_data = 00;
+		opj_free(l_stream);
 	}
 }
 
+void OPJ_CALLCONV opj_stream_set_read_function(opj_stream_t* p_stream, opj_stream_read_fn p_function)
+{
+	opj_stream_private_t* l_stream = (opj_stream_private_t*) p_stream;
 
-/* ----------------------------------------------------------------------- */
+	if ((!l_stream) || (! (l_stream->m_status & opj_stream_e_input))) {
+		return;
+	}
 
-/*
- * Get position in byte stream.
- */
-int OPJ_CALLCONV cio_tell(opj_cio_t *cio) {
-	return cio->bp - cio->start;
+	l_stream->m_read_fn = p_function;
 }
 
-/*
- * Set position in byte stream.
- *
- * pos : position, in number of bytes, from the beginning of the stream
- */
-void OPJ_CALLCONV cio_seek(opj_cio_t *cio, int pos) {
-  assert((cio->start + pos) <= cio->end);
-	cio->bp = cio->start + pos;
+void OPJ_CALLCONV opj_stream_set_seek_function(opj_stream_t* p_stream, opj_stream_seek_fn p_function)
+{
+	opj_stream_private_t* l_stream = (opj_stream_private_t*) p_stream;
+	
+	if (!l_stream) {
+		return;
+	}
+	l_stream->m_seek_fn = p_function;
 }
 
-/*
- * Number of bytes left before the end of the stream.
- */
-int cio_numbytesleft(opj_cio_t *cio) {
-  assert((cio->end - cio->bp) >= 0);
-	return cio->end - cio->bp;
+void OPJ_CALLCONV opj_stream_set_write_function(opj_stream_t* p_stream, opj_stream_write_fn p_function)
+{
+	opj_stream_private_t* l_stream = (opj_stream_private_t*) p_stream;
+	
+	if ((!l_stream )|| (! (l_stream->m_status & opj_stream_e_output))) {
+		return;
+	}
+
+	l_stream->m_write_fn = p_function;
 }
 
-/*
- * Get pointer to the current position in the stream.
- */
-unsigned char *cio_getbp(opj_cio_t *cio) {
-	return cio->bp;
+void OPJ_CALLCONV opj_stream_set_skip_function(opj_stream_t* p_stream, opj_stream_skip_fn p_function)
+{
+	opj_stream_private_t* l_stream = (opj_stream_private_t*) p_stream;
+	
+	if (! l_stream) {
+		return;
+	}
+
+	l_stream->m_skip_fn = p_function;
 }
 
-/*
- * Write a byte.
- */
-opj_bool cio_byteout(opj_cio_t *cio, unsigned char v) {
-	if (cio->bp >= cio->end) {
-		opj_event_msg(cio->cinfo, EVT_ERROR, "write error\n");
-		return OPJ_FALSE;
+void OPJ_CALLCONV opj_stream_set_user_data(opj_stream_t* p_stream, void * p_data, opj_stream_free_user_data_fn p_function)
+{
+	opj_stream_private_t* l_stream = (opj_stream_private_t*) p_stream;
+	if (!l_stream)
+		return;
+	l_stream->m_user_data = p_data;
+  l_stream->m_free_user_data_fn = p_function;
+}
+
+void OPJ_CALLCONV opj_stream_set_user_data_length(opj_stream_t* p_stream, OPJ_UINT64 data_length)
+{
+	opj_stream_private_t* l_stream = (opj_stream_private_t*) p_stream;
+	if (!l_stream)
+		return;
+	l_stream->m_user_data_length = data_length;
+}
+
+OPJ_SIZE_T opj_stream_read_data (opj_stream_private_t * p_stream,OPJ_BYTE * p_buffer, OPJ_SIZE_T p_size, opj_event_mgr_t * p_event_mgr)
+{
+	OPJ_SIZE_T l_read_nb_bytes = 0;
+	if (p_stream->m_bytes_in_buffer >= p_size) {
+		memcpy(p_buffer,p_stream->m_current_data,p_size);
+		p_stream->m_current_data += p_size;
+		p_stream->m_bytes_in_buffer -= p_size;
+		l_read_nb_bytes += p_size;
+		p_stream->m_byte_offset += (OPJ_OFF_T)p_size;
+		return l_read_nb_bytes;
 	}
-	*cio->bp++ = v;
+
+	/* we are now in the case when the remaining data if not sufficient */
+	if (p_stream->m_status & opj_stream_e_end) {
+		l_read_nb_bytes += p_stream->m_bytes_in_buffer;
+		memcpy(p_buffer,p_stream->m_current_data,p_stream->m_bytes_in_buffer);
+		p_stream->m_current_data += p_stream->m_bytes_in_buffer;
+		p_stream->m_byte_offset += (OPJ_OFF_T)p_stream->m_bytes_in_buffer;
+		p_stream->m_bytes_in_buffer = 0;
+		return l_read_nb_bytes ? l_read_nb_bytes : (OPJ_SIZE_T)-1;
+	}
+
+	/* the flag is not set, we copy data and then do an actual read on the stream */
+	if (p_stream->m_bytes_in_buffer) {
+		l_read_nb_bytes += p_stream->m_bytes_in_buffer;
+		memcpy(p_buffer,p_stream->m_current_data,p_stream->m_bytes_in_buffer);
+		p_stream->m_current_data = p_stream->m_stored_data;
+		p_buffer += p_stream->m_bytes_in_buffer;
+		p_size -= p_stream->m_bytes_in_buffer;
+		p_stream->m_byte_offset += (OPJ_OFF_T)p_stream->m_bytes_in_buffer;
+		p_stream->m_bytes_in_buffer = 0;
+	}
+	else {
+    /* case where we are already at the end of the buffer
+       so reset the m_current_data to point to the start of the
+       stored buffer to get ready to read from disk*/
+		p_stream->m_current_data = p_stream->m_stored_data;
+	}
+
+	while(1){
+		/* we should read less than a chunk -> read a chunk */
+		if (p_size < p_stream->m_buffer_size) {
+			/* we should do an actual read on the media */
+			p_stream->m_bytes_in_buffer = p_stream->m_read_fn(p_stream->m_stored_data,p_stream->m_buffer_size,p_stream->m_user_data);
+
+			if (p_stream->m_bytes_in_buffer == (OPJ_SIZE_T)-1) {
+				/* end of stream */
+				opj_event_msg(p_event_mgr, EVT_INFO, "Stream reached its end !\n");
+
+				p_stream->m_bytes_in_buffer = 0;
+				p_stream->m_status |= opj_stream_e_end;
+				/* end of stream */
+				return l_read_nb_bytes ? l_read_nb_bytes : (OPJ_SIZE_T)-1;
+			}
+			else if	(p_stream->m_bytes_in_buffer < p_size) {
+				/* not enough data */
+				l_read_nb_bytes += p_stream->m_bytes_in_buffer;
+				memcpy(p_buffer,p_stream->m_current_data,p_stream->m_bytes_in_buffer);
+				p_stream->m_current_data = p_stream->m_stored_data;
+				p_buffer += p_stream->m_bytes_in_buffer;
+				p_size -= p_stream->m_bytes_in_buffer;
+				p_stream->m_byte_offset += (OPJ_OFF_T)p_stream->m_bytes_in_buffer;
+				p_stream->m_bytes_in_buffer = 0;
+			}
+			else {
+				l_read_nb_bytes += p_size;
+				memcpy(p_buffer,p_stream->m_current_data,p_size);
+				p_stream->m_current_data += p_size;
+				p_stream->m_bytes_in_buffer -= p_size;
+				p_stream->m_byte_offset += (OPJ_OFF_T)p_size;
+				return l_read_nb_bytes;
+			}
+		}
+		else {
+			/* direct read on the dest buffer */
+			p_stream->m_bytes_in_buffer = p_stream->m_read_fn(p_buffer,p_size,p_stream->m_user_data);
+
+			if (p_stream->m_bytes_in_buffer == (OPJ_SIZE_T)-1) {
+				/*  end of stream */
+				opj_event_msg(p_event_mgr, EVT_INFO, "Stream reached its end !\n");
+
+				p_stream->m_bytes_in_buffer = 0;
+				p_stream->m_status |= opj_stream_e_end;
+				/* end of stream */
+				return l_read_nb_bytes ? l_read_nb_bytes : (OPJ_SIZE_T)-1;
+			}
+			else if (p_stream->m_bytes_in_buffer < p_size) {
+				/* not enough data */
+				l_read_nb_bytes += p_stream->m_bytes_in_buffer;
+				p_stream->m_current_data = p_stream->m_stored_data;
+				p_buffer += p_stream->m_bytes_in_buffer;
+				p_size -= p_stream->m_bytes_in_buffer;
+				p_stream->m_byte_offset += (OPJ_OFF_T)p_stream->m_bytes_in_buffer;
+				p_stream->m_bytes_in_buffer = 0;
+			}
+			else {
+				/* we have read the exact size */
+				l_read_nb_bytes += p_stream->m_bytes_in_buffer;
+				p_stream->m_byte_offset += (OPJ_OFF_T)p_stream->m_bytes_in_buffer;
+				p_stream->m_current_data = p_stream->m_stored_data;
+				p_stream->m_bytes_in_buffer = 0;
+				return l_read_nb_bytes;
+			}
+		}
+	}
+}
+
+OPJ_SIZE_T opj_stream_write_data (opj_stream_private_t * p_stream,
+								  const OPJ_BYTE * p_buffer,
+								  OPJ_SIZE_T p_size, 
+								  opj_event_mgr_t * p_event_mgr)
+{
+	OPJ_SIZE_T l_remaining_bytes = 0;
+	OPJ_SIZE_T l_write_nb_bytes = 0;
+
+	if (p_stream->m_status & opj_stream_e_error) {
+		return (OPJ_SIZE_T)-1;
+	}
+
+	while(1) {
+		l_remaining_bytes = p_stream->m_buffer_size - p_stream->m_bytes_in_buffer;
+		
+		/* we have more memory than required */
+		if (l_remaining_bytes >= p_size) {
+			memcpy(p_stream->m_current_data, p_buffer, p_size);
+			
+			p_stream->m_current_data += p_size;
+			p_stream->m_bytes_in_buffer += p_size;
+			l_write_nb_bytes += p_size;
+			p_stream->m_byte_offset += (OPJ_OFF_T)p_size;
+			
+			return l_write_nb_bytes;
+		}
+
+		/* we copy data and then do an actual read on the stream */
+		if (l_remaining_bytes) {
+			l_write_nb_bytes += l_remaining_bytes;
+			
+			memcpy(p_stream->m_current_data,p_buffer,l_remaining_bytes);
+			
+			p_stream->m_current_data = p_stream->m_stored_data;
+			
+			p_buffer += l_remaining_bytes;
+			p_size -= l_remaining_bytes;
+			p_stream->m_bytes_in_buffer += l_remaining_bytes;
+			p_stream->m_byte_offset += (OPJ_OFF_T)l_remaining_bytes;
+		}
+
+		if (! opj_stream_flush(p_stream, p_event_mgr)) {
+			return (OPJ_SIZE_T)-1;
+		}
+	}
+
+}
+
+OPJ_BOOL opj_stream_flush (opj_stream_private_t * p_stream, opj_event_mgr_t * p_event_mgr)
+{
+	/* the number of bytes written on the media. */
+	OPJ_SIZE_T l_current_write_nb_bytes = 0;
+
+	p_stream->m_current_data = p_stream->m_stored_data;
+
+	while (p_stream->m_bytes_in_buffer) {
+		/* we should do an actual write on the media */
+		l_current_write_nb_bytes = p_stream->m_write_fn(p_stream->m_current_data,
+														p_stream->m_bytes_in_buffer,
+														p_stream->m_user_data);
+		
+		if (l_current_write_nb_bytes == (OPJ_SIZE_T)-1) {
+			p_stream->m_status |= opj_stream_e_error;
+			opj_event_msg(p_event_mgr, EVT_INFO, "Error on writing stream!\n");
+
+			return OPJ_FALSE;
+		}
+
+		p_stream->m_current_data += l_current_write_nb_bytes;
+		p_stream->m_bytes_in_buffer -= l_current_write_nb_bytes;
+	}
+
+	p_stream->m_current_data = p_stream->m_stored_data;
+	
 	return OPJ_TRUE;
 }
 
-/*
- * Read a byte.
- */
-unsigned char cio_bytein(opj_cio_t *cio) {
-  assert(cio->bp >= cio->start);
-	if (cio->bp >= cio->end) {
-		opj_event_msg(cio->cinfo, EVT_ERROR, "read error: passed the end of the codestream (start = %d, current = %d, end = %d\n", cio->start, cio->bp, cio->end);
-		return 0;
+OPJ_OFF_T opj_stream_read_skip (opj_stream_private_t * p_stream, OPJ_OFF_T p_size, opj_event_mgr_t * p_event_mgr)
+{
+	OPJ_OFF_T l_skip_nb_bytes = 0;
+	OPJ_OFF_T l_current_skip_nb_bytes = 0;
+	
+	assert( p_size >= 0 );
+	
+	if (p_stream->m_bytes_in_buffer >= (OPJ_SIZE_T)p_size) {
+		p_stream->m_current_data += p_size;
+		/* it is safe to cast p_size to OPJ_SIZE_T since it is <= m_bytes_in_buffer
+		which is of type OPJ_SIZE_T */
+		p_stream->m_bytes_in_buffer -= (OPJ_SIZE_T)p_size;
+		l_skip_nb_bytes += p_size;
+		p_stream->m_byte_offset += l_skip_nb_bytes;
+		return l_skip_nb_bytes;
 	}
-	return *cio->bp++;
+
+	/* we are now in the case when the remaining data if not sufficient */
+	if (p_stream->m_status & opj_stream_e_end) {
+		l_skip_nb_bytes += (OPJ_OFF_T)p_stream->m_bytes_in_buffer;
+		p_stream->m_current_data += p_stream->m_bytes_in_buffer;
+		p_stream->m_bytes_in_buffer = 0;
+		p_stream->m_byte_offset += l_skip_nb_bytes;
+		return l_skip_nb_bytes ? l_skip_nb_bytes : (OPJ_OFF_T) -1;
+	}
+
+	/* the flag is not set, we copy data and then do an actual skip on the stream */
+	if (p_stream->m_bytes_in_buffer) {
+		l_skip_nb_bytes += (OPJ_OFF_T)p_stream->m_bytes_in_buffer;
+		p_stream->m_current_data = p_stream->m_stored_data;
+		p_size -= (OPJ_OFF_T)p_stream->m_bytes_in_buffer;
+		p_stream->m_bytes_in_buffer = 0;
+	}
+
+	while (p_size > 0) {
+		/* we should do an actual skip on the media */
+		l_current_skip_nb_bytes = p_stream->m_skip_fn(p_size, p_stream->m_user_data);
+		if (l_current_skip_nb_bytes == (OPJ_OFF_T) -1) {
+			opj_event_msg(p_event_mgr, EVT_INFO, "Stream reached its end !\n");
+
+			p_stream->m_status |= opj_stream_e_end;
+			p_stream->m_byte_offset += l_skip_nb_bytes;
+			/* end if stream */
+			return l_skip_nb_bytes ? l_skip_nb_bytes : (OPJ_OFF_T) -1;
+		}
+		p_size -= l_current_skip_nb_bytes;
+		l_skip_nb_bytes += l_current_skip_nb_bytes;
+	}
+
+	p_stream->m_byte_offset += l_skip_nb_bytes;
+	
+	return l_skip_nb_bytes;
 }
 
-/*
- * Write some bytes.
- *
- * v : value to write
- * n : number of bytes to write
- */
-unsigned int cio_write(opj_cio_t *cio, unsigned int64 v, int n) {
-	int i;
-	for (i = n - 1; i >= 0; i--) {
-		if( !cio_byteout(cio, (unsigned char) ((v >> (i << 3)) & 0xff)) )
-			return 0;
+OPJ_OFF_T opj_stream_write_skip (opj_stream_private_t * p_stream, OPJ_OFF_T p_size, opj_event_mgr_t * p_event_mgr)
+{
+	OPJ_BOOL l_is_written = 0;
+	OPJ_OFF_T l_current_skip_nb_bytes = 0;
+	OPJ_OFF_T l_skip_nb_bytes = 0;
+
+	if (p_stream->m_status & opj_stream_e_error) {
+		return (OPJ_OFF_T) -1;
+	}
+
+	/* we should flush data */
+	l_is_written = opj_stream_flush (p_stream, p_event_mgr);
+	if (! l_is_written) {
+		p_stream->m_status |= opj_stream_e_error;
+		p_stream->m_bytes_in_buffer = 0;
+		return (OPJ_OFF_T) -1;
+	}
+	/* then skip */
+
+	while (p_size > 0) {
+		/* we should do an actual skip on the media */
+		l_current_skip_nb_bytes = p_stream->m_skip_fn(p_size, p_stream->m_user_data);
+		
+		if (l_current_skip_nb_bytes == (OPJ_OFF_T)-1) {
+			opj_event_msg(p_event_mgr, EVT_INFO, "Stream error!\n");
+
+			p_stream->m_status |= opj_stream_e_error;
+			p_stream->m_byte_offset += l_skip_nb_bytes;
+			/* end if stream */
+			return l_skip_nb_bytes ? l_skip_nb_bytes : (OPJ_OFF_T)-1;
+		}
+		p_size -= l_current_skip_nb_bytes;
+		l_skip_nb_bytes += l_current_skip_nb_bytes;
 	}
-	return n;
+
+	p_stream->m_byte_offset += l_skip_nb_bytes;
+	
+	return l_skip_nb_bytes;
 }
 
-/*
- * Read some bytes.
- *
- * n : number of bytes to read
- *
- * return : value of the n bytes read
- */
-unsigned int cio_read(opj_cio_t *cio, int n) {
-	int i;
-	unsigned int v;
-	v = 0;
-	for (i = n - 1; i >= 0; i--) {
-		v += (unsigned int)cio_bytein(cio) << (i << 3);
+OPJ_OFF_T opj_stream_tell (const opj_stream_private_t * p_stream)
+{
+	return p_stream->m_byte_offset;
+}
+
+OPJ_OFF_T opj_stream_get_number_byte_left (const opj_stream_private_t * p_stream)
+{
+  assert( p_stream->m_byte_offset >= 0 );
+  assert( p_stream->m_user_data_length >= (OPJ_UINT64)p_stream->m_byte_offset);
+  return p_stream->m_user_data_length ?
+				(OPJ_OFF_T)(p_stream->m_user_data_length) - p_stream->m_byte_offset :
+				0;
+}
+
+OPJ_OFF_T opj_stream_skip (opj_stream_private_t * p_stream, OPJ_OFF_T p_size, opj_event_mgr_t * p_event_mgr)
+{
+	assert(p_size >= 0);
+	return p_stream->m_opj_skip(p_stream,p_size,p_event_mgr);
+}
+
+OPJ_BOOL opj_stream_read_seek (opj_stream_private_t * p_stream, OPJ_OFF_T p_size, opj_event_mgr_t * p_event_mgr)
+{
+	OPJ_ARG_NOT_USED(p_event_mgr);
+	p_stream->m_current_data = p_stream->m_stored_data;
+	p_stream->m_bytes_in_buffer = 0;
+
+	if( !(p_stream->m_seek_fn(p_size,p_stream->m_user_data)) ) {
+		p_stream->m_status |= opj_stream_e_end;
+		return OPJ_FALSE;
+	}
+	else {
+		/* reset stream status */
+		p_stream->m_status &= (~opj_stream_e_end);
+		p_stream->m_byte_offset = p_size;
+
+	}
+
+	return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_stream_write_seek (opj_stream_private_t * p_stream, OPJ_OFF_T p_size, opj_event_mgr_t * p_event_mgr)
+{
+	if (! opj_stream_flush(p_stream,p_event_mgr)) {
+		p_stream->m_status |= opj_stream_e_error;
+		return OPJ_FALSE;
 	}
-	return v;
+
+	p_stream->m_current_data = p_stream->m_stored_data;
+	p_stream->m_bytes_in_buffer = 0;
+
+	if (! p_stream->m_seek_fn(p_size,p_stream->m_user_data)) {
+		p_stream->m_status |= opj_stream_e_error;
+		return OPJ_FALSE;
+	}
+	else {
+		p_stream->m_byte_offset = p_size;
+	}
+
+	return OPJ_TRUE;
 }
 
-/* 
- * Skip some bytes.
- *
- * n : number of bytes to skip
- */
-void cio_skip(opj_cio_t *cio, int n) {
-  assert((cio->bp + n) >= cio->bp);
-  if (((cio->bp + n) < cio->start) || ((cio->bp + n) > cio->end)) {
-    assert(0);
-  }
-	cio->bp += n;
+OPJ_BOOL opj_stream_seek (opj_stream_private_t * p_stream, OPJ_OFF_T p_size, struct opj_event_mgr * p_event_mgr)
+{
+	assert(p_size >= 0);
+	return p_stream->m_opj_seek(p_stream,p_size,p_event_mgr);
+}
+
+OPJ_BOOL opj_stream_has_seek (const opj_stream_private_t * p_stream)
+{
+	return p_stream->m_seek_fn != opj_stream_default_seek;
 }
 
+OPJ_SIZE_T opj_stream_default_read (void * p_buffer, OPJ_SIZE_T p_nb_bytes, void * p_user_data)
+{
+	OPJ_ARG_NOT_USED(p_buffer);
+	OPJ_ARG_NOT_USED(p_nb_bytes);
+	OPJ_ARG_NOT_USED(p_user_data);
+	return (OPJ_SIZE_T) -1;
+}
 
+OPJ_SIZE_T opj_stream_default_write (void * p_buffer, OPJ_SIZE_T p_nb_bytes, void * p_user_data)
+{
+	OPJ_ARG_NOT_USED(p_buffer);
+	OPJ_ARG_NOT_USED(p_nb_bytes);
+	OPJ_ARG_NOT_USED(p_user_data);
+	return (OPJ_SIZE_T) -1;
+}
 
+OPJ_OFF_T opj_stream_default_skip (OPJ_OFF_T p_nb_bytes, void * p_user_data)
+{
+	OPJ_ARG_NOT_USED(p_nb_bytes);
+	OPJ_ARG_NOT_USED(p_user_data);
+	return (OPJ_OFF_T) -1;
+}
+
+OPJ_BOOL opj_stream_default_seek (OPJ_OFF_T p_nb_bytes, void * p_user_data)
+{
+	OPJ_ARG_NOT_USED(p_nb_bytes);
+	OPJ_ARG_NOT_USED(p_user_data);
+	return OPJ_FALSE;
+}
diff --git a/extern/libopenjpeg/cio.h b/extern/libopenjpeg/cio.h
index e627431..6dfa5bb 100644
--- a/extern/libopenjpeg/cio.h
+++ b/extern/libopenjpeg/cio.h
@@ -1,10 +1,18 @@
 /*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2001-2003, David Janssens
  * Copyright (c) 2002-2003, Yannick Verschueren
- * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * Copyright (c) 2003-2014, Antonin Descampe
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR 
+ * Copyright (c) 2012, CS Systemes d'Information, France
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -31,13 +39,6 @@
 
 #ifndef __CIO_H
 #define __CIO_H
-
-#if defined(_MSC_VER) || defined(__BORLANDC__)
-#define int64 __int64
-#else
-#define int64 long long
-#endif
-
 /**
 @file cio.h
 @brief Implementation of a byte input-output process (CIO)
@@ -48,46 +49,351 @@ The functions in CIO.C have for goal to realize a byte input / output process.
 /** @defgroup CIO CIO - byte input-output stream */
 /*@{*/
 
+#include "opj_config_private.h"
+
+/* ----------------------------------------------------------------------- */
+
+#if defined(OPJ_BIG_ENDIAN)
+	#define opj_write_bytes		opj_write_bytes_BE
+	#define opj_read_bytes		opj_read_bytes_BE
+	#define opj_write_double	opj_write_double_BE
+	#define opj_read_double		opj_read_double_BE
+	#define opj_write_float		opj_write_float_BE
+	#define opj_read_float		opj_read_float_BE
+#else
+	#define opj_write_bytes		opj_write_bytes_LE
+	#define opj_read_bytes		opj_read_bytes_LE
+	#define opj_write_double	opj_write_double_LE
+	#define opj_read_double		opj_read_double_LE
+	#define opj_write_float		opj_write_float_LE
+	#define opj_read_float		opj_read_float_LE
+#endif
+
+
+
+typedef enum
+{
+	opj_signed_sentinel		= -1, /* do not use in code */
+	opj_stream_e_output		= 0x1,
+	opj_stream_e_input		= 0x2,
+	opj_stream_e_end		= 0x4,
+	opj_stream_e_error		= 0x8
+}
+opj_stream_flag ;
+
+/**
+Byte input-output stream.
+*/
+typedef struct opj_stream_private
+{
+	/**
+	 * User data, be it files, ... The actual data depends on the type of the stream.
+	 */
+	void *					m_user_data;
+
+	/**
+	 * Pointer to function to free m_user_data (NULL at initialization)
+	 * when destroying the stream. If pointer is NULL the function is not
+	 * called and the m_user_data is not freed (even if non-NULL).
+	 */
+	opj_stream_free_user_data_fn		m_free_user_data_fn;
+
+	/**
+	 * User data length
+	 */
+	OPJ_UINT64 				m_user_data_length;
+
+	/**
+	 * Pointer to actual read function (NULL at the initialization of the cio.
+	 */
+	opj_stream_read_fn		m_read_fn;
+
+	/**
+	 * Pointer to actual write function (NULL at the initialization of the cio.
+	 */
+	opj_stream_write_fn		m_write_fn;
+
+	/**
+	 * Pointer to actual skip function (NULL at the initialization of the cio.
+	 * There is no seek function to prevent from back and forth slow procedures.
+	 */
+	opj_stream_skip_fn		m_skip_fn;
+
+	/**
+	 * Pointer to actual seek function (if available).
+	 */
+	opj_stream_seek_fn		m_seek_fn;
+
+	/**
+	 * Actual data stored into the stream if readed from. Data is read by chunk of fixed size.
+	 * you should never access this data directly.
+	 */
+	OPJ_BYTE *					m_stored_data;
+
+	/**
+	 * Pointer to the current read data.
+	 */
+	OPJ_BYTE *					m_current_data;
+
+    /**
+    * FIXME DOC.
+    */
+	OPJ_OFF_T (* m_opj_skip)(struct opj_stream_private * ,OPJ_OFF_T , struct opj_event_mgr *);
+
+    /**
+    * FIXME DOC.
+    */
+	OPJ_BOOL (* m_opj_seek) (struct opj_stream_private * , OPJ_OFF_T , struct opj_event_mgr *);
+
+	/**
+	 * number of bytes containing in the buffer.
+	 */
+	OPJ_SIZE_T			m_bytes_in_buffer;
+
+	/**
+	 * The number of bytes read/written from the beginning of the stream
+	 */
+	OPJ_OFF_T			m_byte_offset;
+
+	/**
+	 * The size of the buffer.
+	 */
+	OPJ_SIZE_T			m_buffer_size;
+
+	/**
+	 * Flags to tell the status of the stream.
+	 */
+	opj_stream_flag m_status;
+
+}
+opj_stream_private_t;
+
 /** @name Exported functions (see also openjpeg.h) */
 /*@{*/
 /* ----------------------------------------------------------------------- */
 /**
-Number of bytes left before the end of the stream
-@param cio CIO handle
-@return Returns the number of bytes before the end of the stream
+ * Write some bytes to the given data buffer, this function is used in Big Endian cpus.
+ * @param p_buffer		pointer the data buffer to write data to.
+ * @param p_value		the value to write
+ * @param p_nb_bytes	the number of bytes to write
 */
-int cio_numbytesleft(opj_cio_t *cio);
+void opj_write_bytes_BE (OPJ_BYTE * p_buffer, OPJ_UINT32 p_value, OPJ_UINT32 p_nb_bytes);
+
 /**
-Get pointer to the current position in the stream
-@param cio CIO handle
-@return Returns a pointer to the current position
-*/
-unsigned char *cio_getbp(opj_cio_t *cio);
+ * Reads some bytes from the given data buffer, this function is used in Big Endian cpus.
+ * @param p_buffer		pointer the data buffer to read data from.
+ * @param p_value		pointer to the value that will store the data.
+ * @param p_nb_bytes	the nb bytes to read.
+ * @return				the number of bytes read or -1 if an error occured.
+ */
+void opj_read_bytes_BE(const OPJ_BYTE * p_buffer, OPJ_UINT32 * p_value, OPJ_UINT32 p_nb_bytes);
+
 /**
-Write some bytes
-@param cio CIO handle
-@param v Value to write
-@param n Number of bytes to write
-@return Returns the number of bytes written or 0 if an error occured
+ * Write some bytes to the given data buffer, this function is used in Little Endian cpus.
+ * @param p_buffer		pointer the data buffer to write data to.
+ * @param p_value		the value to write
+ * @param p_nb_bytes	the number of bytes to write
+ * @return				the number of bytes written or -1 if an error occured
 */
-unsigned int cio_write(opj_cio_t *cio, unsigned int64 v, int n);
+void opj_write_bytes_LE (OPJ_BYTE * p_buffer, OPJ_UINT32 p_value, OPJ_UINT32 p_nb_bytes);
+
 /**
-Read some bytes
-@param cio CIO handle
-@param n Number of bytes to read
-@return Returns the value of the n bytes read
-*/
-unsigned int cio_read(opj_cio_t *cio, int n);
+ * Reads some bytes from the given data buffer, this function is used in Little Endian cpus.
+ * @param p_buffer		pointer the data buffer to read data from.
+ * @param p_value		pointer to the value that will store the data.
+ * @param p_nb_bytes	the nb bytes to read.
+ * @return				the number of bytes read or -1 if an error occured.
+ */
+void opj_read_bytes_LE(const OPJ_BYTE * p_buffer, OPJ_UINT32 * p_value, OPJ_UINT32 p_nb_bytes);
+
+
 /**
-Skip some bytes
-@param cio CIO handle
-@param n Number of bytes to skip
-*/
-void cio_skip(opj_cio_t *cio, int n);
+ * Write some bytes to the given data buffer, this function is used in Little Endian cpus.
+ * @param p_buffer		pointer the data buffer to write data to.
+ * @param p_value		the value to write
+ */
+void opj_write_double_LE(OPJ_BYTE * p_buffer, OPJ_FLOAT64 p_value);
+
+/***
+ * Write some bytes to the given data buffer, this function is used in Big Endian cpus.
+ * @param p_buffer		pointer the data buffer to write data to.
+ * @param p_value		the value to write
+ */
+void opj_write_double_BE(OPJ_BYTE * p_buffer, OPJ_FLOAT64 p_value);
+
+/**
+ * Reads some bytes from the given data buffer, this function is used in Little Endian cpus.
+ * @param p_buffer		pointer the data buffer to read data from.
+ * @param p_value		pointer to the value that will store the data.
+ */
+void opj_read_double_LE(const OPJ_BYTE * p_buffer, OPJ_FLOAT64 * p_value);
+
+/**
+ * Reads some bytes from the given data buffer, this function is used in Big Endian cpus.
+ * @param p_buffer		pointer the data buffer to read data from.
+ * @param p_value		pointer to the value that will store the data.
+ */
+void opj_read_double_BE(const OPJ_BYTE * p_buffer, OPJ_FLOAT64 * p_value);
+
+/**
+ * Reads some bytes from the given data buffer, this function is used in Little Endian cpus.
+ * @param p_buffer		pointer the data buffer to read data from.
+ * @param p_value		pointer to the value that will store the data.
+ */
+void opj_read_float_LE(const OPJ_BYTE * p_buffer, OPJ_FLOAT32 * p_value);
+
+/**
+ * Reads some bytes from the given data buffer, this function is used in Big Endian cpus.
+ * @param p_buffer		pointer the data buffer to read data from.
+ * @param p_value		pointer to the value that will store the data.
+ */
+void opj_read_float_BE(const OPJ_BYTE * p_buffer, OPJ_FLOAT32 * p_value);
+
+/**
+ * Write some bytes to the given data buffer, this function is used in Little Endian cpus.
+ * @param p_buffer		pointer the data buffer to write data to.
+ * @param p_value		the value to write
+ */
+void opj_write_float_LE(OPJ_BYTE * p_buffer, OPJ_FLOAT32 p_value);
+
+/***
+ * Write some bytes to the given data buffer, this function is used in Big Endian cpus.
+ * @param p_buffer		pointer the data buffer to write data to.
+ * @param p_value		the value to write
+ */
+void opj_write_float_BE(OPJ_BYTE * p_buffer, OPJ_FLOAT32 p_value);
+
+/**
+ * Reads some bytes from the stream.
+ * @param		p_stream	the stream to read data from.
+ * @param		p_buffer	pointer to the data buffer that will receive the data.
+ * @param		p_size		number of bytes to read.
+ * @param		p_event_mgr	the user event manager to be notified of special events.
+ * @return		the number of bytes read, or -1 if an error occured or if the stream is at the end.
+ */
+OPJ_SIZE_T opj_stream_read_data (opj_stream_private_t * p_stream,OPJ_BYTE * p_buffer, OPJ_SIZE_T p_size, struct opj_event_mgr * p_event_mgr);
+
+/**
+ * Writes some bytes to the stream.
+ * @param		p_stream	the stream to write data to.
+ * @param		p_buffer	pointer to the data buffer holds the data to be writtent.
+ * @param		p_size		number of bytes to write.
+ * @param		p_event_mgr	the user event manager to be notified of special events.
+ * @return		the number of bytes writtent, or -1 if an error occured.
+ */
+OPJ_SIZE_T opj_stream_write_data (opj_stream_private_t * p_stream,const OPJ_BYTE * p_buffer, OPJ_SIZE_T p_size, struct opj_event_mgr * p_event_mgr);
+
+/**
+ * Writes the content of the stream buffer to the stream.
+ * @param		p_stream	the stream to write data to.
+ * @param		p_event_mgr	the user event manager to be notified of special events.
+ * @return		true if the data could be flushed, false else.
+ */
+OPJ_BOOL opj_stream_flush (opj_stream_private_t * p_stream, struct opj_event_mgr * p_event_mgr);
+
+/**
+ * Skips a number of bytes from the stream.
+ * @param		p_stream	the stream to skip data from.
+ * @param		p_size		the number of bytes to skip.
+ * @param		p_event_mgr	the user event manager to be notified of special events.
+ * @return		the number of bytes skipped, or -1 if an error occured.
+ */
+OPJ_OFF_T opj_stream_skip (opj_stream_private_t * p_stream,OPJ_OFF_T p_size, struct opj_event_mgr * p_event_mgr);
+
+/**
+ * Tells the byte offset on the stream (similar to ftell).
+ *
+ * @param		p_stream	the stream to get the information from.
+ *
+ * @return		the current position o fthe stream.
+ */
+OPJ_OFF_T opj_stream_tell (const opj_stream_private_t * p_stream);
+
+
+/**
+ * Get the number of bytes left before the end of the stream (similar to cio_numbytesleft).
+ *
+ * @param		p_stream	the stream to get the information from.
+ *
+ * @return		Number of bytes left before the end of the stream.
+ */
+OPJ_OFF_T opj_stream_get_number_byte_left (const opj_stream_private_t * p_stream);
+
+/**
+ * Skips a number of bytes from the stream.
+ * @param		p_stream	the stream to skip data from.
+ * @param		p_size		the number of bytes to skip.
+ * @param		p_event_mgr	the user event manager to be notified of special events.
+ * @return		the number of bytes skipped, or -1 if an error occured.
+ */
+OPJ_OFF_T opj_stream_write_skip (opj_stream_private_t * p_stream, OPJ_OFF_T p_size, struct opj_event_mgr * p_event_mgr);
+
+/**
+ * Skips a number of bytes from the stream.
+ * @param		p_stream	the stream to skip data from.
+ * @param		p_size		the number of bytes to skip.
+ * @param		p_event_mgr	the user event manager to be notified of special events.
+ * @return		the number of bytes skipped, or -1 if an error occured.
+ */
+OPJ_OFF_T opj_stream_read_skip (opj_stream_private_t * p_stream, OPJ_OFF_T p_size, struct opj_event_mgr * p_event_mgr);
+
+/**
+ * Skips a number of bytes from the stream.
+ * @param		p_stream	the stream to skip data from.
+ * @param		p_size		the number of bytes to skip.
+ * @param		p_event_mgr	the user event manager to be notified of special events.
+ * @return		OPJ_TRUE if success, or OPJ_FALSE if an error occured.
+ */
+OPJ_BOOL opj_stream_read_seek (opj_stream_private_t * p_stream, OPJ_OFF_T p_size, struct opj_event_mgr * p_event_mgr);
+
+/**
+ * Skips a number of bytes from the stream.
+ * @param		p_stream	the stream to skip data from.
+ * @param		p_size		the number of bytes to skip.
+ * @param		p_event_mgr	the user event manager to be notified of special events.
+ * @return		the number of bytes skipped, or -1 if an error occured.
+ */
+OPJ_BOOL opj_stream_write_seek (opj_stream_private_t * p_stream, OPJ_OFF_T p_size, struct opj_event_mgr * p_event_mgr);
+
+/**
+ * Seeks a number of bytes from the stream.
+ * @param		p_stream	the stream to skip data from.
+ * @param		p_size		the number of bytes to skip.
+ * @param		p_event_mgr	the user event manager to be notified of special events.
+ * @return		true if the stream is seekable.
+ */
+OPJ_BOOL opj_stream_seek (opj_stream_private_t * p_stream, OPJ_OFF_T p_size, struct opj_event_mgr * p_event_mgr);
+
+/**
+ * Tells if the given stream is seekable.
+ */
+OPJ_BOOL opj_stream_has_seek (const opj_stream_private_t * p_stream);
+
+/**
+ * FIXME DOC.
+ */
+OPJ_SIZE_T opj_stream_default_read (void * p_buffer, OPJ_SIZE_T p_nb_bytes, void * p_user_data);
+
+/**
+ * FIXME DOC.
+ */
+OPJ_SIZE_T opj_stream_default_write (void * p_buffer, OPJ_SIZE_T p_nb_bytes, void * p_user_data);
+
+/**
+ * FIXME DOC.
+ */
+OPJ_OFF_T opj_stream_default_skip (OPJ_OFF_T p_nb_bytes, void * p_user_data);
+
+/**
+ * FIXME DOC.
+ */
+OPJ_BOOL opj_stream_default_seek (OPJ_OFF_T p_nb_bytes, void * p_user_data);
+
 /* ----------------------------------------------------------------------- */
 /*@}*/
 
 /*@}*/
 
+
 #endif /* __CIO_H */
 
diff --git a/extern/libopenjpeg/dwt.c b/extern/libopenjpeg/dwt.c
index 0fbfc20..e1f8a33 100644
--- a/extern/libopenjpeg/dwt.c
+++ b/extern/libopenjpeg/dwt.c
@@ -1,9 +1,15 @@
 /*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2001-2003, David Janssens
  * Copyright (c) 2002-2003, Yannick Verschueren
- * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * Copyright (c) 2003-2014, Antonin Descampe
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
  * Copyright (c) 2007, Jonathan Ballard <dzonatas@dzonux.net>
  * Copyright (c) 2007, Callum Lerwick <seg@haxxed.com>
@@ -40,45 +46,44 @@
 /** @defgroup DWT DWT - Implementation of a discrete wavelet transform */
 /*@{*/
 
-#define WS(i) v->mem[(i)*2]
-#define WD(i) v->mem[(1+(i)*2)]
+#define OPJ_WS(i) v->mem[(i)*2]
+#define OPJ_WD(i) v->mem[(1+(i)*2)]
 
 /** @name Local data structures */
 /*@{*/
 
 typedef struct dwt_local {
-	int* mem;
-	int dn;
-	int sn;
-	int cas;
-} dwt_t;
+	OPJ_INT32* mem;
+	OPJ_INT32 dn;
+	OPJ_INT32 sn;
+	OPJ_INT32 cas;
+} opj_dwt_t;
 
 typedef union {
-	float	f[4];
-} v4;
+	OPJ_FLOAT32	f[4];
+} opj_v4_t;
 
 typedef struct v4dwt_local {
-	v4*	wavelet ;
-	int		dn ;
-	int		sn ;
-	int		cas ;
-} v4dwt_t ;
+	opj_v4_t*	wavelet ;
+	OPJ_INT32		dn ;
+	OPJ_INT32		sn ;
+	OPJ_INT32		cas ;
+} opj_v4dwt_t ;
 
-static const float dwt_alpha =  1.586134342f; /*  12994 */
-static const float dwt_beta  =  0.052980118f; /*    434 */
-static const float dwt_gamma = -0.882911075f; /*  -7233 */
-static const float dwt_delta = -0.443506852f; /*  -3633 */
+static const OPJ_FLOAT32 opj_dwt_alpha =  1.586134342f; /*  12994 */
+static const OPJ_FLOAT32 opj_dwt_beta  =  0.052980118f; /*    434 */
+static const OPJ_FLOAT32 opj_dwt_gamma = -0.882911075f; /*  -7233 */
+static const OPJ_FLOAT32 opj_dwt_delta = -0.443506852f; /*  -3633 */
 
-static const float K      = 1.230174105f; /*  10078 */
-/* FIXME: What is this constant? */
-static const float c13318 = 1.625732422f;
+static const OPJ_FLOAT32 opj_K      = 1.230174105f; /*  10078 */
+static const OPJ_FLOAT32 opj_c13318 = 1.625732422f;
 
 /*@}*/
 
 /**
 Virtual function type for wavelet transform in 1-D 
 */
-typedef void (*DWT1DFN)(dwt_t* v);
+typedef void (*DWT1DFN)(opj_dwt_t* v);
 
 /** @name Local static functions */
 /*@{*/
@@ -86,56 +91,83 @@ typedef void (*DWT1DFN)(dwt_t* v);
 /**
 Forward lazy transform (horizontal)
 */
-static void dwt_deinterleave_h(int *a, int *b, int dn, int sn, int cas);
+static void opj_dwt_deinterleave_h(OPJ_INT32 *a, OPJ_INT32 *b, OPJ_INT32 dn, OPJ_INT32 sn, OPJ_INT32 cas);
 /**
 Forward lazy transform (vertical)
 */
-static void dwt_deinterleave_v(int *a, int *b, int dn, int sn, int x, int cas);
+static void opj_dwt_deinterleave_v(OPJ_INT32 *a, OPJ_INT32 *b, OPJ_INT32 dn, OPJ_INT32 sn, OPJ_INT32 x, OPJ_INT32 cas);
 /**
 Inverse lazy transform (horizontal)
 */
-static void dwt_interleave_h(dwt_t* h, int *a);
+static void opj_dwt_interleave_h(opj_dwt_t* h, OPJ_INT32 *a);
 /**
 Inverse lazy transform (vertical)
 */
-static void dwt_interleave_v(dwt_t* v, int *a, int x);
+static void opj_dwt_interleave_v(opj_dwt_t* v, OPJ_INT32 *a, OPJ_INT32 x);
 /**
 Forward 5-3 wavelet transform in 1-D
 */
-static void dwt_encode_1(int *a, int dn, int sn, int cas);
+static void opj_dwt_encode_1(OPJ_INT32 *a, OPJ_INT32 dn, OPJ_INT32 sn, OPJ_INT32 cas);
 /**
 Inverse 5-3 wavelet transform in 1-D
 */
-static void dwt_decode_1(dwt_t *v);
+static void opj_dwt_decode_1(opj_dwt_t *v);
+static void opj_dwt_decode_1_(OPJ_INT32 *a, OPJ_INT32 dn, OPJ_INT32 sn, OPJ_INT32 cas);
 /**
 Forward 9-7 wavelet transform in 1-D
 */
-static void dwt_encode_1_real(int *a, int dn, int sn, int cas);
+static void opj_dwt_encode_1_real(OPJ_INT32 *a, OPJ_INT32 dn, OPJ_INT32 sn, OPJ_INT32 cas);
 /**
 Explicit calculation of the Quantization Stepsizes 
 */
-static void dwt_encode_stepsize(int stepsize, int numbps, opj_stepsize_t *bandno_stepsize);
+static void opj_dwt_encode_stepsize(OPJ_INT32 stepsize, OPJ_INT32 numbps, opj_stepsize_t *bandno_stepsize);
 /**
 Inverse wavelet transform in 2-D.
 */
-static void dwt_decode_tile(opj_tcd_tilecomp_t* tilec, int i, DWT1DFN fn);
+static OPJ_BOOL opj_dwt_decode_tile(opj_tcd_tilecomp_t* tilec, OPJ_UINT32 i, DWT1DFN fn);
+
+static OPJ_BOOL opj_dwt_encode_procedure(	opj_tcd_tilecomp_t * tilec,
+										    void (*p_function)(OPJ_INT32 *, OPJ_INT32,OPJ_INT32,OPJ_INT32) );
+
+static OPJ_UINT32 opj_dwt_max_resolution(opj_tcd_resolution_t* restrict r, OPJ_UINT32 i);
+
+/* <summary>                             */
+/* Inverse 9-7 wavelet transform in 1-D. */
+/* </summary>                            */
+static void opj_v4dwt_decode(opj_v4dwt_t* restrict dwt);
+
+static void opj_v4dwt_interleave_h(opj_v4dwt_t* restrict w, OPJ_FLOAT32* restrict a, OPJ_INT32 x, OPJ_INT32 size);
+
+static void opj_v4dwt_interleave_v(opj_v4dwt_t* restrict v , OPJ_FLOAT32* restrict a , OPJ_INT32 x, OPJ_INT32 nb_elts_read);
+
+#ifdef __SSE__
+static void opj_v4dwt_decode_step1_sse(opj_v4_t* w, OPJ_INT32 count, const __m128 c);
+
+static void opj_v4dwt_decode_step2_sse(opj_v4_t* l, opj_v4_t* w, OPJ_INT32 k, OPJ_INT32 m, __m128 c);
+
+#else
+static void opj_v4dwt_decode_step1(opj_v4_t* w, OPJ_INT32 count, const OPJ_FLOAT32 c);
+
+static void opj_v4dwt_decode_step2(opj_v4_t* l, opj_v4_t* w, OPJ_INT32 k, OPJ_INT32 m, OPJ_FLOAT32 c);
+
+#endif
 
 /*@}*/
 
 /*@}*/
 
-#define S(i) a[(i)*2]
-#define D(i) a[(1+(i)*2)]
-#define S_(i) ((i)<0?S(0):((i)>=sn?S(sn-1):S(i)))
-#define D_(i) ((i)<0?D(0):((i)>=dn?D(dn-1):D(i)))
+#define OPJ_S(i) a[(i)*2]
+#define OPJ_D(i) a[(1+(i)*2)]
+#define OPJ_S_(i) ((i)<0?OPJ_S(0):((i)>=sn?OPJ_S(sn-1):OPJ_S(i)))
+#define OPJ_D_(i) ((i)<0?OPJ_D(0):((i)>=dn?OPJ_D(dn-1):OPJ_D(i)))
 /* new */
-#define SS_(i) ((i)<0?S(0):((i)>=dn?S(dn-1):S(i)))
-#define DD_(i) ((i)<0?D(0):((i)>=sn?D(sn-1):D(i)))
+#define OPJ_SS_(i) ((i)<0?OPJ_S(0):((i)>=dn?OPJ_S(dn-1):OPJ_S(i)))
+#define OPJ_DD_(i) ((i)<0?OPJ_D(0):((i)>=sn?OPJ_D(sn-1):OPJ_D(i)))
 
 /* <summary>                                                              */
 /* This table contains the norms of the 5-3 wavelets for different bands. */
 /* </summary>                                                             */
-static const double dwt_norms[4][10] = {
+static const OPJ_FLOAT64 opj_dwt_norms[4][10] = {
 	{1.000, 1.500, 2.750, 5.375, 10.68, 21.34, 42.67, 85.33, 170.7, 341.3},
 	{1.038, 1.592, 2.919, 5.703, 11.33, 22.64, 45.25, 90.48, 180.9},
 	{1.038, 1.592, 2.919, 5.703, 11.33, 22.64, 45.25, 90.48, 180.9},
@@ -145,7 +177,7 @@ static const double dwt_norms[4][10] = {
 /* <summary>                                                              */
 /* This table contains the norms of the 9-7 wavelets for different bands. */
 /* </summary>                                                             */
-static const double dwt_norms_real[4][10] = {
+static const OPJ_FLOAT64 opj_dwt_norms_real[4][10] = {
 	{1.000, 1.965, 4.177, 8.403, 16.90, 33.84, 67.69, 135.3, 270.6, 540.9},
 	{2.022, 3.989, 8.355, 17.04, 34.27, 68.63, 137.3, 274.6, 549.0},
 	{2.022, 3.989, 8.355, 17.04, 34.27, 68.63, 137.3, 274.6, 549.0},
@@ -161,28 +193,57 @@ static const double dwt_norms_real[4][10] = {
 /* <summary>			                 */
 /* Forward lazy transform (horizontal).  */
 /* </summary>                            */ 
-static void dwt_deinterleave_h(int *a, int *b, int dn, int sn, int cas) {
-	int i;
-    for (i=0; i<sn; i++) b[i]=a[2*i+cas];
-    for (i=0; i<dn; i++) b[sn+i]=a[(2*i+1-cas)];
+void opj_dwt_deinterleave_h(OPJ_INT32 *a, OPJ_INT32 *b, OPJ_INT32 dn, OPJ_INT32 sn, OPJ_INT32 cas) {
+	OPJ_INT32 i;
+	OPJ_INT32 * l_dest = b;
+	OPJ_INT32 * l_src = a+cas;
+
+    for (i=0; i<sn; ++i) {
+		*l_dest++ = *l_src;
+		l_src += 2;
+	}
+	
+    l_dest = b + sn;
+	l_src = a + 1 - cas;
+
+    for	(i=0; i<dn; ++i)  {
+		*l_dest++=*l_src;
+		l_src += 2;
+	}
 }
 
 /* <summary>                             */  
 /* Forward lazy transform (vertical).    */
 /* </summary>                            */ 
-static void dwt_deinterleave_v(int *a, int *b, int dn, int sn, int x, int cas) {
-    int i;
-    for (i=0; i<sn; i++) b[i*x]=a[2*i+cas];
-    for (i=0; i<dn; i++) b[(sn+i)*x]=a[(2*i+1-cas)];
+void opj_dwt_deinterleave_v(OPJ_INT32 *a, OPJ_INT32 *b, OPJ_INT32 dn, OPJ_INT32 sn, OPJ_INT32 x, OPJ_INT32 cas) {
+    OPJ_INT32 i = sn;
+	OPJ_INT32 * l_dest = b;
+	OPJ_INT32 * l_src = a+cas;
+
+    while (i--) {
+		*l_dest = *l_src;
+		l_dest += x;
+		l_src += 2;
+		} /* b[i*x]=a[2*i+cas]; */
+
+	l_dest = b + sn * x;
+	l_src = a + 1 - cas;
+	
+	i = dn;
+    while (i--) {
+		*l_dest = *l_src;
+		l_dest += x;
+		l_src += 2;
+        } /*b[(sn+i)*x]=a[(2*i+1-cas)];*/
 }
 
 /* <summary>                             */
 /* Inverse lazy transform (horizontal).  */
 /* </summary>                            */
-static void dwt_interleave_h(dwt_t* h, int *a) {
-    int *ai = a;
-    int *bi = h->mem + h->cas;
-    int  i	= h->sn;
+void opj_dwt_interleave_h(opj_dwt_t* h, OPJ_INT32 *a) {
+    OPJ_INT32 *ai = a;
+    OPJ_INT32 *bi = h->mem + h->cas;
+    OPJ_INT32  i	= h->sn;
     while( i-- ) {
       *bi = *(ai++);
 	  bi += 2;
@@ -199,10 +260,10 @@ static void dwt_interleave_h(dwt_t* h, int *a) {
 /* <summary>                             */  
 /* Inverse lazy transform (vertical).    */
 /* </summary>                            */ 
-static void dwt_interleave_v(dwt_t* v, int *a, int x) {
-    int *ai = a;
-    int *bi = v->mem + v->cas;
-    int  i = v->sn;
+void opj_dwt_interleave_v(opj_dwt_t* v, OPJ_INT32 *a, OPJ_INT32 x) {
+    OPJ_INT32 *ai = a;
+    OPJ_INT32 *bi = v->mem + v->cas;
+    OPJ_INT32  i = v->sn;
     while( i-- ) {
       *bi = *ai;
 	  bi += 2;
@@ -222,20 +283,20 @@ static void dwt_interleave_v(dwt_t* v, int *a, int x) {
 /* <summary>                            */
 /* Forward 5-3 wavelet transform in 1-D. */
 /* </summary>                           */
-static void dwt_encode_1(int *a, int dn, int sn, int cas) {
-	int i;
+void opj_dwt_encode_1(OPJ_INT32 *a, OPJ_INT32 dn, OPJ_INT32 sn, OPJ_INT32 cas) {
+	OPJ_INT32 i;
 	
 	if (!cas) {
 		if ((dn > 0) || (sn > 1)) {	/* NEW :  CASE ONE ELEMENT */
-			for (i = 0; i < dn; i++) D(i) -= (S_(i) + S_(i + 1)) >> 1;
-			for (i = 0; i < sn; i++) S(i) += (D_(i - 1) + D_(i) + 2) >> 2;
+			for (i = 0; i < dn; i++) OPJ_D(i) -= (OPJ_S_(i) + OPJ_S_(i + 1)) >> 1;
+			for (i = 0; i < sn; i++) OPJ_S(i) += (OPJ_D_(i - 1) + OPJ_D_(i) + 2) >> 2;
 		}
 	} else {
 		if (!sn && dn == 1)		    /* NEW :  CASE ONE ELEMENT */
-			S(0) *= 2;
+			OPJ_S(0) *= 2;
 		else {
-			for (i = 0; i < dn; i++) S(i) -= (DD_(i) + DD_(i - 1)) >> 1;
-			for (i = 0; i < sn; i++) D(i) += (SS_(i) + SS_(i + 1) + 2) >> 2;
+			for (i = 0; i < dn; i++) OPJ_S(i) -= (OPJ_DD_(i) + OPJ_DD_(i - 1)) >> 1;
+			for (i = 0; i < sn; i++) OPJ_D(i) += (OPJ_SS_(i) + OPJ_SS_(i + 1) + 2) >> 2;
 		}
 	}
 }
@@ -243,20 +304,20 @@ static void dwt_encode_1(int *a, int dn, int sn, int cas) {
 /* <summary>                            */
 /* Inverse 5-3 wavelet transform in 1-D. */
 /* </summary>                           */ 
-static void dwt_decode_1_(int *a, int dn, int sn, int cas) {
-	int i;
+void opj_dwt_decode_1_(OPJ_INT32 *a, OPJ_INT32 dn, OPJ_INT32 sn, OPJ_INT32 cas) {
+	OPJ_INT32 i;
 	
 	if (!cas) {
 		if ((dn > 0) || (sn > 1)) { /* NEW :  CASE ONE ELEMENT */
-			for (i = 0; i < sn; i++) S(i) -= (D_(i - 1) + D_(i) + 2) >> 2;
-			for (i = 0; i < dn; i++) D(i) += (S_(i) + S_(i + 1)) >> 1;
+			for (i = 0; i < sn; i++) OPJ_S(i) -= (OPJ_D_(i - 1) + OPJ_D_(i) + 2) >> 2;
+			for (i = 0; i < dn; i++) OPJ_D(i) += (OPJ_S_(i) + OPJ_S_(i + 1)) >> 1;
 		}
 	} else {
 		if (!sn  && dn == 1)          /* NEW :  CASE ONE ELEMENT */
-			S(0) /= 2;
+			OPJ_S(0) /= 2;
 		else {
-			for (i = 0; i < sn; i++) D(i) -= (SS_(i) + SS_(i + 1) + 2) >> 2;
-			for (i = 0; i < dn; i++) S(i) += (DD_(i) + DD_(i - 1)) >> 1;
+			for (i = 0; i < sn; i++) OPJ_D(i) -= (OPJ_SS_(i) + OPJ_SS_(i + 1) + 2) >> 2;
+			for (i = 0; i < dn; i++) OPJ_S(i) += (OPJ_DD_(i) + OPJ_DD_(i - 1)) >> 1;
 		}
 	}
 }
@@ -264,52 +325,52 @@ static void dwt_decode_1_(int *a, int dn, int sn, int cas) {
 /* <summary>                            */
 /* Inverse 5-3 wavelet transform in 1-D. */
 /* </summary>                           */ 
-static void dwt_decode_1(dwt_t *v) {
-	dwt_decode_1_(v->mem, v->dn, v->sn, v->cas);
+void opj_dwt_decode_1(opj_dwt_t *v) {
+	opj_dwt_decode_1_(v->mem, v->dn, v->sn, v->cas);
 }
 
 /* <summary>                             */
 /* Forward 9-7 wavelet transform in 1-D. */
 /* </summary>                            */
-static void dwt_encode_1_real(int *a, int dn, int sn, int cas) {
-	int i;
+void opj_dwt_encode_1_real(OPJ_INT32 *a, OPJ_INT32 dn, OPJ_INT32 sn, OPJ_INT32 cas) {
+	OPJ_INT32 i;
 	if (!cas) {
 		if ((dn > 0) || (sn > 1)) {	/* NEW :  CASE ONE ELEMENT */
 			for (i = 0; i < dn; i++)
-				D(i) -= fix_mul(S_(i) + S_(i + 1), 12993);
+				OPJ_D(i) -= opj_int_fix_mul(OPJ_S_(i) + OPJ_S_(i + 1), 12993);
 			for (i = 0; i < sn; i++)
-				S(i) -= fix_mul(D_(i - 1) + D_(i), 434);
+				OPJ_S(i) -= opj_int_fix_mul(OPJ_D_(i - 1) + OPJ_D_(i), 434);
 			for (i = 0; i < dn; i++)
-				D(i) += fix_mul(S_(i) + S_(i + 1), 7233);
+				OPJ_D(i) += opj_int_fix_mul(OPJ_S_(i) + OPJ_S_(i + 1), 7233);
 			for (i = 0; i < sn; i++)
-				S(i) += fix_mul(D_(i - 1) + D_(i), 3633);
+				OPJ_S(i) += opj_int_fix_mul(OPJ_D_(i - 1) + OPJ_D_(i), 3633);
 			for (i = 0; i < dn; i++)
-				D(i) = fix_mul(D(i), 5038);	/*5038 */
+				OPJ_D(i) = opj_int_fix_mul(OPJ_D(i), 5038);	/*5038 */
 			for (i = 0; i < sn; i++)
-				S(i) = fix_mul(S(i), 6659);	/*6660 */
+				OPJ_S(i) = opj_int_fix_mul(OPJ_S(i), 6659);	/*6660 */
 		}
 	} else {
 		if ((sn > 0) || (dn > 1)) {	/* NEW :  CASE ONE ELEMENT */
 			for (i = 0; i < dn; i++)
-				S(i) -= fix_mul(DD_(i) + DD_(i - 1), 12993);
+				OPJ_S(i) -= opj_int_fix_mul(OPJ_DD_(i) + OPJ_DD_(i - 1), 12993);
 			for (i = 0; i < sn; i++)
-				D(i) -= fix_mul(SS_(i) + SS_(i + 1), 434);
+				OPJ_D(i) -= opj_int_fix_mul(OPJ_SS_(i) + OPJ_SS_(i + 1), 434);
 			for (i = 0; i < dn; i++)
-				S(i) += fix_mul(DD_(i) + DD_(i - 1), 7233);
+				OPJ_S(i) += opj_int_fix_mul(OPJ_DD_(i) + OPJ_DD_(i - 1), 7233);
 			for (i = 0; i < sn; i++)
-				D(i) += fix_mul(SS_(i) + SS_(i + 1), 3633);
+				OPJ_D(i) += opj_int_fix_mul(OPJ_SS_(i) + OPJ_SS_(i + 1), 3633);
 			for (i = 0; i < dn; i++)
-				S(i) = fix_mul(S(i), 5038);	/*5038 */
+				OPJ_S(i) = opj_int_fix_mul(OPJ_S(i), 5038);	/*5038 */
 			for (i = 0; i < sn; i++)
-				D(i) = fix_mul(D(i), 6659);	/*6660 */
+				OPJ_D(i) = opj_int_fix_mul(OPJ_D(i), 6659);	/*6660 */
 		}
 	}
 }
 
-static void dwt_encode_stepsize(int stepsize, int numbps, opj_stepsize_t *bandno_stepsize) {
-	int p, n;
-	p = int_floorlog2(stepsize) - 13;
-	n = 11 - int_floorlog2(stepsize);
+void opj_dwt_encode_stepsize(OPJ_INT32 stepsize, OPJ_INT32 numbps, opj_stepsize_t *bandno_stepsize) {
+	OPJ_INT32 p, n;
+	p = opj_int_floorlog2(stepsize) - 13;
+	n = 11 - opj_int_floorlog2(stepsize);
 	bandno_stepsize->mant = (n < 0 ? stepsize >> -n : stepsize << n) & 0x7ff;
 	bandno_stepsize->expn = numbps - p;
 }
@@ -320,74 +381,105 @@ static void dwt_encode_stepsize(int stepsize, int numbps, opj_stepsize_t *bandno
 ==========================================================
 */
 
+
 /* <summary>                            */
 /* Forward 5-3 wavelet transform in 2-D. */
 /* </summary>                           */
-void dwt_encode(opj_tcd_tilecomp_t * tilec) {
-	int i, j, k;
-	int *a = NULL;
-	int *aj = NULL;
-	int *bj = NULL;
-	int w, l;
-	
+INLINE OPJ_BOOL opj_dwt_encode_procedure(opj_tcd_tilecomp_t * tilec,void (*p_function)(OPJ_INT32 *, OPJ_INT32,OPJ_INT32,OPJ_INT32) )
+{
+	OPJ_INT32 i, j, k;
+	OPJ_INT32 *a = 00;
+	OPJ_INT32 *aj = 00;
+	OPJ_INT32 *bj = 00;
+	OPJ_INT32 w, l;
+
+	OPJ_INT32 rw;			/* width of the resolution level computed   */
+	OPJ_INT32 rh;			/* height of the resolution level computed  */
+	OPJ_UINT32 l_data_size;
+
+	opj_tcd_resolution_t * l_cur_res = 0;
+	opj_tcd_resolution_t * l_last_res = 0;
+
 	w = tilec->x1-tilec->x0;
-	l = tilec->numresolutions-1;
+	l = (OPJ_INT32)tilec->numresolutions-1;
 	a = tilec->data;
-	
-	for (i = 0; i < l; i++) {
-		int rw;			/* width of the resolution level computed                                                           */
-		int rh;			/* height of the resolution level computed                                                          */
-		int rw1;		/* width of the resolution level once lower than computed one                                       */
-		int rh1;		/* height of the resolution level once lower than computed one                                      */
-		int cas_col;	/* 0 = non inversion on horizontal filtering 1 = inversion between low-pass and high-pass filtering */
-		int cas_row;	/* 0 = non inversion on vertical filtering 1 = inversion between low-pass and high-pass filtering   */
-		int dn, sn;
-		
-		rw = tilec->resolutions[l - i].x1 - tilec->resolutions[l - i].x0;
-		rh = tilec->resolutions[l - i].y1 - tilec->resolutions[l - i].y0;
-		rw1= tilec->resolutions[l - i - 1].x1 - tilec->resolutions[l - i - 1].x0;
-		rh1= tilec->resolutions[l - i - 1].y1 - tilec->resolutions[l - i - 1].y0;
-		
-		cas_row = tilec->resolutions[l - i].x0 % 2;
-		cas_col = tilec->resolutions[l - i].y0 % 2;
-        
+
+	l_cur_res = tilec->resolutions + l;
+	l_last_res = l_cur_res - 1;
+
+	l_data_size = opj_dwt_max_resolution( tilec->resolutions,tilec->numresolutions) * (OPJ_UINT32)sizeof(OPJ_INT32);
+	bj = (OPJ_INT32*)opj_malloc((size_t)l_data_size);
+	if (! bj) {
+		return OPJ_FALSE;
+	}
+	i = l;
+
+	while (i--) {
+		OPJ_INT32 rw1;		/* width of the resolution level once lower than computed one                                       */
+		OPJ_INT32 rh1;		/* height of the resolution level once lower than computed one                                      */
+		OPJ_INT32 cas_col;	/* 0 = non inversion on horizontal filtering 1 = inversion between low-pass and high-pass filtering */
+		OPJ_INT32 cas_row;	/* 0 = non inversion on vertical filtering 1 = inversion between low-pass and high-pass filtering   */
+		OPJ_INT32 dn, sn;
+
+		rw  = l_cur_res->x1 - l_cur_res->x0;
+		rh  = l_cur_res->y1 - l_cur_res->y0;
+		rw1 = l_last_res->x1 - l_last_res->x0;
+		rh1 = l_last_res->y1 - l_last_res->y0;
+
+		cas_row = l_cur_res->x0 & 1;
+		cas_col = l_cur_res->y0 & 1;
+
 		sn = rh1;
 		dn = rh - rh1;
-		bj = (int*)opj_malloc(rh * sizeof(int));
-		for (j = 0; j < rw; j++) {
+		for (j = 0; j < rw; ++j) {
 			aj = a + j;
-			for (k = 0; k < rh; k++)  bj[k] = aj[k*w];
-			dwt_encode_1(bj, dn, sn, cas_col);
-			dwt_deinterleave_v(bj, aj, dn, sn, w, cas_col);
+			for (k = 0; k < rh; ++k) {
+				bj[k] = aj[k*w];
+			}
+
+			(*p_function) (bj, dn, sn, cas_col);
+
+			opj_dwt_deinterleave_v(bj, aj, dn, sn, w, cas_col);
 		}
-		opj_free(bj);
-		
+
 		sn = rw1;
 		dn = rw - rw1;
-		bj = (int*)opj_malloc(rw * sizeof(int));
+
 		for (j = 0; j < rh; j++) {
 			aj = a + j * w;
 			for (k = 0; k < rw; k++)  bj[k] = aj[k];
-			dwt_encode_1(bj, dn, sn, cas_row);
-			dwt_deinterleave_h(bj, aj, dn, sn, cas_row);
+			(*p_function) (bj, dn, sn, cas_row);
+			opj_dwt_deinterleave_h(bj, aj, dn, sn, cas_row);
 		}
-		opj_free(bj);
+
+		l_cur_res = l_last_res;
+
+		--l_last_res;
 	}
+
+	opj_free(bj);
+	return OPJ_TRUE;
 }
 
+/* Forward 5-3 wavelet transform in 2-D. */
+/* </summary>                           */
+OPJ_BOOL opj_dwt_encode(opj_tcd_tilecomp_t * tilec)
+{
+	return opj_dwt_encode_procedure(tilec,opj_dwt_encode_1);
+}
 
 /* <summary>                            */
 /* Inverse 5-3 wavelet transform in 2-D. */
 /* </summary>                           */
-void dwt_decode(opj_tcd_tilecomp_t* tilec, int numres) {
-	dwt_decode_tile(tilec, numres, &dwt_decode_1);
+OPJ_BOOL opj_dwt_decode(opj_tcd_tilecomp_t* tilec, OPJ_UINT32 numres) {
+	return opj_dwt_decode_tile(tilec, numres, &opj_dwt_decode_1);
 }
 
 
 /* <summary>                          */
 /* Get gain of 5-3 wavelet transform. */
 /* </summary>                         */
-int dwt_getgain(int orient) {
+OPJ_UINT32 opj_dwt_getgain(OPJ_UINT32 orient) {
 	if (orient == 0)
 		return 0;
 	if (orient == 1 || orient == 2)
@@ -398,71 +490,22 @@ int dwt_getgain(int orient) {
 /* <summary>                */
 /* Get norm of 5-3 wavelet. */
 /* </summary>               */
-double dwt_getnorm(int level, int orient) {
-	return dwt_norms[orient][level];
+OPJ_FLOAT64 opj_dwt_getnorm(OPJ_UINT32 level, OPJ_UINT32 orient) {
+	return opj_dwt_norms[orient][level];
 }
 
 /* <summary>                             */
 /* Forward 9-7 wavelet transform in 2-D. */
 /* </summary>                            */
-
-void dwt_encode_real(opj_tcd_tilecomp_t * tilec) {
-	int i, j, k;
-	int *a = NULL;
-	int *aj = NULL;
-	int *bj = NULL;
-	int w, l;
-	
-	w = tilec->x1-tilec->x0;
-	l = tilec->numresolutions-1;
-	a = tilec->data;
-	
-	for (i = 0; i < l; i++) {
-		int rw;			/* width of the resolution level computed                                                     */
-		int rh;			/* height of the resolution level computed                                                    */
-		int rw1;		/* width of the resolution level once lower than computed one                                 */
-		int rh1;		/* height of the resolution level once lower than computed one                                */
-		int cas_col;	/* 0 = non inversion on horizontal filtering 1 = inversion between low-pass and high-pass filtering */
-		int cas_row;	/* 0 = non inversion on vertical filtering 1 = inversion between low-pass and high-pass filtering   */
-		int dn, sn;
-		
-		rw = tilec->resolutions[l - i].x1 - tilec->resolutions[l - i].x0;
-		rh = tilec->resolutions[l - i].y1 - tilec->resolutions[l - i].y0;
-		rw1= tilec->resolutions[l - i - 1].x1 - tilec->resolutions[l - i - 1].x0;
-		rh1= tilec->resolutions[l - i - 1].y1 - tilec->resolutions[l - i - 1].y0;
-		
-		cas_row = tilec->resolutions[l - i].x0 % 2;
-		cas_col = tilec->resolutions[l - i].y0 % 2;
-		
-		sn = rh1;
-		dn = rh - rh1;
-		bj = (int*)opj_malloc(rh * sizeof(int));
-		for (j = 0; j < rw; j++) {
-			aj = a + j;
-			for (k = 0; k < rh; k++)  bj[k] = aj[k*w];
-			dwt_encode_1_real(bj, dn, sn, cas_col);
-			dwt_deinterleave_v(bj, aj, dn, sn, w, cas_col);
-		}
-		opj_free(bj);
-		
-		sn = rw1;
-		dn = rw - rw1;
-		bj = (int*)opj_malloc(rw * sizeof(int));
-		for (j = 0; j < rh; j++) {
-			aj = a + j * w;
-			for (k = 0; k < rw; k++)  bj[k] = aj[k];
-			dwt_encode_1_real(bj, dn, sn, cas_row);
-			dwt_deinterleave_h(bj, aj, dn, sn, cas_row);
-		}
-		opj_free(bj);
-	}
+OPJ_BOOL opj_dwt_encode_real(opj_tcd_tilecomp_t * tilec)
+{
+	return opj_dwt_encode_procedure(tilec,opj_dwt_encode_1_real);
 }
 
-
 /* <summary>                          */
 /* Get gain of 9-7 wavelet transform. */
 /* </summary>                         */
-int dwt_getgain_real(int orient) {
+OPJ_UINT32 opj_dwt_getgain_real(OPJ_UINT32 orient) {
 	(void)orient;
 	return 0;
 }
@@ -470,16 +513,16 @@ int dwt_getgain_real(int orient) {
 /* <summary>                */
 /* Get norm of 9-7 wavelet. */
 /* </summary>               */
-double dwt_getnorm_real(int level, int orient) {
-	return dwt_norms_real[orient][level];
+OPJ_FLOAT64 opj_dwt_getnorm_real(OPJ_UINT32 level, OPJ_UINT32 orient) {
+	return opj_dwt_norms_real[orient][level];
 }
 
-void dwt_calc_explicit_stepsizes(opj_tccp_t * tccp, int prec) {
-	int numbands, bandno;
+void opj_dwt_calc_explicit_stepsizes(opj_tccp_t * tccp, OPJ_UINT32 prec) {
+	OPJ_UINT32 numbands, bandno;
 	numbands = 3 * tccp->numresolutions - 2;
 	for (bandno = 0; bandno < numbands; bandno++) {
-		double stepsize;
-		int resno, level, orient, gain;
+		OPJ_FLOAT64 stepsize;
+		OPJ_UINT32 resno, level, orient, gain;
 
 		resno = (bandno == 0) ? 0 : ((bandno - 1) / 3 + 1);
 		orient = (bandno == 0) ? 0 : ((bandno - 1) % 3 + 1);
@@ -488,74 +531,77 @@ void dwt_calc_explicit_stepsizes(opj_tccp_t * tccp, int prec) {
 		if (tccp->qntsty == J2K_CCP_QNTSTY_NOQNT) {
 			stepsize = 1.0;
 		} else {
-			double norm = dwt_norms_real[orient][level];
+			OPJ_FLOAT64 norm = opj_dwt_norms_real[orient][level];
 			stepsize = (1 << (gain)) / norm;
 		}
-		dwt_encode_stepsize((int) floor(stepsize * 8192.0), prec + gain, &tccp->stepsizes[bandno]);
+		opj_dwt_encode_stepsize((OPJ_INT32) floor(stepsize * 8192.0), (OPJ_INT32)(prec + gain), &tccp->stepsizes[bandno]);
 	}
 }
 
-
 /* <summary>                             */
 /* Determine maximum computed resolution level for inverse wavelet transform */
 /* </summary>                            */
-static int dwt_decode_max_resolution(opj_tcd_resolution_t* restrict r, int i) {
-	int mr	= 1;
-	int w;
+OPJ_UINT32 opj_dwt_max_resolution(opj_tcd_resolution_t* restrict r, OPJ_UINT32 i) {
+	OPJ_UINT32 mr	= 0;
+	OPJ_UINT32 w;
 	while( --i ) {
-		r++;
-		if( mr < ( w = r->x1 - r->x0 ) )
+		++r;
+		if( mr < ( w = (OPJ_UINT32)(r->x1 - r->x0) ) )
 			mr = w ;
-		if( mr < ( w = r->y1 - r->y0 ) )
+		if( mr < ( w = (OPJ_UINT32)(r->y1 - r->y0) ) )
 			mr = w ;
 	}
 	return mr ;
 }
 
-
 /* <summary>                            */
 /* Inverse wavelet transform in 2-D.     */
 /* </summary>                           */
-static void dwt_decode_tile(opj_tcd_tilecomp_t* tilec, int numres, DWT1DFN dwt_1D) {
-	dwt_t h;
-	dwt_t v;
+OPJ_BOOL opj_dwt_decode_tile(opj_tcd_tilecomp_t* tilec, OPJ_UINT32 numres, DWT1DFN dwt_1D) {
+	opj_dwt_t h;
+	opj_dwt_t v;
 
 	opj_tcd_resolution_t* tr = tilec->resolutions;
 
-	int rw = tr->x1 - tr->x0;	/* width of the resolution level computed */
-	int rh = tr->y1 - tr->y0;	/* height of the resolution level computed */
+	OPJ_UINT32 rw = (OPJ_UINT32)(tr->x1 - tr->x0);	/* width of the resolution level computed */
+	OPJ_UINT32 rh = (OPJ_UINT32)(tr->y1 - tr->y0);	/* height of the resolution level computed */
+
+	OPJ_UINT32 w = (OPJ_UINT32)(tilec->x1 - tilec->x0);
 
-	int w = tilec->x1 - tilec->x0;
+	h.mem = (OPJ_INT32*)
+	opj_aligned_malloc(opj_dwt_max_resolution(tr, numres) * sizeof(OPJ_INT32));
+	if (! h.mem){
+		return OPJ_FALSE;
+	}
 
-	h.mem = (int*)opj_aligned_malloc(dwt_decode_max_resolution(tr, numres) * sizeof(int));
 	v.mem = h.mem;
 
 	while( --numres) {
-		int * restrict tiledp = tilec->data;
-		int j;
+		OPJ_INT32 * restrict tiledp = tilec->data;
+		OPJ_UINT32 j;
 
 		++tr;
-		h.sn = rw;
-		v.sn = rh;
+		h.sn = (OPJ_INT32)rw;
+		v.sn = (OPJ_INT32)rh;
 
-		rw = tr->x1 - tr->x0;
-		rh = tr->y1 - tr->y0;
+		rw = (OPJ_UINT32)(tr->x1 - tr->x0);
+		rh = (OPJ_UINT32)(tr->y1 - tr->y0);
 
-		h.dn = rw - h.sn;
+		h.dn = (OPJ_INT32)(rw - (OPJ_UINT32)h.sn);
 		h.cas = tr->x0 % 2;
 
 		for(j = 0; j < rh; ++j) {
-			dwt_interleave_h(&h, &tiledp[j*w]);
+			opj_dwt_interleave_h(&h, &tiledp[j*w]);
 			(dwt_1D)(&h);
-			memcpy(&tiledp[j*w], h.mem, rw * sizeof(int));
+			memcpy(&tiledp[j*w], h.mem, rw * sizeof(OPJ_INT32));
 		}
 
-		v.dn = rh - v.sn;
+		v.dn = (OPJ_INT32)(rh - (OPJ_UINT32)v.sn);
 		v.cas = tr->y0 % 2;
 
 		for(j = 0; j < rw; ++j){
-			int k;
-			dwt_interleave_v(&v, &tiledp[j], w);
+			OPJ_UINT32 k;
+			opj_dwt_interleave_v(&v, &tiledp[j], (OPJ_INT32)w);
 			(dwt_1D)(&v);
 			for(k = 0; k < rh; ++k) {
 				tiledp[k * w + j] = v.mem[k];
@@ -563,17 +609,19 @@ static void dwt_decode_tile(opj_tcd_tilecomp_t* tilec, int numres, DWT1DFN dwt_1
 		}
 	}
 	opj_aligned_free(h.mem);
+	return OPJ_TRUE;
 }
 
-static void v4dwt_interleave_h(v4dwt_t* restrict w, float* restrict a, int x, int size){
-	float* restrict bi = (float*) (w->wavelet + w->cas);
-	int count = w->sn;
-	int i, k;
+void opj_v4dwt_interleave_h(opj_v4dwt_t* restrict w, OPJ_FLOAT32* restrict a, OPJ_INT32 x, OPJ_INT32 size){
+	OPJ_FLOAT32* restrict bi = (OPJ_FLOAT32*) (w->wavelet + w->cas);
+	OPJ_INT32 count = w->sn;
+	OPJ_INT32 i, k;
+
 	for(k = 0; k < 2; ++k){
-		if (count + 3 * x < size && ((size_t) a & 0x0f) == 0 && ((size_t) bi & 0x0f) == 0 && (x & 0x0f) == 0) {
+		if ( count + 3 * x < size && ((size_t) a & 0x0f) == 0 && ((size_t) bi & 0x0f) == 0 && (x & 0x0f) == 0 ) {
 			/* Fast code path */
 			for(i = 0; i < count; ++i){
-				int j = i;
+				OPJ_INT32 j = i;
 				bi[i*8    ] = a[j];
 				j += x;
 				bi[i*8 + 1] = a[j];
@@ -582,47 +630,52 @@ static void v4dwt_interleave_h(v4dwt_t* restrict w, float* restrict a, int x, in
 				j += x;
 				bi[i*8 + 3] = a[j];
 			}
-		} else {
-			/* Slow code path */
-		for(i = 0; i < count; ++i){
-			int j = i;
-			bi[i*8    ] = a[j];
-			j += x;
-			if(j > size) continue;
-			bi[i*8 + 1] = a[j];
-			j += x;
-			if(j > size) continue;
-			bi[i*8 + 2] = a[j];
-			j += x;
-			if(j > size) continue;
-			bi[i*8 + 3] = a[j];
 		}
+		else {
+			/* Slow code path */
+			for(i = 0; i < count; ++i){
+				OPJ_INT32 j = i;
+				bi[i*8    ] = a[j];
+				j += x;
+				if(j >= size) continue;
+				bi[i*8 + 1] = a[j];
+				j += x;
+				if(j >= size) continue;
+				bi[i*8 + 2] = a[j];
+				j += x;
+				if(j >= size) continue;
+				bi[i*8 + 3] = a[j]; /* This one*/
+			}
 		}
-		bi = (float*) (w->wavelet + 1 - w->cas);
+
+		bi = (OPJ_FLOAT32*) (w->wavelet + 1 - w->cas);
 		a += w->sn;
 		size -= w->sn;
 		count = w->dn;
 	}
 }
 
-static void v4dwt_interleave_v(v4dwt_t* restrict v , float* restrict a , int x){
-	v4* restrict bi = v->wavelet + v->cas;
-	int i;
+void opj_v4dwt_interleave_v(opj_v4dwt_t* restrict v , OPJ_FLOAT32* restrict a , OPJ_INT32 x, OPJ_INT32 nb_elts_read){
+	opj_v4_t* restrict bi = v->wavelet + v->cas;
+	OPJ_INT32 i;
+
 	for(i = 0; i < v->sn; ++i){
-		memcpy(&bi[i*2], &a[i*x], 4 * sizeof(float));
+		memcpy(&bi[i*2], &a[i*x], (size_t)nb_elts_read * sizeof(OPJ_FLOAT32));
 	}
+
 	a += v->sn * x;
 	bi = v->wavelet + 1 - v->cas;
+
 	for(i = 0; i < v->dn; ++i){
-		memcpy(&bi[i*2], &a[i*x], 4 * sizeof(float));
+		memcpy(&bi[i*2], &a[i*x], (size_t)nb_elts_read * sizeof(OPJ_FLOAT32));
 	}
 }
 
 #ifdef __SSE__
 
-static void v4dwt_decode_step1_sse(v4* w, int count, const __m128 c){
+void opj_v4dwt_decode_step1_sse(opj_v4_t* w, OPJ_INT32 count, const __m128 c){
 	__m128* restrict vw = (__m128*) w;
-	int i;
+	OPJ_INT32 i;
 	/* 4x unrolled loop */
 	for(i = 0; i < count >> 2; ++i){
 		*vw = _mm_mul_ps(*vw, c);
@@ -641,10 +694,10 @@ static void v4dwt_decode_step1_sse(v4* w, int count, const __m128 c){
 	}
 }
 
-static void v4dwt_decode_step2_sse(v4* l, v4* w, int k, int m, __m128 c){
+void opj_v4dwt_decode_step2_sse(opj_v4_t* l, opj_v4_t* w, OPJ_INT32 k, OPJ_INT32 m, __m128 c){
 	__m128* restrict vl = (__m128*) l;
 	__m128* restrict vw = (__m128*) w;
-	int i;
+	OPJ_INT32 i;
 	__m128 tmp1, tmp2, tmp3;
 	tmp1 = vl[0];
 	for(i = 0; i < m; ++i){
@@ -669,14 +722,15 @@ static void v4dwt_decode_step2_sse(v4* l, v4* w, int k, int m, __m128 c){
 
 #else
 
-static void v4dwt_decode_step1(v4* w, int count, const float c){
-	float* restrict fw = (float*) w;
-	int i;
+void opj_v4dwt_decode_step1(opj_v4_t* w, OPJ_INT32 count, const OPJ_FLOAT32 c)
+{
+	OPJ_FLOAT32* restrict fw = (OPJ_FLOAT32*) w;
+	OPJ_INT32 i;
 	for(i = 0; i < count; ++i){
-		float tmp1 = fw[i*8    ];
-		float tmp2 = fw[i*8 + 1];
-		float tmp3 = fw[i*8 + 2];
-		float tmp4 = fw[i*8 + 3];
+		OPJ_FLOAT32 tmp1 = fw[i*8    ];
+		OPJ_FLOAT32 tmp2 = fw[i*8 + 1];
+		OPJ_FLOAT32 tmp3 = fw[i*8 + 2];
+		OPJ_FLOAT32 tmp4 = fw[i*8 + 3];
 		fw[i*8    ] = tmp1 * c;
 		fw[i*8 + 1] = tmp2 * c;
 		fw[i*8 + 2] = tmp3 * c;
@@ -684,23 +738,24 @@ static void v4dwt_decode_step1(v4* w, int count, const float c){
 	}
 }
 
-static void v4dwt_decode_step2(v4* l, v4* w, int k, int m, float c){
-	float* restrict fl = (float*) l;
-	float* restrict fw = (float*) w;
-	int i;
+void opj_v4dwt_decode_step2(opj_v4_t* l, opj_v4_t* w, OPJ_INT32 k, OPJ_INT32 m, OPJ_FLOAT32 c)
+{
+	OPJ_FLOAT32* restrict fl = (OPJ_FLOAT32*) l;
+	OPJ_FLOAT32* restrict fw = (OPJ_FLOAT32*) w;
+	OPJ_INT32 i;
 	for(i = 0; i < m; ++i){
-		float tmp1_1 = fl[0];
-		float tmp1_2 = fl[1];
-		float tmp1_3 = fl[2];
-		float tmp1_4 = fl[3];
-		float tmp2_1 = fw[-4];
-		float tmp2_2 = fw[-3];
-		float tmp2_3 = fw[-2];
-		float tmp2_4 = fw[-1];
-		float tmp3_1 = fw[0];
-		float tmp3_2 = fw[1];
-		float tmp3_3 = fw[2];
-		float tmp3_4 = fw[3];
+		OPJ_FLOAT32 tmp1_1 = fl[0];
+		OPJ_FLOAT32 tmp1_2 = fl[1];
+		OPJ_FLOAT32 tmp1_3 = fl[2];
+		OPJ_FLOAT32 tmp1_4 = fl[3];
+		OPJ_FLOAT32 tmp2_1 = fw[-4];
+		OPJ_FLOAT32 tmp2_2 = fw[-3];
+		OPJ_FLOAT32 tmp2_3 = fw[-2];
+		OPJ_FLOAT32 tmp2_4 = fw[-1];
+		OPJ_FLOAT32 tmp3_1 = fw[0];
+		OPJ_FLOAT32 tmp3_2 = fw[1];
+		OPJ_FLOAT32 tmp3_3 = fw[2];
+		OPJ_FLOAT32 tmp3_4 = fw[3];
 		fw[-4] = tmp2_1 + ((tmp1_1 + tmp3_1) * c);
 		fw[-3] = tmp2_2 + ((tmp1_2 + tmp3_2) * c);
 		fw[-2] = tmp2_3 + ((tmp1_3 + tmp3_3) * c);
@@ -709,20 +764,20 @@ static void v4dwt_decode_step2(v4* l, v4* w, int k, int m, float c){
 		fw += 8;
 	}
 	if(m < k){
-		float c1;
-		float c2;
-		float c3;
-		float c4;
+		OPJ_FLOAT32 c1;
+		OPJ_FLOAT32 c2;
+		OPJ_FLOAT32 c3;
+		OPJ_FLOAT32 c4;
 		c += c;
 		c1 = fl[0] * c;
 		c2 = fl[1] * c;
 		c3 = fl[2] * c;
 		c4 = fl[3] * c;
 		for(; m < k; ++m){
-			float tmp1 = fw[-4];
-			float tmp2 = fw[-3];
-			float tmp3 = fw[-2];
-			float tmp4 = fw[-1];
+			OPJ_FLOAT32 tmp1 = fw[-4];
+			OPJ_FLOAT32 tmp2 = fw[-3];
+			OPJ_FLOAT32 tmp3 = fw[-2];
+			OPJ_FLOAT32 tmp4 = fw[-1];
 			fw[-4] = tmp1 + c1;
 			fw[-3] = tmp2 + c2;
 			fw[-2] = tmp3 + c3;
@@ -737,8 +792,9 @@ static void v4dwt_decode_step2(v4* l, v4* w, int k, int m, float c){
 /* <summary>                             */
 /* Inverse 9-7 wavelet transform in 1-D. */
 /* </summary>                            */
-static void v4dwt_decode(v4dwt_t* restrict dwt){
-	int a, b;
+void opj_v4dwt_decode(opj_v4dwt_t* restrict dwt)
+{
+	OPJ_INT32 a, b;
 	if(dwt->cas == 0) {
 		if(!((dwt->dn > 0) || (dwt->sn > 1))){
 			return;
@@ -753,106 +809,117 @@ static void v4dwt_decode(v4dwt_t* restrict dwt){
 		b = 0;
 	}
 #ifdef __SSE__
-	v4dwt_decode_step1_sse(dwt->wavelet+a, dwt->sn, _mm_set1_ps(K));
-	v4dwt_decode_step1_sse(dwt->wavelet+b, dwt->dn, _mm_set1_ps(c13318));
-	v4dwt_decode_step2_sse(dwt->wavelet+b, dwt->wavelet+a+1, dwt->sn, int_min(dwt->sn, dwt->dn-a), _mm_set1_ps(dwt_delta));
-	v4dwt_decode_step2_sse(dwt->wavelet+a, dwt->wavelet+b+1, dwt->dn, int_min(dwt->dn, dwt->sn-b), _mm_set1_ps(dwt_gamma));
-	v4dwt_decode_step2_sse(dwt->wavelet+b, dwt->wavelet+a+1, dwt->sn, int_min(dwt->sn, dwt->dn-a), _mm_set1_ps(dwt_beta));
-	v4dwt_decode_step2_sse(dwt->wavelet+a, dwt->wavelet+b+1, dwt->dn, int_min(dwt->dn, dwt->sn-b), _mm_set1_ps(dwt_alpha));
+	opj_v4dwt_decode_step1_sse(dwt->wavelet+a, dwt->sn, _mm_set1_ps(opj_K));
+	opj_v4dwt_decode_step1_sse(dwt->wavelet+b, dwt->dn, _mm_set1_ps(opj_c13318));
+	opj_v4dwt_decode_step2_sse(dwt->wavelet+b, dwt->wavelet+a+1, dwt->sn, opj_int_min(dwt->sn, dwt->dn-a), _mm_set1_ps(opj_dwt_delta));
+	opj_v4dwt_decode_step2_sse(dwt->wavelet+a, dwt->wavelet+b+1, dwt->dn, opj_int_min(dwt->dn, dwt->sn-b), _mm_set1_ps(opj_dwt_gamma));
+	opj_v4dwt_decode_step2_sse(dwt->wavelet+b, dwt->wavelet+a+1, dwt->sn, opj_int_min(dwt->sn, dwt->dn-a), _mm_set1_ps(opj_dwt_beta));
+	opj_v4dwt_decode_step2_sse(dwt->wavelet+a, dwt->wavelet+b+1, dwt->dn, opj_int_min(dwt->dn, dwt->sn-b), _mm_set1_ps(opj_dwt_alpha));
 #else
-	v4dwt_decode_step1(dwt->wavelet+a, dwt->sn, K);
-	v4dwt_decode_step1(dwt->wavelet+b, dwt->dn, c13318);
-	v4dwt_decode_step2(dwt->wavelet+b, dwt->wavelet+a+1, dwt->sn, int_min(dwt->sn, dwt->dn-a), dwt_delta);
-	v4dwt_decode_step2(dwt->wavelet+a, dwt->wavelet+b+1, dwt->dn, int_min(dwt->dn, dwt->sn-b), dwt_gamma);
-	v4dwt_decode_step2(dwt->wavelet+b, dwt->wavelet+a+1, dwt->sn, int_min(dwt->sn, dwt->dn-a), dwt_beta);
-	v4dwt_decode_step2(dwt->wavelet+a, dwt->wavelet+b+1, dwt->dn, int_min(dwt->dn, dwt->sn-b), dwt_alpha);
+	opj_v4dwt_decode_step1(dwt->wavelet+a, dwt->sn, opj_K);
+	opj_v4dwt_decode_step1(dwt->wavelet+b, dwt->dn, opj_c13318);
+	opj_v4dwt_decode_step2(dwt->wavelet+b, dwt->wavelet+a+1, dwt->sn, opj_int_min(dwt->sn, dwt->dn-a), opj_dwt_delta);
+	opj_v4dwt_decode_step2(dwt->wavelet+a, dwt->wavelet+b+1, dwt->dn, opj_int_min(dwt->dn, dwt->sn-b), opj_dwt_gamma);
+	opj_v4dwt_decode_step2(dwt->wavelet+b, dwt->wavelet+a+1, dwt->sn, opj_int_min(dwt->sn, dwt->dn-a), opj_dwt_beta);
+	opj_v4dwt_decode_step2(dwt->wavelet+a, dwt->wavelet+b+1, dwt->dn, opj_int_min(dwt->dn, dwt->sn-b), opj_dwt_alpha);
 #endif
 }
 
+
 /* <summary>                             */
 /* Inverse 9-7 wavelet transform in 2-D. */
 /* </summary>                            */
-void dwt_decode_real(opj_tcd_tilecomp_t* restrict tilec, int numres){
-	v4dwt_t h;
-	v4dwt_t v;
+OPJ_BOOL opj_dwt_decode_real(opj_tcd_tilecomp_t* restrict tilec, OPJ_UINT32 numres)
+{
+	opj_v4dwt_t h;
+	opj_v4dwt_t v;
 
 	opj_tcd_resolution_t* res = tilec->resolutions;
 
-	int rw = res->x1 - res->x0;	/* width of the resolution level computed */
-	int rh = res->y1 - res->y0;	/* height of the resolution level computed */
+	OPJ_UINT32 rw = (OPJ_UINT32)(res->x1 - res->x0);	/* width of the resolution level computed */
+	OPJ_UINT32 rh = (OPJ_UINT32)(res->y1 - res->y0);	/* height of the resolution level computed */
 
-	int w = tilec->x1 - tilec->x0;
+	OPJ_UINT32 w = (OPJ_UINT32)(tilec->x1 - tilec->x0);
 
-	h.wavelet = (v4*) opj_aligned_malloc((dwt_decode_max_resolution(res, numres)+5) * sizeof(v4));
+	h.wavelet = (opj_v4_t*) opj_aligned_malloc((opj_dwt_max_resolution(res, numres)+5) * sizeof(opj_v4_t));
 	v.wavelet = h.wavelet;
 
 	while( --numres) {
-		float * restrict aj = (float*) tilec->data;
-		int bufsize = (tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0);
-		int j;
+		OPJ_FLOAT32 * restrict aj = (OPJ_FLOAT32*) tilec->data;
+		OPJ_UINT32 bufsize = (OPJ_UINT32)((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0));
+		OPJ_INT32 j;
 
-		h.sn = rw;
-		v.sn = rh;
+		h.sn = (OPJ_INT32)rw;
+		v.sn = (OPJ_INT32)rh;
 
 		++res;
 
-		rw = res->x1 - res->x0;	/* width of the resolution level computed */
-		rh = res->y1 - res->y0;	/* height of the resolution level computed */
+		rw = (OPJ_UINT32)(res->x1 - res->x0);	/* width of the resolution level computed */
+		rh = (OPJ_UINT32)(res->y1 - res->y0);	/* height of the resolution level computed */
 
-		h.dn = rw - h.sn;
+		h.dn = (OPJ_INT32)(rw - (OPJ_UINT32)h.sn);
 		h.cas = res->x0 % 2;
 
-		for(j = rh; j > 3; j -= 4){
-			int k;
-			v4dwt_interleave_h(&h, aj, w, bufsize);
-			v4dwt_decode(&h);
-				for(k = rw; --k >= 0;){
-					aj[k    ] = h.wavelet[k].f[0];
-					aj[k+w  ] = h.wavelet[k].f[1];
-					aj[k+w*2] = h.wavelet[k].f[2];
-					aj[k+w*3] = h.wavelet[k].f[3];
-				}
+		for(j = (OPJ_INT32)rh; j > 3; j -= 4) {
+			OPJ_INT32 k;
+			opj_v4dwt_interleave_h(&h, aj, (OPJ_INT32)w, (OPJ_INT32)bufsize);
+			opj_v4dwt_decode(&h);
+
+			for(k = (OPJ_INT32)rw; --k >= 0;){
+				aj[k               ] = h.wavelet[k].f[0];
+				aj[k+(OPJ_INT32)w  ] = h.wavelet[k].f[1];
+				aj[k+(OPJ_INT32)w*2] = h.wavelet[k].f[2];
+				aj[k+(OPJ_INT32)w*3] = h.wavelet[k].f[3];
+			}
+
 			aj += w*4;
 			bufsize -= w*4;
 		}
+
 		if (rh & 0x03) {
-				int k;
+			OPJ_INT32 k;
 			j = rh & 0x03;
-			v4dwt_interleave_h(&h, aj, w, bufsize);
-			v4dwt_decode(&h);
-				for(k = rw; --k >= 0;){
-					switch(j) {
-						case 3: aj[k+w*2] = h.wavelet[k].f[2];
-						case 2: aj[k+w  ] = h.wavelet[k].f[1];
-						case 1: aj[k    ] = h.wavelet[k].f[0];
-					}
+			opj_v4dwt_interleave_h(&h, aj, (OPJ_INT32)w, (OPJ_INT32)bufsize);
+			opj_v4dwt_decode(&h);
+			for(k = (OPJ_INT32)rw; --k >= 0;){
+				switch(j) {
+					case 3: aj[k+(OPJ_INT32)w*2] = h.wavelet[k].f[2];
+					case 2: aj[k+(OPJ_INT32)w  ] = h.wavelet[k].f[1];
+					case 1: aj[k               ] = h.wavelet[k].f[0];
 				}
 			}
+		}
 
-		v.dn = rh - v.sn;
+		v.dn = (OPJ_INT32)(rh - (OPJ_UINT32)v.sn);
 		v.cas = res->y0 % 2;
 
-		aj = (float*) tilec->data;
-		for(j = rw; j > 3; j -= 4){
-			int k;
-			v4dwt_interleave_v(&v, aj, w);
-			v4dwt_decode(&v);
-				for(k = 0; k < rh; ++k){
-					memcpy(&aj[k*w], &v.wavelet[k], 4 * sizeof(float));
-				}
+		aj = (OPJ_FLOAT32*) tilec->data;
+		for(j = (OPJ_INT32)rw; j > 3; j -= 4){
+			OPJ_UINT32 k;
+
+			opj_v4dwt_interleave_v(&v, aj, (OPJ_INT32)w, 4);
+			opj_v4dwt_decode(&v);
+
+			for(k = 0; k < rh; ++k){
+				memcpy(&aj[k*w], &v.wavelet[k], 4 * sizeof(OPJ_FLOAT32));
+			}
 			aj += 4;
 		}
+
 		if (rw & 0x03){
-				int k;
+			OPJ_UINT32 k;
+
 			j = rw & 0x03;
-			v4dwt_interleave_v(&v, aj, w);
-			v4dwt_decode(&v);
-				for(k = 0; k < rh; ++k){
-					memcpy(&aj[k*w], &v.wavelet[k], j * sizeof(float));
-				}
+
+			opj_v4dwt_interleave_v(&v, aj, (OPJ_INT32)w, j);
+			opj_v4dwt_decode(&v);
+
+			for(k = 0; k < rh; ++k){
+				memcpy(&aj[k*w], &v.wavelet[k], (size_t)j * sizeof(OPJ_FLOAT32));
 			}
+		}
 	}
 
 	opj_aligned_free(h.wavelet);
+	return OPJ_TRUE;
 }
-
diff --git a/extern/libopenjpeg/dwt.h b/extern/libopenjpeg/dwt.h
index adf73e5..f8b57bc 100644
--- a/extern/libopenjpeg/dwt.h
+++ b/extern/libopenjpeg/dwt.h
@@ -1,9 +1,15 @@
 /*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2001-2003, David Janssens
  * Copyright (c) 2002-2003, Yannick Verschueren
- * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * Copyright (c) 2003-2014, Antonin Descampe
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
  * All rights reserved.
  *
@@ -52,59 +58,62 @@ Forward 5-3 wavelet tranform in 2-D.
 Apply a reversible DWT transform to a component of an image.
 @param tilec Tile component information (current tile)
 */
-void dwt_encode(opj_tcd_tilecomp_t * tilec);
+OPJ_BOOL opj_dwt_encode(opj_tcd_tilecomp_t * tilec);
+
 /**
 Inverse 5-3 wavelet tranform in 2-D.
 Apply a reversible inverse DWT transform to a component of an image.
 @param tilec Tile component information (current tile)
 @param numres Number of resolution levels to decode
 */
-void dwt_decode(opj_tcd_tilecomp_t* tilec, int numres);
+OPJ_BOOL opj_dwt_decode(opj_tcd_tilecomp_t* tilec, OPJ_UINT32 numres);
+
 /**
 Get the gain of a subband for the reversible 5-3 DWT.
 @param orient Number that identifies the subband (0->LL, 1->HL, 2->LH, 3->HH)
 @return Returns 0 if orient = 0, returns 1 if orient = 1 or 2, returns 2 otherwise
 */
-int dwt_getgain(int orient);
+OPJ_UINT32 opj_dwt_getgain(OPJ_UINT32 orient) ;
 /**
 Get the norm of a wavelet function of a subband at a specified level for the reversible 5-3 DWT.
 @param level Level of the wavelet function
 @param orient Band of the wavelet function
 @return Returns the norm of the wavelet function
 */
-double dwt_getnorm(int level, int orient);
+OPJ_FLOAT64 opj_dwt_getnorm(OPJ_UINT32 level, OPJ_UINT32 orient);
 /**
 Forward 9-7 wavelet transform in 2-D. 
 Apply an irreversible DWT transform to a component of an image.
 @param tilec Tile component information (current tile)
 */
-void dwt_encode_real(opj_tcd_tilecomp_t * tilec);
+OPJ_BOOL opj_dwt_encode_real(opj_tcd_tilecomp_t * tilec);
 /**
 Inverse 9-7 wavelet transform in 2-D. 
 Apply an irreversible inverse DWT transform to a component of an image.
 @param tilec Tile component information (current tile)
 @param numres Number of resolution levels to decode
 */
-void dwt_decode_real(opj_tcd_tilecomp_t* tilec, int numres);
+OPJ_BOOL opj_dwt_decode_real(opj_tcd_tilecomp_t* restrict tilec, OPJ_UINT32 numres);
+
 /**
 Get the gain of a subband for the irreversible 9-7 DWT.
 @param orient Number that identifies the subband (0->LL, 1->HL, 2->LH, 3->HH)
 @return Returns the gain of the 9-7 wavelet transform
 */
-int dwt_getgain_real(int orient);
+OPJ_UINT32 opj_dwt_getgain_real(OPJ_UINT32 orient);
 /**
 Get the norm of a wavelet function of a subband at a specified level for the irreversible 9-7 DWT
 @param level Level of the wavelet function
 @param orient Band of the wavelet function
 @return Returns the norm of the 9-7 wavelet
 */
-double dwt_getnorm_real(int level, int orient);
+OPJ_FLOAT64 opj_dwt_getnorm_real(OPJ_UINT32 level, OPJ_UINT32 orient);
 /**
 Explicit calculation of the Quantization Stepsizes 
 @param tccp Tile-component coding parameters
 @param prec Precint analyzed
 */
-void dwt_calc_explicit_stepsizes(opj_tccp_t * tccp, int prec);
+void opj_dwt_calc_explicit_stepsizes(opj_tccp_t * tccp, OPJ_UINT32 prec);
 /* ----------------------------------------------------------------------- */
 /*@}*/
 
diff --git a/extern/libopenjpeg/event.c b/extern/libopenjpeg/event.c
index 38db33a..b6034b4 100644
--- a/extern/libopenjpeg/event.c
+++ b/extern/libopenjpeg/event.c
@@ -1,5 +1,12 @@
 /*
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR 
+ * Copyright (c) 2012, CS Systemes d'Information, France
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -60,62 +67,80 @@ _itoa(int i, char *a, int r) {
 
 #endif /* !_WIN32 */
 #endif
+
 /* ----------------------------------------------------------------------- */
+/**
+ * Default callback function.
+ * Do nothing.
+ */
+static void opj_default_callback (const char *msg, void *client_data)
+{
+    OPJ_ARG_NOT_USED(msg);
+    OPJ_ARG_NOT_USED(client_data);
+}
 
-opj_event_mgr_t* OPJ_CALLCONV opj_set_event_mgr(opj_common_ptr cinfo, opj_event_mgr_t *event_mgr, void *context) {
-	if(cinfo) {
-		opj_event_mgr_t *previous = cinfo->event_mgr;
-		cinfo->event_mgr = event_mgr;
-		cinfo->client_data = context;
-		return previous;
-	}
+/* ----------------------------------------------------------------------- */
 
-	return NULL;
-}
 
-opj_bool opj_event_msg(opj_common_ptr cinfo, int event_type, const char *fmt, ...) {
-#define MSG_SIZE 512 /* 512 bytes should be more than enough for a short message */
-	opj_msg_callback msg_handler = NULL;
+/* ----------------------------------------------------------------------- */
+OPJ_BOOL opj_event_msg(opj_event_mgr_t* p_event_mgr, OPJ_INT32 event_type, const char *fmt, ...) {
+#define OPJ_MSG_SIZE 512 /* 512 bytes should be more than enough for a short message */
+	opj_msg_callback msg_handler = 00;
+	void * l_data = 00;
 
-	opj_event_mgr_t *event_mgr = cinfo->event_mgr;
-	if(event_mgr != NULL) {
+	if(p_event_mgr != 00) {
 		switch(event_type) {
 			case EVT_ERROR:
-				msg_handler = event_mgr->error_handler;
+				msg_handler = p_event_mgr->error_handler;
+				l_data = p_event_mgr->m_error_data;
 				break;
 			case EVT_WARNING:
-				msg_handler = event_mgr->warning_handler;
+				msg_handler = p_event_mgr->warning_handler;
+				l_data = p_event_mgr->m_warning_data;
 				break;
 			case EVT_INFO:
-				msg_handler = event_mgr->info_handler;
+				msg_handler = p_event_mgr->info_handler;
+				l_data = p_event_mgr->m_info_data;
 				break;
 			default:
 				break;
 		}
-		if(msg_handler == NULL) {
+		if(msg_handler == 00) {
 			return OPJ_FALSE;
 		}
 	} else {
 		return OPJ_FALSE;
 	}
 
-	if ((fmt != NULL) && (event_mgr != NULL)) {
+	if ((fmt != 00) && (p_event_mgr != 00)) {
 		va_list arg;
-		int str_length/*, i, j*/; /* UniPG */
-		char message[MSG_SIZE];
+		size_t str_length/*, i, j*/; /* UniPG */
+		char message[OPJ_MSG_SIZE];
+		memset(message, 0, OPJ_MSG_SIZE);
 		/* initialize the optional parameter list */
 		va_start(arg, fmt);
+		/* check the length of the format string */
+		str_length = (strlen(fmt) > OPJ_MSG_SIZE) ? OPJ_MSG_SIZE : strlen(fmt);
+        (void)str_length;
 		/* parse the format string and put the result in 'message' */
-		str_length = vsnprintf(message, MSG_SIZE, fmt, arg); /* UniPG */
+		vsnprintf(message, OPJ_MSG_SIZE, fmt, arg); /* UniPG */
 		/* deinitialize the optional parameter list */
 		va_end(arg);
 
 		/* output the message to the user program */
-    if( str_length > -1 && str_length < MSG_SIZE )
-      msg_handler(message, cinfo->client_data);
-    else return OPJ_FALSE;
+		msg_handler(message, l_data);
 	}
 
 	return OPJ_TRUE;
 }
 
+void opj_set_default_event_handler(opj_event_mgr_t * p_manager)
+{
+	p_manager->m_error_data = 00;
+	p_manager->m_warning_data = 00;
+	p_manager->m_info_data = 00;
+	p_manager->error_handler = opj_default_callback;
+	p_manager->info_handler = opj_default_callback;
+	p_manager->warning_handler = opj_default_callback;
+}
+
diff --git a/extern/libopenjpeg/event.h b/extern/libopenjpeg/event.h
index 9c59787..88e0395 100644
--- a/extern/libopenjpeg/event.h
+++ b/extern/libopenjpeg/event.h
@@ -1,5 +1,12 @@
 /*
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR 
+ * Copyright (c) 2012, CS Systemes d'Information, France
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -31,6 +38,31 @@
 
 The functions in EVENT.C have for goal to send output messages (errors, warnings, debug) to the user.
 */
+/**
+Message handler object
+used for 
+<ul>
+<li>Error messages
+<li>Warning messages
+<li>Debugging messages
+</ul>
+*/
+typedef struct opj_event_mgr 
+{
+	/** Data to call the event manager upon */
+	void *			m_error_data;
+	/** Data to call the event manager upon */
+	void *			m_warning_data;
+	/** Data to call the event manager upon */
+	void *			m_info_data;
+	/** Error message callback if available, NULL otherwise */
+	opj_msg_callback error_handler;
+	/** Warning message callback if available, NULL otherwise */
+	opj_msg_callback warning_handler;
+	/** Debug message callback if available, NULL otherwise */
+	opj_msg_callback info_handler;
+} opj_event_mgr_t;
+
 
 #define EVT_ERROR	1	/**< Error event type */
 #define EVT_WARNING	2	/**< Warning event type */
@@ -42,15 +74,27 @@ The functions in EVENT.C have for goal to send output messages (errors, warnings
 /** @name Exported functions (see also openjpeg.h) */
 /*@{*/
 /* ----------------------------------------------------------------------- */
+
+
+/* ----------------------------------------------------------------------- */
+
 /**
-Write formatted data to a string and send the string to a user callback. 
-@param cinfo Codec context info
-@param event_type Event type or callback to use to send the message
-@param fmt Format-control string (plus optionnal arguments)
-@return Returns true if successful, returns false otherwise
-*/
-opj_bool opj_event_msg(opj_common_ptr cinfo, int event_type, const char *fmt, ...);
+ * Write formatted data to a string and send the string to a user callback.
+ *
+ * @param event_mgr			Event handler
+ * @param event_type 		Event type or callback to use to send the message
+ * @param fmt 				Format-control string (plus optional arguments)
+ *
+ * @return Returns true if successful, returns false otherwise
+ */
+OPJ_BOOL opj_event_msg(opj_event_mgr_t* event_mgr, OPJ_INT32 event_type, const char *fmt, ...);
 /* ----------------------------------------------------------------------- */
+
+/**
+ * Set the event manager with the default callback function for the 3 levels.
+ */
+void opj_set_default_event_handler(opj_event_mgr_t * p_manager);
+
 /*@}*/
 
 /*@}*/
diff --git a/extern/libopenjpeg/fix.h b/extern/libopenjpeg/fix.h
deleted file mode 100644
index bcb2acb..0000000
--- a/extern/libopenjpeg/fix.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
- * Copyright (c) 2001-2003, David Janssens
- * Copyright (c) 2002-2003, Yannick Verschueren
- * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
- * Copyright (c) 2005, Herve Drolon, FreeImage Team
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef __FIX_H
-#define __FIX_H
-
-#if defined(_MSC_VER) || defined(__BORLANDC__)
-#define int64 __int64
-#else
-#define int64 long long
-#endif
-
-/**
-@file fix.h
-@brief Implementation of operations of specific multiplication (FIX)
-
-The functions in FIX.H have for goal to realize specific multiplication.
-*/
-
-/** @defgroup FIX FIX - Implementation of operations of specific multiplication */
-/*@{*/
-
-/**
-Multiply two fixed-precision rational numbers.
-@param a
-@param b
-@return Returns a * b
-*/
-static INLINE int fix_mul(int a, int b) {
-    int64 temp = (int64) a * (int64) b ;
-    temp += temp & 4096;
-    return (int) (temp >> 13) ;
-}
-
-/*@}*/
-
-#endif /* __FIX_H */
diff --git a/extern/libopenjpeg/function_list.c b/extern/libopenjpeg/function_list.c
new file mode 100644
index 0000000..4c8aae6
--- /dev/null
+++ b/extern/libopenjpeg/function_list.c
@@ -0,0 +1,119 @@
+/*
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2008, Jerome Fimes, Communications & Systemes <jerome.fimes@c-s.fr>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+
+/**
+ * Default size of the validation list, if not sufficient, data will be reallocated with a double size.
+ */
+#define OPJ_VALIDATION_SIZE 10
+
+opj_procedure_list_t *  opj_procedure_list_create()
+{
+        /* memory allocation */
+        opj_procedure_list_t * l_validation = (opj_procedure_list_t *) opj_malloc(sizeof(opj_procedure_list_t));
+        if (! l_validation)
+        {
+                return 00;
+        }
+        /* initialization */
+        memset(l_validation,0,sizeof(opj_procedure_list_t));
+        l_validation->m_nb_max_procedures = OPJ_VALIDATION_SIZE;
+        l_validation->m_procedures = (opj_procedure*)opj_malloc(
+                OPJ_VALIDATION_SIZE * sizeof(opj_procedure));
+        if (! l_validation->m_procedures)
+        {
+                opj_free(l_validation);
+                return 00;
+        }
+        memset(l_validation->m_procedures,0,OPJ_VALIDATION_SIZE * sizeof(opj_procedure));
+        return l_validation;
+}
+
+void  opj_procedure_list_destroy(opj_procedure_list_t * p_list)
+{
+        if (! p_list)
+        {
+                return;
+        }
+        /* initialization */
+        if (p_list->m_procedures)
+        {
+                opj_free(p_list->m_procedures);
+        }
+        opj_free(p_list);
+}
+
+OPJ_BOOL opj_procedure_list_add_procedure (opj_procedure_list_t * p_validation_list, opj_procedure p_procedure)
+{
+        if (p_validation_list->m_nb_max_procedures == p_validation_list->m_nb_procedures)
+        {
+                opj_procedure * new_procedures;
+
+                p_validation_list->m_nb_max_procedures += OPJ_VALIDATION_SIZE;
+                new_procedures = (opj_procedure*)opj_realloc(
+                        p_validation_list->m_procedures,
+                        p_validation_list->m_nb_max_procedures * sizeof(opj_procedure));
+                if (! new_procedures)
+                {
+                        opj_free(p_validation_list->m_procedures);
+                        p_validation_list->m_nb_max_procedures = 0;
+                        p_validation_list->m_nb_procedures = 0;
+                        /* opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to add a new validation procedure\n"); */
+                        fprintf(stderr, "Not enough memory to add a new validation procedure\n");
+                        
+                        return OPJ_FALSE;
+                }
+                else
+                {
+                        p_validation_list->m_procedures = new_procedures;
+                }
+        }
+        p_validation_list->m_procedures[p_validation_list->m_nb_procedures] = p_procedure;
+        ++p_validation_list->m_nb_procedures;
+
+        return OPJ_TRUE;
+}
+
+OPJ_UINT32 opj_procedure_list_get_nb_procedures (opj_procedure_list_t * p_validation_list)
+{
+        return p_validation_list->m_nb_procedures;
+}
+
+opj_procedure* opj_procedure_list_get_first_procedure (opj_procedure_list_t * p_validation_list)
+{
+        return p_validation_list->m_procedures;
+}
+
+void opj_procedure_list_clear (opj_procedure_list_t * p_validation_list)
+{
+        p_validation_list->m_nb_procedures = 0;
+}
diff --git a/extern/libopenjpeg/function_list.h b/extern/libopenjpeg/function_list.h
new file mode 100644
index 0000000..749ad9e
--- /dev/null
+++ b/extern/libopenjpeg/function_list.h
@@ -0,0 +1,131 @@
+/*
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2008, Jerome Fimes, Communications & Systemes <jerome.fimes@c-s.fr>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __FUNCTION_LIST_H
+#define __FUNCTION_LIST_H
+
+/** 
+ * @file function_list.h
+ * @brief Implementation of a list of procedures.
+
+ * The functions in validation.c aims to have access to a list of procedures.
+*/
+
+/** @defgroup VAL VAL - validation procedure*/
+/*@{*/
+
+/**************************************************************************************************
+ ***************************************** FORWARD DECLARATION ************************************
+ **************************************************************************************************/
+
+/**
+ * declare a function pointer
+ */
+typedef void (*opj_procedure)(void);
+
+/**
+ * A list of procedures.
+*/
+typedef struct opj_procedure_list 
+{
+	/**
+	 * The number of validation procedures.
+	 */
+	OPJ_UINT32 m_nb_procedures;
+	/**
+	 * The number of the array of validation procedures.
+	 */
+	OPJ_UINT32 m_nb_max_procedures;
+	/**
+	 * The array of procedures.
+	 */
+	opj_procedure * m_procedures;
+
+} opj_procedure_list_t;
+
+/* ----------------------------------------------------------------------- */
+
+/**
+ * Creates a validation list.
+ *
+ * @return	the newly created validation list.
+ */
+opj_procedure_list_t *  opj_procedure_list_create(void);
+
+/**
+ * Destroys a validation list.
+ *
+ * @param p_list the list to destroy.
+ */
+void  opj_procedure_list_destroy(opj_procedure_list_t * p_list);
+
+/**
+ * Adds a new validation procedure.
+ *
+ * @param	p_validation_list the list of procedure to modify.
+ * @param	p_procedure		the procedure to add.
+ *
+ * @return	OPJ_TRUE if the procedure could be added.
+ */
+OPJ_BOOL opj_procedure_list_add_procedure (opj_procedure_list_t * p_validation_list, opj_procedure p_procedure);
+
+/**
+ * Gets the number of validation procedures.
+ *
+ * @param	p_validation_list the list of procedure to modify.
+ *
+ * @return the number of validation procedures.
+ */
+OPJ_UINT32 opj_procedure_list_get_nb_procedures (opj_procedure_list_t * p_validation_list);
+
+/**
+ * Gets the pointer on the first validation procedure. This function is similar to the C++
+ * iterator class to iterate through all the procedures inside the validation list.
+ * the caller does not take ownership of the pointer.
+ *
+ * @param	p_validation_list the list of procedure to get the first procedure from.
+ *
+ * @return	a pointer to the first procedure.
+ */
+opj_procedure* opj_procedure_list_get_first_procedure (opj_procedure_list_t * p_validation_list);
+
+
+/**
+ * Clears the list of validation procedures.
+ *
+ * @param	p_validation_list the list of procedure to clear.
+ *
+ */
+void opj_procedure_list_clear (opj_procedure_list_t * p_validation_list);
+/*@}*/
+
+#endif /* __FUNCTION_LIST_H */
+
diff --git a/extern/libopenjpeg/image.c b/extern/libopenjpeg/image.c
index 579fd73..2c3540c 100644
--- a/extern/libopenjpeg/image.c
+++ b/extern/libopenjpeg/image.c
@@ -1,4 +1,9 @@
 /*
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
  * All rights reserved.
  *
@@ -31,8 +36,8 @@ opj_image_t* opj_image_create0(void) {
 	return image;
 }
 
-opj_image_t* OPJ_CALLCONV opj_image_create(int numcmpts, opj_image_cmptparm_t *cmptparms, OPJ_COLOR_SPACE clrspc) {
-	int compno;
+opj_image_t* OPJ_CALLCONV opj_image_create(OPJ_UINT32 numcmpts, opj_image_cmptparm_t *cmptparms, OPJ_COLOR_SPACE clrspc) {
+	OPJ_UINT32 compno;
 	opj_image_t *image = NULL;
 
 	image = (opj_image_t*) opj_calloc(1, sizeof(opj_image_t));
@@ -58,7 +63,7 @@ opj_image_t* OPJ_CALLCONV opj_image_create(int numcmpts, opj_image_cmptparm_t *c
 			comp->prec = cmptparms[compno].prec;
 			comp->bpp = cmptparms[compno].bpp;
 			comp->sgnd = cmptparms[compno].sgnd;
-			comp->data = (int*) opj_calloc(comp->w * comp->h, sizeof(int));
+			comp->data = (OPJ_INT32*) opj_calloc(comp->w * comp->h, sizeof(OPJ_INT32));
 			if(!comp->data) {
 				fprintf(stderr,"Unable to allocate memory for image.\n");
 				opj_image_destroy(image);
@@ -71,19 +76,165 @@ opj_image_t* OPJ_CALLCONV opj_image_create(int numcmpts, opj_image_cmptparm_t *c
 }
 
 void OPJ_CALLCONV opj_image_destroy(opj_image_t *image) {
-	int i;
 	if(image) {
 		if(image->comps) {
+			OPJ_UINT32 compno;
+
 			/* image components */
-			for(i = 0; i < image->numcomps; i++) {
-				opj_image_comp_t *image_comp = &image->comps[i];
+			for(compno = 0; compno < image->numcomps; compno++) {
+				opj_image_comp_t *image_comp = &(image->comps[compno]);
 				if(image_comp->data) {
 					opj_free(image_comp->data);
 				}
 			}
 			opj_free(image->comps);
 		}
+
+		if(image->icc_profile_buf) {
+			opj_free(image->icc_profile_buf);
+		}
+
 		opj_free(image);
 	}
 }
 
+/**
+ * Updates the components characteristics of the image from the coding parameters.
+ *
+ * @param p_image_header	the image header to update.
+ * @param p_cp				the coding parameters from which to update the image.
+ */
+void opj_image_comp_header_update(opj_image_t * p_image_header, const struct opj_cp * p_cp)
+{
+	OPJ_UINT32 i, l_width, l_height;
+	OPJ_INT32 l_x0, l_y0, l_x1, l_y1;
+	OPJ_INT32 l_comp_x0, l_comp_y0, l_comp_x1, l_comp_y1;
+	opj_image_comp_t* l_img_comp = NULL;
+
+	l_x0 = opj_int_max((OPJ_INT32)p_cp->tx0 , (OPJ_INT32)p_image_header->x0);
+	l_y0 = opj_int_max((OPJ_INT32)p_cp->ty0 , (OPJ_INT32)p_image_header->y0);
+	l_x1 = opj_int_min((OPJ_INT32)(p_cp->tx0 + p_cp->tw * p_cp->tdx), (OPJ_INT32)p_image_header->x1);
+	l_y1 = opj_int_min((OPJ_INT32)(p_cp->ty0 + p_cp->th * p_cp->tdy), (OPJ_INT32)p_image_header->y1);
+
+	l_img_comp = p_image_header->comps;
+	for	(i = 0; i < p_image_header->numcomps; ++i) {
+		l_comp_x0 = opj_int_ceildiv(l_x0, (OPJ_INT32)l_img_comp->dx);
+		l_comp_y0 = opj_int_ceildiv(l_y0, (OPJ_INT32)l_img_comp->dy);
+		l_comp_x1 = opj_int_ceildiv(l_x1, (OPJ_INT32)l_img_comp->dx);
+		l_comp_y1 = opj_int_ceildiv(l_y1, (OPJ_INT32)l_img_comp->dy);
+		l_width = (OPJ_UINT32)opj_int_ceildivpow2(l_comp_x1 - l_comp_x0, (OPJ_INT32)l_img_comp->factor);
+		l_height = (OPJ_UINT32)opj_int_ceildivpow2(l_comp_y1 - l_comp_y0, (OPJ_INT32)l_img_comp->factor);
+		l_img_comp->w = l_width;
+		l_img_comp->h = l_height;
+		l_img_comp->x0 = (OPJ_UINT32)l_comp_x0/*l_x0*/;
+		l_img_comp->y0 = (OPJ_UINT32)l_comp_y0/*l_y0*/;
+		++l_img_comp;
+	}
+}
+
+
+/**
+ * Copy only header of image and its component header (no data are copied)
+ * if dest image have data, they will be freed
+ *
+ * @param	p_image_src		the src image
+ * @param	p_image_dest	the dest image
+ *
+ */
+void opj_copy_image_header(const opj_image_t* p_image_src, opj_image_t* p_image_dest)
+{
+	OPJ_UINT32 compno;
+
+	/* preconditions */
+	assert(p_image_src != 00);
+	assert(p_image_dest != 00);
+
+	p_image_dest->x0 = p_image_src->x0;
+	p_image_dest->y0 = p_image_src->y0;
+	p_image_dest->x1 = p_image_src->x1;
+	p_image_dest->y1 = p_image_src->y1;
+
+	if (p_image_dest->comps){
+		for(compno = 0; compno < p_image_dest->numcomps; compno++) {
+			opj_image_comp_t *image_comp = &(p_image_dest->comps[compno]);
+			if(image_comp->data) {
+				opj_free(image_comp->data);
+			}
+		}
+		opj_free(p_image_dest->comps);
+		p_image_dest->comps = NULL;
+	}
+
+	p_image_dest->numcomps = p_image_src->numcomps;
+
+	p_image_dest->comps = (opj_image_comp_t*) opj_malloc(p_image_dest->numcomps * sizeof(opj_image_comp_t));
+	if (!p_image_dest->comps){
+		p_image_dest->comps = NULL;
+		p_image_dest->numcomps = 0;
+		return;
+	}
+
+	for (compno=0; compno < p_image_dest->numcomps; compno++){
+		memcpy( &(p_image_dest->comps[compno]),
+				&(p_image_src->comps[compno]),
+				sizeof(opj_image_comp_t));
+		p_image_dest->comps[compno].data = NULL;
+	}
+
+	p_image_dest->color_space = p_image_src->color_space;
+	p_image_dest->icc_profile_len = p_image_src->icc_profile_len;
+
+	if (p_image_dest->icc_profile_len) {
+		p_image_dest->icc_profile_buf = (OPJ_BYTE*)opj_malloc(p_image_dest->icc_profile_len);
+		if (!p_image_dest->icc_profile_buf){
+			p_image_dest->icc_profile_buf = NULL;
+			p_image_dest->icc_profile_len = 0;
+			return;
+		}
+		memcpy( p_image_dest->icc_profile_buf,
+				p_image_src->icc_profile_buf,
+				p_image_src->icc_profile_len);
+		}
+		else
+			p_image_dest->icc_profile_buf = NULL;
+
+	return;
+}
+
+opj_image_t* OPJ_CALLCONV opj_image_tile_create(OPJ_UINT32 numcmpts, opj_image_cmptparm_t *cmptparms, OPJ_COLOR_SPACE clrspc) {
+	OPJ_UINT32 compno;
+	opj_image_t *image = 00;
+
+	image = (opj_image_t*) opj_malloc(sizeof(opj_image_t));
+	if (image)
+	{
+		memset(image,0,sizeof(opj_image_t));
+		
+		image->color_space = clrspc;
+		image->numcomps = numcmpts;
+		
+		/* allocate memory for the per-component information */
+		image->comps = (opj_image_comp_t*)opj_malloc(image->numcomps * sizeof(opj_image_comp_t));
+		if (!image->comps) {
+			opj_image_destroy(image);
+			return 00;
+		}
+		memset(image->comps,0,image->numcomps * sizeof(opj_image_comp_t));
+		
+		/* create the individual image components */
+		for(compno = 0; compno < numcmpts; compno++) {
+			opj_image_comp_t *comp = &image->comps[compno];
+			comp->dx = cmptparms[compno].dx;
+			comp->dy = cmptparms[compno].dy;
+			comp->w = cmptparms[compno].w;
+			comp->h = cmptparms[compno].h;
+			comp->x0 = cmptparms[compno].x0;
+			comp->y0 = cmptparms[compno].y0;
+			comp->prec = cmptparms[compno].prec;
+			comp->sgnd = cmptparms[compno].sgnd;
+			comp->data = 0;
+		}
+	}
+
+	return image;
+}
diff --git a/extern/libopenjpeg/image.h b/extern/libopenjpeg/image.h
index f828b5b..e0e2772 100644
--- a/extern/libopenjpeg/image.h
+++ b/extern/libopenjpeg/image.h
@@ -1,4 +1,9 @@
 /*
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
  * All rights reserved.
  *
@@ -32,16 +37,31 @@
 The functions in IMAGE.C have for goal to realize operations on images.
 */
 
+struct opj_image;
+struct opj_cp;
+
 /** @defgroup IMAGE IMAGE - Implementation of operations on images */
 /*@{*/
 
 /**
-Create an empty image
-@todo this function should be removed
-@return returns an empty image if successful, returns NULL otherwise
-*/
+ * Create an empty image
+ *
+ * @return returns an empty image if successful, returns NULL otherwise
+ */
 opj_image_t* opj_image_create0(void);
 
+
+
+/**
+ * Updates the components characteristics of the image from the coding parameters.
+ *
+ * @param p_image_header		the image header to update.
+ * @param p_cp					the coding parameters from which to update the image.
+ */
+void opj_image_comp_header_update(opj_image_t * p_image, const struct opj_cp* p_cp);
+
+void opj_copy_image_header(const opj_image_t* p_image_src, opj_image_t* p_image_dest);
+
 /*@}*/
 
 #endif /* __IMAGE_H */
diff --git a/extern/libopenjpeg/indexbox_manager.h b/extern/libopenjpeg/indexbox_manager.h
index 7364df6..ec5525f 100644
--- a/extern/libopenjpeg/indexbox_manager.h
+++ b/extern/libopenjpeg/indexbox_manager.h
@@ -1,8 +1,8 @@
 /*
  * $Id: indexbox_manager.h 897 2011-08-28 21:43:57Z Kaori.Hagihara@gmail.com $
  *
- * Copyright (c) 2002-2011, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2011, Professor Benoit Macq
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2003-2004, Yannick Verschueren
  * Copyright (c) 2010-2011, Kaori Hagihara
  * All rights reserved.
@@ -65,7 +65,8 @@
  * @param[in] cio       file output handle
  * @return              length of tpix box
  */
-int write_tpix( int coff, opj_codestream_info_t cstr_info, int j2klen, opj_cio_t *cio);
+int opj_write_tpix( int coff, opj_codestream_info_t cstr_info, int j2klen, opj_stream_private_t *cio,
+              opj_event_mgr_t * p_manager );
 
 
 /* 
@@ -76,7 +77,7 @@ int write_tpix( int coff, opj_codestream_info_t cstr_info, int j2klen, opj_cio_t
  * @param[in] cio       file output handle
  * @return              length of thix box
  */
-int write_thix( int coff, opj_codestream_info_t cstr_info, opj_cio_t *cio);
+int opj_write_thix( int coff, opj_codestream_info_t cstr_info, opj_stream_private_t *cio, opj_event_mgr_t * p_manager );
 
 
 /* 
@@ -89,7 +90,8 @@ int write_thix( int coff, opj_codestream_info_t cstr_info, opj_cio_t *cio);
  * @param[in] cio       file output handle
  * @return              length of ppix box
  */
-int write_ppix( int coff, opj_codestream_info_t cstr_info, opj_bool EPHused, int j2klen, opj_cio_t *cio);
+int opj_write_ppix( int coff, opj_codestream_info_t cstr_info, OPJ_BOOL EPHused, int j2klen, opj_stream_private_t *cio,
+              opj_event_mgr_t * p_manager );
 
 
 /* 
@@ -102,7 +104,8 @@ int write_ppix( int coff, opj_codestream_info_t cstr_info, opj_bool EPHused, int
  * @param[in] cio       file output handle
  * @return              length of ppix box
  */
-int write_phix( int coff, opj_codestream_info_t cstr_info, opj_bool EPHused, int j2klen, opj_cio_t *cio);
+int opj_write_phix( int coff, opj_codestream_info_t cstr_info, OPJ_BOOL EPHused, int j2klen, opj_stream_private_t *cio,
+              opj_event_mgr_t * p_manager );
 
 /* 
  * Wriet manifest box (box)
@@ -112,7 +115,34 @@ int write_phix( int coff, opj_codestream_info_t cstr_info, opj_bool EPHused, int
  * @param[in] box    box to be manifested
  * @param[in] cio    file output handle
  */
-void write_manf(int second, int v, opj_jp2_box_t *box, opj_cio_t *cio);
 
+void opj_write_manf(int second, 
+                    int v, 
+                    opj_jp2_box_t *box, 
+                    opj_stream_private_t *cio,
+                    opj_event_mgr_t * p_manager );
+
+/* 
+ * Write main header index table (box)
+ *
+ * @param[in] coff offset of j2k codestream
+ * @param[in] cstr_info codestream information
+ * @param[in] cio  file output handle
+ * @return         length of mainmhix box
+ */
+int opj_write_mainmhix( int coff, opj_codestream_info_t cstr_info, opj_stream_private_t *cio,
+              opj_event_mgr_t * p_manager );
+
+int opj_write_phixfaix( int coff, int compno, opj_codestream_info_t cstr_info, OPJ_BOOL EPHused, int j2klen, opj_stream_private_t *cio,
+              opj_event_mgr_t * p_manager );
+
+int opj_write_ppixfaix( int coff, int compno, opj_codestream_info_t cstr_info, OPJ_BOOL EPHused, int j2klen, opj_stream_private_t *cio,
+              opj_event_mgr_t * p_manager );
+
+int opj_write_tilemhix( int coff, opj_codestream_info_t cstr_info, int tileno, opj_stream_private_t *cio,
+              opj_event_mgr_t * p_manager );
+
+int opj_write_tpixfaix( int coff, int compno, opj_codestream_info_t cstr_info, int j2klen, opj_stream_private_t *cio,
+              opj_event_mgr_t * p_manager );
 
 #endif      /* !INDEXBOX_MANAGER_H_ */
diff --git a/extern/libopenjpeg/int.h b/extern/libopenjpeg/int.h
deleted file mode 100644
index 4e5fe08..0000000
--- a/extern/libopenjpeg/int.h
+++ /dev/null
@@ -1,119 +0,0 @@
-/*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
- * Copyright (c) 2001-2003, David Janssens
- * Copyright (c) 2002-2003, Yannick Verschueren
- * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
- * Copyright (c) 2005, Herve Drolon, FreeImage Team
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef __INT_H
-#define __INT_H
-/**
-@file int.h
-@brief Implementation of operations on integers (INT)
-
-The functions in INT.H have for goal to realize operations on integers.
-*/
-
-/** @defgroup INT INT - Implementation of operations on integers */
-/*@{*/
-
-/** @name Exported functions (see also openjpeg.h) */
-/*@{*/
-/* ----------------------------------------------------------------------- */
-/**
-Get the minimum of two integers
-@return Returns a if a < b else b
-*/
-static INLINE int int_min(int a, int b) {
-	return a < b ? a : b;
-}
-/**
-Get the maximum of two integers
-@return Returns a if a > b else b
-*/
-static INLINE int int_max(int a, int b) {
-	return (a > b) ? a : b;
-}
-/**
-Clamp an integer inside an interval
-@return
-<ul>
-<li>Returns a if (min < a < max)
-<li>Returns max if (a > max)
-<li>Returns min if (a < min) 
-</ul>
-*/
-static INLINE int int_clamp(int a, int min, int max) {
-	if (a < min)
-		return min;
-	if (a > max)
-		return max;
-	return a;
-}
-/**
-@return Get absolute value of integer
-*/
-static INLINE int int_abs(int a) {
-	return a < 0 ? -a : a;
-}
-/**
-Divide an integer and round upwards
-@return Returns a divided by b
-*/
-static INLINE int int_ceildiv(int a, int b) {
-	return (a + b - 1) / b;
-}
-/**
-Divide an integer by a power of 2 and round upwards
-@return Returns a divided by 2^b
-*/
-static INLINE int int_ceildivpow2(int a, int b) {
-	return (a + (1 << b) - 1) >> b;
-}
-/**
-Divide an integer by a power of 2 and round downwards
-@return Returns a divided by 2^b
-*/
-static INLINE int int_floordivpow2(int a, int b) {
-	return a >> b;
-}
-/**
-Get logarithm of an integer and round downwards
-@return Returns log2(a)
-*/
-static INLINE int int_floorlog2(int a) {
-	int l;
-	for (l = 0; a > 1; l++) {
-		a >>= 1;
-	}
-	return l;
-}
-/* ----------------------------------------------------------------------- */
-/*@}*/
-
-/*@}*/
-
-#endif
diff --git a/extern/libopenjpeg/invert.c b/extern/libopenjpeg/invert.c
new file mode 100644
index 0000000..4c1ee78
--- /dev/null
+++ b/extern/libopenjpeg/invert.c
@@ -0,0 +1,294 @@
+/*
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2008, Jerome Fimes, Communications & Systemes <jerome.fimes@c-s.fr>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+
+/** 
+ * LUP decomposition
+ */
+static OPJ_BOOL opj_lupDecompose(OPJ_FLOAT32 * matrix,
+                                 OPJ_UINT32 * permutations, 
+                                 OPJ_FLOAT32 * p_swap_area,
+                                 OPJ_UINT32 nb_compo);
+/** 
+ * LUP solving
+ */
+static void opj_lupSolve(OPJ_FLOAT32 * pResult, 
+                         OPJ_FLOAT32* pMatrix, 
+                         OPJ_FLOAT32* pVector, 
+                         OPJ_UINT32* pPermutations, 
+                         OPJ_UINT32 nb_compo,
+                         OPJ_FLOAT32 * p_intermediate_data);
+
+/** 
+ *LUP inversion (call with the result of lupDecompose)
+ */
+static void opj_lupInvert ( OPJ_FLOAT32 * pSrcMatrix,
+                            OPJ_FLOAT32 * pDestMatrix,
+                            OPJ_UINT32 nb_compo,
+                            OPJ_UINT32 * pPermutations,
+                            OPJ_FLOAT32 * p_src_temp,
+                            OPJ_FLOAT32 * p_dest_temp,
+                            OPJ_FLOAT32 * p_swap_area);
+
+/*
+==========================================================
+   Matric inversion interface
+==========================================================
+*/
+/**
+ * Matrix inversion.
+ */
+OPJ_BOOL opj_matrix_inversion_f(OPJ_FLOAT32 * pSrcMatrix,
+                                OPJ_FLOAT32 * pDestMatrix, 
+                                OPJ_UINT32 nb_compo)
+{
+	OPJ_BYTE * l_data = 00;
+	OPJ_UINT32 l_permutation_size = nb_compo * (OPJ_UINT32)sizeof(OPJ_UINT32);
+	OPJ_UINT32 l_swap_size = nb_compo * (OPJ_UINT32)sizeof(OPJ_FLOAT32);
+	OPJ_UINT32 l_total_size = l_permutation_size + 3 * l_swap_size;
+	OPJ_UINT32 * lPermutations = 00;
+	OPJ_FLOAT32 * l_double_data = 00;
+
+	l_data = (OPJ_BYTE *) opj_malloc(l_total_size);
+	if (l_data == 0) {
+		return OPJ_FALSE;
+	}
+	lPermutations = (OPJ_UINT32 *) l_data;
+	l_double_data = (OPJ_FLOAT32 *) (l_data + l_permutation_size);
+	memset(lPermutations,0,l_permutation_size);
+
+	if(! opj_lupDecompose(pSrcMatrix,lPermutations,l_double_data,nb_compo)) {
+		opj_free(l_data);
+		return OPJ_FALSE;
+	}
+	
+    opj_lupInvert(pSrcMatrix,pDestMatrix,nb_compo,lPermutations,l_double_data,l_double_data + nb_compo,l_double_data + 2*nb_compo);
+	opj_free(l_data);
+	
+    return OPJ_TRUE;
+}
+
+
+/*
+==========================================================
+   Local functions
+==========================================================
+*/
+OPJ_BOOL opj_lupDecompose(OPJ_FLOAT32 * matrix,OPJ_UINT32 * permutations, 
+                          OPJ_FLOAT32 * p_swap_area,
+                          OPJ_UINT32 nb_compo) 
+{
+	OPJ_UINT32 * tmpPermutations = permutations;
+	OPJ_UINT32 * dstPermutations;
+	OPJ_UINT32 k2=0,t;
+	OPJ_FLOAT32 temp;
+	OPJ_UINT32 i,j,k;
+	OPJ_FLOAT32 p;
+	OPJ_UINT32 lLastColum = nb_compo - 1;
+	OPJ_UINT32 lSwapSize = nb_compo * (OPJ_UINT32)sizeof(OPJ_FLOAT32);
+	OPJ_FLOAT32 * lTmpMatrix = matrix;
+	OPJ_FLOAT32 * lColumnMatrix,* lDestMatrix;
+	OPJ_UINT32 offset = 1;
+	OPJ_UINT32 lStride = nb_compo-1;
+
+	/*initialize permutations */
+	for (i = 0; i < nb_compo; ++i) 
+	{
+    	*tmpPermutations++ = i;
+	}
+	/* now make a pivot with colum switch */
+	tmpPermutations = permutations;
+	for (k = 0; k < lLastColum; ++k) {
+		p = 0.0;
+
+		/* take the middle element */
+		lColumnMatrix = lTmpMatrix + k;
+		
+		/* make permutation with the biggest value in the column */
+        for (i = k; i < nb_compo; ++i) {
+			temp = ((*lColumnMatrix > 0) ? *lColumnMatrix : -(*lColumnMatrix));
+     		if (temp > p) {
+     			p = temp;
+     			k2 = i;
+     		}
+			/* next line */
+			lColumnMatrix += nb_compo;
+     	}
+
+     	/* a whole rest of 0 -> non singular */
+     	if (p == 0.0) {
+    		return OPJ_FALSE;
+		}
+
+		/* should we permute ? */
+		if (k2 != k) {
+			/*exchange of line */
+     		/* k2 > k */
+			dstPermutations = tmpPermutations + k2 - k;
+			/* swap indices */
+			t = *tmpPermutations;
+     		*tmpPermutations = *dstPermutations;
+     		*dstPermutations = t;
+
+			/* and swap entire line. */
+			lColumnMatrix = lTmpMatrix + (k2 - k) * nb_compo;
+			memcpy(p_swap_area,lColumnMatrix,lSwapSize);
+			memcpy(lColumnMatrix,lTmpMatrix,lSwapSize);
+			memcpy(lTmpMatrix,p_swap_area,lSwapSize);
+		}
+
+		/* now update data in the rest of the line and line after */
+		lDestMatrix = lTmpMatrix + k;
+		lColumnMatrix = lDestMatrix + nb_compo;
+		/* take the middle element */
+		temp = *(lDestMatrix++);
+
+		/* now compute up data (i.e. coeff up of the diagonal). */
+     	for (i = offset; i < nb_compo; ++i)  {
+			/*lColumnMatrix; */
+			/* divide the lower column elements by the diagonal value */
+
+			/* matrix[i][k] /= matrix[k][k]; */
+     		/* p = matrix[i][k] */
+			p = *lColumnMatrix / temp;
+			*(lColumnMatrix++) = p;
+     		
+            for (j = /* k + 1 */ offset; j < nb_compo; ++j) {
+				/* matrix[i][j] -= matrix[i][k] * matrix[k][j]; */
+     			*(lColumnMatrix++) -= p * (*(lDestMatrix++));
+			}
+			/* come back to the k+1th element */
+			lDestMatrix -= lStride;
+			/* go to kth element of the next line */
+			lColumnMatrix += k;
+     	}
+
+		/* offset is now k+2 */
+		++offset;
+		/* 1 element less for stride */
+		--lStride;
+		/* next line */
+		lTmpMatrix+=nb_compo;
+		/* next permutation element */
+		++tmpPermutations;
+	}
+    return OPJ_TRUE;
+}
+   		
+void opj_lupSolve (OPJ_FLOAT32 * pResult, 
+                   OPJ_FLOAT32 * pMatrix, 
+                   OPJ_FLOAT32 * pVector, 
+                   OPJ_UINT32* pPermutations, 
+                   OPJ_UINT32 nb_compo,OPJ_FLOAT32 * p_intermediate_data) 
+{
+	OPJ_INT32 k;
+    OPJ_UINT32 i,j;
+	OPJ_FLOAT32 sum;
+	OPJ_FLOAT32 u;
+    OPJ_UINT32 lStride = nb_compo+1;
+	OPJ_FLOAT32 * lCurrentPtr;
+	OPJ_FLOAT32 * lIntermediatePtr;
+	OPJ_FLOAT32 * lDestPtr;
+	OPJ_FLOAT32 * lTmpMatrix;
+	OPJ_FLOAT32 * lLineMatrix = pMatrix;
+	OPJ_FLOAT32 * lBeginPtr = pResult + nb_compo - 1;
+	OPJ_FLOAT32 * lGeneratedData;
+	OPJ_UINT32 * lCurrentPermutationPtr = pPermutations;
+
+	
+	lIntermediatePtr = p_intermediate_data;
+	lGeneratedData = p_intermediate_data + nb_compo - 1;
+	
+    for (i = 0; i < nb_compo; ++i) {
+       	sum = 0.0;
+		lCurrentPtr = p_intermediate_data;
+		lTmpMatrix = lLineMatrix;
+        for (j = 1; j <= i; ++j) 
+		{
+			/* sum += matrix[i][j-1] * y[j-1]; */
+        	sum += (*(lTmpMatrix++)) * (*(lCurrentPtr++));
+        }
+		/*y[i] = pVector[pPermutations[i]] - sum; */
+        *(lIntermediatePtr++) = pVector[*(lCurrentPermutationPtr++)] - sum;
+		lLineMatrix += nb_compo;
+	}
+
+	/* we take the last point of the matrix */
+	lLineMatrix = pMatrix + nb_compo*nb_compo - 1;
+
+	/* and we take after the last point of the destination vector */
+	lDestPtr = pResult + nb_compo;
+
+
+    assert(nb_compo != 0);
+	for (k = (OPJ_INT32)nb_compo - 1; k != -1 ; --k) {
+		sum = 0.0;
+		lTmpMatrix = lLineMatrix;
+        u = *(lTmpMatrix++);
+		lCurrentPtr = lDestPtr--;
+        for (j = (OPJ_UINT32)(k + 1); j < nb_compo; ++j) {
+			/* sum += matrix[k][j] * x[j] */
+        	sum += (*(lTmpMatrix++)) * (*(lCurrentPtr++));
+		}
+		/*x[k] = (y[k] - sum) / u; */
+        *(lBeginPtr--) = (*(lGeneratedData--) - sum) / u;
+		lLineMatrix -= lStride;
+	}
+}
+    
+
+void opj_lupInvert (OPJ_FLOAT32 * pSrcMatrix,
+                    OPJ_FLOAT32 * pDestMatrix,
+                    OPJ_UINT32 nb_compo,
+                    OPJ_UINT32 * pPermutations,
+                    OPJ_FLOAT32 * p_src_temp,
+                    OPJ_FLOAT32 * p_dest_temp,
+                    OPJ_FLOAT32 * p_swap_area )
+{
+	OPJ_UINT32 j,i;
+	OPJ_FLOAT32 * lCurrentPtr;
+	OPJ_FLOAT32 * lLineMatrix = pDestMatrix;
+	OPJ_UINT32 lSwapSize = nb_compo * (OPJ_UINT32)sizeof(OPJ_FLOAT32);
+
+	for (j = 0; j < nb_compo; ++j) {
+		lCurrentPtr = lLineMatrix++;
+        memset(p_src_temp,0,lSwapSize);
+    	p_src_temp[j] = 1.0;
+		opj_lupSolve(p_dest_temp,pSrcMatrix,p_src_temp, pPermutations, nb_compo , p_swap_area);
+
+		for (i = 0; i < nb_compo; ++i) {
+    		*(lCurrentPtr) = p_dest_temp[i];
+			lCurrentPtr+=nb_compo;
+    	}
+    }
+}
+
diff --git a/extern/libopenjpeg/invert.h b/extern/libopenjpeg/invert.h
new file mode 100644
index 0000000..2fae8e5
--- /dev/null
+++ b/extern/libopenjpeg/invert.h
@@ -0,0 +1,64 @@
+/*
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2008, Jerome Fimes, Communications & Systemes <jerome.fimes@c-s.fr>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __INVERT_H
+#define __INVERT_H
+/**
+@file invert.h
+@brief Implementation of the matrix inversion
+
+The function in INVERT.H compute a matrix inversion with a LUP method
+*/
+
+/** @defgroup INVERT INVERT - Implementation of a matrix inversion */
+/*@{*/
+/** @name Exported functions */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+
+/**
+ * Calculates a n x n double matrix inversion with a LUP method. Data is aligned, rows after rows (or columns after columns).
+ * The function does not take ownership of any memory block, data must be fred by the user.
+ *
+ * @param pSrcMatrix	the matrix to invert.
+ * @param pDestMatrix	data to store the inverted matrix. 
+ * @param n size of the matrix
+ * @return OPJ_TRUE if the inversion is successful, OPJ_FALSE if the matrix is singular.
+ */
+OPJ_BOOL opj_matrix_inversion_f(OPJ_FLOAT32 * pSrcMatrix,
+                                OPJ_FLOAT32 * pDestMatrix, 
+                                OPJ_UINT32 nb_compo);
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __INVERT_H */ 
diff --git a/extern/libopenjpeg/j2k.c b/extern/libopenjpeg/j2k.c
index 93e5c9e..881cc72 100644
--- a/extern/libopenjpeg/j2k.c
+++ b/extern/libopenjpeg/j2k.c
@@ -1,12 +1,21 @@
 /*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2001-2003, David Janssens
  * Copyright (c) 2002-2003, Yannick Verschueren
- * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * Copyright (c) 2003-2014, Antonin Descampe
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * Copyright (c) 2008, Jerome Fimes, Communications & Systemes <jerome.fimes@c-s.fr>
  * Copyright (c) 2006-2007, Parvatha Elangovan
  * Copyright (c) 2010-2011, Kaori Hagihara
+ * Copyright (c) 2011-2012, Centre National d'Etudes Spatiales (CNES), France 
+ * Copyright (c) 2012, CS Systemes d'Information, France
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -32,7 +41,6 @@
  */
 
 #include "opj_includes.h"
-#include <assert.h>
 
 /** @defgroup J2K J2K - JPEG-2000 codestream reader/writer */
 /*@{*/
@@ -41,2659 +49,10265 @@
 /*@{*/
 
 /**
-Write the SOC marker (Start Of Codestream)
-@param j2k J2K handle
+ * Sets up the procedures to do on reading header. Developpers wanting to extend the library can add their own reading procedures.
+ */
+static void opj_j2k_setup_header_reading (opj_j2k_t *p_j2k);
+
+/**
+ * The read header procedure.
+ */
+static OPJ_BOOL opj_j2k_read_header_procedure(  opj_j2k_t *p_j2k,
+                                                opj_stream_private_t *p_stream,
+                                                opj_event_mgr_t * p_manager);
+
+/**
+ * The default encoding validation procedure without any extension.
+ *
+ * @param       p_j2k                   the jpeg2000 codec to validate.
+ * @param       p_stream                the input stream to validate.
+ * @param       p_manager               the user event manager.
+ *
+ * @return true if the parameters are correct.
+ */
+static OPJ_BOOL opj_j2k_encoding_validation (   opj_j2k_t * p_j2k,
+                                                opj_stream_private_t *p_stream,
+                                                opj_event_mgr_t * p_manager );
+
+/**
+ * The default decoding validation procedure without any extension.
+ *
+ * @param       p_j2k                   the jpeg2000 codec to validate.
+ * @param       p_stream                                the input stream to validate.
+ * @param       p_manager               the user event manager.
+ *
+ * @return true if the parameters are correct.
+ */
+static OPJ_BOOL opj_j2k_decoding_validation (   opj_j2k_t * p_j2k,
+                                                opj_stream_private_t *p_stream,
+                                                opj_event_mgr_t * p_manager );
+
+/**
+ * Sets up the validation ,i.e. adds the procedures to lauch to make sure the codec parameters
+ * are valid. Developpers wanting to extend the library can add their own validation procedures.
+ */
+static void opj_j2k_setup_encoding_validation (opj_j2k_t *p_j2k);
+
+/**
+ * Sets up the validation ,i.e. adds the procedures to lauch to make sure the codec parameters
+ * are valid. Developpers wanting to extend the library can add their own validation procedures.
+ */
+static void opj_j2k_setup_decoding_validation (opj_j2k_t *p_j2k);
+
+/**
+ * Sets up the validation ,i.e. adds the procedures to lauch to make sure the codec parameters
+ * are valid. Developpers wanting to extend the library can add their own validation procedures.
+ */
+static void opj_j2k_setup_end_compress (opj_j2k_t *p_j2k);
+
+/**
+ * The mct encoding validation procedure.
+ *
+ * @param       p_j2k                   the jpeg2000 codec to validate.
+ * @param       p_stream                                the input stream to validate.
+ * @param       p_manager               the user event manager.
+ *
+ * @return true if the parameters are correct.
+ */
+static OPJ_BOOL opj_j2k_mct_validation (opj_j2k_t * p_j2k,
+                                        opj_stream_private_t *p_stream,
+                                        opj_event_mgr_t * p_manager );
+
+/**
+ * Builds the tcd decoder to use to decode tile.
+ */
+static OPJ_BOOL opj_j2k_build_decoder ( opj_j2k_t * p_j2k,
+                                        opj_stream_private_t *p_stream,
+                                        opj_event_mgr_t * p_manager );
+/**
+ * Builds the tcd encoder to use to encode tile.
+ */
+static OPJ_BOOL opj_j2k_build_encoder ( opj_j2k_t * p_j2k,
+                                        opj_stream_private_t *p_stream,
+                                        opj_event_mgr_t * p_manager );
+
+/**
+ * Creates a tile-coder decoder.
+ *
+ * @param       p_stream                        the stream to write data to.
+ * @param       p_j2k                           J2K codec.
+ * @param       p_manager                   the user event manager.
+*/
+static OPJ_BOOL opj_j2k_create_tcd(     opj_j2k_t *p_j2k,
+                                                                    opj_stream_private_t *p_stream,
+                                                                    opj_event_mgr_t * p_manager );
+
+/**
+ * Excutes the given procedures on the given codec.
+ *
+ * @param       p_procedure_list        the list of procedures to execute
+ * @param       p_j2k                           the jpeg2000 codec to execute the procedures on.
+ * @param       p_stream                        the stream to execute the procedures on.
+ * @param       p_manager                       the user manager.
+ *
+ * @return      true                            if all the procedures were successfully executed.
+ */
+static OPJ_BOOL opj_j2k_exec (  opj_j2k_t * p_j2k,
+                            opj_procedure_list_t * p_procedure_list,
+                            opj_stream_private_t *p_stream,
+                            opj_event_mgr_t * p_manager);
+
+/**
+ * Updates the rates of the tcp.
+ *
+ * @param       p_stream                                the stream to write data to.
+ * @param       p_j2k                           J2K codec.
+ * @param       p_manager               the user event manager.
+*/
+static OPJ_BOOL opj_j2k_update_rates(   opj_j2k_t *p_j2k,
+                                                                            opj_stream_private_t *p_stream,
+                                                                            opj_event_mgr_t * p_manager );
+
+/**
+ * Copies the decoding tile parameters onto all the tile parameters.
+ * Creates also the tile decoder.
+ */
+static OPJ_BOOL opj_j2k_copy_default_tcp_and_create_tcd (       opj_j2k_t * p_j2k,
+                                                            opj_stream_private_t *p_stream,
+                                                            opj_event_mgr_t * p_manager );
+
+/**
+ * Destroys the memory associated with the decoding of headers.
+ */
+static OPJ_BOOL opj_j2k_destroy_header_memory ( opj_j2k_t * p_j2k,
+                                                opj_stream_private_t *p_stream,
+                                                opj_event_mgr_t * p_manager );
+
+/**
+ * Reads the lookup table containing all the marker, status and action, and returns the handler associated
+ * with the marker value.
+ * @param       p_id            Marker value to look up
+ *
+ * @return      the handler associated with the id.
+*/
+static const struct opj_dec_memory_marker_handler * opj_j2k_get_marker_handler (OPJ_UINT32 p_id);
+
+/**
+ * Destroys a tile coding parameter structure.
+ *
+ * @param       p_tcp           the tile coding parameter to destroy.
+ */
+static void opj_j2k_tcp_destroy (opj_tcp_t *p_tcp);
+
+/**
+ * Destroys the data inside a tile coding parameter structure.
+ *
+ * @param       p_tcp           the tile coding parameter which contain data to destroy.
+ */
+static void opj_j2k_tcp_data_destroy (opj_tcp_t *p_tcp);
+
+/**
+ * Destroys a coding parameter structure.
+ *
+ * @param       p_cp            the coding parameter to destroy.
+ */
+static void opj_j2k_cp_destroy (opj_cp_t *p_cp);
+
+/**
+ * Writes a SPCod or SPCoc element, i.e. the coding style of a given component of a tile.
+ *
+ * @param       p_j2k           J2K codec.
+ * @param       p_tile_no       FIXME DOC
+ * @param       p_comp_no       the component number to output.
+ * @param       p_data          FIXME DOC
+ * @param       p_header_size   FIXME DOC
+ * @param       p_manager       the user event manager.
+ *
+ * @return FIXME DOC
+*/
+static OPJ_BOOL opj_j2k_write_SPCod_SPCoc(      opj_j2k_t *p_j2k,
+                                                                                    OPJ_UINT32 p_tile_no,
+                                                                                    OPJ_UINT32 p_comp_no,
+                                                                                    OPJ_BYTE * p_data,
+                                                                                    OPJ_UINT32 * p_header_size,
+                                                                                    opj_event_mgr_t * p_manager );
+
+/**
+ * Gets the size taken by writing a SPCod or SPCoc for the given tile and component.
+ *
+ * @param       p_j2k                   the J2K codec.
+ * @param       p_tile_no               the tile index.
+ * @param       p_comp_no               the component being outputted.
+ *
+ * @return      the number of bytes taken by the SPCod element.
+ */
+static OPJ_UINT32 opj_j2k_get_SPCod_SPCoc_size (opj_j2k_t *p_j2k,
+                                                                                            OPJ_UINT32 p_tile_no,
+                                                                                            OPJ_UINT32 p_comp_no );
+
+/**
+ * Reads a SPCod or SPCoc element, i.e. the coding style of a given component of a tile.
+ * @param       p_j2k           the jpeg2000 codec.
+ * @param       compno          FIXME DOC
+ * @param       p_header_data   the data contained in the COM box.
+ * @param       p_header_size   the size of the data contained in the COM marker.
+ * @param       p_manager       the user event manager.
+*/
+static OPJ_BOOL opj_j2k_read_SPCod_SPCoc(   opj_j2k_t *p_j2k,
+                                            OPJ_UINT32 compno,
+                                            OPJ_BYTE * p_header_data,
+                                            OPJ_UINT32 * p_header_size,
+                                            opj_event_mgr_t * p_manager );
+
+/**
+ * Gets the size taken by writing SQcd or SQcc element, i.e. the quantization values of a band in the QCD or QCC.
+ *
+ * @param       p_tile_no               the tile index.
+ * @param       p_comp_no               the component being outputted.
+ * @param       p_j2k                   the J2K codec.
+ *
+ * @return      the number of bytes taken by the SPCod element.
+ */
+static OPJ_UINT32 opj_j2k_get_SQcd_SQcc_size (  opj_j2k_t *p_j2k,
+                                                                                    OPJ_UINT32 p_tile_no,
+                                                                                    OPJ_UINT32 p_comp_no );
+
+/**
+ * Writes a SQcd or SQcc element, i.e. the quantization values of a band in the QCD or QCC.
+ *
+ * @param       p_tile_no               the tile to output.
+ * @param       p_comp_no               the component number to output.
+ * @param       p_data                  the data buffer.
+ * @param       p_header_size   pointer to the size of the data buffer, it is changed by the function.
+ * @param       p_j2k                   J2K codec.
+ * @param       p_manager               the user event manager.
+ *
+*/
+static OPJ_BOOL opj_j2k_write_SQcd_SQcc(opj_j2k_t *p_j2k,
+                                                                            OPJ_UINT32 p_tile_no,
+                                                                            OPJ_UINT32 p_comp_no,
+                                                                            OPJ_BYTE * p_data,
+                                                                            OPJ_UINT32 * p_header_size,
+                                                                            opj_event_mgr_t * p_manager);
+
+/**
+ * Updates the Tile Length Marker.
+ */
+static void opj_j2k_update_tlm ( opj_j2k_t * p_j2k, OPJ_UINT32 p_tile_part_size);
+
+/**
+ * Reads a SQcd or SQcc element, i.e. the quantization values of a band in the QCD or QCC.
+ *
+ * @param       p_j2k           J2K codec.
+ * @param       compno          the component number to output.
+ * @param       p_header_data   the data buffer.
+ * @param       p_header_size   pointer to the size of the data buffer, it is changed by the function.
+ * @param       p_manager       the user event manager.
+ *
+*/
+static OPJ_BOOL opj_j2k_read_SQcd_SQcc( opj_j2k_t *p_j2k,
+                                        OPJ_UINT32 compno,
+                                        OPJ_BYTE * p_header_data,
+                                        OPJ_UINT32 * p_header_size,
+                                        opj_event_mgr_t * p_manager );
+
+/**
+ * Copies the tile component parameters of all the component from the first tile component.
+ *
+ * @param               p_j2k           the J2k codec.
+ */
+static void opj_j2k_copy_tile_component_parameters( opj_j2k_t *p_j2k );
+
+/**
+ * Copies the tile quantization parameters of all the component from the first tile component.
+ *
+ * @param               p_j2k           the J2k codec.
+ */
+static void opj_j2k_copy_tile_quantization_parameters( opj_j2k_t *p_j2k );
+
+/**
+ * Reads the tiles.
+ */
+static OPJ_BOOL opj_j2k_decode_tiles (  opj_j2k_t *p_j2k,
+                                        opj_stream_private_t *p_stream,
+                                        opj_event_mgr_t * p_manager);
+
+static OPJ_BOOL opj_j2k_pre_write_tile ( opj_j2k_t * p_j2k,
+                                                                             OPJ_UINT32 p_tile_index,
+                                                                             opj_stream_private_t *p_stream,
+                                                                             opj_event_mgr_t * p_manager );
+
+static OPJ_BOOL opj_j2k_update_image_data (opj_tcd_t * p_tcd, OPJ_BYTE * p_data, opj_image_t* p_output_image);
+
+static void opj_j2k_get_tile_data (opj_tcd_t * p_tcd, OPJ_BYTE * p_data);
+
+static OPJ_BOOL opj_j2k_post_write_tile (opj_j2k_t * p_j2k,
+                                                                             OPJ_BYTE * p_data,
+                                                                             OPJ_UINT32 p_data_size,
+                                                                             opj_stream_private_t *p_stream,
+                                                                             opj_event_mgr_t * p_manager );
+
+/**
+ * Sets up the procedures to do on writing header.
+ * Developers wanting to extend the library can add their own writing procedures.
+ */
+static void opj_j2k_setup_header_writing (opj_j2k_t *p_j2k);
+
+static OPJ_BOOL opj_j2k_write_first_tile_part(  opj_j2k_t *p_j2k,
+                                                                                            OPJ_BYTE * p_data,
+                                                                                            OPJ_UINT32 * p_data_written,
+                                                                                            OPJ_UINT32 p_total_data_size,
+                                                                                            opj_stream_private_t *p_stream,
+                                                                                            struct opj_event_mgr * p_manager );
+
+static OPJ_BOOL opj_j2k_write_all_tile_parts(   opj_j2k_t *p_j2k,
+                                                                                            OPJ_BYTE * p_data,
+                                                                                            OPJ_UINT32 * p_data_written,
+                                                                                            OPJ_UINT32 p_total_data_size,
+                                                                                            opj_stream_private_t *p_stream,
+                                                                                            struct opj_event_mgr * p_manager );
+
+/**
+ * Gets the offset of the header.
+ *
+ * @param       p_stream                the stream to write data to.
+ * @param       p_j2k                   J2K codec.
+ * @param       p_manager               the user event manager.
+*/
+static OPJ_BOOL opj_j2k_get_end_header( opj_j2k_t *p_j2k,
+                                        opj_stream_private_t *p_stream,
+                                        opj_event_mgr_t * p_manager );
+
+static OPJ_BOOL opj_j2k_allocate_tile_element_cstr_index(opj_j2k_t *p_j2k);
+
+/*
+ * -----------------------------------------------------------------------
+ * -----------------------------------------------------------------------
+ * -----------------------------------------------------------------------
+ */
+
+/**
+ * Writes the SOC marker (Start Of Codestream)
+ *
+ * @param       p_stream                        the stream to write data to.
+ * @param       p_j2k                   J2K codec.
+ * @param       p_manager       the user event manager.
 */
-static void j2k_write_soc(opj_j2k_t *j2k);
+static OPJ_BOOL opj_j2k_write_soc(      opj_j2k_t *p_j2k,
+                                                        opj_stream_private_t *p_stream,
+                                                            opj_event_mgr_t * p_manager );
+
 /**
-Read the SOC marker (Start of Codestream)
-@param j2k J2K handle
+ * Reads a SOC marker (Start of Codestream)
+ * @param       p_j2k           the jpeg2000 file codec.
+ * @param       p_stream        XXX needs data
+ * @param       p_manager       the user event manager.
 */
-static void j2k_read_soc(opj_j2k_t *j2k);
+static OPJ_BOOL opj_j2k_read_soc(   opj_j2k_t *p_j2k,
+                                    opj_stream_private_t *p_stream,
+                                    opj_event_mgr_t * p_manager );
+
 /**
-Write the SIZ marker (image and tile size)
-@param j2k J2K handle
+ * Writes the SIZ marker (image and tile size)
+ *
+ * @param       p_j2k           J2K codec.
+ * @param       p_stream        the stream to write data to.
+ * @param       p_manager       the user event manager.
 */
-static void j2k_write_siz(opj_j2k_t *j2k);
+static OPJ_BOOL opj_j2k_write_siz(      opj_j2k_t *p_j2k,
+                                                                opj_stream_private_t *p_stream,
+                                                                opj_event_mgr_t * p_manager );
+
 /**
-Read the SIZ marker (image and tile size)
-@param j2k J2K handle
+ * Reads a SIZ marker (image and tile size)
+ * @param       p_j2k           the jpeg2000 file codec.
+ * @param       p_header_data   the data contained in the SIZ box.
+ * @param       p_header_size   the size of the data contained in the SIZ marker.
+ * @param       p_manager       the user event manager.
 */
-static void j2k_read_siz(opj_j2k_t *j2k);
+static OPJ_BOOL opj_j2k_read_siz(opj_j2k_t *p_j2k,
+                                 OPJ_BYTE * p_header_data,
+                                 OPJ_UINT32 p_header_size,
+                                 opj_event_mgr_t * p_manager);
+
 /**
-Write the COM marker (comment)
-@param j2k J2K handle
+ * Writes the COM marker (comment)
+ *
+ * @param       p_stream                        the stream to write data to.
+ * @param       p_j2k                   J2K codec.
+ * @param       p_manager       the user event manager.
 */
-static void j2k_write_com(opj_j2k_t *j2k);
+static OPJ_BOOL opj_j2k_write_com(      opj_j2k_t *p_j2k,
+                                                                        opj_stream_private_t *p_stream,
+                                                                        opj_event_mgr_t * p_manager );
+
 /**
-Read the COM marker (comment)
-@param j2k J2K handle
+ * Reads a COM marker (comments)
+ * @param       p_j2k           the jpeg2000 file codec.
+ * @param       p_header_data   the data contained in the COM box.
+ * @param       p_header_size   the size of the data contained in the COM marker.
+ * @param       p_manager       the user event manager.
 */
-static void j2k_read_com(opj_j2k_t *j2k);
+static OPJ_BOOL opj_j2k_read_com (  opj_j2k_t *p_j2k,
+                                    OPJ_BYTE * p_header_data,
+                                    OPJ_UINT32 p_header_size,
+                                    opj_event_mgr_t * p_manager );
 /**
-Write the value concerning the specified component in the marker COD and COC
-@param j2k J2K handle
-@param compno Number of the component concerned by the information written
+ * Writes the COD marker (Coding style default)
+ *
+ * @param       p_stream                        the stream to write data to.
+ * @param       p_j2k                   J2K codec.
+ * @param       p_manager       the user event manager.
 */
-static void j2k_write_cox(opj_j2k_t *j2k, int compno);
+static OPJ_BOOL opj_j2k_write_cod(      opj_j2k_t *p_j2k,
+                                                                        opj_stream_private_t *p_stream,
+                                                                        opj_event_mgr_t * p_manager );
+
 /**
-Read the value concerning the specified component in the marker COD and COC
-@param j2k J2K handle
-@param compno Number of the component concerned by the information read
+ * Reads a COD marker (Coding Styke defaults)
+ * @param       p_header_data   the data contained in the COD box.
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_header_size   the size of the data contained in the COD marker.
+ * @param       p_manager               the user event manager.
 */
-static void j2k_read_cox(opj_j2k_t *j2k, int compno);
+static OPJ_BOOL opj_j2k_read_cod (  opj_j2k_t *p_j2k,
+                                    OPJ_BYTE * p_header_data,
+                                    OPJ_UINT32 p_header_size,
+                                    opj_event_mgr_t * p_manager);
+
+#if 0
 /**
-Write the COD marker (coding style default)
-@param j2k J2K handle
+ * Writes the COC marker (Coding style component)
+ *
+ * @param       p_j2k       J2K codec.
+ * @param       p_comp_no   the index of the component to output.
+ * @param       p_stream    the stream to write data to.
+ * @param       p_manager   the user event manager.
 */
-static void j2k_write_cod(opj_j2k_t *j2k);
+static OPJ_BOOL opj_j2k_write_coc(  opj_j2k_t *p_j2k,
+                                                                OPJ_UINT32 p_comp_no,
+                                                                opj_stream_private_t *p_stream,
+                                                                opj_event_mgr_t * p_manager );
+#endif
+
+#if 0
 /**
-Read the COD marker (coding style default)
-@param j2k J2K handle
+ * Writes the COC marker (Coding style component)
+ *
+ * @param       p_j2k                   J2K codec.
+ * @param       p_comp_no               the index of the component to output.
+ * @param       p_data          FIXME DOC
+ * @param       p_data_written  FIXME DOC
+ * @param       p_manager               the user event manager.
 */
-static void j2k_read_cod(opj_j2k_t *j2k);
+static void opj_j2k_write_coc_in_memory(opj_j2k_t *p_j2k,
+                                                                            OPJ_UINT32 p_comp_no,
+                                                                            OPJ_BYTE * p_data,
+                                                                            OPJ_UINT32 * p_data_written,
+                                                                            opj_event_mgr_t * p_manager );
+#endif
+
+/**
+ * Gets the maximum size taken by a coc.
+ *
+ * @param       p_j2k   the jpeg2000 codec to use.
+ */
+static OPJ_UINT32 opj_j2k_get_max_coc_size(opj_j2k_t *p_j2k);
+
 /**
-Write the COC marker (coding style component)
-@param j2k J2K handle
-@param compno Number of the component concerned by the information written
+ * Reads a COC marker (Coding Style Component)
+ * @param       p_header_data   the data contained in the COC box.
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_header_size   the size of the data contained in the COC marker.
+ * @param       p_manager               the user event manager.
 */
-static void j2k_write_coc(opj_j2k_t *j2k, int compno);
+static OPJ_BOOL opj_j2k_read_coc (  opj_j2k_t *p_j2k,
+                                    OPJ_BYTE * p_header_data,
+                                    OPJ_UINT32 p_header_size,
+                                    opj_event_mgr_t * p_manager );
+
 /**
-Read the COC marker (coding style component)
-@param j2k J2K handle
+ * Writes the QCD marker (quantization default)
+ *
+ * @param       p_j2k                   J2K codec.
+ * @param       p_stream                the stream to write data to.
+ * @param       p_manager               the user event manager.
 */
-static void j2k_read_coc(opj_j2k_t *j2k);
+static OPJ_BOOL opj_j2k_write_qcd(      opj_j2k_t *p_j2k,
+                                                                        opj_stream_private_t *p_stream,
+                                                                        opj_event_mgr_t * p_manager );
+
 /**
-Write the value concerning the specified component in the marker QCD and QCC
-@param j2k J2K handle
-@param compno Number of the component concerned by the information written
+ * Reads a QCD marker (Quantization defaults)
+ * @param       p_header_data   the data contained in the QCD box.
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_header_size   the size of the data contained in the QCD marker.
+ * @param       p_manager               the user event manager.
 */
-static void j2k_write_qcx(opj_j2k_t *j2k, int compno);
+static OPJ_BOOL opj_j2k_read_qcd (  opj_j2k_t *p_j2k,
+                                    OPJ_BYTE * p_header_data,
+                                    OPJ_UINT32 p_header_size,
+                                    opj_event_mgr_t * p_manager );
+#if 0
 /**
-Read the value concerning the specified component in the marker QCD and QCC
-@param j2k J2K handle
-@param compno Number of the component concern by the information read
-@param len Length of the information in the QCX part of the marker QCD/QCC
+ * Writes the QCC marker (quantization component)
+ *
+ * @param       p_comp_no       the index of the component to output.
+ * @param       p_stream                the stream to write data to.
+ * @param       p_j2k                   J2K codec.
+ * @param       p_manager               the user event manager.
 */
-static void j2k_read_qcx(opj_j2k_t *j2k, int compno, int len);
+static OPJ_BOOL opj_j2k_write_qcc(      opj_j2k_t *p_j2k,
+                                                                        OPJ_UINT32 p_comp_no,
+                                                                        opj_stream_private_t *p_stream,
+                                                                        opj_event_mgr_t * p_manager );
+#endif
+
+#if 0
 /**
-Write the QCD marker (quantization default)
-@param j2k J2K handle
+ * Writes the QCC marker (quantization component)
+ *
+ * @param       p_j2k           J2K codec.
+ * @param       p_comp_no       the index of the component to output.
+ * @param       p_data          FIXME DOC
+ * @param       p_data_written  the stream to write data to.
+ * @param       p_manager       the user event manager.
 */
-static void j2k_write_qcd(opj_j2k_t *j2k);
+static void opj_j2k_write_qcc_in_memory(opj_j2k_t *p_j2k,
+                                                                            OPJ_UINT32 p_comp_no,
+                                                                            OPJ_BYTE * p_data,
+                                                                            OPJ_UINT32 * p_data_written,
+                                                                            opj_event_mgr_t * p_manager );
+#endif
+
+/**
+ * Gets the maximum size taken by a qcc.
+ */
+static OPJ_UINT32 opj_j2k_get_max_qcc_size (opj_j2k_t *p_j2k);
+
 /**
-Read the QCD marker (quantization default)
-@param j2k J2K handle
+ * Reads a QCC marker (Quantization component)
+ * @param       p_header_data   the data contained in the QCC box.
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_header_size   the size of the data contained in the QCC marker.
+ * @param       p_manager               the user event manager.
 */
-static void j2k_read_qcd(opj_j2k_t *j2k);
+static OPJ_BOOL opj_j2k_read_qcc(   opj_j2k_t *p_j2k,
+                                    OPJ_BYTE * p_header_data,
+                                    OPJ_UINT32 p_header_size,
+                                    opj_event_mgr_t * p_manager);
 /**
-Write the QCC marker (quantization component)
-@param j2k J2K handle
-@param compno Number of the component concerned by the information written
+ * Writes the POC marker (Progression Order Change)
+ *
+ * @param       p_stream                                the stream to write data to.
+ * @param       p_j2k                           J2K codec.
+ * @param       p_manager               the user event manager.
 */
-static void j2k_write_qcc(opj_j2k_t *j2k, int compno);
+static OPJ_BOOL opj_j2k_write_poc(      opj_j2k_t *p_j2k,
+                                                                        opj_stream_private_t *p_stream,
+                                                                        opj_event_mgr_t * p_manager );
+/**
+ * Writes the POC marker (Progression Order Change)
+ *
+ * @param       p_j2k          J2K codec.
+ * @param       p_data         FIXME DOC
+ * @param       p_data_written the stream to write data to.
+ * @param       p_manager      the user event manager.
+ */
+static void opj_j2k_write_poc_in_memory(opj_j2k_t *p_j2k,
+                                                                            OPJ_BYTE * p_data,
+                                                                            OPJ_UINT32 * p_data_written,
+                                                                            opj_event_mgr_t * p_manager );
+/**
+ * Gets the maximum size taken by the writing of a POC.
+ */
+static OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k);
+
 /**
-Read the QCC marker (quantization component)
-@param j2k J2K handle
+ * Reads a POC marker (Progression Order Change)
+ *
+ * @param       p_header_data   the data contained in the POC box.
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_header_size   the size of the data contained in the POC marker.
+ * @param       p_manager               the user event manager.
 */
-static void j2k_read_qcc(opj_j2k_t *j2k);
+static OPJ_BOOL opj_j2k_read_poc (  opj_j2k_t *p_j2k,
+                                    OPJ_BYTE * p_header_data,
+                                    OPJ_UINT32 p_header_size,
+                                    opj_event_mgr_t * p_manager );
+
+/**
+ * Gets the maximum size taken by the toc headers of all the tile parts of any given tile.
+ */
+static OPJ_UINT32 opj_j2k_get_max_toc_size (opj_j2k_t *p_j2k);
+
+/**
+ * Gets the maximum size taken by the headers of the SOT.
+ *
+ * @param       p_j2k   the jpeg2000 codec to use.
+ */
+static OPJ_UINT32 opj_j2k_get_specific_header_sizes(opj_j2k_t *p_j2k);
+
 /**
-Write the POC marker (progression order change)
-@param j2k J2K handle
+ * Reads a CRG marker (Component registration)
+ *
+ * @param       p_header_data   the data contained in the TLM box.
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_header_size   the size of the data contained in the TLM marker.
+ * @param       p_manager               the user event manager.
 */
-static void j2k_write_poc(opj_j2k_t *j2k);
+static OPJ_BOOL opj_j2k_read_crg (  opj_j2k_t *p_j2k,
+                                    OPJ_BYTE * p_header_data,
+                                    OPJ_UINT32 p_header_size,
+                                    opj_event_mgr_t * p_manager );
 /**
-Read the POC marker (progression order change)
-@param j2k J2K handle
+ * Reads a TLM marker (Tile Length Marker)
+ *
+ * @param       p_header_data   the data contained in the TLM box.
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_header_size   the size of the data contained in the TLM marker.
+ * @param       p_manager               the user event manager.
 */
-static void j2k_read_poc(opj_j2k_t *j2k);
+static OPJ_BOOL opj_j2k_read_tlm (  opj_j2k_t *p_j2k,
+                                    OPJ_BYTE * p_header_data,
+                                    OPJ_UINT32 p_header_size,
+                                    opj_event_mgr_t * p_manager);
+
 /**
-Read the CRG marker (component registration)
-@param j2k J2K handle
+ * Writes the updated tlm.
+ *
+ * @param       p_stream                the stream to write data to.
+ * @param       p_j2k                   J2K codec.
+ * @param       p_manager               the user event manager.
 */
-static void j2k_read_crg(opj_j2k_t *j2k);
+static OPJ_BOOL opj_j2k_write_updated_tlm(      opj_j2k_t *p_j2k,
+                                            opj_stream_private_t *p_stream,
+                                            opj_event_mgr_t * p_manager );
+
 /**
-Read the TLM marker (tile-part lengths)
-@param j2k J2K handle
+ * Reads a PLM marker (Packet length, main header marker)
+ *
+ * @param       p_header_data   the data contained in the TLM box.
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_header_size   the size of the data contained in the TLM marker.
+ * @param       p_manager               the user event manager.
 */
-static void j2k_read_tlm(opj_j2k_t *j2k);
+static OPJ_BOOL opj_j2k_read_plm (  opj_j2k_t *p_j2k,
+                                    OPJ_BYTE * p_header_data,
+                                    OPJ_UINT32 p_header_size,
+                                    opj_event_mgr_t * p_manager);
 /**
-Read the PLM marker (packet length, main header)
-@param j2k J2K handle
+ * Reads a PLT marker (Packet length, tile-part header)
+ *
+ * @param       p_header_data   the data contained in the PLT box.
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_header_size   the size of the data contained in the PLT marker.
+ * @param       p_manager               the user event manager.
 */
-static void j2k_read_plm(opj_j2k_t *j2k);
+static OPJ_BOOL opj_j2k_read_plt (  opj_j2k_t *p_j2k,
+                                    OPJ_BYTE * p_header_data,
+                                    OPJ_UINT32 p_header_size,
+                                    opj_event_mgr_t * p_manager );
+
+#if 0
 /**
-Read the PLT marker (packet length, tile-part header)
-@param j2k J2K handle
+ * Reads a PPM marker (Packed packet headers, main header)
+ *
+ * @param       p_header_data   the data contained in the POC box.
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_header_size   the size of the data contained in the POC marker.
+ * @param       p_manager               the user event manager.
 */
-static void j2k_read_plt(opj_j2k_t *j2k);
+static OPJ_BOOL j2k_read_ppm_v2 (
+                                                opj_j2k_t *p_j2k,
+                                                OPJ_BYTE * p_header_data,
+                                                OPJ_UINT32 p_header_size,
+                                                struct opj_event_mgr * p_manager
+                                        );
+#endif
+
+static OPJ_BOOL j2k_read_ppm_v3 (
+                                                opj_j2k_t *p_j2k,
+                                                OPJ_BYTE * p_header_data,
+                                                OPJ_UINT32 p_header_size,
+                                                opj_event_mgr_t * p_manager );
+
 /**
-Read the PPM marker (packet packet headers, main header)
-@param j2k J2K handle
+ * Reads a PPT marker (Packed packet headers, tile-part header)
+ *
+ * @param       p_header_data   the data contained in the PPT box.
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_header_size   the size of the data contained in the PPT marker.
+ * @param       p_manager               the user event manager.
 */
-static void j2k_read_ppm(opj_j2k_t *j2k);
+static OPJ_BOOL opj_j2k_read_ppt (  opj_j2k_t *p_j2k,
+                                    OPJ_BYTE * p_header_data,
+                                    OPJ_UINT32 p_header_size,
+                                    opj_event_mgr_t * p_manager );
 /**
-Read the PPT marker (packet packet headers, tile-part header)
-@param j2k J2K handle
+ * Writes the TLM marker (Tile Length Marker)
+ *
+ * @param       p_stream                                the stream to write data to.
+ * @param       p_j2k                           J2K codec.
+ * @param       p_manager               the user event manager.
 */
-static void j2k_read_ppt(opj_j2k_t *j2k);
+static OPJ_BOOL opj_j2k_write_tlm(      opj_j2k_t *p_j2k,
+                                                                        opj_stream_private_t *p_stream,
+                                                                        opj_event_mgr_t * p_manager );
+
 /**
-Write the TLM marker (Mainheader)
-@param j2k J2K handle
+ * Writes the SOT marker (Start of tile-part)
+ *
+ * @param       p_j2k            J2K codec.
+ * @param       p_data           FIXME DOC
+ * @param       p_data_written   FIXME DOC
+ * @param       p_stream         the stream to write data to.
+ * @param       p_manager        the user event manager.
 */
-static void j2k_write_tlm(opj_j2k_t *j2k);
+static OPJ_BOOL opj_j2k_write_sot(      opj_j2k_t *p_j2k,
+                                                                        OPJ_BYTE * p_data,
+                                                                        OPJ_UINT32 * p_data_written,
+                                                                        const opj_stream_private_t *p_stream,
+                                                                        opj_event_mgr_t * p_manager );
+
 /**
-Write the SOT marker (start of tile-part)
-@param j2k J2K handle
+ * Reads a PPT marker (Packed packet headers, tile-part header)
+ *
+ * @param       p_header_data   the data contained in the PPT box.
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_header_size   the size of the data contained in the PPT marker.
+ * @param       p_manager               the user event manager.
 */
-static void j2k_write_sot(opj_j2k_t *j2k);
+static OPJ_BOOL opj_j2k_read_sot (  opj_j2k_t *p_j2k,
+                                    OPJ_BYTE * p_header_data,
+                                    OPJ_UINT32 p_header_size,
+                                    opj_event_mgr_t * p_manager );
 /**
-Read the SOT marker (start of tile-part)
-@param j2k J2K handle
+ * Writes the SOD marker (Start of data)
+ *
+ * @param       p_j2k               J2K codec.
+ * @param       p_tile_coder        FIXME DOC
+ * @param       p_data              FIXME DOC
+ * @param       p_data_written      FIXME DOC
+ * @param       p_total_data_size   FIXME DOC
+ * @param       p_stream            the stream to write data to.
+ * @param       p_manager           the user event manager.
 */
-static void j2k_read_sot(opj_j2k_t *j2k);
+static OPJ_BOOL opj_j2k_write_sod(      opj_j2k_t *p_j2k,
+                                                                        opj_tcd_t * p_tile_coder,
+                                                                        OPJ_BYTE * p_data,
+                                                                        OPJ_UINT32 * p_data_written,
+                                                                        OPJ_UINT32 p_total_data_size,
+                                                                        const opj_stream_private_t *p_stream,
+                                                                        opj_event_mgr_t * p_manager );
+
 /**
-Write the SOD marker (start of data)
-@param j2k J2K handle
-@param tile_coder Pointer to a TCD handle
+ * Reads a SOD marker (Start Of Data)
+ *
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_stream                FIXME DOC
+ * @param       p_manager               the user event manager.
 */
-static void j2k_write_sod(opj_j2k_t *j2k, void *tile_coder);
+static OPJ_BOOL opj_j2k_read_sod(   opj_j2k_t *p_j2k,
+                                    opj_stream_private_t *p_stream,
+                                    opj_event_mgr_t * p_manager );
+
+void opj_j2k_update_tlm (opj_j2k_t * p_j2k, OPJ_UINT32 p_tile_part_size )
+{
+        opj_write_bytes(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current,p_j2k->m_current_tile_number,1);            /* PSOT */
+        ++p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current;
+
+        opj_write_bytes(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current,p_tile_part_size,4);                                        /* PSOT */
+        p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current += 4;
+}
+
 /**
-Read the SOD marker (start of data)
-@param j2k J2K handle
+ * Writes the RGN marker (Region Of Interest)
+ *
+ * @param       p_tile_no               the tile to output
+ * @param       p_comp_no               the component to output
+ * @param       nb_comps                the number of components
+ * @param       p_stream                the stream to write data to.
+ * @param       p_j2k                   J2K codec.
+ * @param       p_manager               the user event manager.
 */
-static void j2k_read_sod(opj_j2k_t *j2k);
+static OPJ_BOOL opj_j2k_write_rgn(  opj_j2k_t *p_j2k,
+                                    OPJ_UINT32 p_tile_no,
+                                    OPJ_UINT32 p_comp_no,
+                                    OPJ_UINT32 nb_comps,
+                                    opj_stream_private_t *p_stream,
+                                    opj_event_mgr_t * p_manager );
+
 /**
-Write the RGN marker (region-of-interest)
-@param j2k J2K handle
-@param compno Number of the component concerned by the information written
-@param tileno Number of the tile concerned by the information written
+ * Reads a RGN marker (Region Of Interest)
+ *
+ * @param       p_header_data   the data contained in the POC box.
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_header_size   the size of the data contained in the POC marker.
+ * @param       p_manager               the user event manager.
 */
-static void j2k_write_rgn(opj_j2k_t *j2k, int compno, int tileno);
+static OPJ_BOOL opj_j2k_read_rgn (opj_j2k_t *p_j2k,
+                                  OPJ_BYTE * p_header_data,
+                                  OPJ_UINT32 p_header_size,
+                                  opj_event_mgr_t * p_manager );
+
 /**
-Read the RGN marker (region-of-interest)
-@param j2k J2K handle
+ * Writes the EOC marker (End of Codestream)
+ *
+ * @param       p_stream                the stream to write data to.
+ * @param       p_j2k                   J2K codec.
+ * @param       p_manager               the user event manager.
 */
-static void j2k_read_rgn(opj_j2k_t *j2k);
+static OPJ_BOOL opj_j2k_write_eoc(      opj_j2k_t *p_j2k,
+                                    opj_stream_private_t *p_stream,
+                                    opj_event_mgr_t * p_manager );
+
+#if 0
 /**
-Write the EOC marker (end of codestream)
-@param j2k J2K handle
+ * Reads a EOC marker (End Of Codestream)
+ *
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_stream                FIXME DOC
+ * @param       p_manager               the user event manager.
 */
-static void j2k_write_eoc(opj_j2k_t *j2k);
+static OPJ_BOOL opj_j2k_read_eoc (      opj_j2k_t *p_j2k,
+                                                                opj_stream_private_t *p_stream,
+                                                                opj_event_mgr_t * p_manager );
+#endif
+
 /**
-Read the EOC marker (end of codestream)
-@param j2k J2K handle
+ * Writes the CBD-MCT-MCC-MCO markers (Multi components transform)
+ *
+ * @param       p_stream                        the stream to write data to.
+ * @param       p_j2k                   J2K codec.
+ * @param       p_manager       the user event manager.
 */
-static void j2k_read_eoc(opj_j2k_t *j2k);
+static OPJ_BOOL opj_j2k_write_mct_data_group(   opj_j2k_t *p_j2k,
+                                                opj_stream_private_t *p_stream,
+                                                opj_event_mgr_t * p_manager );
+
 /**
-Read an unknown marker
-@param j2k J2K handle
+ * Inits the Info
+ *
+ * @param       p_stream                the stream to write data to.
+ * @param       p_j2k                   J2K codec.
+ * @param       p_manager               the user event manager.
 */
-static void j2k_read_unk(opj_j2k_t *j2k);
+static OPJ_BOOL opj_j2k_init_info(      opj_j2k_t *p_j2k,
+                                    opj_stream_private_t *p_stream,
+                                    opj_event_mgr_t * p_manager );
+
 /**
 Add main header marker information
-@param cstr_info Codestream information structure
-@param type marker type
-@param pos byte offset of marker segment
-@param len length of marker segment
+@param cstr_index    Codestream information structure
+@param type         marker type
+@param pos          byte offset of marker segment
+@param len          length of marker segment
  */
-static void j2k_add_mhmarker(opj_codestream_info_t *cstr_info, unsigned short int type, int pos, int len);
+static OPJ_BOOL opj_j2k_add_mhmarker(opj_codestream_index_t *cstr_index, OPJ_UINT32 type, OPJ_OFF_T pos, OPJ_UINT32 len) ;
 /**
 Add tile header marker information
-@param tileno tile index number
-@param cstr_info Codestream information structure
-@param type marker type
-@param pos byte offset of marker segment
-@param len length of marker segment
+@param tileno       tile index number
+@param cstr_index   Codestream information structure
+@param type         marker type
+@param pos          byte offset of marker segment
+@param len          length of marker segment
  */
-static void j2k_add_tlmarker( int tileno, opj_codestream_info_t *cstr_info, unsigned short int type, int pos, int len);
+static OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno, opj_codestream_index_t *cstr_index, OPJ_UINT32 type, OPJ_OFF_T pos, OPJ_UINT32 len);
+
+/**
+ * Reads an unknown marker
+ *
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_stream                the stream object to read from.
+ * @param       output_marker           FIXME DOC
+ * @param       p_manager               the user event manager.
+ *
+ * @return      true                    if the marker could be deduced.
+*/
+static OPJ_BOOL opj_j2k_read_unk( opj_j2k_t *p_j2k,
+                                  opj_stream_private_t *p_stream,
+                                  OPJ_UINT32 *output_marker,
+                                  opj_event_mgr_t * p_manager );
+
+/**
+ * Writes the MCT marker (Multiple Component Transform)
+ *
+ * @param       p_j2k           J2K codec.
+ * @param       p_mct_record    FIXME DOC
+ * @param       p_stream        the stream to write data to.
+ * @param       p_manager       the user event manager.
+*/
+static OPJ_BOOL opj_j2k_write_mct_record(       opj_j2k_t *p_j2k,
+                                                                                    opj_mct_data_t * p_mct_record,
+                                            opj_stream_private_t *p_stream,
+                                            opj_event_mgr_t * p_manager );
+
+/**
+ * Reads a MCT marker (Multiple Component Transform)
+ *
+ * @param       p_header_data   the data contained in the MCT box.
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_header_size   the size of the data contained in the MCT marker.
+ * @param       p_manager               the user event manager.
+*/
+static OPJ_BOOL opj_j2k_read_mct (      opj_j2k_t *p_j2k,
+                                                                    OPJ_BYTE * p_header_data,
+                                                                    OPJ_UINT32 p_header_size,
+                                                                    opj_event_mgr_t * p_manager );
+
+/**
+ * Writes the MCC marker (Multiple Component Collection)
+ *
+ * @param       p_j2k                   J2K codec.
+ * @param       p_mcc_record            FIXME DOC
+ * @param       p_stream                the stream to write data to.
+ * @param       p_manager               the user event manager.
+*/
+static OPJ_BOOL opj_j2k_write_mcc_record(   opj_j2k_t *p_j2k,
+                                            opj_simple_mcc_decorrelation_data_t * p_mcc_record,
+                                            opj_stream_private_t *p_stream,
+                                            opj_event_mgr_t * p_manager );
+
+/**
+ * Reads a MCC marker (Multiple Component Collection)
+ *
+ * @param       p_header_data   the data contained in the MCC box.
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_header_size   the size of the data contained in the MCC marker.
+ * @param       p_manager               the user event manager.
+*/
+static OPJ_BOOL opj_j2k_read_mcc (      opj_j2k_t *p_j2k,
+                                                                    OPJ_BYTE * p_header_data,
+                                                                    OPJ_UINT32 p_header_size,
+                                                                    opj_event_mgr_t * p_manager );
+
+/**
+ * Writes the MCO marker (Multiple component transformation ordering)
+ *
+ * @param       p_stream                                the stream to write data to.
+ * @param       p_j2k                           J2K codec.
+ * @param       p_manager               the user event manager.
+*/
+static OPJ_BOOL opj_j2k_write_mco(      opj_j2k_t *p_j2k,
+                                    opj_stream_private_t *p_stream,
+                                    opj_event_mgr_t * p_manager );
+
+/**
+ * Reads a MCO marker (Multiple Component Transform Ordering)
+ *
+ * @param       p_header_data   the data contained in the MCO box.
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_header_size   the size of the data contained in the MCO marker.
+ * @param       p_manager               the user event manager.
+*/
+static OPJ_BOOL opj_j2k_read_mco (      opj_j2k_t *p_j2k,
+                                                                    OPJ_BYTE * p_header_data,
+                                                                    OPJ_UINT32 p_header_size,
+                                                                    opj_event_mgr_t * p_manager );
+
+static OPJ_BOOL opj_j2k_add_mct(opj_tcp_t * p_tcp, opj_image_t * p_image, OPJ_UINT32 p_index);
+
+static void  opj_j2k_read_int16_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);
+static void  opj_j2k_read_int32_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);
+static void  opj_j2k_read_float32_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);
+static void  opj_j2k_read_float64_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);
+
+static void  opj_j2k_read_int16_to_int32 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);
+static void  opj_j2k_read_int32_to_int32 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);
+static void  opj_j2k_read_float32_to_int32 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);
+static void  opj_j2k_read_float64_to_int32 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);
+
+static void  opj_j2k_write_float_to_int16 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);
+static void  opj_j2k_write_float_to_int32 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);
+static void  opj_j2k_write_float_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);
+static void  opj_j2k_write_float_to_float64 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);
+
+/**
+ * Ends the encoding, i.e. frees memory.
+ *
+ * @param       p_stream                the stream to write data to.
+ * @param       p_j2k                   J2K codec.
+ * @param       p_manager               the user event manager.
+*/
+static OPJ_BOOL opj_j2k_end_encoding(   opj_j2k_t *p_j2k,
+                                                                            opj_stream_private_t *p_stream,
+                                                                            opj_event_mgr_t * p_manager );
+
+/**
+ * Writes the CBD marker (Component bit depth definition)
+ *
+ * @param       p_stream                                the stream to write data to.
+ * @param       p_j2k                           J2K codec.
+ * @param       p_manager               the user event manager.
+*/
+static OPJ_BOOL opj_j2k_write_cbd(      opj_j2k_t *p_j2k,
+                                                                    opj_stream_private_t *p_stream,
+                                                                        opj_event_mgr_t * p_manager );
+
+/**
+ * Reads a CBD marker (Component bit depth definition)
+ * @param       p_header_data   the data contained in the CBD box.
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_header_size   the size of the data contained in the CBD marker.
+ * @param       p_manager               the user event manager.
+*/
+static OPJ_BOOL opj_j2k_read_cbd (      opj_j2k_t *p_j2k,
+                                                                OPJ_BYTE * p_header_data,
+                                                                OPJ_UINT32 p_header_size,
+                                                                opj_event_mgr_t * p_manager);
+
+#if 0
+/**
+ * Writes COC marker for each component.
+ *
+ * @param       p_stream                the stream to write data to.
+ * @param       p_j2k                   J2K codec.
+ * @param       p_manager               the user event manager.
+*/
+static OPJ_BOOL opj_j2k_write_all_coc( opj_j2k_t *p_j2k,
+                                                                        opj_stream_private_t *p_stream,
+                                                                        opj_event_mgr_t * p_manager );
+#endif
+
+#if 0
+/**
+ * Writes QCC marker for each component.
+ *
+ * @param       p_stream                the stream to write data to.
+ * @param       p_j2k                   J2K codec.
+ * @param       p_manager               the user event manager.
+*/
+static OPJ_BOOL opj_j2k_write_all_qcc( opj_j2k_t *p_j2k,
+                                                                        opj_stream_private_t *p_stream,
+                                                                        opj_event_mgr_t * p_manager );
+#endif
+
+/**
+ * Writes regions of interests.
+ *
+ * @param       p_stream                the stream to write data to.
+ * @param       p_j2k                   J2K codec.
+ * @param       p_manager               the user event manager.
+*/
+static OPJ_BOOL opj_j2k_write_regions(  opj_j2k_t *p_j2k,
+                                                                        opj_stream_private_t *p_stream,
+                                                                        opj_event_mgr_t * p_manager );
+
+/**
+ * Writes EPC ????
+ *
+ * @param       p_stream                the stream to write data to.
+ * @param       p_j2k                   J2K codec.
+ * @param       p_manager               the user event manager.
+*/
+static OPJ_BOOL opj_j2k_write_epc(      opj_j2k_t *p_j2k,
+                                                                    opj_stream_private_t *p_stream,
+                                                                    opj_event_mgr_t * p_manager );
+
+/**
+ * Checks the progression order changes values. Tells of the poc given as input are valid.
+ * A nice message is outputted at errors.
+ *
+ * @param       p_pocs                  the progression order changes.
+ * @param       p_nb_pocs               the number of progression order changes.
+ * @param       p_nb_resolutions        the number of resolutions.
+ * @param       numcomps                the number of components
+ * @param       numlayers               the number of layers.
+ * @param       p_manager               the user event manager.
+ *
+ * @return      true if the pocs are valid.
+ */
+static OPJ_BOOL opj_j2k_check_poc_val(  const opj_poc_t *p_pocs,
+                                                                            OPJ_UINT32 p_nb_pocs,
+                                                                            OPJ_UINT32 p_nb_resolutions,
+                                                                            OPJ_UINT32 numcomps,
+                                                                            OPJ_UINT32 numlayers,
+                                                                            opj_event_mgr_t * p_manager);
+
+/**
+ * Gets the number of tile parts used for the given change of progression (if any) and the given tile.
+ *
+ * @param               cp                      the coding parameters.
+ * @param               pino            the offset of the given poc (i.e. its position in the coding parameter).
+ * @param               tileno          the given tile.
+ *
+ * @return              the number of tile parts.
+ */
+static OPJ_UINT32 opj_j2k_get_num_tp( opj_cp_t *cp, OPJ_UINT32 pino, OPJ_UINT32 tileno);
+
+/**
+ * Calculates the total number of tile parts needed by the encoder to
+ * encode such an image. If not enough memory is available, then the function return false.
+ *
+ * @param       p_nb_tiles      pointer that will hold the number of tile parts.
+ * @param       cp                      the coding parameters for the image.
+ * @param       image           the image to encode.
+ * @param       p_j2k                   the p_j2k encoder.
+ * @param       p_manager       the user event manager.
+ *
+ * @return true if the function was successful, false else.
+ */
+static OPJ_BOOL opj_j2k_calculate_tp(   opj_j2k_t *p_j2k,
+                                                                            opj_cp_t *cp,
+                                                                            OPJ_UINT32 * p_nb_tiles,
+                                                                            opj_image_t *image,
+                                                                            opj_event_mgr_t * p_manager);
+
+static void opj_j2k_dump_MH_info(opj_j2k_t* p_j2k, FILE* out_stream);
+
+static void opj_j2k_dump_MH_index(opj_j2k_t* p_j2k, FILE* out_stream);
+
+static opj_codestream_index_t* opj_j2k_create_cstr_index(void);
+
+static OPJ_FLOAT32 opj_j2k_get_tp_stride (opj_tcp_t * p_tcp);
+
+static OPJ_FLOAT32 opj_j2k_get_default_stride (opj_tcp_t * p_tcp);
+
+static int opj_j2k_initialise_4K_poc(opj_poc_t *POC, int numres);
+
+static void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters, opj_image_t *image, opj_event_mgr_t *p_manager);
+
+static OPJ_BOOL opj_j2k_is_cinema_compliant(opj_image_t *image, OPJ_UINT16 rsiz, opj_event_mgr_t *p_manager);
+
+/*@}*/
+
+/*@}*/
+
+/* ----------------------------------------------------------------------- */
+typedef struct j2k_prog_order{
+        OPJ_PROG_ORDER enum_prog;
+        char str_prog[5];
+}j2k_prog_order_t;
+
+j2k_prog_order_t j2k_prog_order_list[] = {
+        {OPJ_CPRL, "CPRL"},
+        {OPJ_LRCP, "LRCP"},
+        {OPJ_PCRL, "PCRL"},
+        {OPJ_RLCP, "RLCP"},
+        {OPJ_RPCL, "RPCL"},
+        {(OPJ_PROG_ORDER)-1, ""}
+};
+
+/**
+ * FIXME DOC
+ */
+static const OPJ_UINT32 MCT_ELEMENT_SIZE [] =
+{
+        2,
+        4,
+        4,
+        8
+};
+
+typedef void (* opj_j2k_mct_function) (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem);
+
+const opj_j2k_mct_function j2k_mct_read_functions_to_float [] =
+{
+        opj_j2k_read_int16_to_float,
+        opj_j2k_read_int32_to_float,
+        opj_j2k_read_float32_to_float,
+        opj_j2k_read_float64_to_float
+};
+
+const opj_j2k_mct_function j2k_mct_read_functions_to_int32 [] =
+{
+        opj_j2k_read_int16_to_int32,
+        opj_j2k_read_int32_to_int32,
+        opj_j2k_read_float32_to_int32,
+        opj_j2k_read_float64_to_int32
+};
+
+const opj_j2k_mct_function j2k_mct_write_functions_from_float [] =
+{
+        opj_j2k_write_float_to_int16,
+        opj_j2k_write_float_to_int32,
+        opj_j2k_write_float_to_float,
+        opj_j2k_write_float_to_float64
+};
+
+typedef struct opj_dec_memory_marker_handler
+{
+        /** marker value */
+        OPJ_UINT32 id;
+        /** value of the state when the marker can appear */
+        OPJ_UINT32 states;
+        /** action linked to the marker */
+        OPJ_BOOL (*handler) (   opj_j2k_t *p_j2k,
+                            OPJ_BYTE * p_header_data,
+                            OPJ_UINT32 p_header_size,
+                            opj_event_mgr_t * p_manager );
+}
+opj_dec_memory_marker_handler_t;
+
+const opj_dec_memory_marker_handler_t j2k_memory_marker_handler_tab [] =
+{
+  {J2K_MS_SOT, J2K_STATE_MH | J2K_STATE_TPHSOT, opj_j2k_read_sot},
+  {J2K_MS_COD, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_cod},
+  {J2K_MS_COC, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_coc},
+  {J2K_MS_RGN, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_rgn},
+  {J2K_MS_QCD, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_qcd},
+  {J2K_MS_QCC, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_qcc},
+  {J2K_MS_POC, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_poc},
+  {J2K_MS_SIZ, J2K_STATE_MHSIZ, opj_j2k_read_siz},
+  {J2K_MS_TLM, J2K_STATE_MH, opj_j2k_read_tlm},
+  {J2K_MS_PLM, J2K_STATE_MH, opj_j2k_read_plm},
+  {J2K_MS_PLT, J2K_STATE_TPH, opj_j2k_read_plt},
+  {J2K_MS_PPM, J2K_STATE_MH, j2k_read_ppm_v3},
+  {J2K_MS_PPT, J2K_STATE_TPH, opj_j2k_read_ppt},
+  {J2K_MS_SOP, 0, 0},
+  {J2K_MS_CRG, J2K_STATE_MH, opj_j2k_read_crg},
+  {J2K_MS_COM, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_com},
+  {J2K_MS_MCT, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_mct},
+  {J2K_MS_CBD, J2K_STATE_MH , opj_j2k_read_cbd},
+  {J2K_MS_MCC, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_mcc},
+  {J2K_MS_MCO, J2K_STATE_MH | J2K_STATE_TPH, opj_j2k_read_mco},
+#ifdef USE_JPWL
+#ifdef TODO_MS /* remove these functions which are not commpatible with the v2 API */
+  {J2K_MS_EPC, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_epc},
+  {J2K_MS_EPB, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_epb},
+  {J2K_MS_ESD, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_esd},
+  {J2K_MS_RED, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_red},
+#endif
+#endif /* USE_JPWL */
+#ifdef USE_JPSEC
+  {J2K_MS_SEC, J2K_DEC_STATE_MH, j2k_read_sec},
+  {J2K_MS_INSEC, 0, j2k_read_insec}
+#endif /* USE_JPSEC */
+  {J2K_MS_UNK, J2K_STATE_MH | J2K_STATE_TPH, 0}/*opj_j2k_read_unk is directly used*/
+};
+
+void  opj_j2k_read_int16_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
+{
+        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
+        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
+        OPJ_UINT32 i;
+        OPJ_UINT32 l_temp;
+
+        for (i=0;i<p_nb_elem;++i) {
+                opj_read_bytes(l_src_data,&l_temp,2);
+
+                l_src_data+=sizeof(OPJ_INT16);
+
+                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
+        }
+}
+
+void  opj_j2k_read_int32_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
+{
+        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
+        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
+        OPJ_UINT32 i;
+        OPJ_UINT32 l_temp;
+
+        for (i=0;i<p_nb_elem;++i) {
+                opj_read_bytes(l_src_data,&l_temp,4);
+
+                l_src_data+=sizeof(OPJ_INT32);
+
+                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
+        }
+}
+
+void  opj_j2k_read_float32_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
+{
+        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
+        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
+        OPJ_UINT32 i;
+        OPJ_FLOAT32 l_temp;
+
+        for (i=0;i<p_nb_elem;++i) {
+                opj_read_float(l_src_data,&l_temp);
+
+                l_src_data+=sizeof(OPJ_FLOAT32);
+
+                *(l_dest_data++) = l_temp;
+        }
+}
+
+void  opj_j2k_read_float64_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
+{
+        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
+        OPJ_FLOAT32 * l_dest_data = (OPJ_FLOAT32 *) p_dest_data;
+        OPJ_UINT32 i;
+        OPJ_FLOAT64 l_temp;
+
+        for (i=0;i<p_nb_elem;++i) {
+                opj_read_double(l_src_data,&l_temp);
+
+                l_src_data+=sizeof(OPJ_FLOAT64);
+
+                *(l_dest_data++) = (OPJ_FLOAT32) l_temp;
+        }
+}
+
+void  opj_j2k_read_int16_to_int32 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
+{
+        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
+        OPJ_INT32 * l_dest_data = (OPJ_INT32 *) p_dest_data;
+        OPJ_UINT32 i;
+        OPJ_UINT32 l_temp;
+
+        for (i=0;i<p_nb_elem;++i) {
+                opj_read_bytes(l_src_data,&l_temp,2);
+
+                l_src_data+=sizeof(OPJ_INT16);
+
+                *(l_dest_data++) = (OPJ_INT32) l_temp;
+        }
+}
+
+void  opj_j2k_read_int32_to_int32 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
+{
+        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
+        OPJ_INT32 * l_dest_data = (OPJ_INT32 *) p_dest_data;
+        OPJ_UINT32 i;
+        OPJ_UINT32 l_temp;
+
+        for (i=0;i<p_nb_elem;++i) {
+                opj_read_bytes(l_src_data,&l_temp,4);
+
+                l_src_data+=sizeof(OPJ_INT32);
+
+                *(l_dest_data++) = (OPJ_INT32) l_temp;
+        }
+}
+
+void  opj_j2k_read_float32_to_int32 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
+{
+        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
+        OPJ_INT32 * l_dest_data = (OPJ_INT32 *) p_dest_data;
+        OPJ_UINT32 i;
+        OPJ_FLOAT32 l_temp;
+
+        for (i=0;i<p_nb_elem;++i) {
+                opj_read_float(l_src_data,&l_temp);
+
+                l_src_data+=sizeof(OPJ_FLOAT32);
+
+                *(l_dest_data++) = (OPJ_INT32) l_temp;
+        }
+}
+
+void  opj_j2k_read_float64_to_int32 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
+{
+        OPJ_BYTE * l_src_data = (OPJ_BYTE *) p_src_data;
+        OPJ_INT32 * l_dest_data = (OPJ_INT32 *) p_dest_data;
+        OPJ_UINT32 i;
+        OPJ_FLOAT64 l_temp;
+
+        for (i=0;i<p_nb_elem;++i) {
+                opj_read_double(l_src_data,&l_temp);
+
+                l_src_data+=sizeof(OPJ_FLOAT64);
+
+                *(l_dest_data++) = (OPJ_INT32) l_temp;
+        }
+}
+
+void  opj_j2k_write_float_to_int16 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
+{
+        OPJ_BYTE * l_dest_data = (OPJ_BYTE *) p_dest_data;
+        OPJ_FLOAT32 * l_src_data = (OPJ_FLOAT32 *) p_src_data;
+        OPJ_UINT32 i;
+        OPJ_UINT32 l_temp;
+
+        for (i=0;i<p_nb_elem;++i) {
+                l_temp = (OPJ_UINT32) *(l_src_data++);
+
+                opj_write_bytes(l_dest_data,l_temp,sizeof(OPJ_INT16));
+
+                l_dest_data+=sizeof(OPJ_INT16);
+        }
+}
+
+void opj_j2k_write_float_to_int32 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
+{
+        OPJ_BYTE * l_dest_data = (OPJ_BYTE *) p_dest_data;
+        OPJ_FLOAT32 * l_src_data = (OPJ_FLOAT32 *) p_src_data;
+        OPJ_UINT32 i;
+        OPJ_UINT32 l_temp;
+
+        for (i=0;i<p_nb_elem;++i) {
+                l_temp = (OPJ_UINT32) *(l_src_data++);
+
+                opj_write_bytes(l_dest_data,l_temp,sizeof(OPJ_INT32));
+
+                l_dest_data+=sizeof(OPJ_INT32);
+        }
+}
+
+void  opj_j2k_write_float_to_float (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
+{
+        OPJ_BYTE * l_dest_data = (OPJ_BYTE *) p_dest_data;
+        OPJ_FLOAT32 * l_src_data = (OPJ_FLOAT32 *) p_src_data;
+        OPJ_UINT32 i;
+        OPJ_FLOAT32 l_temp;
+
+        for (i=0;i<p_nb_elem;++i) {
+                l_temp = (OPJ_FLOAT32) *(l_src_data++);
+
+                opj_write_float(l_dest_data,l_temp);
+
+                l_dest_data+=sizeof(OPJ_FLOAT32);
+        }
+}
+
+void  opj_j2k_write_float_to_float64 (const void * p_src_data, void * p_dest_data, OPJ_UINT32 p_nb_elem)
+{
+        OPJ_BYTE * l_dest_data = (OPJ_BYTE *) p_dest_data;
+        OPJ_FLOAT32 * l_src_data = (OPJ_FLOAT32 *) p_src_data;
+        OPJ_UINT32 i;
+        OPJ_FLOAT64 l_temp;
+
+        for (i=0;i<p_nb_elem;++i) {
+                l_temp = (OPJ_FLOAT64) *(l_src_data++);
+
+                opj_write_double(l_dest_data,l_temp);
+
+                l_dest_data+=sizeof(OPJ_FLOAT64);
+        }
+}
+
+char *opj_j2k_convert_progression_order(OPJ_PROG_ORDER prg_order){
+        j2k_prog_order_t *po;
+        for(po = j2k_prog_order_list; po->enum_prog != -1; po++ ){
+                if(po->enum_prog == prg_order){
+                        return po->str_prog;
+                }
+        }
+        return po->str_prog;
+}
+
+OPJ_BOOL opj_j2k_check_poc_val( const opj_poc_t *p_pocs,
+                                                        OPJ_UINT32 p_nb_pocs,
+                                                        OPJ_UINT32 p_nb_resolutions,
+                                                        OPJ_UINT32 p_num_comps,
+                                                        OPJ_UINT32 p_num_layers,
+                                                        opj_event_mgr_t * p_manager)
+{
+        OPJ_UINT32* packet_array;
+        OPJ_UINT32 index , resno, compno, layno;
+        OPJ_UINT32 i;
+        OPJ_UINT32 step_c = 1;
+        OPJ_UINT32 step_r = p_num_comps * step_c;
+        OPJ_UINT32 step_l = p_nb_resolutions * step_r;
+        OPJ_BOOL loss = OPJ_FALSE;
+        OPJ_UINT32 layno0 = 0;
+
+        packet_array = (OPJ_UINT32*) opj_calloc(step_l * p_num_layers, sizeof(OPJ_UINT32));
+        if (packet_array == 00) {
+                opj_event_msg(p_manager , EVT_ERROR, "Not enough memory for checking the poc values.\n");
+                return OPJ_FALSE;
+        }
+        memset(packet_array,0,step_l * p_num_layers* sizeof(OPJ_UINT32));
+
+        if (p_nb_pocs == 0) {
+        opj_free(packet_array);
+                return OPJ_TRUE;
+        }
+
+        index = step_r * p_pocs->resno0;
+        /* take each resolution for each poc */
+        for (resno = p_pocs->resno0 ; resno < p_pocs->resno1 ; ++resno)
+        {
+                OPJ_UINT32 res_index = index + p_pocs->compno0 * step_c;
+
+                /* take each comp of each resolution for each poc */
+                for (compno = p_pocs->compno0 ; compno < p_pocs->compno1 ; ++compno) {
+                        OPJ_UINT32 comp_index = res_index + layno0 * step_l;
+
+                        /* and finally take each layer of each res of ... */
+                        for (layno = layno0; layno < p_pocs->layno1 ; ++layno) {
+                                /*index = step_r * resno + step_c * compno + step_l * layno;*/
+                                packet_array[comp_index] = 1;
+                                comp_index += step_l;
+                        }
+
+                        res_index += step_c;
+                }
+
+                index += step_r;
+        }
+        ++p_pocs;
+
+        /* iterate through all the pocs */
+        for (i = 1; i < p_nb_pocs ; ++i) {
+                OPJ_UINT32 l_last_layno1 = (p_pocs-1)->layno1 ;
+
+                layno0 = (p_pocs->layno1 > l_last_layno1)? l_last_layno1 : 0;
+                index = step_r * p_pocs->resno0;
+
+                /* take each resolution for each poc */
+                for (resno = p_pocs->resno0 ; resno < p_pocs->resno1 ; ++resno) {
+                        OPJ_UINT32 res_index = index + p_pocs->compno0 * step_c;
+
+                        /* take each comp of each resolution for each poc */
+                        for (compno = p_pocs->compno0 ; compno < p_pocs->compno1 ; ++compno) {
+                                OPJ_UINT32 comp_index = res_index + layno0 * step_l;
+
+                                /* and finally take each layer of each res of ... */
+                                for (layno = layno0; layno < p_pocs->layno1 ; ++layno) {
+                                        /*index = step_r * resno + step_c * compno + step_l * layno;*/
+                                        packet_array[comp_index] = 1;
+                                        comp_index += step_l;
+                                }
+
+                                res_index += step_c;
+                        }
+
+                        index += step_r;
+                }
+
+                ++p_pocs;
+        }
+
+        index = 0;
+        for (layno = 0; layno < p_num_layers ; ++layno) {
+                for (resno = 0; resno < p_nb_resolutions; ++resno) {
+                        for (compno = 0; compno < p_num_comps; ++compno) {
+                                loss |= (packet_array[index]!=1);
+                                /*index = step_r * resno + step_c * compno + step_l * layno;*/
+                                index += step_c;
+                        }
+                }
+        }
+
+        if (loss) {
+                opj_event_msg(p_manager , EVT_ERROR, "Missing packets possible loss of data\n");
+        }
+
+        opj_free(packet_array);
+
+        return !loss;
+}
+
+/* ----------------------------------------------------------------------- */
+
+OPJ_UINT32 opj_j2k_get_num_tp(opj_cp_t *cp, OPJ_UINT32 pino, OPJ_UINT32 tileno)
+{
+        const OPJ_CHAR *prog = 00;
+        OPJ_INT32 i;
+        OPJ_UINT32 tpnum = 1;
+        opj_tcp_t *tcp = 00;
+        opj_poc_t * l_current_poc = 00;
+
+        /*  preconditions */
+        assert(tileno < (cp->tw * cp->th));
+        assert(pino < (cp->tcps[tileno].numpocs + 1));
+
+        /* get the given tile coding parameter */
+        tcp = &cp->tcps[tileno];
+        assert(tcp != 00);
+
+        l_current_poc = &(tcp->pocs[pino]);
+        assert(l_current_poc != 0);
+
+        /* get the progression order as a character string */
+        prog = opj_j2k_convert_progression_order(tcp->prg);
+        assert(strlen(prog) > 0);
+
+        if (cp->m_specific_param.m_enc.m_tp_on == 1) {
+                for (i=0;i<4;++i) {
+                        switch (prog[i])
+                        {
+                                /* component wise */
+                                case 'C':
+                                        tpnum *= l_current_poc->compE;
+                                        break;
+                                /* resolution wise */
+                                case 'R':
+                                        tpnum *= l_current_poc->resE;
+                                        break;
+                                /* precinct wise */
+                                case 'P':
+                                        tpnum *= l_current_poc->prcE;
+                                        break;
+                                /* layer wise */
+                                case 'L':
+                                        tpnum *= l_current_poc->layE;
+                                        break;
+                        }
+                        /* whould we split here ? */
+                        if ( cp->m_specific_param.m_enc.m_tp_flag == prog[i] ) {
+                                cp->m_specific_param.m_enc.m_tp_pos=i;
+                                break;
+                        }
+                }
+        }
+        else {
+                tpnum=1;
+        }
+
+        return tpnum;
+}
+
+OPJ_BOOL opj_j2k_calculate_tp(  opj_j2k_t *p_j2k,
+                                                        opj_cp_t *cp,
+                                                        OPJ_UINT32 * p_nb_tiles,
+                                                        opj_image_t *image,
+                                                        opj_event_mgr_t * p_manager
+                                )
+{
+        OPJ_UINT32 pino,tileno;
+        OPJ_UINT32 l_nb_tiles;
+        opj_tcp_t *tcp;
+
+        /* preconditions */
+        assert(p_nb_tiles != 00);
+        assert(cp != 00);
+        assert(image != 00);
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+
+        l_nb_tiles = cp->tw * cp->th;
+        * p_nb_tiles = 0;
+        tcp = cp->tcps;
+
+        /* INDEX >> */
+        /* TODO mergeV2: check this part which use cstr_info */
+        /*if (p_j2k->cstr_info) {
+                opj_tile_info_t * l_info_tile_ptr = p_j2k->cstr_info->tile;
+
+                for (tileno = 0; tileno < l_nb_tiles; ++tileno) {
+                        OPJ_UINT32 cur_totnum_tp = 0;
+
+                        opj_pi_update_encoding_parameters(image,cp,tileno);
+
+                        for (pino = 0; pino <= tcp->numpocs; ++pino)
+                        {
+                                OPJ_UINT32 tp_num = opj_j2k_get_num_tp(cp,pino,tileno);
+
+                                *p_nb_tiles = *p_nb_tiles + tp_num;
+
+                                cur_totnum_tp += tp_num;
+                        }
+
+                        tcp->m_nb_tile_parts = cur_totnum_tp;
+
+                        l_info_tile_ptr->tp = (opj_tp_info_t *) opj_malloc(cur_totnum_tp * sizeof(opj_tp_info_t));
+                        if (l_info_tile_ptr->tp == 00) {
+                                return OPJ_FALSE;
+                        }
+
+                        memset(l_info_tile_ptr->tp,0,cur_totnum_tp * sizeof(opj_tp_info_t));
+
+                        l_info_tile_ptr->num_tps = cur_totnum_tp;
+
+                        ++l_info_tile_ptr;
+                        ++tcp;
+                }
+        }
+        else */{
+                for (tileno = 0; tileno < l_nb_tiles; ++tileno) {
+                        OPJ_UINT32 cur_totnum_tp = 0;
+
+                        opj_pi_update_encoding_parameters(image,cp,tileno);
+
+                        for (pino = 0; pino <= tcp->numpocs; ++pino) {
+                                OPJ_UINT32 tp_num = opj_j2k_get_num_tp(cp,pino,tileno);
+
+                                *p_nb_tiles = *p_nb_tiles + tp_num;
+
+                                cur_totnum_tp += tp_num;
+                        }
+                        tcp->m_nb_tile_parts = cur_totnum_tp;
+
+                        ++tcp;
+                }
+        }
+
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_j2k_write_soc(     opj_j2k_t *p_j2k,
+                                                opj_stream_private_t *p_stream,
+                                                    opj_event_mgr_t * p_manager )
+{
+        /* 2 bytes will be written */
+        OPJ_BYTE * l_start_stream = 00;
+
+        /* preconditions */
+        assert(p_stream != 00);
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+
+        l_start_stream = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
+
+        /* write SOC identifier */
+        opj_write_bytes(l_start_stream,J2K_MS_SOC,2);
+
+        if (opj_stream_write_data(p_stream,l_start_stream,2,p_manager) != 2) {
+                return OPJ_FALSE;
+        }
+
+/* UniPG>> */
+#ifdef USE_JPWL
+        /* update markers struct */
+/*
+        OPJ_BOOL res = j2k_add_marker(p_j2k->cstr_info, J2K_MS_SOC, p_stream_tell(p_stream) - 2, 2);
+*/
+  assert( 0 && "TODO" );
+#endif /* USE_JPWL */
+/* <<UniPG */
+
+        return OPJ_TRUE;
+}
+
+/**
+ * Reads a SOC marker (Start of Codestream)
+ * @param       p_j2k           the jpeg2000 file codec.
+ * @param       p_stream        FIXME DOC
+ * @param       p_manager       the user event manager.
+*/
+static OPJ_BOOL opj_j2k_read_soc(   opj_j2k_t *p_j2k,
+                                    opj_stream_private_t *p_stream,
+                                    opj_event_mgr_t * p_manager
+                                    )
+{
+        OPJ_BYTE l_data [2];
+        OPJ_UINT32 l_marker;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_stream != 00);
+
+        if (opj_stream_read_data(p_stream,l_data,2,p_manager) != 2) {
+                return OPJ_FALSE;
+        }
+
+        opj_read_bytes(l_data,&l_marker,2);
+        if (l_marker != J2K_MS_SOC) {
+                return OPJ_FALSE;
+        }
+
+        /* Next marker should be a SIZ marker in the main header */
+        p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_MHSIZ;
+
+        /* FIXME move it in a index structure included in p_j2k*/
+        p_j2k->cstr_index->main_head_start = opj_stream_tell(p_stream) - 2;
+
+        opj_event_msg(p_manager, EVT_INFO, "Start to read j2k main header (%d).\n", p_j2k->cstr_index->main_head_start);
+
+        /* Add the marker to the codestream index*/
+        if (OPJ_FALSE == opj_j2k_add_mhmarker(p_j2k->cstr_index, J2K_MS_SOC, p_j2k->cstr_index->main_head_start, 2)) {
+                opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to add mh marker\n");
+                return OPJ_FALSE;
+        }
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_j2k_write_siz(     opj_j2k_t *p_j2k,
+                                                        opj_stream_private_t *p_stream,
+                                                        opj_event_mgr_t * p_manager )
+{
+        OPJ_UINT32 i;
+        OPJ_UINT32 l_size_len;
+        OPJ_BYTE * l_current_ptr;
+        opj_image_t * l_image = 00;
+        opj_cp_t *cp = 00;
+        opj_image_comp_t * l_img_comp = 00;
+
+        /* preconditions */
+        assert(p_stream != 00);
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+
+        l_image = p_j2k->m_private_image;
+        cp = &(p_j2k->m_cp);
+        l_size_len = 40 + 3 * l_image->numcomps;
+        l_img_comp = l_image->comps;
+
+        if (l_size_len > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
+
+                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_size_len);
+                if (! new_header_tile_data) {
+                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
+                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;
+                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;
+                        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory for the SIZ marker\n");
+                        return OPJ_FALSE;
+                }
+                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
+                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_size_len;
+        }
+
+        l_current_ptr = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
+
+        /* write SOC identifier */
+        opj_write_bytes(l_current_ptr,J2K_MS_SIZ,2);    /* SIZ */
+        l_current_ptr+=2;
+
+        opj_write_bytes(l_current_ptr,l_size_len-2,2); /* L_SIZ */
+        l_current_ptr+=2;
+
+        opj_write_bytes(l_current_ptr, cp->rsiz, 2);    /* Rsiz (capabilities) */
+        l_current_ptr+=2;
+
+        opj_write_bytes(l_current_ptr, l_image->x1, 4); /* Xsiz */
+        l_current_ptr+=4;
+
+        opj_write_bytes(l_current_ptr, l_image->y1, 4); /* Ysiz */
+        l_current_ptr+=4;
+
+        opj_write_bytes(l_current_ptr, l_image->x0, 4); /* X0siz */
+        l_current_ptr+=4;
+
+        opj_write_bytes(l_current_ptr, l_image->y0, 4); /* Y0siz */
+        l_current_ptr+=4;
+
+        opj_write_bytes(l_current_ptr, cp->tdx, 4);             /* XTsiz */
+        l_current_ptr+=4;
+
+        opj_write_bytes(l_current_ptr, cp->tdy, 4);             /* YTsiz */
+        l_current_ptr+=4;
+
+        opj_write_bytes(l_current_ptr, cp->tx0, 4);             /* XT0siz */
+        l_current_ptr+=4;
+
+        opj_write_bytes(l_current_ptr, cp->ty0, 4);             /* YT0siz */
+        l_current_ptr+=4;
+
+        opj_write_bytes(l_current_ptr, l_image->numcomps, 2);   /* Csiz */
+        l_current_ptr+=2;
+
+        for (i = 0; i < l_image->numcomps; ++i) {
+                /* TODO here with MCT ? */
+                opj_write_bytes(l_current_ptr, l_img_comp->prec - 1 + (l_img_comp->sgnd << 7), 1);      /* Ssiz_i */
+                ++l_current_ptr;
+
+                opj_write_bytes(l_current_ptr, l_img_comp->dx, 1);      /* XRsiz_i */
+                ++l_current_ptr;
+
+                opj_write_bytes(l_current_ptr, l_img_comp->dy, 1);      /* YRsiz_i */
+                ++l_current_ptr;
+
+                ++l_img_comp;
+        }
+
+        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_size_len,p_manager) != l_size_len) {
+                return OPJ_FALSE;
+        }
+
+        return OPJ_TRUE;
+}
+
+/**
+ * Reads a SIZ marker (image and tile size)
+ * @param       p_j2k           the jpeg2000 file codec.
+ * @param       p_header_data   the data contained in the SIZ box.
+ * @param       p_header_size   the size of the data contained in the SIZ marker.
+ * @param       p_manager       the user event manager.
+*/
+static OPJ_BOOL opj_j2k_read_siz(opj_j2k_t *p_j2k,
+                                 OPJ_BYTE * p_header_data,
+                                 OPJ_UINT32 p_header_size,
+                                 opj_event_mgr_t * p_manager
+                                 )
+{
+        OPJ_UINT32 i;
+        OPJ_UINT32 l_nb_comp;
+        OPJ_UINT32 l_nb_comp_remain;
+        OPJ_UINT32 l_remaining_size;
+        OPJ_UINT32 l_nb_tiles;
+        OPJ_UINT32 l_tmp;
+        opj_image_t *l_image = 00;
+        opj_cp_t *l_cp = 00;
+        opj_image_comp_t * l_img_comp = 00;
+        opj_tcp_t * l_current_tile_param = 00;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_header_data != 00);
+
+        l_image = p_j2k->m_private_image;
+        l_cp = &(p_j2k->m_cp);
+
+        /* minimum size == 39 - 3 (= minimum component parameter) */
+        if (p_header_size < 36) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error with SIZ marker size\n");
+                return OPJ_FALSE;
+        }
+
+        l_remaining_size = p_header_size - 36;
+        l_nb_comp = l_remaining_size / 3;
+        l_nb_comp_remain = l_remaining_size % 3;
+        if (l_nb_comp_remain != 0){
+                opj_event_msg(p_manager, EVT_ERROR, "Error with SIZ marker size\n");
+                return OPJ_FALSE;
+        }
+
+        opj_read_bytes(p_header_data,&l_tmp ,2);                                                /* Rsiz (capabilities) */
+        p_header_data+=2;
+        l_cp->rsiz = (OPJ_UINT16) l_tmp;
+        opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_image->x1, 4);   /* Xsiz */
+        p_header_data+=4;
+        opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_image->y1, 4);   /* Ysiz */
+        p_header_data+=4;
+        opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_image->x0, 4);   /* X0siz */
+        p_header_data+=4;
+        opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_image->y0, 4);   /* Y0siz */
+        p_header_data+=4;
+        opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_cp->tdx, 4);             /* XTsiz */
+        p_header_data+=4;
+        opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_cp->tdy, 4);             /* YTsiz */
+        p_header_data+=4;
+        opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_cp->tx0, 4);             /* XT0siz */
+        p_header_data+=4;
+        opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_cp->ty0, 4);             /* YT0siz */
+        p_header_data+=4;
+        opj_read_bytes(p_header_data, (OPJ_UINT32*) &l_tmp, 2);                 /* Csiz */
+        p_header_data+=2;
+        if (l_tmp < 16385)
+                l_image->numcomps = (OPJ_UINT16) l_tmp;
+        else {
+                opj_event_msg(p_manager, EVT_ERROR, "Error with SIZ marker: number of component is illegal -> %d\n", l_tmp);
+                return OPJ_FALSE;
+        }
+
+        if (l_image->numcomps != l_nb_comp) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error with SIZ marker: number of component is not compatible with the remaining number of parameters ( %d vs %d)\n", l_image->numcomps, l_nb_comp);
+                return OPJ_FALSE;
+        }
+
+        /* testcase 4035.pdf.SIGSEGV.d8b.3375 */
+        if (l_image->x0 > l_image->x1 || l_image->y0 > l_image->y1) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error with SIZ marker: negative image size (%d x %d)\n", l_image->x1 - l_image->x0, l_image->y1 - l_image->y0);
+                return OPJ_FALSE;
+        }
+        /* testcase 2539.pdf.SIGFPE.706.1712 (also 3622.pdf.SIGFPE.706.2916 and 4008.pdf.SIGFPE.706.3345 and maybe more) */
+        if (!(l_cp->tdx * l_cp->tdy)) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error with SIZ marker: invalid tile size (tdx: %d, tdy: %d)\n", l_cp->tdx, l_cp->tdy);
+                return OPJ_FALSE;
+        }
+
+        /* testcase 1610.pdf.SIGSEGV.59c.681 */
+        if (((OPJ_UINT64)l_image->x1) * ((OPJ_UINT64)l_image->y1) != (l_image->x1 * l_image->y1)) {
+                opj_event_msg(p_manager, EVT_ERROR, "Prevent buffer overflow (x1: %d, y1: %d)\n", l_image->x1, l_image->y1);
+                return OPJ_FALSE;
+        }
+
+#ifdef USE_JPWL
+        if (l_cp->correct) {
+                /* if JPWL is on, we check whether TX errors have damaged
+                  too much the SIZ parameters */
+                if (!(l_image->x1 * l_image->y1)) {
+                        opj_event_msg(p_manager, EVT_ERROR,
+                                "JPWL: bad image size (%d x %d)\n",
+                                l_image->x1, l_image->y1);
+                        if (!JPWL_ASSUME || JPWL_ASSUME) {
+                                opj_event_msg(p_manager, EVT_ERROR, "JPWL: giving up\n");
+                                return OPJ_FALSE;
+                        }
+                }
+
+        /* FIXME check previously in the function so why keep this piece of code ? Need by the norm ?
+                if (l_image->numcomps != ((len - 38) / 3)) {
+                        opj_event_msg(p_manager, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,
+                                "JPWL: Csiz is %d => space in SIZ only for %d comps.!!!\n",
+                                l_image->numcomps, ((len - 38) / 3));
+                        if (!JPWL_ASSUME) {
+                                opj_event_msg(p_manager, EVT_ERROR, "JPWL: giving up\n");
+                                return OPJ_FALSE;
+                        }
+        */              /* we try to correct */
+        /*              opj_event_msg(p_manager, EVT_WARNING, "- trying to adjust this\n");
+                        if (l_image->numcomps < ((len - 38) / 3)) {
+                                len = 38 + 3 * l_image->numcomps;
+                                opj_event_msg(p_manager, EVT_WARNING, "- setting Lsiz to %d => HYPOTHESIS!!!\n",
+                                        len);
+                        } else {
+                                l_image->numcomps = ((len - 38) / 3);
+                                opj_event_msg(p_manager, EVT_WARNING, "- setting Csiz to %d => HYPOTHESIS!!!\n",
+                                        l_image->numcomps);
+                        }
+                }
+        */
+
+                /* update components number in the jpwl_exp_comps filed */
+                l_cp->exp_comps = l_image->numcomps;
+        }
+#endif /* USE_JPWL */
+
+        /* Allocate the resulting image components */
+        l_image->comps = (opj_image_comp_t*) opj_calloc(l_image->numcomps, sizeof(opj_image_comp_t));
+        if (l_image->comps == 00){
+                l_image->numcomps = 0;
+                opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to take in charge SIZ marker\n");
+                return OPJ_FALSE;
+        }
+
+        memset(l_image->comps,0,l_image->numcomps * sizeof(opj_image_comp_t));
+        l_img_comp = l_image->comps;
+
+        /* Read the component information */
+        for (i = 0; i < l_image->numcomps; ++i){
+                OPJ_UINT32 tmp;
+                opj_read_bytes(p_header_data,&tmp,1);   /* Ssiz_i */
+                ++p_header_data;
+                l_img_comp->prec = (tmp & 0x7f) + 1;
+                l_img_comp->sgnd = tmp >> 7;
+                opj_read_bytes(p_header_data,&tmp,1);   /* XRsiz_i */
+                ++p_header_data;
+                l_img_comp->dx = (OPJ_UINT32)tmp; /* should be between 1 and 255 */
+                opj_read_bytes(p_header_data,&tmp,1);   /* YRsiz_i */
+                ++p_header_data;
+                l_img_comp->dy = (OPJ_UINT32)tmp; /* should be between 1 and 255 */
+                if( l_img_comp->dx < 1 || l_img_comp->dx > 255 ||
+                    l_img_comp->dy < 1 || l_img_comp->dy > 255 ) {
+                    opj_event_msg(p_manager, EVT_ERROR,
+                                  "Invalid values for comp = %d : dx=%u dy=%u\n (should be between 1 and 255 according the JPEG2000 norm)",
+                                  i, l_img_comp->dx, l_img_comp->dy);
+                    return OPJ_FALSE;
+                }
+
+#ifdef USE_JPWL
+                if (l_cp->correct) {
+                /* if JPWL is on, we check whether TX errors have damaged
+                        too much the SIZ parameters, again */
+                        if (!(l_image->comps[i].dx * l_image->comps[i].dy)) {
+                                opj_event_msg(p_manager, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,
+                                        "JPWL: bad XRsiz_%d/YRsiz_%d (%d x %d)\n",
+                                        i, i, l_image->comps[i].dx, l_image->comps[i].dy);
+                                if (!JPWL_ASSUME) {
+                                        opj_event_msg(p_manager, EVT_ERROR, "JPWL: giving up\n");
+                                        return OPJ_FALSE;
+                                }
+                                /* we try to correct */
+                                opj_event_msg(p_manager, EVT_WARNING, "- trying to adjust them\n");
+                                if (!l_image->comps[i].dx) {
+                                        l_image->comps[i].dx = 1;
+                                        opj_event_msg(p_manager, EVT_WARNING, "- setting XRsiz_%d to %d => HYPOTHESIS!!!\n",
+                                                i, l_image->comps[i].dx);
+                                }
+                                if (!l_image->comps[i].dy) {
+                                        l_image->comps[i].dy = 1;
+                                        opj_event_msg(p_manager, EVT_WARNING, "- setting YRsiz_%d to %d => HYPOTHESIS!!!\n",
+                                                i, l_image->comps[i].dy);
+                                }
+                        }
+                }
+#endif /* USE_JPWL */
+                l_img_comp->resno_decoded = 0;                                                          /* number of resolution decoded */
+                l_img_comp->factor = l_cp->m_specific_param.m_dec.m_reduce; /* reducing factor per component */
+                ++l_img_comp;
+        }
+
+        /* Compute the number of tiles */
+        l_cp->tw = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(l_image->x1 - l_cp->tx0), (OPJ_INT32)l_cp->tdx);
+        l_cp->th = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(l_image->y1 - l_cp->ty0), (OPJ_INT32)l_cp->tdy);
+
+        /* Check that the number of tiles is valid */
+        if (l_cp->tw == 0 || l_cp->th == 0 || l_cp->tw > 65535 / l_cp->th) {
+            opj_event_msg(  p_manager, EVT_ERROR, 
+                            "Invalid number of tiles : %u x %u (maximum fixed by jpeg2000 norm is 65535 tiles)\n",
+                            l_cp->tw, l_cp->th);
+            return OPJ_FALSE;
+        }
+        l_nb_tiles = l_cp->tw * l_cp->th;
+
+        /* Define the tiles which will be decoded */
+        if (p_j2k->m_specific_param.m_decoder.m_discard_tiles) {
+                p_j2k->m_specific_param.m_decoder.m_start_tile_x = (p_j2k->m_specific_param.m_decoder.m_start_tile_x - l_cp->tx0) / l_cp->tdx;
+                p_j2k->m_specific_param.m_decoder.m_start_tile_y = (p_j2k->m_specific_param.m_decoder.m_start_tile_y - l_cp->ty0) / l_cp->tdy;
+                p_j2k->m_specific_param.m_decoder.m_end_tile_x = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(p_j2k->m_specific_param.m_decoder.m_end_tile_x - l_cp->tx0), (OPJ_INT32)l_cp->tdx);
+                p_j2k->m_specific_param.m_decoder.m_end_tile_y = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(p_j2k->m_specific_param.m_decoder.m_end_tile_y - l_cp->ty0), (OPJ_INT32)l_cp->tdy);
+        }
+        else {
+                p_j2k->m_specific_param.m_decoder.m_start_tile_x = 0;
+                p_j2k->m_specific_param.m_decoder.m_start_tile_y = 0;
+                p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;
+                p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;
+        }
+
+#ifdef USE_JPWL
+        if (l_cp->correct) {
+                /* if JPWL is on, we check whether TX errors have damaged
+                  too much the SIZ parameters */
+                if ((l_cp->tw < 1) || (l_cp->th < 1) || (l_cp->tw > l_cp->max_tiles) || (l_cp->th > l_cp->max_tiles)) {
+                        opj_event_msg(p_manager, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,
+                                "JPWL: bad number of tiles (%d x %d)\n",
+                                l_cp->tw, l_cp->th);
+                        if (!JPWL_ASSUME) {
+                                opj_event_msg(p_manager, EVT_ERROR, "JPWL: giving up\n");
+                                return OPJ_FALSE;
+                        }
+                        /* we try to correct */
+                        opj_event_msg(p_manager, EVT_WARNING, "- trying to adjust them\n");
+                        if (l_cp->tw < 1) {
+                                l_cp->tw= 1;
+                                opj_event_msg(p_manager, EVT_WARNING, "- setting %d tiles in x => HYPOTHESIS!!!\n",
+                                                l_cp->tw);
+                        }
+                        if (l_cp->tw > l_cp->max_tiles) {
+                                l_cp->tw= 1;
+                                opj_event_msg(p_manager, EVT_WARNING, "- too large x, increase expectance of %d\n"
+                                        "- setting %d tiles in x => HYPOTHESIS!!!\n",
+                                        l_cp->max_tiles, l_cp->tw);
+                        }
+                        if (l_cp->th < 1) {
+                                l_cp->th= 1;
+                                opj_event_msg(p_manager, EVT_WARNING, "- setting %d tiles in y => HYPOTHESIS!!!\n",
+                                                l_cp->th);
+                        }
+                        if (l_cp->th > l_cp->max_tiles) {
+                                l_cp->th= 1;
+                                opj_event_msg(p_manager, EVT_WARNING, "- too large y, increase expectance of %d to continue\n",
+                                        "- setting %d tiles in y => HYPOTHESIS!!!\n",
+                                        l_cp->max_tiles, l_cp->th);
+                        }
+                }
+        }
+#endif /* USE_JPWL */
+
+        /* memory allocations */
+        l_cp->tcps = (opj_tcp_t*) opj_calloc(l_nb_tiles, sizeof(opj_tcp_t));
+        if (l_cp->tcps == 00) {
+                opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to take in charge SIZ marker\n");
+                return OPJ_FALSE;
+        }
+        memset(l_cp->tcps,0,l_nb_tiles*sizeof(opj_tcp_t));
+
+#ifdef USE_JPWL
+        if (l_cp->correct) {
+                if (!l_cp->tcps) {
+                        opj_event_msg(p_manager, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,
+                                "JPWL: could not alloc tcps field of cp\n");
+                        if (!JPWL_ASSUME || JPWL_ASSUME) {
+                                opj_event_msg(p_manager, EVT_ERROR, "JPWL: giving up\n");
+                                return OPJ_FALSE;
+                        }
+                }
+        }
+#endif /* USE_JPWL */
+
+        p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps =
+                        (opj_tccp_t*) opj_calloc(l_image->numcomps, sizeof(opj_tccp_t));
+        if(p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps  == 00) {
+                opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to take in charge SIZ marker\n");
+                return OPJ_FALSE;
+        }
+        memset(p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps ,0,l_image->numcomps*sizeof(opj_tccp_t));
+
+        p_j2k->m_specific_param.m_decoder.m_default_tcp->m_mct_records =
+                        (opj_mct_data_t*)opj_malloc(OPJ_J2K_MCT_DEFAULT_NB_RECORDS * sizeof(opj_mct_data_t));
+
+        if (! p_j2k->m_specific_param.m_decoder.m_default_tcp->m_mct_records) {
+                opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to take in charge SIZ marker\n");
+                return OPJ_FALSE;
+        }
+        memset(p_j2k->m_specific_param.m_decoder.m_default_tcp->m_mct_records,0,OPJ_J2K_MCT_DEFAULT_NB_RECORDS * sizeof(opj_mct_data_t));
+        p_j2k->m_specific_param.m_decoder.m_default_tcp->m_nb_max_mct_records = OPJ_J2K_MCT_DEFAULT_NB_RECORDS;
+
+        p_j2k->m_specific_param.m_decoder.m_default_tcp->m_mcc_records =
+                        (opj_simple_mcc_decorrelation_data_t*)
+                        opj_malloc(OPJ_J2K_MCC_DEFAULT_NB_RECORDS * sizeof(opj_simple_mcc_decorrelation_data_t));
+
+        if (! p_j2k->m_specific_param.m_decoder.m_default_tcp->m_mcc_records) {
+                opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to take in charge SIZ marker\n");
+                return OPJ_FALSE;
+        }
+        memset(p_j2k->m_specific_param.m_decoder.m_default_tcp->m_mcc_records,0,OPJ_J2K_MCC_DEFAULT_NB_RECORDS * sizeof(opj_simple_mcc_decorrelation_data_t));
+        p_j2k->m_specific_param.m_decoder.m_default_tcp->m_nb_max_mcc_records = OPJ_J2K_MCC_DEFAULT_NB_RECORDS;
+
+        /* set up default dc level shift */
+        for (i=0;i<l_image->numcomps;++i) {
+                if (! l_image->comps[i].sgnd) {
+                        p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps[i].m_dc_level_shift = 1 << (l_image->comps[i].prec - 1);
+                }
+        }
+
+        l_current_tile_param = l_cp->tcps;
+        for     (i = 0; i < l_nb_tiles; ++i) {
+                l_current_tile_param->tccps = (opj_tccp_t*) opj_malloc(l_image->numcomps * sizeof(opj_tccp_t));
+                if (l_current_tile_param->tccps == 00) {
+                        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to take in charge SIZ marker\n");
+                        return OPJ_FALSE;
+                }
+                memset(l_current_tile_param->tccps,0,l_image->numcomps * sizeof(opj_tccp_t));
+
+                ++l_current_tile_param;
+        }
+
+        p_j2k->m_specific_param.m_decoder.m_state =  J2K_STATE_MH; /* FIXME J2K_DEC_STATE_MH; */
+        opj_image_comp_header_update(l_image,l_cp);
+
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_j2k_write_com(     opj_j2k_t *p_j2k,
+                                                        opj_stream_private_t *p_stream,
+                                                        opj_event_mgr_t * p_manager
+                            )
+{
+        OPJ_UINT32 l_comment_size;
+        OPJ_UINT32 l_total_com_size;
+        const OPJ_CHAR *l_comment;
+        OPJ_BYTE * l_current_ptr = 00;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_stream != 00);
+        assert(p_manager != 00);
+
+        l_comment = p_j2k->m_cp.comment;
+        l_comment_size = (OPJ_UINT32)strlen(l_comment);
+        l_total_com_size = l_comment_size + 6;
+
+        if (l_total_com_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
+                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_total_com_size);
+                if (! new_header_tile_data) {
+                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
+                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;
+                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;
+                        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to write the COM marker\n");
+                        return OPJ_FALSE;
+                }
+                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
+                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_total_com_size;
+        }
+
+        l_current_ptr = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
+
+        opj_write_bytes(l_current_ptr,J2K_MS_COM , 2);  /* COM */
+        l_current_ptr+=2;
+
+        opj_write_bytes(l_current_ptr,l_total_com_size - 2 , 2);        /* L_COM */
+        l_current_ptr+=2;
+
+        opj_write_bytes(l_current_ptr,1 , 2);   /* General use (IS 8859-15:1999 (Latin) values) */
+        l_current_ptr+=2;
+
+        memcpy( l_current_ptr,l_comment,l_comment_size);
+
+        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_total_com_size,p_manager) != l_total_com_size) {
+                return OPJ_FALSE;
+        }
+
+        return OPJ_TRUE;
+}
+
+/**
+ * Reads a COM marker (comments)
+ * @param       p_j2k           the jpeg2000 file codec.
+ * @param       p_header_data   the data contained in the COM box.
+ * @param       p_header_size   the size of the data contained in the COM marker.
+ * @param       p_manager               the user event manager.
+*/
+static OPJ_BOOL opj_j2k_read_com (  opj_j2k_t *p_j2k,
+                                    OPJ_BYTE * p_header_data,
+                                    OPJ_UINT32 p_header_size,
+                                    opj_event_mgr_t * p_manager
+                                    )
+{
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_header_data != 00);
+  (void)p_header_size;
+
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_j2k_write_cod(     opj_j2k_t *p_j2k,
+                                                        opj_stream_private_t *p_stream,
+                                                        opj_event_mgr_t * p_manager )
+{
+        opj_cp_t *l_cp = 00;
+        opj_tcp_t *l_tcp = 00;
+        OPJ_UINT32 l_code_size,l_remaining_size;
+        OPJ_BYTE * l_current_data = 00;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_stream != 00);
+
+        l_cp = &(p_j2k->m_cp);
+        l_tcp = &l_cp->tcps[p_j2k->m_current_tile_number];
+        l_code_size = 9 + opj_j2k_get_SPCod_SPCoc_size(p_j2k,p_j2k->m_current_tile_number,0);
+        l_remaining_size = l_code_size;
+
+        if (l_code_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
+                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_code_size);
+                if (! new_header_tile_data) {
+                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
+                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;
+                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;
+                        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to write COD marker\n");
+                        return OPJ_FALSE;
+                }
+                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
+                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_code_size;
+        }
+
+        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
+
+        opj_write_bytes(l_current_data,J2K_MS_COD,2);           /* COD */
+        l_current_data += 2;
+
+        opj_write_bytes(l_current_data,l_code_size-2,2);        /* L_COD */
+        l_current_data += 2;
+
+        opj_write_bytes(l_current_data,l_tcp->csty,1);          /* Scod */
+        ++l_current_data;
+
+        opj_write_bytes(l_current_data,l_tcp->prg,1);           /* SGcod (A) */
+        ++l_current_data;
+
+        opj_write_bytes(l_current_data,l_tcp->numlayers,2);     /* SGcod (B) */
+        l_current_data+=2;
+
+        opj_write_bytes(l_current_data,l_tcp->mct,1);           /* SGcod (C) */
+        ++l_current_data;
+
+        l_remaining_size -= 9;
+
+        if (! opj_j2k_write_SPCod_SPCoc(p_j2k,p_j2k->m_current_tile_number,0,l_current_data,&l_remaining_size,p_manager)) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error writing COD marker\n");
+                return OPJ_FALSE;
+        }
+
+        if (l_remaining_size != 0) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error writing COD marker\n");
+                return OPJ_FALSE;
+        }
+
+        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_code_size,p_manager) != l_code_size) {
+                return OPJ_FALSE;
+        }
+
+        return OPJ_TRUE;
+}
+
+/**
+ * Reads a COD marker (Coding Styke defaults)
+ * @param       p_header_data   the data contained in the COD box.
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_header_size   the size of the data contained in the COD marker.
+ * @param       p_manager               the user event manager.
+*/
+static OPJ_BOOL opj_j2k_read_cod (  opj_j2k_t *p_j2k,
+                                    OPJ_BYTE * p_header_data,
+                                    OPJ_UINT32 p_header_size,
+                                    opj_event_mgr_t * p_manager
+                                    )
+{
+        /* loop */
+        OPJ_UINT32 i;
+        OPJ_UINT32 l_tmp;
+        opj_cp_t *l_cp = 00;
+        opj_tcp_t *l_tcp = 00;
+        opj_image_t *l_image = 00;
+
+        /* preconditions */
+        assert(p_header_data != 00);
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+
+        l_image = p_j2k->m_private_image;
+        l_cp = &(p_j2k->m_cp);
+
+        /* If we are in the first tile-part header of the current tile */
+        l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ?
+                                &l_cp->tcps[p_j2k->m_current_tile_number] :
+                                p_j2k->m_specific_param.m_decoder.m_default_tcp;
+
+        /* Make sure room is sufficient */
+        if (p_header_size < 5) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading COD marker\n");
+                return OPJ_FALSE;
+        }
+
+        opj_read_bytes(p_header_data,&l_tcp->csty,1);           /* Scod */
+        ++p_header_data;
+        opj_read_bytes(p_header_data,&l_tmp,1);                         /* SGcod (A) */
+        ++p_header_data;
+        l_tcp->prg = (OPJ_PROG_ORDER) l_tmp;
+        opj_read_bytes(p_header_data,&l_tcp->numlayers,2);      /* SGcod (B) */
+        p_header_data+=2;
+
+        /* If user didn't set a number layer to decode take the max specify in the codestream. */
+        if      (l_cp->m_specific_param.m_dec.m_layer) {
+                l_tcp->num_layers_to_decode = l_cp->m_specific_param.m_dec.m_layer;
+        }
+        else {
+                l_tcp->num_layers_to_decode = l_tcp->numlayers;
+        }
+
+        opj_read_bytes(p_header_data,&l_tcp->mct,1);            /* SGcod (C) */
+        ++p_header_data;
+
+        p_header_size -= 5;
+        for     (i = 0; i < l_image->numcomps; ++i) {
+                l_tcp->tccps[i].csty = l_tcp->csty & J2K_CCP_CSTY_PRT;
+        }
+
+        if (! opj_j2k_read_SPCod_SPCoc(p_j2k,0,p_header_data,&p_header_size,p_manager)) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading COD marker\n");
+                return OPJ_FALSE;
+        }
+
+        if (p_header_size != 0) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading COD marker\n");
+                return OPJ_FALSE;
+        }
+
+        /* Apply the coding style to other components of the current tile or the m_default_tcp*/
+        opj_j2k_copy_tile_component_parameters(p_j2k);
+
+        /* Index */
+#ifdef WIP_REMOVE_MSD
+        if (p_j2k->cstr_info) {
+                /*opj_codestream_info_t *l_cstr_info = p_j2k->cstr_info;*/
+                p_j2k->cstr_info->prog = l_tcp->prg;
+                p_j2k->cstr_info->numlayers = l_tcp->numlayers;
+                p_j2k->cstr_info->numdecompos = (OPJ_INT32*) opj_malloc(l_image->numcomps * sizeof(OPJ_UINT32));
+                for     (i = 0; i < l_image->numcomps; ++i) {
+                        p_j2k->cstr_info->numdecompos[i] = l_tcp->tccps[i].numresolutions - 1;
+                }
+        }
+#endif
+
+        return OPJ_TRUE;
+}
+
+#if 0
+OPJ_BOOL opj_j2k_write_coc( opj_j2k_t *p_j2k,
+                                                OPJ_UINT32 p_comp_no,
+                                                opj_stream_private_t *p_stream,
+                                                opj_event_mgr_t * p_manager )
+{
+        OPJ_UINT32 l_coc_size,l_remaining_size;
+        OPJ_UINT32 l_comp_room;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_stream != 00);
+
+        l_comp_room = (p_j2k->m_private_image->numcomps <= 256) ? 1 : 2;
+
+        l_coc_size = 5 + l_comp_room + opj_j2k_get_SPCod_SPCoc_size(p_j2k,p_j2k->m_current_tile_number,p_comp_no);
+
+        if (l_coc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
+                OPJ_BYTE *new_header_tile_data;
+                /*p_j2k->m_specific_param.m_encoder.m_header_tile_data
+                        = (OPJ_BYTE*)opj_realloc(
+                                p_j2k->m_specific_param.m_encoder.m_header_tile_data,
+                                l_coc_size);*/
+
+                new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_coc_size);
+                if (! new_header_tile_data) {
+                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
+                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;
+                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;
+                        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to write COC marker\n");
+                        return OPJ_FALSE;
+                }
+                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
+                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_coc_size;
+        }
+
+        opj_j2k_write_coc_in_memory(p_j2k,p_comp_no,p_j2k->m_specific_param.m_encoder.m_header_tile_data,&l_remaining_size,p_manager);
+
+        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_coc_size,p_manager) != l_coc_size) {
+                return OPJ_FALSE;
+        }
+
+        return OPJ_TRUE;
+}
+#endif
+
+#if 0
+void opj_j2k_write_coc_in_memory(   opj_j2k_t *p_j2k,
+                                                OPJ_UINT32 p_comp_no,
+                                                OPJ_BYTE * p_data,
+                                                OPJ_UINT32 * p_data_written,
+                                                opj_event_mgr_t * p_manager
+                                    )
+{
+        opj_cp_t *l_cp = 00;
+        opj_tcp_t *l_tcp = 00;
+        OPJ_UINT32 l_coc_size,l_remaining_size;
+        OPJ_BYTE * l_current_data = 00;
+        opj_image_t *l_image = 00;
+        OPJ_UINT32 l_comp_room;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+
+        l_cp = &(p_j2k->m_cp);
+        l_tcp = &l_cp->tcps[p_j2k->m_current_tile_number];
+        l_image = p_j2k->m_private_image;
+        l_comp_room = (l_image->numcomps <= 256) ? 1 : 2;
+
+        l_coc_size = 5 + l_comp_room + opj_j2k_get_SPCod_SPCoc_size(p_j2k,p_j2k->m_current_tile_number,p_comp_no);
+        l_remaining_size = l_coc_size;
+
+        l_current_data = p_data;
+
+        opj_write_bytes(l_current_data,J2K_MS_COC,2);                           /* COC */
+        l_current_data += 2;
+
+        opj_write_bytes(l_current_data,l_coc_size-2,2);                         /* L_COC */
+        l_current_data += 2;
+
+        opj_write_bytes(l_current_data,p_comp_no, l_comp_room);         /* Ccoc */
+        l_current_data+=l_comp_room;
+
+        opj_write_bytes(l_current_data, l_tcp->tccps[p_comp_no].csty, 1);               /* Scoc */
+        ++l_current_data;
+
+        l_remaining_size -= (5 + l_comp_room);
+        opj_j2k_write_SPCod_SPCoc(p_j2k,p_j2k->m_current_tile_number,0,l_current_data,&l_remaining_size,p_manager);
+        * p_data_written = l_coc_size;
+}
+#endif
+
+OPJ_UINT32 opj_j2k_get_max_coc_size(opj_j2k_t *p_j2k)
+{
+        OPJ_UINT32 i,j;
+        OPJ_UINT32 l_nb_comp;
+        OPJ_UINT32 l_nb_tiles;
+        OPJ_UINT32 l_max = 0;
+
+        /* preconditions */
+
+        l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th ;
+        l_nb_comp = p_j2k->m_private_image->numcomps;
+
+        for (i=0;i<l_nb_tiles;++i) {
+                for (j=0;j<l_nb_comp;++j) {
+                        l_max = opj_uint_max(l_max,opj_j2k_get_SPCod_SPCoc_size(p_j2k,i,j));
+                }
+        }
+
+        return 6 + l_max;
+}
+
+/**
+ * Reads a COC marker (Coding Style Component)
+ * @param       p_header_data   the data contained in the COC box.
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_header_size   the size of the data contained in the COC marker.
+ * @param       p_manager               the user event manager.
+*/
+static OPJ_BOOL opj_j2k_read_coc (  opj_j2k_t *p_j2k,
+                                    OPJ_BYTE * p_header_data,
+                                    OPJ_UINT32 p_header_size,
+                                    opj_event_mgr_t * p_manager
+                                    )
+{
+        opj_cp_t *l_cp = NULL;
+        opj_tcp_t *l_tcp = NULL;
+        opj_image_t *l_image = NULL;
+        OPJ_UINT32 l_comp_room;
+        OPJ_UINT32 l_comp_no;
+
+        /* preconditions */
+        assert(p_header_data != 00);
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+
+        l_cp = &(p_j2k->m_cp);
+        l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH ) ? /*FIXME J2K_DEC_STATE_TPH*/
+                                &l_cp->tcps[p_j2k->m_current_tile_number] :
+                                p_j2k->m_specific_param.m_decoder.m_default_tcp;
+        l_image = p_j2k->m_private_image;
+
+        l_comp_room = l_image->numcomps <= 256 ? 1 : 2;
+
+        /* make sure room is sufficient*/
+        if (p_header_size < l_comp_room + 1) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading COC marker\n");
+                return OPJ_FALSE;
+        }
+        p_header_size -= l_comp_room + 1;
+
+        opj_read_bytes(p_header_data,&l_comp_no,l_comp_room);                   /* Ccoc */
+        p_header_data += l_comp_room;
+        if (l_comp_no >= l_image->numcomps) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading COC marker (bad number of components)\n");
+                return OPJ_FALSE;
+        }
+
+        opj_read_bytes(p_header_data,&l_tcp->tccps[l_comp_no].csty,1);                  /* Scoc */
+        ++p_header_data ;
+
+        if (! opj_j2k_read_SPCod_SPCoc(p_j2k,l_comp_no,p_header_data,&p_header_size,p_manager)) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading COC marker\n");
+                return OPJ_FALSE;
+        }
+
+        if (p_header_size != 0) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading COC marker\n");
+                return OPJ_FALSE;
+        }
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_j2k_write_qcd(     opj_j2k_t *p_j2k,
+                                                        opj_stream_private_t *p_stream,
+                                                        opj_event_mgr_t * p_manager
+                            )
+{
+        OPJ_UINT32 l_qcd_size,l_remaining_size;
+        OPJ_BYTE * l_current_data = 00;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_stream != 00);
+
+        l_qcd_size = 4 + opj_j2k_get_SQcd_SQcc_size(p_j2k,p_j2k->m_current_tile_number,0);
+        l_remaining_size = l_qcd_size;
+
+        if (l_qcd_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
+                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_qcd_size);
+                if (! new_header_tile_data) {
+                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
+                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;
+                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;
+                        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to write QCD marker\n");
+                        return OPJ_FALSE;
+                }
+                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
+                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_qcd_size;
+        }
+
+        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
+
+        opj_write_bytes(l_current_data,J2K_MS_QCD,2);           /* QCD */
+        l_current_data += 2;
+
+        opj_write_bytes(l_current_data,l_qcd_size-2,2);         /* L_QCD */
+        l_current_data += 2;
+
+        l_remaining_size -= 4;
+
+        if (! opj_j2k_write_SQcd_SQcc(p_j2k,p_j2k->m_current_tile_number,0,l_current_data,&l_remaining_size,p_manager)) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error writing QCD marker\n");
+                return OPJ_FALSE;
+        }
+
+        if (l_remaining_size != 0) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error writing QCD marker\n");
+                return OPJ_FALSE;
+        }
+
+        if (opj_stream_write_data(p_stream, p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_qcd_size,p_manager) != l_qcd_size) {
+                return OPJ_FALSE;
+        }
+
+        return OPJ_TRUE;
+}
+
+/**
+ * Reads a QCD marker (Quantization defaults)
+ * @param       p_header_data   the data contained in the QCD box.
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_header_size   the size of the data contained in the QCD marker.
+ * @param       p_manager               the user event manager.
+*/
+static OPJ_BOOL opj_j2k_read_qcd (  opj_j2k_t *p_j2k,
+                                    OPJ_BYTE * p_header_data,
+                                    OPJ_UINT32 p_header_size,
+                                    opj_event_mgr_t * p_manager
+                                    )
+{
+        /* preconditions */
+        assert(p_header_data != 00);
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+
+        if (! opj_j2k_read_SQcd_SQcc(p_j2k,0,p_header_data,&p_header_size,p_manager)) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading QCD marker\n");
+                return OPJ_FALSE;
+        }
+
+        if (p_header_size != 0) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading QCD marker\n");
+                return OPJ_FALSE;
+        }
+
+        /* Apply the quantization parameters to other components of the current tile or the m_default_tcp */
+        opj_j2k_copy_tile_quantization_parameters(p_j2k);
+
+        return OPJ_TRUE;
+}
+
+#if 0
+OPJ_BOOL opj_j2k_write_qcc(     opj_j2k_t *p_j2k,
+                                                OPJ_UINT32 p_comp_no,
+                                                opj_stream_private_t *p_stream,
+                                                opj_event_mgr_t * p_manager
+                            )
+{
+        OPJ_UINT32 l_qcc_size,l_remaining_size;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_stream != 00);
+
+        l_qcc_size = 5 + opj_j2k_get_SQcd_SQcc_size(p_j2k,p_j2k->m_current_tile_number,p_comp_no);
+        l_qcc_size += p_j2k->m_private_image->numcomps <= 256 ? 0:1;
+        l_remaining_size = l_qcc_size;
+
+        if (l_qcc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
+                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_qcc_size);
+                if (! new_header_tile_data) {
+                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
+                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;
+                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;
+                        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to write QCC marker\n");
+                        return OPJ_FALSE;
+                }
+                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
+                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_qcc_size;
+        }
+
+        opj_j2k_write_qcc_in_memory(p_j2k,p_comp_no,p_j2k->m_specific_param.m_encoder.m_header_tile_data,&l_remaining_size,p_manager);
+
+        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_qcc_size,p_manager) != l_qcc_size) {
+                return OPJ_FALSE;
+        }
+
+        return OPJ_TRUE;
+}
+#endif
+
+#if 0
+void opj_j2k_write_qcc_in_memory(   opj_j2k_t *p_j2k,
+                                                                OPJ_UINT32 p_comp_no,
+                                                                OPJ_BYTE * p_data,
+                                                                OPJ_UINT32 * p_data_written,
+                                                                opj_event_mgr_t * p_manager
+                                    )
+{
+        OPJ_UINT32 l_qcc_size,l_remaining_size;
+        OPJ_BYTE * l_current_data = 00;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+
+        l_qcc_size = 6 + opj_j2k_get_SQcd_SQcc_size(p_j2k,p_j2k->m_current_tile_number,p_comp_no);
+        l_remaining_size = l_qcc_size;
+
+        l_current_data = p_data;
+
+        opj_write_bytes(l_current_data,J2K_MS_QCC,2);           /* QCC */
+        l_current_data += 2;
+
+        if (p_j2k->m_private_image->numcomps <= 256) {
+                --l_qcc_size;
+
+                opj_write_bytes(l_current_data,l_qcc_size-2,2);         /* L_QCC */
+                l_current_data += 2;
+
+                opj_write_bytes(l_current_data, p_comp_no, 1);  /* Cqcc */
+                ++l_current_data;
+
+                /* in the case only one byte is sufficient the last byte allocated is useless -> still do -6 for available */
+                l_remaining_size -= 6;
+        }
+        else {
+                opj_write_bytes(l_current_data,l_qcc_size-2,2);         /* L_QCC */
+                l_current_data += 2;
+
+                opj_write_bytes(l_current_data, p_comp_no, 2);  /* Cqcc */
+                l_current_data+=2;
+
+                l_remaining_size -= 6;
+        }
+
+        opj_j2k_write_SQcd_SQcc(p_j2k,p_j2k->m_current_tile_number,p_comp_no,l_current_data,&l_remaining_size,p_manager);
+
+        *p_data_written = l_qcc_size;
+}
+#endif
+
+OPJ_UINT32 opj_j2k_get_max_qcc_size (opj_j2k_t *p_j2k)
+{
+        return opj_j2k_get_max_coc_size(p_j2k);
+}
+
+/**
+ * Reads a QCC marker (Quantization component)
+ * @param       p_header_data   the data contained in the QCC box.
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_header_size   the size of the data contained in the QCC marker.
+ * @param       p_manager               the user event manager.
+*/
+static OPJ_BOOL opj_j2k_read_qcc(   opj_j2k_t *p_j2k,
+                                    OPJ_BYTE * p_header_data,
+                                    OPJ_UINT32 p_header_size,
+                                    opj_event_mgr_t * p_manager
+                                    )
+{
+        OPJ_UINT32 l_num_comp,l_comp_no;
+
+        /* preconditions */
+        assert(p_header_data != 00);
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+
+        l_num_comp = p_j2k->m_private_image->numcomps;
+
+        if (l_num_comp <= 256) {
+                if (p_header_size < 1) {
+                        opj_event_msg(p_manager, EVT_ERROR, "Error reading QCC marker\n");
+                        return OPJ_FALSE;
+                }
+                opj_read_bytes(p_header_data,&l_comp_no,1);
+                ++p_header_data;
+                --p_header_size;
+        }
+        else {
+                if (p_header_size < 2) {
+                        opj_event_msg(p_manager, EVT_ERROR, "Error reading QCC marker\n");
+                        return OPJ_FALSE;
+                }
+                opj_read_bytes(p_header_data,&l_comp_no,2);
+                p_header_data+=2;
+                p_header_size-=2;
+        }
+
+#ifdef USE_JPWL
+        if (p_j2k->m_cp.correct) {
+
+                static OPJ_UINT32 backup_compno = 0;
+
+                /* compno is negative or larger than the number of components!!! */
+                if (/*(l_comp_no < 0) ||*/ (l_comp_no >= l_num_comp)) {
+                        opj_event_msg(p_manager, EVT_ERROR,
+                                "JPWL: bad component number in QCC (%d out of a maximum of %d)\n",
+                                l_comp_no, l_num_comp);
+                        if (!JPWL_ASSUME) {
+                                opj_event_msg(p_manager, EVT_ERROR, "JPWL: giving up\n");
+                                return OPJ_FALSE;
+                        }
+                        /* we try to correct */
+                        l_comp_no = backup_compno % l_num_comp;
+                        opj_event_msg(p_manager, EVT_WARNING, "- trying to adjust this\n"
+                                "- setting component number to %d\n",
+                                l_comp_no);
+                }
+
+                /* keep your private count of tiles */
+                backup_compno++;
+        };
+#endif /* USE_JPWL */
+
+        if (l_comp_no >= p_j2k->m_private_image->numcomps) {
+                opj_event_msg(p_manager, EVT_ERROR,
+                              "Invalid component number: %d, regarding the number of components %d\n",
+                              l_comp_no, p_j2k->m_private_image->numcomps);
+                return OPJ_FALSE;
+        }
+
+        if (! opj_j2k_read_SQcd_SQcc(p_j2k,l_comp_no,p_header_data,&p_header_size,p_manager)) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading QCC marker\n");
+                return OPJ_FALSE;
+        }
+
+        if (p_header_size != 0) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading QCC marker\n");
+                return OPJ_FALSE;
+        }
+
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_j2k_write_poc(     opj_j2k_t *p_j2k,
+                                                        opj_stream_private_t *p_stream,
+                                                        opj_event_mgr_t * p_manager
+                            )
+{
+        OPJ_UINT32 l_nb_comp;
+        OPJ_UINT32 l_nb_poc;
+        OPJ_UINT32 l_poc_size;
+        OPJ_UINT32 l_written_size = 0;
+        opj_tcp_t *l_tcp = 00;
+        OPJ_UINT32 l_poc_room;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_stream != 00);
+
+        l_tcp = &p_j2k->m_cp.tcps[p_j2k->m_current_tile_number];
+        l_nb_comp = p_j2k->m_private_image->numcomps;
+        l_nb_poc = 1 + l_tcp->numpocs;
+
+        if (l_nb_comp <= 256) {
+                l_poc_room = 1;
+        }
+        else {
+                l_poc_room = 2;
+        }
+        l_poc_size = 4 + (5 + 2 * l_poc_room) * l_nb_poc;
+
+        if (l_poc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
+                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_poc_size);
+                if (! new_header_tile_data) {
+                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
+                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;
+                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;
+                        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to write POC marker\n");
+                        return OPJ_FALSE;
+                }
+                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
+                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_poc_size;
+        }
+
+        opj_j2k_write_poc_in_memory(p_j2k,p_j2k->m_specific_param.m_encoder.m_header_tile_data,&l_written_size,p_manager);
+
+        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_poc_size,p_manager) != l_poc_size) {
+                return OPJ_FALSE;
+        }
+
+        return OPJ_TRUE;
+}
+
+void opj_j2k_write_poc_in_memory(   opj_j2k_t *p_j2k,
+                                                                OPJ_BYTE * p_data,
+                                                                OPJ_UINT32 * p_data_written,
+                                                                opj_event_mgr_t * p_manager
+                                    )
+{
+        OPJ_UINT32 i;
+        OPJ_BYTE * l_current_data = 00;
+        OPJ_UINT32 l_nb_comp;
+        OPJ_UINT32 l_nb_poc;
+        OPJ_UINT32 l_poc_size;
+        opj_image_t *l_image = 00;
+        opj_tcp_t *l_tcp = 00;
+        opj_tccp_t *l_tccp = 00;
+        opj_poc_t *l_current_poc = 00;
+        OPJ_UINT32 l_poc_room;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+
+        l_tcp = &p_j2k->m_cp.tcps[p_j2k->m_current_tile_number];
+        l_tccp = &l_tcp->tccps[0];
+        l_image = p_j2k->m_private_image;
+        l_nb_comp = l_image->numcomps;
+        l_nb_poc = 1 + l_tcp->numpocs;
+
+        if (l_nb_comp <= 256) {
+                l_poc_room = 1;
+        }
+        else {
+                l_poc_room = 2;
+        }
+
+        l_poc_size = 4 + (5 + 2 * l_poc_room) * l_nb_poc;
+
+        l_current_data = p_data;
+
+        opj_write_bytes(l_current_data,J2K_MS_POC,2);                                   /* POC  */
+        l_current_data += 2;
+
+        opj_write_bytes(l_current_data,l_poc_size-2,2);                                 /* Lpoc */
+        l_current_data += 2;
+
+        l_current_poc =  l_tcp->pocs;
+        for (i = 0; i < l_nb_poc; ++i) {
+                opj_write_bytes(l_current_data,l_current_poc->resno0,1);                                /* RSpoc_i */
+                ++l_current_data;
+
+                opj_write_bytes(l_current_data,l_current_poc->compno0,l_poc_room);              /* CSpoc_i */
+                l_current_data+=l_poc_room;
+
+                opj_write_bytes(l_current_data,l_current_poc->layno1,2);                                /* LYEpoc_i */
+                l_current_data+=2;
+
+                opj_write_bytes(l_current_data,l_current_poc->resno1,1);                                /* REpoc_i */
+                ++l_current_data;
+
+                opj_write_bytes(l_current_data,l_current_poc->compno1,l_poc_room);              /* CEpoc_i */
+                l_current_data+=l_poc_room;
+
+                opj_write_bytes(l_current_data,l_current_poc->prg,1);                                   /* Ppoc_i */
+                ++l_current_data;
+
+                /* change the value of the max layer according to the actual number of layers in the file, components and resolutions*/
+                l_current_poc->layno1 = (OPJ_UINT32)opj_int_min((OPJ_INT32)l_current_poc->layno1, (OPJ_INT32)l_tcp->numlayers);
+                l_current_poc->resno1 = (OPJ_UINT32)opj_int_min((OPJ_INT32)l_current_poc->resno1, (OPJ_INT32)l_tccp->numresolutions);
+                l_current_poc->compno1 = (OPJ_UINT32)opj_int_min((OPJ_INT32)l_current_poc->compno1, (OPJ_INT32)l_nb_comp);
+
+                ++l_current_poc;
+        }
+
+        *p_data_written = l_poc_size;
+}
+
+OPJ_UINT32 opj_j2k_get_max_poc_size(opj_j2k_t *p_j2k)
+{
+        opj_tcp_t * l_tcp = 00;
+        OPJ_UINT32 l_nb_tiles = 0;
+        OPJ_UINT32 l_max_poc = 0;
+        OPJ_UINT32 i;
+
+        l_tcp = p_j2k->m_cp.tcps;
+        l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
+
+        for (i=0;i<l_nb_tiles;++i) {
+                l_max_poc = opj_uint_max(l_max_poc,l_tcp->numpocs);
+                ++l_tcp;
+        }
+
+        ++l_max_poc;
+
+        return 4 + 9 * l_max_poc;
+}
+
+OPJ_UINT32 opj_j2k_get_max_toc_size (opj_j2k_t *p_j2k)
+{
+        OPJ_UINT32 i;
+        OPJ_UINT32 l_nb_tiles;
+        OPJ_UINT32 l_max = 0;
+        opj_tcp_t * l_tcp = 00;
+
+        l_tcp = p_j2k->m_cp.tcps;
+        l_nb_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th ;
+
+        for (i=0;i<l_nb_tiles;++i) {
+                l_max = opj_uint_max(l_max,l_tcp->m_nb_tile_parts);
+
+                ++l_tcp;
+        }
+
+        return 12 * l_max;
+}
+
+OPJ_UINT32 opj_j2k_get_specific_header_sizes(opj_j2k_t *p_j2k)
+{
+        OPJ_UINT32 l_nb_bytes = 0;
+        OPJ_UINT32 l_nb_comps;
+        OPJ_UINT32 l_coc_bytes,l_qcc_bytes;
+
+        l_nb_comps = p_j2k->m_private_image->numcomps - 1;
+        l_nb_bytes += opj_j2k_get_max_toc_size(p_j2k);
+
+        if (!(OPJ_IS_CINEMA(p_j2k->m_cp.rsiz))) {
+                l_coc_bytes = opj_j2k_get_max_coc_size(p_j2k);
+                l_nb_bytes += l_nb_comps * l_coc_bytes;
+
+                l_qcc_bytes = opj_j2k_get_max_qcc_size(p_j2k);
+                l_nb_bytes += l_nb_comps * l_qcc_bytes;
+        }
+
+        l_nb_bytes += opj_j2k_get_max_poc_size(p_j2k);
+
+        /*** DEVELOPER CORNER, Add room for your headers ***/
+
+        return l_nb_bytes;
+}
+
+/**
+ * Reads a POC marker (Progression Order Change)
+ *
+ * @param       p_header_data   the data contained in the POC box.
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_header_size   the size of the data contained in the POC marker.
+ * @param       p_manager               the user event manager.
+*/
+static OPJ_BOOL opj_j2k_read_poc (  opj_j2k_t *p_j2k,
+                                    OPJ_BYTE * p_header_data,
+                                    OPJ_UINT32 p_header_size,
+                                    opj_event_mgr_t * p_manager
+                                    )
+{
+        OPJ_UINT32 i, l_nb_comp, l_tmp;
+        opj_image_t * l_image = 00;
+        OPJ_UINT32 l_old_poc_nb, l_current_poc_nb, l_current_poc_remaining;
+        OPJ_UINT32 l_chunk_size, l_comp_room;
+
+        opj_cp_t *l_cp = 00;
+        opj_tcp_t *l_tcp = 00;
+        opj_poc_t *l_current_poc = 00;
+
+        /* preconditions */
+        assert(p_header_data != 00);
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+
+        l_image = p_j2k->m_private_image;
+        l_nb_comp = l_image->numcomps;
+        if (l_nb_comp <= 256) {
+                l_comp_room = 1;
+        }
+        else {
+                l_comp_room = 2;
+        }
+        l_chunk_size = 5 + 2 * l_comp_room;
+        l_current_poc_nb = p_header_size / l_chunk_size;
+        l_current_poc_remaining = p_header_size % l_chunk_size;
+
+        if ((l_current_poc_nb <= 0) || (l_current_poc_remaining != 0)) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading POC marker\n");
+                return OPJ_FALSE;
+        }
+
+        l_cp = &(p_j2k->m_cp);
+        l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ?
+                                &l_cp->tcps[p_j2k->m_current_tile_number] :
+                                p_j2k->m_specific_param.m_decoder.m_default_tcp;
+        l_old_poc_nb = l_tcp->POC ? l_tcp->numpocs + 1 : 0;
+        l_current_poc_nb += l_old_poc_nb;
+
+        if(l_current_poc_nb >= 32)
+          {
+          opj_event_msg(p_manager, EVT_ERROR, "Too many POCs %d\n", l_current_poc_nb);
+          return OPJ_FALSE;
+          }
+        assert(l_current_poc_nb < 32);
+
+        /* now poc is in use.*/
+        l_tcp->POC = 1;
+
+        l_current_poc = &l_tcp->pocs[l_old_poc_nb];
+        for     (i = l_old_poc_nb; i < l_current_poc_nb; ++i) {
+                opj_read_bytes(p_header_data,&(l_current_poc->resno0),1);                               /* RSpoc_i */
+                ++p_header_data;
+                opj_read_bytes(p_header_data,&(l_current_poc->compno0),l_comp_room);    /* CSpoc_i */
+                p_header_data+=l_comp_room;
+                opj_read_bytes(p_header_data,&(l_current_poc->layno1),2);                               /* LYEpoc_i */
+                /* make sure layer end is in acceptable bounds */
+                l_current_poc->layno1 = opj_uint_min(l_current_poc->layno1, l_tcp->numlayers);
+                p_header_data+=2;
+                opj_read_bytes(p_header_data,&(l_current_poc->resno1),1);                               /* REpoc_i */
+                ++p_header_data;
+                opj_read_bytes(p_header_data,&(l_current_poc->compno1),l_comp_room);    /* CEpoc_i */
+                p_header_data+=l_comp_room;
+                opj_read_bytes(p_header_data,&l_tmp,1);                                                                 /* Ppoc_i */
+                ++p_header_data;
+                l_current_poc->prg = (OPJ_PROG_ORDER) l_tmp;
+                /* make sure comp is in acceptable bounds */
+                l_current_poc->compno1 = opj_uint_min(l_current_poc->compno1, l_nb_comp);
+                ++l_current_poc;
+        }
+
+        l_tcp->numpocs = l_current_poc_nb - 1;
+        return OPJ_TRUE;
+}
+
+/**
+ * Reads a CRG marker (Component registration)
+ *
+ * @param       p_header_data   the data contained in the TLM box.
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_header_size   the size of the data contained in the TLM marker.
+ * @param       p_manager               the user event manager.
+*/
+static OPJ_BOOL opj_j2k_read_crg (  opj_j2k_t *p_j2k,
+                                    OPJ_BYTE * p_header_data,
+                                    OPJ_UINT32 p_header_size,
+                                    opj_event_mgr_t * p_manager
+                                    )
+{
+        OPJ_UINT32 l_nb_comp;
+        /* preconditions */
+        assert(p_header_data != 00);
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+
+        l_nb_comp = p_j2k->m_private_image->numcomps;
+
+        if (p_header_size != l_nb_comp *4) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading CRG marker\n");
+                return OPJ_FALSE;
+        }
+        /* Do not care of this at the moment since only local variables are set here */
+        /*
+        for
+                (i = 0; i < l_nb_comp; ++i)
+        {
+                opj_read_bytes(p_header_data,&l_Xcrg_i,2);                              // Xcrg_i
+                p_header_data+=2;
+                opj_read_bytes(p_header_data,&l_Ycrg_i,2);                              // Xcrg_i
+                p_header_data+=2;
+        }
+        */
+        return OPJ_TRUE;
+}
+
+/**
+ * Reads a TLM marker (Tile Length Marker)
+ *
+ * @param       p_header_data   the data contained in the TLM box.
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_header_size   the size of the data contained in the TLM marker.
+ * @param       p_manager               the user event manager.
+*/
+static OPJ_BOOL opj_j2k_read_tlm (  opj_j2k_t *p_j2k,
+                                    OPJ_BYTE * p_header_data,
+                                    OPJ_UINT32 p_header_size,
+                                    opj_event_mgr_t * p_manager
+                                    )
+{
+        OPJ_UINT32 l_Ztlm, l_Stlm, l_ST, l_SP, l_tot_num_tp_remaining, l_quotient, l_Ptlm_size;
+        /* preconditions */
+        assert(p_header_data != 00);
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+
+        if (p_header_size < 2) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading TLM marker\n");
+                return OPJ_FALSE;
+        }
+        p_header_size -= 2;
+
+        opj_read_bytes(p_header_data,&l_Ztlm,1);                                /* Ztlm */
+        ++p_header_data;
+        opj_read_bytes(p_header_data,&l_Stlm,1);                                /* Stlm */
+        ++p_header_data;
+
+        l_ST = ((l_Stlm >> 4) & 0x3);
+        l_SP = (l_Stlm >> 6) & 0x1;
+
+        l_Ptlm_size = (l_SP + 1) * 2;
+        l_quotient = l_Ptlm_size + l_ST;
+
+        l_tot_num_tp_remaining = p_header_size % l_quotient;
+
+        if (l_tot_num_tp_remaining != 0) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading TLM marker\n");
+                return OPJ_FALSE;
+        }
+        /* FIXME Do not care of this at the moment since only local variables are set here */
+        /*
+        for
+                (i = 0; i < l_tot_num_tp; ++i)
+        {
+                opj_read_bytes(p_header_data,&l_Ttlm_i,l_ST);                           // Ttlm_i
+                p_header_data += l_ST;
+                opj_read_bytes(p_header_data,&l_Ptlm_i,l_Ptlm_size);            // Ptlm_i
+                p_header_data += l_Ptlm_size;
+        }*/
+        return OPJ_TRUE;
+}
+
+/**
+ * Reads a PLM marker (Packet length, main header marker)
+ *
+ * @param       p_header_data   the data contained in the TLM box.
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_header_size   the size of the data contained in the TLM marker.
+ * @param       p_manager               the user event manager.
+*/
+static OPJ_BOOL opj_j2k_read_plm (  opj_j2k_t *p_j2k,
+                                    OPJ_BYTE * p_header_data,
+                                    OPJ_UINT32 p_header_size,
+                                    opj_event_mgr_t * p_manager
+                                    )
+{
+        /* preconditions */
+        assert(p_header_data != 00);
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+
+        if (p_header_size < 1) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading PLM marker\n");
+                return OPJ_FALSE;
+        }
+        /* Do not care of this at the moment since only local variables are set here */
+        /*
+        opj_read_bytes(p_header_data,&l_Zplm,1);                                        // Zplm
+        ++p_header_data;
+        --p_header_size;
+
+        while
+                (p_header_size > 0)
+        {
+                opj_read_bytes(p_header_data,&l_Nplm,1);                                // Nplm
+                ++p_header_data;
+                p_header_size -= (1+l_Nplm);
+                if
+                        (p_header_size < 0)
+                {
+                        opj_event_msg(p_manager, EVT_ERROR, "Error reading PLM marker\n");
+                        return false;
+                }
+                for
+                        (i = 0; i < l_Nplm; ++i)
+                {
+                        opj_read_bytes(p_header_data,&l_tmp,1);                         // Iplm_ij
+                        ++p_header_data;
+                        // take only the last seven bytes
+                        l_packet_len |= (l_tmp & 0x7f);
+                        if
+                                (l_tmp & 0x80)
+                        {
+                                l_packet_len <<= 7;
+                        }
+                        else
+                        {
+                // store packet length and proceed to next packet
+                                l_packet_len = 0;
+                        }
+                }
+                if
+                        (l_packet_len != 0)
+                {
+                        opj_event_msg(p_manager, EVT_ERROR, "Error reading PLM marker\n");
+                        return false;
+                }
+        }
+        */
+        return OPJ_TRUE;
+}
+
+/**
+ * Reads a PLT marker (Packet length, tile-part header)
+ *
+ * @param       p_header_data   the data contained in the PLT box.
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_header_size   the size of the data contained in the PLT marker.
+ * @param       p_manager               the user event manager.
+*/
+static OPJ_BOOL opj_j2k_read_plt (  opj_j2k_t *p_j2k,
+                                    OPJ_BYTE * p_header_data,
+                                    OPJ_UINT32 p_header_size,
+                                    opj_event_mgr_t * p_manager
+                                    )
+{
+        OPJ_UINT32 l_Zplt, l_tmp, l_packet_len = 0, i;
+
+        /* preconditions */
+        assert(p_header_data != 00);
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+
+        if (p_header_size < 1) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading PLT marker\n");
+                return OPJ_FALSE;
+        }
+
+        opj_read_bytes(p_header_data,&l_Zplt,1);                /* Zplt */
+        ++p_header_data;
+        --p_header_size;
+
+        for (i = 0; i < p_header_size; ++i) {
+                opj_read_bytes(p_header_data,&l_tmp,1);         /* Iplt_ij */
+                ++p_header_data;
+                /* take only the last seven bytes */
+                l_packet_len |= (l_tmp & 0x7f);
+                if (l_tmp & 0x80) {
+                        l_packet_len <<= 7;
+                }
+                else {
+            /* store packet length and proceed to next packet */
+                        l_packet_len = 0;
+                }
+        }
+
+        if (l_packet_len != 0) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading PLT marker\n");
+                return OPJ_FALSE;
+        }
+
+        return OPJ_TRUE;
+}
+
+#if 0
+OPJ_BOOL j2k_read_ppm_v2 (
+                                                opj_j2k_t *p_j2k,
+                                                OPJ_BYTE * p_header_data,
+                                                OPJ_UINT32 p_header_size,
+                                                struct opj_event_mgr * p_manager
+                                        )
+{
+
+        opj_cp_t *l_cp = 00;
+        OPJ_UINT32 l_remaining_data, l_Z_ppm, l_N_ppm;
+
+        /* preconditions */
+        assert(p_header_data != 00);
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+
+        if (p_header_size < 1) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading PPM marker\n");
+                return OPJ_FALSE;
+        }
+
+        l_cp = &(p_j2k->m_cp);
+        l_cp->ppm = 1;
+
+        opj_read_bytes(p_header_data,&l_Z_ppm,1);               /* Z_ppm */
+        ++p_header_data;
+        --p_header_size;
+
+        /* First PPM marker */
+        if (l_Z_ppm == 0) {
+                if (p_header_size < 4) {
+                        opj_event_msg(p_manager, EVT_ERROR, "Error reading PPM marker\n");
+                        return OPJ_FALSE;
+                }
+
+                opj_read_bytes(p_header_data,&l_N_ppm,4);               /* N_ppm */
+                p_header_data+=4;
+                p_header_size-=4;
+
+                /* First PPM marker: Initialization */
+                l_cp->ppm_len = l_N_ppm;
+                l_cp->ppm_data_size = 0;
+
+                l_cp->ppm_buffer = (OPJ_BYTE *) opj_malloc(l_cp->ppm_len);
+                if (l_cp->ppm_buffer == 00) {
+                        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory reading ppm marker\n");
+                        return OPJ_FALSE;
+                }
+                memset(l_cp->ppm_buffer,0,l_cp->ppm_len);
+
+                l_cp->ppm_data = l_cp->ppm_buffer;
+        }
+
+        while (1) {
+                if (l_cp->ppm_data_size == l_cp->ppm_len) {
+                        if (p_header_size >= 4) {
+                                /* read a N_ppm */
+                                opj_read_bytes(p_header_data,&l_N_ppm,4);               /* N_ppm */
+                                p_header_data+=4;
+                                p_header_size-=4;
+                                l_cp->ppm_len += l_N_ppm ;
+
+                                OPJ_BYTE *new_ppm_buffer = (OPJ_BYTE *) opj_realloc(l_cp->ppm_buffer, l_cp->ppm_len);
+                                if (! new_ppm_buffer) {
+                                        opj_free(l_cp->ppm_buffer);
+                                        l_cp->ppm_buffer = NULL;
+                                        l_cp->ppm_len = 0;
+                                        l_cp->ppm_data = NULL;
+                                        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory reading ppm marker\n");
+                                        return OPJ_FALSE;
+                                }
+                                l_cp->ppm_buffer = new_ppm_buffer;
+                                memset(l_cp->ppm_buffer+l_cp->ppm_data_size,0,l_N_ppm);
+                                l_cp->ppm_data = l_cp->ppm_buffer;
+                        }
+                        else {
+                                return OPJ_FALSE;
+                        }
+                }
+
+                l_remaining_data = l_cp->ppm_len - l_cp->ppm_data_size;
+
+                if (l_remaining_data <= p_header_size) {
+                        /* we must store less information than available in the packet */
+                        memcpy(l_cp->ppm_buffer + l_cp->ppm_data_size , p_header_data , l_remaining_data);
+                        l_cp->ppm_data_size = l_cp->ppm_len;
+                        p_header_size -= l_remaining_data;
+                        p_header_data += l_remaining_data;
+                }
+                else {
+                        memcpy(l_cp->ppm_buffer + l_cp->ppm_data_size , p_header_data , p_header_size);
+                        l_cp->ppm_data_size += p_header_size;
+                        p_header_data += p_header_size;
+                        p_header_size = 0;
+                        break;
+                }
+        }
+
+        return OPJ_TRUE;
+}
+#endif
+
+OPJ_BOOL j2k_read_ppm_v3 (
+                                                opj_j2k_t *p_j2k,
+                                                OPJ_BYTE * p_header_data,
+                                                OPJ_UINT32 p_header_size,
+                                                struct opj_event_mgr * p_manager
+                                        )
+{
+        opj_cp_t *l_cp = 00;
+        OPJ_UINT32 l_remaining_data, l_Z_ppm, l_N_ppm;
+
+        /* preconditions */
+        assert(p_header_data != 00);
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+
+        /* Minimum size of PPM marker is equal to the size of Zppm element */
+        if (p_header_size < 1) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading PPM marker\n");
+                return OPJ_FALSE;
+        }
+
+        l_cp = &(p_j2k->m_cp);
+        l_cp->ppm = 1;
+
+        opj_read_bytes(p_header_data,&l_Z_ppm,1);               /* Z_ppm */
+        ++p_header_data;
+        --p_header_size;
+
+        /* First PPM marker */
+        if (l_Z_ppm == 0) {
+                /* We need now at least the Nppm^0 element */
+                if (p_header_size < 4) {
+                        opj_event_msg(p_manager, EVT_ERROR, "Error reading PPM marker\n");
+                        return OPJ_FALSE;
+                }
+
+                opj_read_bytes(p_header_data,&l_N_ppm,4);               /* First N_ppm */
+                p_header_data+=4;
+                p_header_size-=4;
+
+                /* sanity check: how much bytes is left for Ippm */
+                if( p_header_size < l_N_ppm )
+                  {
+                  opj_event_msg(p_manager, EVT_ERROR, "Not enough bytes (%u) to hold Ippm series (%u), Index (%d)\n", p_header_size, l_N_ppm, l_Z_ppm );
+                  opj_free(l_cp->ppm_data);
+                  l_cp->ppm_data = NULL;
+                  l_cp->ppm_buffer = NULL;
+                  l_cp->ppm = 0; /* do not use PPM */
+                  return OPJ_FALSE;
+                  }
+
+                /* First PPM marker: Initialization */
+                l_cp->ppm_len = l_N_ppm;
+                l_cp->ppm_data_read = 0;
+
+                l_cp->ppm_data = (OPJ_BYTE *) opj_malloc(l_cp->ppm_len);
+                l_cp->ppm_buffer = l_cp->ppm_data;
+                if (l_cp->ppm_data == 00) {
+                        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to read ppm marker\n");
+                        return OPJ_FALSE;
+                }
+                memset(l_cp->ppm_data,0,l_cp->ppm_len);
+
+                l_cp->ppm_data_current = l_cp->ppm_data;
+
+                /*l_cp->ppm_data = l_cp->ppm_buffer;*/
+        }
+        else {
+                if (p_header_size < 4) {
+                        opj_event_msg(p_manager, EVT_WARNING, "Empty PPM marker\n");
+                        return OPJ_TRUE;
+                }
+                else {
+                        /* Uncompleted Ippm series in the previous PPM marker?*/
+                        if (l_cp->ppm_data_read < l_cp->ppm_len) {
+                                /* Get the place where add the remaining Ippm series*/
+                                l_cp->ppm_data_current = &(l_cp->ppm_data[l_cp->ppm_data_read]);
+                                l_N_ppm = l_cp->ppm_len - l_cp->ppm_data_read;
+                        }
+                        else {
+                                OPJ_BYTE *new_ppm_data;
+                                opj_read_bytes(p_header_data,&l_N_ppm,4);               /* First N_ppm */
+                                p_header_data+=4;
+                                p_header_size-=4;
+
+                                /* sanity check: how much bytes is left for Ippm */
+                                if( p_header_size < l_N_ppm )
+                                  {
+                                  opj_event_msg(p_manager, EVT_ERROR, "Not enough bytes (%u) to hold Ippm series (%u), Index (%d)\n", p_header_size, l_N_ppm, l_Z_ppm );
+                                  opj_free(l_cp->ppm_data);
+                                  l_cp->ppm_data = NULL;
+                                  l_cp->ppm_buffer = NULL;
+                                  l_cp->ppm = 0; /* do not use PPM */
+                                  return OPJ_FALSE;
+                                  }
+                                /* Increase the size of ppm_data to add the new Ippm series*/
+                                assert(l_cp->ppm_data == l_cp->ppm_buffer && "We need ppm_data and ppm_buffer to be the same when reallocating");
+                                new_ppm_data = (OPJ_BYTE *) opj_realloc(l_cp->ppm_data, l_cp->ppm_len + l_N_ppm);
+                                if (! new_ppm_data) {
+                                        opj_free(l_cp->ppm_data);
+                                        l_cp->ppm_data = NULL;
+                                        l_cp->ppm_buffer = NULL;  /* TODO: no need for a new local variable: ppm_buffer and ppm_data are enough */
+                                        l_cp->ppm_len = 0;
+                                        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to increase the size of ppm_data to add the new Ippm series\n");
+                                        return OPJ_FALSE;
+                                }
+                                l_cp->ppm_data = new_ppm_data;
+                                l_cp->ppm_buffer = l_cp->ppm_data;
+
+                                /* Keep the position of the place where concatenate the new series*/
+                                l_cp->ppm_data_current = &(l_cp->ppm_data[l_cp->ppm_len]);
+                                l_cp->ppm_len += l_N_ppm;
+                        }
+                }
+        }
+
+        l_remaining_data = p_header_size;
+
+        while (l_remaining_data >= l_N_ppm) {
+                /* read a complete Ippm series*/
+                memcpy(l_cp->ppm_data_current, p_header_data, l_N_ppm);
+                p_header_size -= l_N_ppm;
+                p_header_data += l_N_ppm;
+
+                l_cp->ppm_data_read += l_N_ppm; /* Increase the number of data read*/
+
+                if (p_header_size)
+                {
+                        opj_read_bytes(p_header_data,&l_N_ppm,4);               /* N_ppm^i */
+                        p_header_data+=4;
+                        p_header_size-=4;
+                }
+                else {
+                        l_remaining_data = p_header_size;
+                        break;
+                }
+
+                l_remaining_data = p_header_size;
+
+                /* Next Ippm series is a complete series ?*/
+                if (l_remaining_data >= l_N_ppm) {
+                        OPJ_BYTE *new_ppm_data;
+                        /* Increase the size of ppm_data to add the new Ippm series*/
+                        assert(l_cp->ppm_data == l_cp->ppm_buffer && "We need ppm_data and ppm_buffer to be the same when reallocating");
+                        new_ppm_data = (OPJ_BYTE *) opj_realloc(l_cp->ppm_data, l_cp->ppm_len + l_N_ppm);
+                        if (! new_ppm_data) {
+                                opj_free(l_cp->ppm_data);
+                                l_cp->ppm_data = NULL;
+                                l_cp->ppm_buffer = NULL;  /* TODO: no need for a new local variable: ppm_buffer and ppm_data are enough */
+                                l_cp->ppm_len = 0;
+                                opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to increase the size of ppm_data to add the new (complete) Ippm series\n");
+                                return OPJ_FALSE;
+                        }
+                        l_cp->ppm_data = new_ppm_data;
+                        l_cp->ppm_buffer = l_cp->ppm_data;
+
+                        /* Keep the position of the place where concatenate the new series */
+                        l_cp->ppm_data_current = &(l_cp->ppm_data[l_cp->ppm_len]);
+                        l_cp->ppm_len += l_N_ppm;
+                }
+
+        }
+
+        /* Need to read an incomplete Ippm series*/
+        if (l_remaining_data) {
+                OPJ_BYTE *new_ppm_data;
+                assert(l_cp->ppm_data == l_cp->ppm_buffer && "We need ppm_data and ppm_buffer to be the same when reallocating");
+                new_ppm_data = (OPJ_BYTE *) opj_realloc(l_cp->ppm_data, l_cp->ppm_len + l_N_ppm);
+                if (! new_ppm_data) {
+                        opj_free(l_cp->ppm_data);
+                        l_cp->ppm_data = NULL;
+                        l_cp->ppm_buffer = NULL;  /* TODO: no need for a new local variable: ppm_buffer and ppm_data are enough */
+                        l_cp->ppm_len = 0;
+                        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to increase the size of ppm_data to add the new (incomplete) Ippm series\n");
+                        return OPJ_FALSE;
+                }
+                l_cp->ppm_data = new_ppm_data;
+                l_cp->ppm_buffer = l_cp->ppm_data;
+
+                /* Keep the position of the place where concatenate the new series*/
+                l_cp->ppm_data_current = &(l_cp->ppm_data[l_cp->ppm_len]);
+                l_cp->ppm_len += l_N_ppm;
+
+                /* Read incomplete Ippm series*/
+                memcpy(l_cp->ppm_data_current, p_header_data, l_remaining_data);
+                p_header_size -= l_remaining_data;
+                p_header_data += l_remaining_data;
+
+                l_cp->ppm_data_read += l_remaining_data; /* Increase the number of data read*/
+        }
+
+#ifdef CLEAN_MSD
+
+                if (l_cp->ppm_data_size == l_cp->ppm_len) {
+                        if (p_header_size >= 4) {
+                                /* read a N_ppm*/
+                                opj_read_bytes(p_header_data,&l_N_ppm,4);               /* N_ppm */
+                                p_header_data+=4;
+                                p_header_size-=4;
+                                l_cp->ppm_len += l_N_ppm ;
+
+                                OPJ_BYTE *new_ppm_buffer = (OPJ_BYTE *) opj_realloc(l_cp->ppm_buffer, l_cp->ppm_len);
+                                if (! new_ppm_buffer) {
+                                        opj_free(l_cp->ppm_buffer);
+                                        l_cp->ppm_buffer = NULL;
+                                        l_cp->ppm_len = 0;
+                                        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to read ppm marker\n");
+                                        return OPJ_FALSE;
+                                }
+                                l_cp->ppm_buffer = new_ppm_buffer;
+                                memset(l_cp->ppm_buffer+l_cp->ppm_data_size,0,l_N_ppm);
+
+                                l_cp->ppm_data = l_cp->ppm_buffer;
+                        }
+                        else {
+                                return OPJ_FALSE;
+                        }
+                }
+
+                l_remaining_data = l_cp->ppm_len - l_cp->ppm_data_size;
+
+                if (l_remaining_data <= p_header_size) {
+                        /* we must store less information than available in the packet */
+                        memcpy(l_cp->ppm_buffer + l_cp->ppm_data_size , p_header_data , l_remaining_data);
+                        l_cp->ppm_data_size = l_cp->ppm_len;
+                        p_header_size -= l_remaining_data;
+                        p_header_data += l_remaining_data;
+                }
+                else {
+                        memcpy(l_cp->ppm_buffer + l_cp->ppm_data_size , p_header_data , p_header_size);
+                        l_cp->ppm_data_size += p_header_size;
+                        p_header_data += p_header_size;
+                        p_header_size = 0;
+                        break;
+                }
+        }
+#endif
+        return OPJ_TRUE;
+}
+
+/**
+ * Reads a PPT marker (Packed packet headers, tile-part header)
+ *
+ * @param       p_header_data   the data contained in the PPT box.
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_header_size   the size of the data contained in the PPT marker.
+ * @param       p_manager               the user event manager.
+*/
+static OPJ_BOOL opj_j2k_read_ppt (  opj_j2k_t *p_j2k,
+                                    OPJ_BYTE * p_header_data,
+                                    OPJ_UINT32 p_header_size,
+                                    opj_event_mgr_t * p_manager
+                                    )
+{
+        opj_cp_t *l_cp = 00;
+        opj_tcp_t *l_tcp = 00;
+        OPJ_UINT32 l_Z_ppt;
+
+        /* preconditions */
+        assert(p_header_data != 00);
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+
+        /* We need to have the Z_ppt element at minimum */
+        if (p_header_size < 1) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading PPT marker\n");
+                return OPJ_FALSE;
+        }
+
+        l_cp = &(p_j2k->m_cp);
+        if (l_cp->ppm){
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading PPT marker: packet header have been previously found in the main header (PPM marker).\n");
+                return OPJ_FALSE;
+        }
+
+        l_tcp = &(l_cp->tcps[p_j2k->m_current_tile_number]);
+        l_tcp->ppt = 1;
+
+        opj_read_bytes(p_header_data,&l_Z_ppt,1);               /* Z_ppt */
+        ++p_header_data;
+        --p_header_size;
+
+        /* Allocate buffer to read the packet header */
+        if (l_Z_ppt == 0) {
+                /* First PPT marker */
+                l_tcp->ppt_data_size = 0;
+                l_tcp->ppt_len = p_header_size;
+
+                opj_free(l_tcp->ppt_buffer);
+                l_tcp->ppt_buffer = (OPJ_BYTE *) opj_calloc(l_tcp->ppt_len, sizeof(OPJ_BYTE) );
+                if (l_tcp->ppt_buffer == 00) {
+                        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to read PPT marker\n");
+                        return OPJ_FALSE;
+                }
+                l_tcp->ppt_data = l_tcp->ppt_buffer;
+
+                /* memset(l_tcp->ppt_buffer,0,l_tcp->ppt_len); */
+        }
+        else {
+                OPJ_BYTE *new_ppt_buffer;
+                l_tcp->ppt_len += p_header_size;
+
+                new_ppt_buffer = (OPJ_BYTE *) opj_realloc(l_tcp->ppt_buffer, l_tcp->ppt_len);
+                if (! new_ppt_buffer) {
+                        opj_free(l_tcp->ppt_buffer);
+                        l_tcp->ppt_buffer = NULL;
+                        l_tcp->ppt_len = 0;
+                        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to read PPT marker\n");
+                        return OPJ_FALSE;
+                }
+                l_tcp->ppt_buffer = new_ppt_buffer;
+                l_tcp->ppt_data = l_tcp->ppt_buffer;
+
+                memset(l_tcp->ppt_buffer+l_tcp->ppt_data_size,0,p_header_size);
+        }
+
+        /* Read packet header from buffer */
+        memcpy(l_tcp->ppt_buffer+l_tcp->ppt_data_size,p_header_data,p_header_size);
+
+        l_tcp->ppt_data_size += p_header_size;
+
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_j2k_write_tlm(     opj_j2k_t *p_j2k,
+                                                        opj_stream_private_t *p_stream,
+                                                        opj_event_mgr_t * p_manager
+                            )
+{
+        OPJ_BYTE * l_current_data = 00;
+        OPJ_UINT32 l_tlm_size;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_stream != 00);
+
+        l_tlm_size = 6 + (5*p_j2k->m_specific_param.m_encoder.m_total_tile_parts);
+
+        if (l_tlm_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
+                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_tlm_size);
+                if (! new_header_tile_data) {
+                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
+                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;
+                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;
+                        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to write TLM marker\n");
+                        return OPJ_FALSE;
+                }
+                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
+                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_tlm_size;
+        }
+
+        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
+
+        /* change the way data is written to avoid seeking if possible */
+        /* TODO */
+        p_j2k->m_specific_param.m_encoder.m_tlm_start = opj_stream_tell(p_stream);
+
+        opj_write_bytes(l_current_data,J2K_MS_TLM,2);                                   /* TLM */
+        l_current_data += 2;
+
+        opj_write_bytes(l_current_data,l_tlm_size-2,2);                                 /* Lpoc */
+        l_current_data += 2;
+
+        opj_write_bytes(l_current_data,0,1);                                                    /* Ztlm=0*/
+        ++l_current_data;
+
+        opj_write_bytes(l_current_data,0x50,1);                                                 /* Stlm ST=1(8bits-255 tiles max),SP=1(Ptlm=32bits) */
+        ++l_current_data;
+
+        /* do nothing on the 5 * l_j2k->m_specific_param.m_encoder.m_total_tile_parts remaining data */
+        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_tlm_size,p_manager) != l_tlm_size) {
+                return OPJ_FALSE;
+        }
+
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_j2k_write_sot(     opj_j2k_t *p_j2k,
+                                                        OPJ_BYTE * p_data,
+                                                        OPJ_UINT32 * p_data_written,
+                                                        const opj_stream_private_t *p_stream,
+                                                        opj_event_mgr_t * p_manager
+                            )
+{
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_stream != 00);
+
+        opj_write_bytes(p_data,J2K_MS_SOT,2);                                   /* SOT */
+        p_data += 2;
+
+        opj_write_bytes(p_data,10,2);                                                   /* Lsot */
+        p_data += 2;
+
+        opj_write_bytes(p_data, p_j2k->m_current_tile_number,2);                        /* Isot */
+        p_data += 2;
+
+        /* Psot  */
+        p_data += 4;
+
+        opj_write_bytes(p_data, p_j2k->m_specific_param.m_encoder.m_current_tile_part_number,1);                        /* TPsot */
+        ++p_data;
+
+        opj_write_bytes(p_data, p_j2k->m_cp.tcps[p_j2k->m_current_tile_number].m_nb_tile_parts,1);                      /* TNsot */
+        ++p_data;
+
+        /* UniPG>> */
+#ifdef USE_JPWL
+        /* update markers struct */
+/*
+        OPJ_BOOL res = j2k_add_marker(p_j2k->cstr_info, J2K_MS_SOT, p_j2k->sot_start, len + 2);
+*/
+  assert( 0 && "TODO" );
+#endif /* USE_JPWL */
+
+        * p_data_written = 12;
+
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_j2k_read_sot ( opj_j2k_t *p_j2k,
+                            OPJ_BYTE * p_header_data,
+                            OPJ_UINT32 p_header_size,
+                            opj_event_mgr_t * p_manager )
+{
+        opj_cp_t *l_cp = 00;
+        opj_tcp_t *l_tcp = 00;
+        OPJ_UINT32 l_tot_len, l_num_parts = 0;
+        OPJ_UINT32 l_current_part;
+        OPJ_UINT32 l_tile_x,l_tile_y;
+
+        /* preconditions */
+        assert(p_header_data != 00);
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+
+        /* Size of this marker is fixed = 12 (we have already read marker and its size)*/
+        if (p_header_size != 8) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading SOT marker\n");
+                return OPJ_FALSE;
+        }
+
+        l_cp = &(p_j2k->m_cp);
+        opj_read_bytes(p_header_data,&(p_j2k->m_current_tile_number),2);                /* Isot */
+        p_header_data+=2;
+
+        /* testcase 2.pdf.SIGFPE.706.1112 */
+        if (p_j2k->m_current_tile_number >= l_cp->tw * l_cp->th) {
+                opj_event_msg(p_manager, EVT_ERROR, "Invalid tile number %d\n", p_j2k->m_current_tile_number);
+                return OPJ_FALSE;
+        }
+
+        l_tcp = &l_cp->tcps[p_j2k->m_current_tile_number];
+        l_tile_x = p_j2k->m_current_tile_number % l_cp->tw;
+        l_tile_y = p_j2k->m_current_tile_number / l_cp->tw;
+
+#ifdef USE_JPWL
+        if (l_cp->correct) {
+
+                OPJ_UINT32 tileno = p_j2k->m_current_tile_number;
+                static OPJ_UINT32 backup_tileno = 0;
+
+                /* tileno is negative or larger than the number of tiles!!! */
+                if (tileno > (l_cp->tw * l_cp->th)) {
+                        opj_event_msg(p_manager, EVT_ERROR,
+                                        "JPWL: bad tile number (%d out of a maximum of %d)\n",
+                                        tileno, (l_cp->tw * l_cp->th));
+                        if (!JPWL_ASSUME) {
+                                opj_event_msg(p_manager, EVT_ERROR, "JPWL: giving up\n");
+                                return OPJ_FALSE;
+                        }
+                        /* we try to correct */
+                        tileno = backup_tileno;
+                        opj_event_msg(p_manager, EVT_WARNING, "- trying to adjust this\n"
+                                        "- setting tile number to %d\n",
+                                        tileno);
+                }
+
+                /* keep your private count of tiles */
+                backup_tileno++;
+        };
+#endif /* USE_JPWL */
+
+        /* look for the tile in the list of already processed tile (in parts). */
+        /* Optimization possible here with a more complex data structure and with the removing of tiles */
+        /* since the time taken by this function can only grow at the time */
+
+        opj_read_bytes(p_header_data,&l_tot_len,4);             /* Psot */
+        p_header_data+=4;
+
+        /* PSot should be equal to zero or >=14 or <= 2^32-1 */
+        if ((l_tot_len !=0 ) && (l_tot_len < 14) )
+        {
+            if (l_tot_len == 12 ) /* MSD: Special case for the PHR data which are read by kakadu*/
+            {
+                opj_event_msg(p_manager, EVT_WARNING, "Empty SOT marker detected: Psot=%d.\n", l_tot_len);
+            }
+            else
+            {
+                opj_event_msg(p_manager, EVT_ERROR, "Psot value is not correct regards to the JPEG2000 norm: %d.\n", l_tot_len);
+                return OPJ_FALSE;
+            }
+        }
+
+#ifdef USE_JPWL
+        if (l_cp->correct) {
+
+                /* totlen is negative or larger than the bytes left!!! */
+                if (/*(l_tot_len < 0) ||*/ (l_tot_len > p_header_size ) ) { /* FIXME it seems correct; for info in V1 -> (p_stream_numbytesleft(p_stream) + 8))) { */
+                        opj_event_msg(p_manager, EVT_ERROR,
+                                        "JPWL: bad tile byte size (%d bytes against %d bytes left)\n",
+                                        l_tot_len, p_header_size ); /* FIXME it seems correct; for info in V1 -> p_stream_numbytesleft(p_stream) + 8); */
+                        if (!JPWL_ASSUME) {
+                                opj_event_msg(p_manager, EVT_ERROR, "JPWL: giving up\n");
+                                return OPJ_FALSE;
+                        }
+                        /* we try to correct */
+                        l_tot_len = 0;
+                        opj_event_msg(p_manager, EVT_WARNING, "- trying to adjust this\n"
+                                        "- setting Psot to %d => assuming it is the last tile\n",
+                                        l_tot_len);
+                }
+                };
+#endif /* USE_JPWL */
+
+                /* Ref A.4.2: Psot could be equal zero if it is the last tile-part of the codestream.*/
+                if (!l_tot_len) {
+                        opj_event_msg(p_manager, EVT_INFO, "Psot value of the current tile-part is equal to zero, "
+                                        "we assuming it is the last tile-part of the codestream.\n");
+                        p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;
+                }
+
+                opj_read_bytes(p_header_data,&l_current_part ,1);       /* TPsot */
+                ++p_header_data;
+
+                opj_read_bytes(p_header_data,&l_num_parts ,1);          /* TNsot */
+                ++p_header_data;
+
+                if (l_num_parts != 0) { /* Number of tile-part header is provided by this tile-part header */
+                        /* Useful to manage the case of textGBR.jp2 file because two values of TNSot are allowed: the correct numbers of
+                         * tile-parts for that tile and zero (A.4.2 of 15444-1 : 2002). */
+                        if (l_tcp->m_nb_tile_parts) {
+                                if (l_current_part >= l_tcp->m_nb_tile_parts){
+                                        opj_event_msg(p_manager, EVT_ERROR, "In SOT marker, TPSot (%d) is not valid regards to the current "
+                                                        "number of tile-part (%d), giving up\n", l_current_part, l_tcp->m_nb_tile_parts );
+                                        p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;
+                                        return OPJ_FALSE;
+                                }
+                        }
+                        if( l_current_part >= l_num_parts ) {
+                          /* testcase 451.pdf.SIGSEGV.ce9.3723 */
+                          opj_event_msg(p_manager, EVT_ERROR, "In SOT marker, TPSot (%d) is not valid regards to the current "
+                            "number of tile-part (header) (%d), giving up\n", l_current_part, l_num_parts );
+                          p_j2k->m_specific_param.m_decoder.m_last_tile_part = 1;
+                          return OPJ_FALSE;
+                        }
+                        l_tcp->m_nb_tile_parts = l_num_parts;
+                }
+
+                /* If know the number of tile part header we will check if we didn't read the last*/
+                if (l_tcp->m_nb_tile_parts) {
+                        if (l_tcp->m_nb_tile_parts == (l_current_part+1)) {
+                                p_j2k->m_specific_param.m_decoder.m_can_decode = 1; /* Process the last tile-part header*/
+                        }
+                }
+
+                if (!p_j2k->m_specific_param.m_decoder.m_last_tile_part){
+                        /* Keep the size of data to skip after this marker */
+                        p_j2k->m_specific_param.m_decoder.m_sot_length = l_tot_len - 12; /* SOT_marker_size = 12 */
+                }
+                else {
+                        /* FIXME: need to be computed from the number of bytes remaining in the codestream */
+                        p_j2k->m_specific_param.m_decoder.m_sot_length = 0;
+                }
+
+                p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_TPH;
+
+                /* Check if the current tile is outside the area we want decode or not corresponding to the tile index*/
+                if (p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec == -1) {
+                        p_j2k->m_specific_param.m_decoder.m_skip_data =
+                                (l_tile_x < p_j2k->m_specific_param.m_decoder.m_start_tile_x)
+                                ||      (l_tile_x >= p_j2k->m_specific_param.m_decoder.m_end_tile_x)
+                                ||  (l_tile_y < p_j2k->m_specific_param.m_decoder.m_start_tile_y)
+                                ||      (l_tile_y >= p_j2k->m_specific_param.m_decoder.m_end_tile_y);
+                }
+                else {
+                        assert( p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec >= 0 );
+                        p_j2k->m_specific_param.m_decoder.m_skip_data =
+                                (p_j2k->m_current_tile_number != (OPJ_UINT32)p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec);
+                }
+
+                /* Index */
+                if (p_j2k->cstr_index)
+                {
+                        assert(p_j2k->cstr_index->tile_index != 00);
+                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tileno = p_j2k->m_current_tile_number;
+                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_tpsno = l_current_part;
+
+                        if (l_num_parts != 0){
+                                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].nb_tps = l_num_parts;
+                                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps = l_num_parts;
+
+                                if (!p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index) {
+                                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index =
+                                                (opj_tp_index_t*)opj_calloc(l_num_parts, sizeof(opj_tp_index_t));
+                                }
+                                else {
+                                        opj_tp_index_t *new_tp_index = (opj_tp_index_t *) opj_realloc(
+                                                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index, l_num_parts* sizeof(opj_tp_index_t));
+                                        if (! new_tp_index) {
+                                                opj_free(p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index);
+                                                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index = NULL;
+                                                opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to read PPT marker\n");
+                                                return OPJ_FALSE;
+                                        }
+                                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index = new_tp_index;
+                                }
+                        }
+                        else{
+                                /*if (!p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index)*/ {
+
+                                        if (!p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index) {
+                                                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps = 10;
+                                                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index =
+                                                        (opj_tp_index_t*)opj_calloc( p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps,
+                                                                        sizeof(opj_tp_index_t));
+                                        }
+
+                                        if ( l_current_part >= p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps ){
+                                                opj_tp_index_t *new_tp_index;
+                                                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps = l_current_part + 1;
+                                                new_tp_index = (opj_tp_index_t *) opj_realloc(
+                                                                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index,
+                                                                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps * sizeof(opj_tp_index_t));
+                                                if (! new_tp_index) {
+                                                        opj_free(p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index);
+                                                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index = NULL;
+                                                        p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].current_nb_tps = 0;
+                                                        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to read PPT marker\n");
+                                                        return OPJ_FALSE;
+                                                }
+                                                p_j2k->cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index = new_tp_index;
+                                        }
+                                }
+
+                        }
+
+                }
+
+                /* FIXME move this onto a separate method to call before reading any SOT, remove part about main_end header, use a index struct inside p_j2k */
+                /* if (p_j2k->cstr_info) {
+                   if (l_tcp->first) {
+                   if (tileno == 0) {
+                   p_j2k->cstr_info->main_head_end = p_stream_tell(p_stream) - 13;
+                   }
+
+                   p_j2k->cstr_info->tile[tileno].tileno = tileno;
+                   p_j2k->cstr_info->tile[tileno].start_pos = p_stream_tell(p_stream) - 12;
+                   p_j2k->cstr_info->tile[tileno].end_pos = p_j2k->cstr_info->tile[tileno].start_pos + totlen - 1;
+                   p_j2k->cstr_info->tile[tileno].num_tps = numparts;
+
+                   if (numparts) {
+                   p_j2k->cstr_info->tile[tileno].tp = (opj_tp_info_t *) opj_malloc(numparts * sizeof(opj_tp_info_t));
+                   }
+                   else {
+                   p_j2k->cstr_info->tile[tileno].tp = (opj_tp_info_t *) opj_malloc(10 * sizeof(opj_tp_info_t)); // Fixme (10)
+                   }
+                   }
+                   else {
+                   p_j2k->cstr_info->tile[tileno].end_pos += totlen;
+                   }
+
+                   p_j2k->cstr_info->tile[tileno].tp[partno].tp_start_pos = p_stream_tell(p_stream) - 12;
+                   p_j2k->cstr_info->tile[tileno].tp[partno].tp_end_pos =
+                   p_j2k->cstr_info->tile[tileno].tp[partno].tp_start_pos + totlen - 1;
+                   }*/
+                return OPJ_TRUE;
+        }
+
+OPJ_BOOL opj_j2k_write_sod(     opj_j2k_t *p_j2k,
+                                                        opj_tcd_t * p_tile_coder,
+                                                        OPJ_BYTE * p_data,
+                                                        OPJ_UINT32 * p_data_written,
+                                                        OPJ_UINT32 p_total_data_size,
+                                                        const opj_stream_private_t *p_stream,
+                                                        opj_event_mgr_t * p_manager
+                            )
+{
+        opj_codestream_info_t *l_cstr_info = 00;
+        OPJ_UINT32 l_remaining_data;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_stream != 00);
+
+        opj_write_bytes(p_data,J2K_MS_SOD,2);                                   /* SOD */
+        p_data += 2;
+
+        /* make room for the EOF marker */
+        l_remaining_data =  p_total_data_size - 4;
+
+        /* update tile coder */
+        p_tile_coder->tp_num = p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number ;
+        p_tile_coder->cur_tp_num = p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;
+
+         /* INDEX >> */
+        /* TODO mergeV2: check this part which use cstr_info */
+        /*l_cstr_info = p_j2k->cstr_info;
+        if (l_cstr_info) {
+                if (!p_j2k->m_specific_param.m_encoder.m_current_tile_part_number ) {
+                        //TODO cstr_info->tile[p_j2k->m_current_tile_number].end_header = p_stream_tell(p_stream) + p_j2k->pos_correction - 1;
+                        l_cstr_info->tile[p_j2k->m_current_tile_number].tileno = p_j2k->m_current_tile_number;
+                }
+                else {*/
+                        /*
+                        TODO
+                        if
+                                (cstr_info->tile[p_j2k->m_current_tile_number].packet[cstr_info->packno - 1].end_pos < p_stream_tell(p_stream))
+                        {
+                                cstr_info->tile[p_j2k->m_current_tile_number].packet[cstr_info->packno].start_pos = p_stream_tell(p_stream);
+                        }*/
+                /*}*/
+                /* UniPG>> */
+#ifdef USE_JPWL
+                /* update markers struct */
+                /*OPJ_BOOL res = j2k_add_marker(p_j2k->cstr_info, J2K_MS_SOD, p_j2k->sod_start, 2);
+*/
+  assert( 0 && "TODO" );
+#endif /* USE_JPWL */
+                /* <<UniPG */
+        /*}*/
+        /* << INDEX */
+
+        if (p_j2k->m_specific_param.m_encoder.m_current_tile_part_number == 0) {
+                p_tile_coder->tcd_image->tiles->packno = 0;
+                if (l_cstr_info) {
+                        l_cstr_info->packno = 0;
+                }
+        }
+
+        *p_data_written = 0;
+
+        if (! opj_tcd_encode_tile(p_tile_coder, p_j2k->m_current_tile_number, p_data, p_data_written, l_remaining_data , l_cstr_info)) {
+                opj_event_msg(p_manager, EVT_ERROR, "Cannot encode tile\n");
+                return OPJ_FALSE;
+        }
+
+        *p_data_written += 2;
+
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_j2k_read_sod (opj_j2k_t *p_j2k,
+                           opj_stream_private_t *p_stream,
+                                                   opj_event_mgr_t * p_manager
+                           )
+{
+        OPJ_SIZE_T l_current_read_size;
+        opj_codestream_index_t * l_cstr_index = 00;
+        OPJ_BYTE ** l_current_data = 00;
+        opj_tcp_t * l_tcp = 00;
+        OPJ_UINT32 * l_tile_len = 00;
+        OPJ_BOOL l_sot_length_pb_detected = OPJ_FALSE;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_stream != 00);
+
+        l_tcp = &(p_j2k->m_cp.tcps[p_j2k->m_current_tile_number]);
+
+        if (p_j2k->m_specific_param.m_decoder.m_last_tile_part) {
+                /* opj_stream_get_number_byte_left returns OPJ_OFF_T
+                // but we are in the last tile part,
+                // so its result will fit on OPJ_UINT32 unless we find
+                // a file with a single tile part of more than 4 GB...*/
+                p_j2k->m_specific_param.m_decoder.m_sot_length = (OPJ_UINT32)(opj_stream_get_number_byte_left(p_stream) - 2);
+        }
+        else {
+            /* Check to avoid pass the limit of OPJ_UINT32 */
+            if (p_j2k->m_specific_param.m_decoder.m_sot_length >= 2 )
+                p_j2k->m_specific_param.m_decoder.m_sot_length -= 2;
+            else {
+                /* MSD: case commented to support empty SOT marker (PHR data) */
+            }
+        }
+
+        l_current_data = &(l_tcp->m_data);
+        l_tile_len = &l_tcp->m_data_size;
+
+        /* Patch to support new PHR data */
+        if (p_j2k->m_specific_param.m_decoder.m_sot_length) {
+            if (! *l_current_data) {
+                /* LH: oddly enough, in this path, l_tile_len!=0.
+                 * TODO: If this was consistant, we could simplify the code to only use realloc(), as realloc(0,...) default to malloc(0,...).
+                 */
+                *l_current_data = (OPJ_BYTE*) opj_malloc(p_j2k->m_specific_param.m_decoder.m_sot_length);
+            }
+            else {
+                OPJ_BYTE *l_new_current_data = (OPJ_BYTE *) opj_realloc(*l_current_data, *l_tile_len + p_j2k->m_specific_param.m_decoder.m_sot_length);
+                if (! l_new_current_data) {
+                        opj_free(*l_current_data);
+                        /*nothing more is done as l_current_data will be set to null, and just
+                          afterward we enter in the error path
+                          and the actual tile_len is updated (committed) at the end of the
+                          function. */
+                }
+                *l_current_data = l_new_current_data;
+            }
+            
+            if (*l_current_data == 00) {
+                opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to decode tile\n");
+                return OPJ_FALSE;
+            }
+        }
+        else {
+            l_sot_length_pb_detected = OPJ_TRUE;
+        }
+
+        /* Index */
+        l_cstr_index = p_j2k->cstr_index;
+        if (l_cstr_index) {
+                OPJ_OFF_T l_current_pos = opj_stream_tell(p_stream) - 2;
+
+                OPJ_UINT32 l_current_tile_part = l_cstr_index->tile_index[p_j2k->m_current_tile_number].current_tpsno;
+                l_cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index[l_current_tile_part].end_header =
+                                l_current_pos;
+                l_cstr_index->tile_index[p_j2k->m_current_tile_number].tp_index[l_current_tile_part].end_pos =
+                                l_current_pos + p_j2k->m_specific_param.m_decoder.m_sot_length + 2;
+
+                if (OPJ_FALSE == opj_j2k_add_tlmarker(p_j2k->m_current_tile_number,
+                                        l_cstr_index,
+                                        J2K_MS_SOD,
+                                        l_current_pos,
+                                        p_j2k->m_specific_param.m_decoder.m_sot_length + 2)) {
+                        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to add tl marker\n");
+                        return OPJ_FALSE;
+                }
+
+                /*l_cstr_index->packno = 0;*/
+        }
+
+        /* Patch to support new PHR data */
+        if (!l_sot_length_pb_detected) {
+            l_current_read_size = opj_stream_read_data(
+                        p_stream,
+                        *l_current_data + *l_tile_len,
+                        p_j2k->m_specific_param.m_decoder.m_sot_length,
+                        p_manager);
+        }
+        else
+        {
+            l_current_read_size = 0;
+        }
+
+        if (l_current_read_size != p_j2k->m_specific_param.m_decoder.m_sot_length) {
+                p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_NEOC;
+        }
+        else {
+                p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_TPHSOT;
+        }
+
+        *l_tile_len += (OPJ_UINT32)l_current_read_size;
+
+        return OPJ_TRUE;
+}
+
+ OPJ_BOOL opj_j2k_write_rgn(opj_j2k_t *p_j2k,
+                            OPJ_UINT32 p_tile_no,
+                            OPJ_UINT32 p_comp_no,
+                            OPJ_UINT32 nb_comps,
+                            opj_stream_private_t *p_stream,
+                            opj_event_mgr_t * p_manager
+                            )
+{
+        OPJ_BYTE * l_current_data = 00;
+        OPJ_UINT32 l_rgn_size;
+        opj_cp_t *l_cp = 00;
+        opj_tcp_t *l_tcp = 00;
+        opj_tccp_t *l_tccp = 00;
+        OPJ_UINT32 l_comp_room;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_stream != 00);
+
+        l_cp = &(p_j2k->m_cp);
+        l_tcp = &l_cp->tcps[p_tile_no];
+        l_tccp = &l_tcp->tccps[p_comp_no];
+
+        if (nb_comps <= 256) {
+                l_comp_room = 1;
+        }
+        else {
+                l_comp_room = 2;
+        }
+
+        l_rgn_size = 6 + l_comp_room;
+
+        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
+
+        opj_write_bytes(l_current_data,J2K_MS_RGN,2);                                   /* RGN  */
+        l_current_data += 2;
+
+        opj_write_bytes(l_current_data,l_rgn_size-2,2);                                 /* Lrgn */
+        l_current_data += 2;
+
+        opj_write_bytes(l_current_data,p_comp_no,l_comp_room);                          /* Crgn */
+        l_current_data+=l_comp_room;
+
+        opj_write_bytes(l_current_data, 0,1);                                           /* Srgn */
+        ++l_current_data;
+
+        opj_write_bytes(l_current_data, (OPJ_UINT32)l_tccp->roishift,1);                            /* SPrgn */
+        ++l_current_data;
+
+        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_rgn_size,p_manager) != l_rgn_size) {
+                return OPJ_FALSE;
+        }
+
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_j2k_write_eoc(     opj_j2k_t *p_j2k,
+                            opj_stream_private_t *p_stream,
+                            opj_event_mgr_t * p_manager
+                            )
+{
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_stream != 00);
+
+        opj_write_bytes(p_j2k->m_specific_param.m_encoder.m_header_tile_data,J2K_MS_EOC,2);                                     /* EOC */
+
+/* UniPG>> */
+#ifdef USE_JPWL
+        /* update markers struct */
+        /*
+        OPJ_BOOL res = j2k_add_marker(p_j2k->cstr_info, J2K_MS_EOC, p_stream_tell(p_stream) - 2, 2);
+*/
+#endif /* USE_JPWL */
+
+        if ( opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,2,p_manager) != 2) {
+                return OPJ_FALSE;
+        }
+
+        if ( ! opj_stream_flush(p_stream,p_manager) ) {
+                return OPJ_FALSE;
+        }
+
+        return OPJ_TRUE;
+}
+
+/**
+ * Reads a RGN marker (Region Of Interest)
+ *
+ * @param       p_header_data   the data contained in the POC box.
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_header_size   the size of the data contained in the POC marker.
+ * @param       p_manager               the user event manager.
+*/
+static OPJ_BOOL opj_j2k_read_rgn (opj_j2k_t *p_j2k,
+                                  OPJ_BYTE * p_header_data,
+                                  OPJ_UINT32 p_header_size,
+                                  opj_event_mgr_t * p_manager
+                                  )
+{
+        OPJ_UINT32 l_nb_comp;
+        opj_image_t * l_image = 00;
+
+        opj_cp_t *l_cp = 00;
+        opj_tcp_t *l_tcp = 00;
+        OPJ_UINT32 l_comp_room, l_comp_no, l_roi_sty;
+
+        /* preconditions*/
+        assert(p_header_data != 00);
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+
+        l_image = p_j2k->m_private_image;
+        l_nb_comp = l_image->numcomps;
+
+        if (l_nb_comp <= 256) {
+                l_comp_room = 1; }
+        else {
+                l_comp_room = 2; }
+
+        if (p_header_size != 2 + l_comp_room) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading RGN marker\n");
+                return OPJ_FALSE;
+        }
+
+        l_cp = &(p_j2k->m_cp);
+        l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ?
+                                &l_cp->tcps[p_j2k->m_current_tile_number] :
+                                p_j2k->m_specific_param.m_decoder.m_default_tcp;
+
+        opj_read_bytes(p_header_data,&l_comp_no,l_comp_room);           /* Crgn */
+        p_header_data+=l_comp_room;
+        opj_read_bytes(p_header_data,&l_roi_sty,1);                                     /* Srgn */
+        ++p_header_data;
+
+#ifdef USE_JPWL
+        if (l_cp->correct) {
+                /* totlen is negative or larger than the bytes left!!! */
+                if (l_comp_room >= l_nb_comp) {
+                        opj_event_msg(p_manager, EVT_ERROR,
+                                "JPWL: bad component number in RGN (%d when there are only %d)\n",
+                                l_comp_room, l_nb_comp);
+                        if (!JPWL_ASSUME || JPWL_ASSUME) {
+                                opj_event_msg(p_manager, EVT_ERROR, "JPWL: giving up\n");
+                                return OPJ_FALSE;
+                        }
+                }
+        };
+#endif /* USE_JPWL */
+
+        /* testcase 3635.pdf.asan.77.2930 */
+        if (l_comp_no >= l_nb_comp) {
+                opj_event_msg(p_manager, EVT_ERROR,
+                        "bad component number in RGN (%d when there are only %d)\n",
+                        l_comp_no, l_nb_comp);
+                return OPJ_FALSE;
+        }
+
+        opj_read_bytes(p_header_data,(OPJ_UINT32 *) (&(l_tcp->tccps[l_comp_no].roishift)),1);   /* SPrgn */
+        ++p_header_data;
+
+        return OPJ_TRUE;
+
+}
+
+OPJ_FLOAT32 opj_j2k_get_tp_stride (opj_tcp_t * p_tcp)
+{
+        return (OPJ_FLOAT32) ((p_tcp->m_nb_tile_parts - 1) * 14);
+}
+
+OPJ_FLOAT32 opj_j2k_get_default_stride (opj_tcp_t * p_tcp)
+{
+    (void)p_tcp;
+    return 0;
+}
+
+OPJ_BOOL opj_j2k_update_rates(  opj_j2k_t *p_j2k,
+                                                            opj_stream_private_t *p_stream,
+                                                            opj_event_mgr_t * p_manager )
+{
+        opj_cp_t * l_cp = 00;
+        opj_image_t * l_image = 00;
+        opj_tcp_t * l_tcp = 00;
+        opj_image_comp_t * l_img_comp = 00;
+
+        OPJ_UINT32 i,j,k;
+        OPJ_INT32 l_x0,l_y0,l_x1,l_y1;
+        OPJ_FLOAT32 * l_rates = 0;
+        OPJ_FLOAT32 l_sot_remove;
+        OPJ_UINT32 l_bits_empty, l_size_pixel;
+        OPJ_UINT32 l_tile_size = 0;
+        OPJ_UINT32 l_last_res;
+        OPJ_FLOAT32 (* l_tp_stride_func)(opj_tcp_t *) = 00;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_stream != 00);
+
+        l_cp = &(p_j2k->m_cp);
+        l_image = p_j2k->m_private_image;
+        l_tcp = l_cp->tcps;
+
+        l_bits_empty = 8 * l_image->comps->dx * l_image->comps->dy;
+        l_size_pixel = l_image->numcomps * l_image->comps->prec;
+        l_sot_remove = (OPJ_FLOAT32) opj_stream_tell(p_stream) / (OPJ_FLOAT32)(l_cp->th * l_cp->tw);
+
+        if (l_cp->m_specific_param.m_enc.m_tp_on) {
+                l_tp_stride_func = opj_j2k_get_tp_stride;
+        }
+        else {
+                l_tp_stride_func = opj_j2k_get_default_stride;
+        }
+
+        for (i=0;i<l_cp->th;++i) {
+                for (j=0;j<l_cp->tw;++j) {
+                        OPJ_FLOAT32 l_offset = (OPJ_FLOAT32)(*l_tp_stride_func)(l_tcp) / (OPJ_FLOAT32)l_tcp->numlayers;
+
+                        /* 4 borders of the tile rescale on the image if necessary */
+                        l_x0 = opj_int_max((OPJ_INT32)(l_cp->tx0 + j * l_cp->tdx), (OPJ_INT32)l_image->x0);
+                        l_y0 = opj_int_max((OPJ_INT32)(l_cp->ty0 + i * l_cp->tdy), (OPJ_INT32)l_image->y0);
+                        l_x1 = opj_int_min((OPJ_INT32)(l_cp->tx0 + (j + 1) * l_cp->tdx), (OPJ_INT32)l_image->x1);
+                        l_y1 = opj_int_min((OPJ_INT32)(l_cp->ty0 + (i + 1) * l_cp->tdy), (OPJ_INT32)l_image->y1);
+
+                        l_rates = l_tcp->rates;
+
+                        /* Modification of the RATE >> */
+                        if (*l_rates) {
+                                *l_rates =              (( (OPJ_FLOAT32) (l_size_pixel * (OPJ_UINT32)(l_x1 - l_x0) * (OPJ_UINT32)(l_y1 - l_y0)))
+                                                                /
+                                                                ((*l_rates) * (OPJ_FLOAT32)l_bits_empty)
+                                                                )
+                                                                -
+                                                                l_offset;
+                        }
+
+                        ++l_rates;
+
+                        for (k = 1; k < l_tcp->numlayers; ++k) {
+                                if (*l_rates) {
+                                        *l_rates =              (( (OPJ_FLOAT32) (l_size_pixel * (OPJ_UINT32)(l_x1 - l_x0) * (OPJ_UINT32)(l_y1 - l_y0)))
+                                                                        /
+                                                                                ((*l_rates) * (OPJ_FLOAT32)l_bits_empty)
+                                                                        )
+                                                                        -
+                                                                        l_offset;
+                                }
+
+                                ++l_rates;
+                        }
+
+                        ++l_tcp;
+
+                }
+        }
+
+        l_tcp = l_cp->tcps;
+
+        for (i=0;i<l_cp->th;++i) {
+                for     (j=0;j<l_cp->tw;++j) {
+                        l_rates = l_tcp->rates;
+
+                        if (*l_rates) {
+                                *l_rates -= l_sot_remove;
+
+                                if (*l_rates < 30) {
+                                        *l_rates = 30;
+                                }
+                        }
+
+                        ++l_rates;
+
+                        l_last_res = l_tcp->numlayers - 1;
+
+                        for (k = 1; k < l_last_res; ++k) {
+
+                                if (*l_rates) {
+                                        *l_rates -= l_sot_remove;
+
+                                        if (*l_rates < *(l_rates - 1) + 10) {
+                                                *l_rates  = (*(l_rates - 1)) + 20;
+                                        }
+                                }
+
+                                ++l_rates;
+                        }
+
+                        if (*l_rates) {
+                                *l_rates -= (l_sot_remove + 2.f);
+
+                                if (*l_rates < *(l_rates - 1) + 10) {
+                                        *l_rates  = (*(l_rates - 1)) + 20;
+                                }
+                        }
+
+                        ++l_tcp;
+                }
+        }
+
+        l_img_comp = l_image->comps;
+        l_tile_size = 0;
+
+        for (i=0;i<l_image->numcomps;++i) {
+                l_tile_size += (        opj_uint_ceildiv(l_cp->tdx,l_img_comp->dx)
+                                                        *
+                                                        opj_uint_ceildiv(l_cp->tdy,l_img_comp->dy)
+                                                        *
+                                                        l_img_comp->prec
+                                                );
+
+                ++l_img_comp;
+        }
+
+        l_tile_size = (OPJ_UINT32) (l_tile_size * 0.1625); /* 1.3/8 = 0.1625 */
+
+        l_tile_size += opj_j2k_get_specific_header_sizes(p_j2k);
+
+        p_j2k->m_specific_param.m_encoder.m_encoded_tile_size = l_tile_size;
+        p_j2k->m_specific_param.m_encoder.m_encoded_tile_data =
+                        (OPJ_BYTE *) opj_malloc(p_j2k->m_specific_param.m_encoder.m_encoded_tile_size);
+        if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data == 00) {
+                return OPJ_FALSE;
+        }
+
+        if (OPJ_IS_CINEMA(l_cp->rsiz)) {
+                p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer =
+                                (OPJ_BYTE *) opj_malloc(5*p_j2k->m_specific_param.m_encoder.m_total_tile_parts);
+                if (! p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {
+                        return OPJ_FALSE;
+                }
+
+                p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current =
+                                p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer;
+        }
+
+        return OPJ_TRUE;
+}
+
+#if 0
+OPJ_BOOL opj_j2k_read_eoc (     opj_j2k_t *p_j2k,
+                                                        opj_stream_private_t *p_stream,
+                                                        opj_event_mgr_t * p_manager )
+{
+        OPJ_UINT32 i;
+        opj_tcd_t * l_tcd = 00;
+        OPJ_UINT32 l_nb_tiles;
+        opj_tcp_t * l_tcp = 00;
+        OPJ_BOOL l_success;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_stream != 00);
+
+        l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
+        l_tcp = p_j2k->m_cp.tcps;
+
+        l_tcd = opj_tcd_create(OPJ_TRUE);
+        if (l_tcd == 00) {
+                opj_event_msg(p_manager, EVT_ERROR, "Cannot decode tile, memory error\n");
+                return OPJ_FALSE;
+        }
+
+        for (i = 0; i < l_nb_tiles; ++i) {
+                if (l_tcp->m_data) {
+                        if (! opj_tcd_init_decode_tile(l_tcd, i)) {
+                                opj_tcd_destroy(l_tcd);
+                                opj_event_msg(p_manager, EVT_ERROR, "Cannot decode tile, memory error\n");
+                                return OPJ_FALSE;
+                        }
+
+                        l_success = opj_tcd_decode_tile(l_tcd, l_tcp->m_data, l_tcp->m_data_size, i, p_j2k->cstr_index);
+                        /* cleanup */
+
+                        if (! l_success) {
+                                p_j2k->m_specific_param.m_decoder.m_state |= J2K_STATE_ERR;
+                                break;
+                        }
+                }
+
+                opj_j2k_tcp_destroy(l_tcp);
+                ++l_tcp;
+        }
+
+        opj_tcd_destroy(l_tcd);
+        return OPJ_TRUE;
+}
+#endif
+
+OPJ_BOOL opj_j2k_get_end_header(opj_j2k_t *p_j2k,
+                                                        struct opj_stream_private *p_stream,
+                                                        struct opj_event_mgr * p_manager )
+{
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_stream != 00);
+
+        p_j2k->cstr_index->main_head_end = opj_stream_tell(p_stream);
+
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_j2k_write_mct_data_group(  opj_j2k_t *p_j2k,
+                                                                        struct opj_stream_private *p_stream,
+                                                                        struct opj_event_mgr * p_manager )
+{
+        OPJ_UINT32 i;
+        opj_simple_mcc_decorrelation_data_t * l_mcc_record;
+        opj_mct_data_t * l_mct_record;
+        opj_tcp_t * l_tcp;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_stream != 00);
+        assert(p_manager != 00);
+
+        if (! opj_j2k_write_cbd(p_j2k,p_stream,p_manager)) {
+                return OPJ_FALSE;
+        }
+
+        l_tcp = &(p_j2k->m_cp.tcps[p_j2k->m_current_tile_number]);
+        l_mct_record = l_tcp->m_mct_records;
+
+        for (i=0;i<l_tcp->m_nb_mct_records;++i) {
+
+                if (! opj_j2k_write_mct_record(p_j2k,l_mct_record,p_stream,p_manager)) {
+                        return OPJ_FALSE;
+                }
+
+                ++l_mct_record;
+        }
+
+        l_mcc_record = l_tcp->m_mcc_records;
+
+        for     (i=0;i<l_tcp->m_nb_mcc_records;++i) {
+
+                if (! opj_j2k_write_mcc_record(p_j2k,l_mcc_record,p_stream,p_manager)) {
+                        return OPJ_FALSE;
+                }
+
+                ++l_mcc_record;
+        }
+
+        if (! opj_j2k_write_mco(p_j2k,p_stream,p_manager)) {
+                return OPJ_FALSE;
+        }
+
+        return OPJ_TRUE;
+}
+
+#if 0
+OPJ_BOOL opj_j2k_write_all_coc(opj_j2k_t *p_j2k,
+                                                                        struct opj_stream_private *p_stream,
+                                                                        struct opj_event_mgr * p_manager )
+{
+        OPJ_UINT32 compno;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_stream != 00);
+
+        for (compno = 0; compno < p_j2k->m_private_image->numcomps; ++compno)
+        {
+                if (! opj_j2k_write_coc(p_j2k,compno,p_stream, p_manager)) {
+                        return OPJ_FALSE;
+                }
+        }
+
+        return OPJ_TRUE;
+}
+#endif
+
+#if 0
+OPJ_BOOL opj_j2k_write_all_qcc(opj_j2k_t *p_j2k,
+                                                                        struct opj_stream_private *p_stream,
+                                                                        struct opj_event_mgr * p_manager )
+{
+        OPJ_UINT32 compno;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_stream != 00);
+
+        for (compno = 0; compno < p_j2k->m_private_image->numcomps; ++compno)
+        {
+                if (! opj_j2k_write_qcc(p_j2k,compno,p_stream, p_manager)) {
+                        return OPJ_FALSE;
+                }
+        }
+
+        return OPJ_TRUE;
+}
+#endif
+
+
+OPJ_BOOL opj_j2k_write_regions( opj_j2k_t *p_j2k,
+                                                        struct opj_stream_private *p_stream,
+                                                        struct opj_event_mgr * p_manager )
+{
+        OPJ_UINT32 compno;
+        const opj_tccp_t *l_tccp = 00;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_stream != 00);
+
+        l_tccp = p_j2k->m_cp.tcps->tccps;
+
+        for     (compno = 0; compno < p_j2k->m_private_image->numcomps; ++compno)  {
+                if (l_tccp->roishift) {
+
+                        if (! opj_j2k_write_rgn(p_j2k,0,compno,p_j2k->m_private_image->numcomps,p_stream,p_manager)) {
+                                return OPJ_FALSE;
+                        }
+                }
+
+                ++l_tccp;
+        }
+
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_j2k_write_epc(     opj_j2k_t *p_j2k,
+                                                struct opj_stream_private *p_stream,
+                                                struct opj_event_mgr * p_manager )
+{
+        opj_codestream_index_t * l_cstr_index = 00;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_stream != 00);
+
+        l_cstr_index = p_j2k->cstr_index;
+        if (l_cstr_index) {
+                l_cstr_index->codestream_size = (OPJ_UINT64)opj_stream_tell(p_stream);
+                /* UniPG>> */
+                /* The following adjustment is done to adjust the codestream size */
+                /* if SOD is not at 0 in the buffer. Useful in case of JP2, where */
+                /* the first bunch of bytes is not in the codestream              */
+                l_cstr_index->codestream_size -= (OPJ_UINT64)l_cstr_index->main_head_start;
+                /* <<UniPG */
+        }
+
+#ifdef USE_JPWL
+        /* preparation of JPWL marker segments */
+#if 0
+        if(cp->epc_on) {
+
+                /* encode according to JPWL */
+                jpwl_encode(p_j2k, p_stream, image);
+
+        }
+#endif
+  assert( 0 && "TODO" );
+#endif /* USE_JPWL */
+
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_j2k_read_unk (     opj_j2k_t *p_j2k,
+                                                        opj_stream_private_t *p_stream,
+                                                        OPJ_UINT32 *output_marker,
+                                                        opj_event_mgr_t * p_manager
+                                                        )
+{
+        OPJ_UINT32 l_unknown_marker;
+        const opj_dec_memory_marker_handler_t * l_marker_handler;
+        OPJ_UINT32 l_size_unk = 2;
+
+        /* preconditions*/
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_stream != 00);
+
+        opj_event_msg(p_manager, EVT_WARNING, "Unknown marker\n");
+
+        while(1) {
+                /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer*/
+                if (opj_stream_read_data(p_stream,p_j2k->m_specific_param.m_decoder.m_header_data,2,p_manager) != 2) {
+                        opj_event_msg(p_manager, EVT_ERROR, "Stream too short\n");
+                        return OPJ_FALSE;
+                }
+
+                /* read 2 bytes as the new marker ID*/
+                opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,&l_unknown_marker,2);
+
+                if (!(l_unknown_marker < 0xff00)) {
+
+                        /* Get the marker handler from the marker ID*/
+                        l_marker_handler = opj_j2k_get_marker_handler(l_unknown_marker);
+
+                        if (!(p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states)) {
+                                opj_event_msg(p_manager, EVT_ERROR, "Marker is not compliant with its position\n");
+                                return OPJ_FALSE;
+                        }
+                        else {
+                                if (l_marker_handler->id != J2K_MS_UNK) {
+                                        /* Add the marker to the codestream index*/
+                                        if (l_marker_handler->id != J2K_MS_SOT)
+                                        {
+                                                OPJ_BOOL res = opj_j2k_add_mhmarker(p_j2k->cstr_index, J2K_MS_UNK,
+                                                                (OPJ_UINT32) opj_stream_tell(p_stream) - l_size_unk,
+                                                                l_size_unk);
+                                                if (res == OPJ_FALSE) {
+                                                        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to add mh marker\n");
+                                                        return OPJ_FALSE;
+                                                }
+                                        }
+                                        break; /* next marker is known and well located */
+                                }
+                                else
+                                        l_size_unk += 2;
+                        }
+                }
+        }
+
+        *output_marker = l_marker_handler->id ;
+
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_j2k_write_mct_record(      opj_j2k_t *p_j2k,
+                                                                opj_mct_data_t * p_mct_record,
+                                                                struct opj_stream_private *p_stream,
+                                                                struct opj_event_mgr * p_manager )
+{
+        OPJ_UINT32 l_mct_size;
+        OPJ_BYTE * l_current_data = 00;
+        OPJ_UINT32 l_tmp;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_stream != 00);
+
+        l_mct_size = 10 + p_mct_record->m_data_size;
+
+        if (l_mct_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
+                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mct_size);
+                if (! new_header_tile_data) {
+                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
+                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;
+                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;
+                        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to write MCT marker\n");
+                        return OPJ_FALSE;
+                }
+                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
+                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mct_size;
+        }
+
+        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
+
+        opj_write_bytes(l_current_data,J2K_MS_MCT,2);                                   /* MCT */
+        l_current_data += 2;
+
+        opj_write_bytes(l_current_data,l_mct_size-2,2);                                 /* Lmct */
+        l_current_data += 2;
+
+        opj_write_bytes(l_current_data,0,2);                                                    /* Zmct */
+        l_current_data += 2;
+
+        /* only one marker atm */
+        l_tmp = (p_mct_record->m_index & 0xff) | (p_mct_record->m_array_type << 8) | (p_mct_record->m_element_type << 10);
+
+        opj_write_bytes(l_current_data,l_tmp,2);
+        l_current_data += 2;
+
+        opj_write_bytes(l_current_data,0,2);                                                    /* Ymct */
+        l_current_data+=2;
+
+        memcpy(l_current_data,p_mct_record->m_data,p_mct_record->m_data_size);
+
+        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_mct_size,p_manager) != l_mct_size) {
+                return OPJ_FALSE;
+        }
+
+        return OPJ_TRUE;
+}
+
+/**
+ * Reads a MCT marker (Multiple Component Transform)
+ *
+ * @param       p_header_data   the data contained in the MCT box.
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_header_size   the size of the data contained in the MCT marker.
+ * @param       p_manager               the user event manager.
+*/
+static OPJ_BOOL opj_j2k_read_mct (      opj_j2k_t *p_j2k,
+                                                                    OPJ_BYTE * p_header_data,
+                                                                    OPJ_UINT32 p_header_size,
+                                                                    opj_event_mgr_t * p_manager
+                                    )
+{
+        OPJ_UINT32 i;
+        opj_tcp_t *l_tcp = 00;
+        OPJ_UINT32 l_tmp;
+        OPJ_UINT32 l_indix;
+        opj_mct_data_t * l_mct_data;
+
+        /* preconditions */
+        assert(p_header_data != 00);
+        assert(p_j2k != 00);
+
+        l_tcp = p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH ?
+                        &p_j2k->m_cp.tcps[p_j2k->m_current_tile_number] :
+                        p_j2k->m_specific_param.m_decoder.m_default_tcp;
+
+        if (p_header_size < 2) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading MCT marker\n");
+                return OPJ_FALSE;
+        }
+
+        /* first marker */
+        opj_read_bytes(p_header_data,&l_tmp,2);                         /* Zmct */
+        p_header_data += 2;
+        if (l_tmp != 0) {
+                opj_event_msg(p_manager, EVT_WARNING, "Cannot take in charge mct data within multiple MCT records\n");
+                return OPJ_TRUE;
+        }
+
+        if(p_header_size <= 6) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading MCT marker\n");
+                return OPJ_FALSE;
+        }
+
+        /* Imct -> no need for other values, take the first, type is double with decorrelation x0000 1101 0000 0000*/
+        opj_read_bytes(p_header_data,&l_tmp,2);                         /* Imct */
+        p_header_data += 2;
+
+        l_indix = l_tmp & 0xff;
+        l_mct_data = l_tcp->m_mct_records;
+
+        for (i=0;i<l_tcp->m_nb_mct_records;++i) {
+                if (l_mct_data->m_index == l_indix) {
+                        break;
+                }
+                ++l_mct_data;
+        }
+
+        /* NOT FOUND */
+        if (i == l_tcp->m_nb_mct_records) {
+                if (l_tcp->m_nb_mct_records == l_tcp->m_nb_max_mct_records) {
+                        opj_mct_data_t *new_mct_records;
+                        l_tcp->m_nb_max_mct_records += OPJ_J2K_MCT_DEFAULT_NB_RECORDS;
+
+                        new_mct_records = (opj_mct_data_t *) opj_realloc(l_tcp->m_mct_records, l_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t));
+                        if (! new_mct_records) {
+                                opj_free(l_tcp->m_mct_records);
+                                l_tcp->m_mct_records = NULL;
+                                l_tcp->m_nb_max_mct_records = 0;
+                                l_tcp->m_nb_mct_records = 0;
+                                opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to read MCT marker\n");
+                                return OPJ_FALSE;
+                        }
+                        l_tcp->m_mct_records = new_mct_records;
+                        l_mct_data = l_tcp->m_mct_records + l_tcp->m_nb_mct_records;
+                        memset(l_mct_data ,0,(l_tcp->m_nb_max_mct_records - l_tcp->m_nb_mct_records) * sizeof(opj_mct_data_t));
+                }
+
+                l_mct_data = l_tcp->m_mct_records + l_tcp->m_nb_mct_records;
+        }
+
+        if (l_mct_data->m_data) {
+                opj_free(l_mct_data->m_data);
+                l_mct_data->m_data = 00;
+        }
+
+        l_mct_data->m_index = l_indix;
+        l_mct_data->m_array_type = (J2K_MCT_ARRAY_TYPE)((l_tmp  >> 8) & 3);
+        l_mct_data->m_element_type = (J2K_MCT_ELEMENT_TYPE)((l_tmp  >> 10) & 3);
+
+        opj_read_bytes(p_header_data,&l_tmp,2);                         /* Ymct */
+        p_header_data+=2;
+        if (l_tmp != 0) {
+                opj_event_msg(p_manager, EVT_WARNING, "Cannot take in charge multiple MCT markers\n");
+                return OPJ_TRUE;
+        }
+
+        p_header_size -= 6;
+
+        l_mct_data->m_data = (OPJ_BYTE*)opj_malloc(p_header_size);
+        if (! l_mct_data->m_data) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading MCT marker\n");
+                return OPJ_FALSE;
+        }
+        memcpy(l_mct_data->m_data,p_header_data,p_header_size);
+
+        l_mct_data->m_data_size = p_header_size;
+        ++l_tcp->m_nb_mct_records;
+
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_j2k_write_mcc_record(      opj_j2k_t *p_j2k,
+                                                                struct opj_simple_mcc_decorrelation_data * p_mcc_record,
+                                                                struct opj_stream_private *p_stream,
+                                                                struct opj_event_mgr * p_manager )
+{
+        OPJ_UINT32 i;
+        OPJ_UINT32 l_mcc_size;
+        OPJ_BYTE * l_current_data = 00;
+        OPJ_UINT32 l_nb_bytes_for_comp;
+        OPJ_UINT32 l_mask;
+        OPJ_UINT32 l_tmcc;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_stream != 00);
+
+        if (p_mcc_record->m_nb_comps > 255 ) {
+        l_nb_bytes_for_comp = 2;
+                l_mask = 0x8000;
+        }
+        else {
+                l_nb_bytes_for_comp = 1;
+                l_mask = 0;
+        }
+
+        l_mcc_size = p_mcc_record->m_nb_comps * 2 * l_nb_bytes_for_comp + 19;
+        if (l_mcc_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size)
+        {
+                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mcc_size);
+                if (! new_header_tile_data) {
+                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
+                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;
+                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;
+                        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to write MCC marker\n");
+                        return OPJ_FALSE;
+                }
+                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
+                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mcc_size;
+        }
+
+        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
+
+        opj_write_bytes(l_current_data,J2K_MS_MCC,2);                                   /* MCC */
+        l_current_data += 2;
+
+        opj_write_bytes(l_current_data,l_mcc_size-2,2);                                 /* Lmcc */
+        l_current_data += 2;
+
+        /* first marker */
+        opj_write_bytes(l_current_data,0,2);                                    /* Zmcc */
+        l_current_data += 2;
+
+        opj_write_bytes(l_current_data,p_mcc_record->m_index,1);                                        /* Imcc -> no need for other values, take the first */
+        ++l_current_data;
+
+        /* only one marker atm */
+        opj_write_bytes(l_current_data,0,2);                                    /* Ymcc */
+        l_current_data+=2;
+
+        opj_write_bytes(l_current_data,1,2);                                    /* Qmcc -> number of collections -> 1 */
+        l_current_data+=2;
+
+        opj_write_bytes(l_current_data,0x1,1);                                  /* Xmcci type of component transformation -> array based decorrelation */
+        ++l_current_data;
+
+        opj_write_bytes(l_current_data,p_mcc_record->m_nb_comps | l_mask,2);    /* Nmcci number of input components involved and size for each component offset = 8 bits */
+        l_current_data+=2;
+
+        for (i=0;i<p_mcc_record->m_nb_comps;++i) {
+                opj_write_bytes(l_current_data,i,l_nb_bytes_for_comp);                          /* Cmccij Component offset*/
+                l_current_data+=l_nb_bytes_for_comp;
+        }
+
+        opj_write_bytes(l_current_data,p_mcc_record->m_nb_comps|l_mask,2);      /* Mmcci number of output components involved and size for each component offset = 8 bits */
+        l_current_data+=2;
+
+        for (i=0;i<p_mcc_record->m_nb_comps;++i)
+        {
+                opj_write_bytes(l_current_data,i,l_nb_bytes_for_comp);                          /* Wmccij Component offset*/
+                l_current_data+=l_nb_bytes_for_comp;
+        }
+
+        l_tmcc = ((!p_mcc_record->m_is_irreversible)&1)<<16;
+
+        if (p_mcc_record->m_decorrelation_array) {
+                l_tmcc |= p_mcc_record->m_decorrelation_array->m_index;
+        }
+
+        if (p_mcc_record->m_offset_array) {
+                l_tmcc |= ((p_mcc_record->m_offset_array->m_index)<<8);
+        }
+
+        opj_write_bytes(l_current_data,l_tmcc,3);       /* Tmcci : use MCT defined as number 1 and irreversible array based. */
+        l_current_data+=3;
+
+        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_mcc_size,p_manager) != l_mcc_size) {
+                return OPJ_FALSE;
+        }
+
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_j2k_read_mcc (     opj_j2k_t *p_j2k,
+                                                OPJ_BYTE * p_header_data,
+                                                OPJ_UINT32 p_header_size,
+                                                opj_event_mgr_t * p_manager )
+{
+        OPJ_UINT32 i,j;
+        OPJ_UINT32 l_tmp;
+        OPJ_UINT32 l_indix;
+        opj_tcp_t * l_tcp;
+        opj_simple_mcc_decorrelation_data_t * l_mcc_record;
+        opj_mct_data_t * l_mct_data;
+        OPJ_UINT32 l_nb_collections;
+        OPJ_UINT32 l_nb_comps;
+        OPJ_UINT32 l_nb_bytes_by_comp;
+
+        /* preconditions */
+        assert(p_header_data != 00);
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+
+        l_tcp = p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH ?
+                        &p_j2k->m_cp.tcps[p_j2k->m_current_tile_number] :
+                        p_j2k->m_specific_param.m_decoder.m_default_tcp;
+
+        if (p_header_size < 2) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading MCC marker\n");
+                return OPJ_FALSE;
+        }
+
+        /* first marker */
+        opj_read_bytes(p_header_data,&l_tmp,2);                         /* Zmcc */
+        p_header_data += 2;
+        if (l_tmp != 0) {
+                opj_event_msg(p_manager, EVT_WARNING, "Cannot take in charge multiple data spanning\n");
+                return OPJ_TRUE;
+        }
+
+        if (p_header_size < 7) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading MCC marker\n");
+                return OPJ_FALSE;
+        }
+
+        opj_read_bytes(p_header_data,&l_indix,1); /* Imcc -> no need for other values, take the first */
+        ++p_header_data;
+
+        l_mcc_record = l_tcp->m_mcc_records;
+
+        for(i=0;i<l_tcp->m_nb_mcc_records;++i) {
+                if (l_mcc_record->m_index == l_indix) {
+                        break;
+                }
+                ++l_mcc_record;
+        }
+
+        /** NOT FOUND */
+        if (i == l_tcp->m_nb_mcc_records) {
+                if (l_tcp->m_nb_mcc_records == l_tcp->m_nb_max_mcc_records) {
+                        opj_simple_mcc_decorrelation_data_t *new_mcc_records;
+                        l_tcp->m_nb_max_mcc_records += OPJ_J2K_MCC_DEFAULT_NB_RECORDS;
+
+                        new_mcc_records = (opj_simple_mcc_decorrelation_data_t *) opj_realloc(
+                                        l_tcp->m_mcc_records, l_tcp->m_nb_max_mcc_records * sizeof(opj_simple_mcc_decorrelation_data_t));
+                        if (! new_mcc_records) {
+                                opj_free(l_tcp->m_mcc_records);
+                                l_tcp->m_mcc_records = NULL;
+                                l_tcp->m_nb_max_mcc_records = 0;
+                                l_tcp->m_nb_mcc_records = 0;
+                                opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to read MCC marker\n");
+                                return OPJ_FALSE;
+                        }
+                        l_tcp->m_mcc_records = new_mcc_records;
+                        l_mcc_record = l_tcp->m_mcc_records + l_tcp->m_nb_mcc_records;
+                        memset(l_mcc_record,0,(l_tcp->m_nb_max_mcc_records-l_tcp->m_nb_mcc_records) * sizeof(opj_simple_mcc_decorrelation_data_t));
+                }
+                l_mcc_record = l_tcp->m_mcc_records + l_tcp->m_nb_mcc_records;
+        }
+        l_mcc_record->m_index = l_indix;
+
+        /* only one marker atm */
+        opj_read_bytes(p_header_data,&l_tmp,2);                         /* Ymcc */
+        p_header_data+=2;
+        if (l_tmp != 0) {
+                opj_event_msg(p_manager, EVT_WARNING, "Cannot take in charge multiple data spanning\n");
+                return OPJ_TRUE;
+        }
+
+        opj_read_bytes(p_header_data,&l_nb_collections,2);                              /* Qmcc -> number of collections -> 1 */
+        p_header_data+=2;
+
+        if (l_nb_collections > 1) {
+                opj_event_msg(p_manager, EVT_WARNING, "Cannot take in charge multiple collections\n");
+                return OPJ_TRUE;
+        }
+
+        p_header_size -= 7;
+
+        for (i=0;i<l_nb_collections;++i) {
+                if (p_header_size < 3) {
+                        opj_event_msg(p_manager, EVT_ERROR, "Error reading MCC marker\n");
+                        return OPJ_FALSE;
+                }
+
+                opj_read_bytes(p_header_data,&l_tmp,1); /* Xmcci type of component transformation -> array based decorrelation */
+                ++p_header_data;
+
+                if (l_tmp != 1) {
+                        opj_event_msg(p_manager, EVT_WARNING, "Cannot take in charge collections other than array decorrelation\n");
+                        return OPJ_TRUE;
+                }
+
+                opj_read_bytes(p_header_data,&l_nb_comps,2);
+
+                p_header_data+=2;
+                p_header_size-=3;
+
+                l_nb_bytes_by_comp = 1 + (l_nb_comps>>15);
+                l_mcc_record->m_nb_comps = l_nb_comps & 0x7fff;
+
+                if (p_header_size < (l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 2)) {
+                        opj_event_msg(p_manager, EVT_ERROR, "Error reading MCC marker\n");
+                        return OPJ_FALSE;
+                }
+
+                p_header_size -= (l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 2);
+
+                for (j=0;j<l_mcc_record->m_nb_comps;++j) {
+                        opj_read_bytes(p_header_data,&l_tmp,l_nb_bytes_by_comp);        /* Cmccij Component offset*/
+                        p_header_data+=l_nb_bytes_by_comp;
+
+                        if (l_tmp != j) {
+                                opj_event_msg(p_manager, EVT_WARNING, "Cannot take in charge collections with indix shuffle\n");
+                                return OPJ_TRUE;
+                        }
+                }
+
+                opj_read_bytes(p_header_data,&l_nb_comps,2);
+                p_header_data+=2;
+
+                l_nb_bytes_by_comp = 1 + (l_nb_comps>>15);
+                l_nb_comps &= 0x7fff;
+
+                if (l_nb_comps != l_mcc_record->m_nb_comps) {
+                        opj_event_msg(p_manager, EVT_WARNING, "Cannot take in charge collections without same number of indixes\n");
+                        return OPJ_TRUE;
+                }
+
+                if (p_header_size < (l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 3)) {
+                        opj_event_msg(p_manager, EVT_ERROR, "Error reading MCC marker\n");
+                        return OPJ_FALSE;
+                }
+
+                p_header_size -= (l_nb_bytes_by_comp * l_mcc_record->m_nb_comps + 3);
+
+                for (j=0;j<l_mcc_record->m_nb_comps;++j) {
+                        opj_read_bytes(p_header_data,&l_tmp,l_nb_bytes_by_comp);        /* Wmccij Component offset*/
+                        p_header_data+=l_nb_bytes_by_comp;
+
+                        if (l_tmp != j) {
+                                opj_event_msg(p_manager, EVT_WARNING, "Cannot take in charge collections with indix shuffle\n");
+                                return OPJ_TRUE;
+                        }
+                }
+
+                opj_read_bytes(p_header_data,&l_tmp,3); /* Wmccij Component offset*/
+                p_header_data += 3;
+
+                l_mcc_record->m_is_irreversible = ! ((l_tmp>>16) & 1);
+                l_mcc_record->m_decorrelation_array = 00;
+                l_mcc_record->m_offset_array = 00;
+
+                l_indix = l_tmp & 0xff;
+                if (l_indix != 0) {
+                        l_mct_data = l_tcp->m_mct_records;
+                        for (j=0;j<l_tcp->m_nb_mct_records;++j) {
+                                if (l_mct_data->m_index == l_indix) {
+                                        l_mcc_record->m_decorrelation_array = l_mct_data;
+                                        break;
+                                }
+                                ++l_mct_data;
+                        }
+
+                        if (l_mcc_record->m_decorrelation_array == 00) {
+                                opj_event_msg(p_manager, EVT_ERROR, "Error reading MCC marker\n");
+                                return OPJ_FALSE;
+                        }
+                }
+
+                l_indix = (l_tmp >> 8) & 0xff;
+                if (l_indix != 0) {
+                        l_mct_data = l_tcp->m_mct_records;
+                        for (j=0;j<l_tcp->m_nb_mct_records;++j) {
+                                if (l_mct_data->m_index == l_indix) {
+                                        l_mcc_record->m_offset_array = l_mct_data;
+                                        break;
+                                }
+                                ++l_mct_data;
+                        }
+
+                        if (l_mcc_record->m_offset_array == 00) {
+                                opj_event_msg(p_manager, EVT_ERROR, "Error reading MCC marker\n");
+                                return OPJ_FALSE;
+                        }
+                }
+        }
+
+        if (p_header_size != 0) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading MCC marker\n");
+                return OPJ_FALSE;
+        }
+
+        ++l_tcp->m_nb_mcc_records;
+
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_j2k_write_mco(     opj_j2k_t *p_j2k,
+                                                struct opj_stream_private *p_stream,
+                                                struct opj_event_mgr * p_manager
+                                  )
+{
+        OPJ_BYTE * l_current_data = 00;
+        OPJ_UINT32 l_mco_size;
+        opj_tcp_t * l_tcp = 00;
+        opj_simple_mcc_decorrelation_data_t * l_mcc_record;
+        OPJ_UINT32 i;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_stream != 00);
+
+        l_tcp =&(p_j2k->m_cp.tcps[p_j2k->m_current_tile_number]);
+        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
+
+        l_mco_size = 5 + l_tcp->m_nb_mcc_records;
+        if (l_mco_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
+
+                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_mco_size);
+                if (! new_header_tile_data) {
+                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
+                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;
+                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;
+                        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to write MCO marker\n");
+                        return OPJ_FALSE;
+                }
+                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
+                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_mco_size;
+        }
+
+        opj_write_bytes(l_current_data,J2K_MS_MCO,2);                   /* MCO */
+        l_current_data += 2;
+
+        opj_write_bytes(l_current_data,l_mco_size-2,2);                 /* Lmco */
+        l_current_data += 2;
+
+        opj_write_bytes(l_current_data,l_tcp->m_nb_mcc_records,1);      /* Nmco : only one tranform stage*/
+        ++l_current_data;
+
+        l_mcc_record = l_tcp->m_mcc_records;
+        for     (i=0;i<l_tcp->m_nb_mcc_records;++i) {
+                opj_write_bytes(l_current_data,l_mcc_record->m_index,1);/* Imco -> use the mcc indicated by 1*/
+                ++l_current_data;
+
+                ++l_mcc_record;
+        }
+
+        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_mco_size,p_manager) != l_mco_size) {
+                return OPJ_FALSE;
+        }
+
+        return OPJ_TRUE;
+}
+
+/**
+ * Reads a MCO marker (Multiple Component Transform Ordering)
+ *
+ * @param       p_header_data   the data contained in the MCO box.
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_header_size   the size of the data contained in the MCO marker.
+ * @param       p_manager               the user event manager.
+*/
+static OPJ_BOOL opj_j2k_read_mco (      opj_j2k_t *p_j2k,
+                                                                    OPJ_BYTE * p_header_data,
+                                                                    OPJ_UINT32 p_header_size,
+                                                                    opj_event_mgr_t * p_manager
+                                    )
+{
+        OPJ_UINT32 l_tmp, i;
+        OPJ_UINT32 l_nb_stages;
+        opj_tcp_t * l_tcp;
+        opj_tccp_t * l_tccp;
+        opj_image_t * l_image;
+
+        /* preconditions */
+        assert(p_header_data != 00);
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+
+        l_image = p_j2k->m_private_image;
+        l_tcp = p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH ?
+                        &p_j2k->m_cp.tcps[p_j2k->m_current_tile_number] :
+                        p_j2k->m_specific_param.m_decoder.m_default_tcp;
+
+        if (p_header_size < 1) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading MCO marker\n");
+                return OPJ_FALSE;
+        }
+
+        opj_read_bytes(p_header_data,&l_nb_stages,1);                           /* Nmco : only one tranform stage*/
+        ++p_header_data;
+
+        if (l_nb_stages > 1) {
+                opj_event_msg(p_manager, EVT_WARNING, "Cannot take in charge multiple transformation stages.\n");
+                return OPJ_TRUE;
+        }
+
+        if (p_header_size != l_nb_stages + 1) {
+                opj_event_msg(p_manager, EVT_WARNING, "Error reading MCO marker\n");
+                return OPJ_FALSE;
+        }
+
+        l_tccp = l_tcp->tccps;
+
+        for (i=0;i<l_image->numcomps;++i) {
+                l_tccp->m_dc_level_shift = 0;
+                ++l_tccp;
+        }
+
+        if (l_tcp->m_mct_decoding_matrix) {
+                opj_free(l_tcp->m_mct_decoding_matrix);
+                l_tcp->m_mct_decoding_matrix = 00;
+        }
+
+        for (i=0;i<l_nb_stages;++i) {
+                opj_read_bytes(p_header_data,&l_tmp,1);
+                ++p_header_data;
+
+                if (! opj_j2k_add_mct(l_tcp,p_j2k->m_private_image,l_tmp)) {
+                        return OPJ_FALSE;
+                }
+        }
+
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_j2k_add_mct(opj_tcp_t * p_tcp, opj_image_t * p_image, OPJ_UINT32 p_index)
+{
+        OPJ_UINT32 i;
+        opj_simple_mcc_decorrelation_data_t * l_mcc_record;
+        opj_mct_data_t * l_deco_array, * l_offset_array;
+        OPJ_UINT32 l_data_size,l_mct_size, l_offset_size;
+        OPJ_UINT32 l_nb_elem;
+        OPJ_UINT32 * l_offset_data, * l_current_offset_data;
+        opj_tccp_t * l_tccp;
+
+        /* preconditions */
+        assert(p_tcp != 00);
+
+        l_mcc_record = p_tcp->m_mcc_records;
+
+        for (i=0;i<p_tcp->m_nb_mcc_records;++i) {
+                if (l_mcc_record->m_index == p_index) {
+                        break;
+                }
+        }
+
+        if (i==p_tcp->m_nb_mcc_records) {
+                /** element discarded **/
+                return OPJ_TRUE;
+        }
+
+        if (l_mcc_record->m_nb_comps != p_image->numcomps) {
+                /** do not support number of comps != image */
+                return OPJ_TRUE;
+        }
+
+        l_deco_array = l_mcc_record->m_decorrelation_array;
+
+        if (l_deco_array) {
+                l_data_size = MCT_ELEMENT_SIZE[l_deco_array->m_element_type] * p_image->numcomps * p_image->numcomps;
+                if (l_deco_array->m_data_size != l_data_size) {
+                        return OPJ_FALSE;
+                }
+
+                l_nb_elem = p_image->numcomps * p_image->numcomps;
+                l_mct_size = l_nb_elem * (OPJ_UINT32)sizeof(OPJ_FLOAT32);
+                p_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32*)opj_malloc(l_mct_size);
+
+                if (! p_tcp->m_mct_decoding_matrix ) {
+                        return OPJ_FALSE;
+                }
+
+                j2k_mct_read_functions_to_float[l_deco_array->m_element_type](l_deco_array->m_data,p_tcp->m_mct_decoding_matrix,l_nb_elem);
+        }
+
+        l_offset_array = l_mcc_record->m_offset_array;
+
+        if (l_offset_array) {
+                l_data_size = MCT_ELEMENT_SIZE[l_offset_array->m_element_type] * p_image->numcomps;
+                if (l_offset_array->m_data_size != l_data_size) {
+                        return OPJ_FALSE;
+                }
+
+                l_nb_elem = p_image->numcomps;
+                l_offset_size = l_nb_elem * (OPJ_UINT32)sizeof(OPJ_UINT32);
+                l_offset_data = (OPJ_UINT32*)opj_malloc(l_offset_size);
+
+                if (! l_offset_data ) {
+                        return OPJ_FALSE;
+                }
+
+                j2k_mct_read_functions_to_int32[l_offset_array->m_element_type](l_offset_array->m_data,l_offset_data,l_nb_elem);
+
+                l_tccp = p_tcp->tccps;
+                l_current_offset_data = l_offset_data;
+
+                for (i=0;i<p_image->numcomps;++i) {
+                        l_tccp->m_dc_level_shift = (OPJ_INT32)*(l_current_offset_data++);
+                        ++l_tccp;
+                }
+
+                opj_free(l_offset_data);
+        }
+
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_j2k_write_cbd( opj_j2k_t *p_j2k,
+                                                struct opj_stream_private *p_stream,
+                                                struct opj_event_mgr * p_manager )
+{
+        OPJ_UINT32 i;
+        OPJ_UINT32 l_cbd_size;
+        OPJ_BYTE * l_current_data = 00;
+        opj_image_t *l_image = 00;
+        opj_image_comp_t * l_comp = 00;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_stream != 00);
+
+        l_image = p_j2k->m_private_image;
+        l_cbd_size = 6 + p_j2k->m_private_image->numcomps;
+
+        if (l_cbd_size > p_j2k->m_specific_param.m_encoder.m_header_tile_data_size) {
+                OPJ_BYTE *new_header_tile_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_encoder.m_header_tile_data, l_cbd_size);
+                if (! new_header_tile_data) {
+                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
+                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = NULL;
+                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;
+                        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to write CBD marker\n");
+                        return OPJ_FALSE;
+                }
+                p_j2k->m_specific_param.m_encoder.m_header_tile_data = new_header_tile_data;
+                p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = l_cbd_size;
+        }
+
+        l_current_data = p_j2k->m_specific_param.m_encoder.m_header_tile_data;
+
+        opj_write_bytes(l_current_data,J2K_MS_CBD,2);                   /* CBD */
+        l_current_data += 2;
+
+        opj_write_bytes(l_current_data,l_cbd_size-2,2);                 /* L_CBD */
+        l_current_data += 2;
+
+        opj_write_bytes(l_current_data,l_image->numcomps, 2);           /* Ncbd */
+        l_current_data+=2;
+
+        l_comp = l_image->comps;
+
+        for (i=0;i<l_image->numcomps;++i) {
+                opj_write_bytes(l_current_data, (l_comp->sgnd << 7) | (l_comp->prec - 1), 1);           /* Component bit depth */
+                ++l_current_data;
+
+                ++l_comp;
+        }
+
+        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_header_tile_data,l_cbd_size,p_manager) != l_cbd_size) {
+                return OPJ_FALSE;
+        }
+
+        return OPJ_TRUE;
+}
+
+/**
+ * Reads a CBD marker (Component bit depth definition)
+ * @param       p_header_data   the data contained in the CBD box.
+ * @param       p_j2k                   the jpeg2000 codec.
+ * @param       p_header_size   the size of the data contained in the CBD marker.
+ * @param       p_manager               the user event manager.
+*/
+static OPJ_BOOL opj_j2k_read_cbd (      opj_j2k_t *p_j2k,
+                                                                OPJ_BYTE * p_header_data,
+                                                                OPJ_UINT32 p_header_size,
+                                                                opj_event_mgr_t * p_manager
+                                    )
+{
+        OPJ_UINT32 l_nb_comp,l_num_comp;
+        OPJ_UINT32 l_comp_def;
+        OPJ_UINT32 i;
+        opj_image_comp_t * l_comp = 00;
+
+        /* preconditions */
+        assert(p_header_data != 00);
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+
+        l_num_comp = p_j2k->m_private_image->numcomps;
+
+        if (p_header_size != (p_j2k->m_private_image->numcomps + 2)) {
+                opj_event_msg(p_manager, EVT_ERROR, "Crror reading CBD marker\n");
+                return OPJ_FALSE;
+        }
+
+        opj_read_bytes(p_header_data,&l_nb_comp,2);                             /* Ncbd */
+        p_header_data+=2;
+
+        if (l_nb_comp != l_num_comp) {
+                opj_event_msg(p_manager, EVT_ERROR, "Crror reading CBD marker\n");
+                return OPJ_FALSE;
+        }
+
+        l_comp = p_j2k->m_private_image->comps;
+        for (i=0;i<l_num_comp;++i) {
+                opj_read_bytes(p_header_data,&l_comp_def,1);                    /* Component bit depth */
+                ++p_header_data;
+        l_comp->sgnd = (l_comp_def>>7) & 1;
+                l_comp->prec = (l_comp_def&0x7f) + 1;
+                ++l_comp;
+        }
+
+        return OPJ_TRUE;
+}
+
+/* ----------------------------------------------------------------------- */
+/* J2K / JPT decoder interface                                             */
+/* ----------------------------------------------------------------------- */
+
+void opj_j2k_setup_decoder(opj_j2k_t *j2k, opj_dparameters_t *parameters)
+{
+        if(j2k && parameters) {
+                j2k->m_cp.m_specific_param.m_dec.m_layer = parameters->cp_layer;
+                j2k->m_cp.m_specific_param.m_dec.m_reduce = parameters->cp_reduce;
+
+#ifdef USE_JPWL
+                j2k->m_cp.correct = parameters->jpwl_correct;
+                j2k->m_cp.exp_comps = parameters->jpwl_exp_comps;
+                j2k->m_cp.max_tiles = parameters->jpwl_max_tiles;
+#endif /* USE_JPWL */
+        }
+}
+
+/* ----------------------------------------------------------------------- */
+/* J2K encoder interface                                                       */
+/* ----------------------------------------------------------------------- */
+
+opj_j2k_t* opj_j2k_create_compress(void)
+{
+        opj_j2k_t *l_j2k = (opj_j2k_t*) opj_malloc(sizeof(opj_j2k_t));
+        if (!l_j2k) {
+                return NULL;
+        }
+
+        memset(l_j2k,0,sizeof(opj_j2k_t));
+
+        l_j2k->m_is_decoder = 0;
+        l_j2k->m_cp.m_is_decoder = 0;
+
+        l_j2k->m_specific_param.m_encoder.m_header_tile_data = (OPJ_BYTE *) opj_malloc(OPJ_J2K_DEFAULT_HEADER_SIZE);
+        if (! l_j2k->m_specific_param.m_encoder.m_header_tile_data) {
+                opj_j2k_destroy(l_j2k);
+                return NULL;
+        }
+
+        l_j2k->m_specific_param.m_encoder.m_header_tile_data_size = OPJ_J2K_DEFAULT_HEADER_SIZE;
+
+        /* validation list creation*/
+        l_j2k->m_validation_list = opj_procedure_list_create();
+        if (! l_j2k->m_validation_list) {
+                opj_j2k_destroy(l_j2k);
+                return NULL;
+        }
+
+        /* execution list creation*/
+        l_j2k->m_procedure_list = opj_procedure_list_create();
+        if (! l_j2k->m_procedure_list) {
+                opj_j2k_destroy(l_j2k);
+                return NULL;
+        }
+
+        return l_j2k;
+}
+
+int opj_j2k_initialise_4K_poc(opj_poc_t *POC, int numres){
+    POC[0].tile  = 1;
+    POC[0].resno0  = 0;
+    POC[0].compno0 = 0;
+    POC[0].layno1  = 1;
+    POC[0].resno1  = (OPJ_UINT32)(numres-1);
+    POC[0].compno1 = 3;
+    POC[0].prg1 = OPJ_CPRL;
+    POC[1].tile  = 1;
+    POC[1].resno0  = (OPJ_UINT32)(numres-1);
+    POC[1].compno0 = 0;
+    POC[1].layno1  = 1;
+    POC[1].resno1  = (OPJ_UINT32)numres;
+    POC[1].compno1 = 3;
+    POC[1].prg1 = OPJ_CPRL;
+    return 2;
+}
+
+void opj_j2k_set_cinema_parameters(opj_cparameters_t *parameters, opj_image_t *image, opj_event_mgr_t *p_manager)
+{
+    /* Configure cinema parameters */
+    int i;
+
+    /* No tiling */
+    parameters->tile_size_on = OPJ_FALSE;
+    parameters->cp_tdx=1;
+    parameters->cp_tdy=1;
+
+    /* One tile part for each component */
+    parameters->tp_flag = 'C';
+    parameters->tp_on = 1;
+
+    /* Tile and Image shall be at (0,0) */
+    parameters->cp_tx0 = 0;
+    parameters->cp_ty0 = 0;
+    parameters->image_offset_x0 = 0;
+    parameters->image_offset_y0 = 0;
+
+    /* Codeblock size= 32*32 */
+    parameters->cblockw_init = 32;
+    parameters->cblockh_init = 32;
+
+    /* Codeblock style: no mode switch enabled */
+    parameters->mode = 0;
+
+    /* No ROI */
+    parameters->roi_compno = -1;
+
+    /* No subsampling */
+    parameters->subsampling_dx = 1;
+    parameters->subsampling_dy = 1;
+
+    /* 9-7 transform */
+    parameters->irreversible = 1;
+
+    /* Number of layers */
+    if (parameters->tcp_numlayers > 1){
+        opj_event_msg(p_manager, EVT_WARNING,
+                "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n"
+                "1 single quality layer"
+                "-> Number of layers forced to 1 (rather than %d)\n"
+                "-> Rate of the last layer (%3.1f) will be used",
+                parameters->tcp_numlayers, parameters->tcp_rates[parameters->tcp_numlayers-1]);
+        parameters->tcp_rates[0] = parameters->tcp_rates[parameters->tcp_numlayers-1];
+        parameters->tcp_numlayers = 1;
+    }
+
+    /* Resolution levels */
+    switch (parameters->rsiz){
+    case OPJ_PROFILE_CINEMA_2K:
+        if(parameters->numresolution > 6){
+            opj_event_msg(p_manager, EVT_WARNING,
+                    "JPEG 2000 Profile-3 (2k dc profile) requires:\n"
+                    "Number of decomposition levels <= 5\n"
+                    "-> Number of decomposition levels forced to 5 (rather than %d)\n",
+                    parameters->numresolution+1);
+            parameters->numresolution = 6;
+        }
+        break;
+    case OPJ_PROFILE_CINEMA_4K:
+        if(parameters->numresolution < 2){
+            opj_event_msg(p_manager, EVT_WARNING,
+                    "JPEG 2000 Profile-4 (4k dc profile) requires:\n"
+                    "Number of decomposition levels >= 1 && <= 6\n"
+                    "-> Number of decomposition levels forced to 1 (rather than %d)\n",
+                    parameters->numresolution+1);
+            parameters->numresolution = 1;
+        }else if(parameters->numresolution > 7){
+            opj_event_msg(p_manager, EVT_WARNING,
+                    "JPEG 2000 Profile-4 (4k dc profile) requires:\n"
+                    "Number of decomposition levels >= 1 && <= 6\n"
+                    "-> Number of decomposition levels forced to 6 (rather than %d)\n",
+                    parameters->numresolution+1);
+            parameters->numresolution = 7;
+        }
+        break;
+    default :
+        break;
+    }
+
+    /* Precincts */
+    parameters->csty |= 0x01;
+    parameters->res_spec = parameters->numresolution-1;
+    for (i = 0; i<parameters->res_spec; i++) {
+        parameters->prcw_init[i] = 256;
+        parameters->prch_init[i] = 256;
+    }
+
+    /* The progression order shall be CPRL */
+    parameters->prog_order = OPJ_CPRL;
+
+    /* Progression order changes for 4K, disallowed for 2K */
+    if (parameters->rsiz == OPJ_PROFILE_CINEMA_4K) {
+        parameters->numpocs = (OPJ_UINT32)opj_j2k_initialise_4K_poc(parameters->POC,parameters->numresolution);
+    } else {
+        parameters->numpocs = 0;
+    }
+
+    /* Limited bit-rate */
+    parameters->cp_disto_alloc = 1;
+    if (parameters->max_cs_size <= 0) {
+        /* No rate has been introduced, 24 fps is assumed */
+        parameters->max_cs_size = OPJ_CINEMA_24_CS;
+        opj_event_msg(p_manager, EVT_WARNING,
+                      "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n"
+                      "Maximum 1302083 compressed bytes @ 24fps\n"
+                      "As no rate has been given, this limit will be used.\n");
+    } else if (parameters->max_cs_size > OPJ_CINEMA_24_CS) {
+        opj_event_msg(p_manager, EVT_WARNING,
+                      "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n"
+                      "Maximum 1302083 compressed bytes @ 24fps\n"
+                      "-> Specified rate exceeds this limit. Rate will be forced to 1302083 bytes.\n");
+        parameters->max_cs_size = OPJ_CINEMA_24_CS;
+    }
+
+    if (parameters->max_comp_size <= 0) {
+        /* No rate has been introduced, 24 fps is assumed */
+        parameters->max_comp_size = OPJ_CINEMA_24_COMP;
+        opj_event_msg(p_manager, EVT_WARNING,
+                      "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n"
+                      "Maximum 1041666 compressed bytes @ 24fps\n"
+                      "As no rate has been given, this limit will be used.\n");
+    } else if (parameters->max_comp_size > OPJ_CINEMA_24_COMP) {
+        opj_event_msg(p_manager, EVT_WARNING,
+                      "JPEG 2000 Profile-3 and 4 (2k/4k dc profile) requires:\n"
+                      "Maximum 1041666 compressed bytes @ 24fps\n"
+                      "-> Specified rate exceeds this limit. Rate will be forced to 1041666 bytes.\n");
+        parameters->max_comp_size = OPJ_CINEMA_24_COMP;
+    }
+
+    parameters->tcp_rates[0] = (OPJ_FLOAT32) (image->numcomps * image->comps[0].w * image->comps[0].h * image->comps[0].prec)/
+            (OPJ_FLOAT32)(((OPJ_UINT32)parameters->max_cs_size) * 8 * image->comps[0].dx * image->comps[0].dy);
+
+}
+
+OPJ_BOOL opj_j2k_is_cinema_compliant(opj_image_t *image, OPJ_UINT16 rsiz, opj_event_mgr_t *p_manager)
+{
+    OPJ_UINT32 i;
+
+    /* Number of components */
+    if (image->numcomps != 3){
+        opj_event_msg(p_manager, EVT_WARNING,
+                "JPEG 2000 Profile-3 (2k dc profile) requires:\n"
+                "3 components"
+                "-> Number of components of input image (%d) is not compliant\n"
+                "-> Non-profile-3 codestream will be generated\n",
+                image->numcomps);
+        return OPJ_FALSE;
+    }
+
+    /* Bitdepth */
+    for (i = 0; i < image->numcomps; i++) {
+        if ((image->comps[i].bpp != 12) | (image->comps[i].sgnd)){
+            char signed_str[] = "signed";
+            char unsigned_str[] = "unsigned";
+            char *tmp_str = image->comps[i].sgnd?signed_str:unsigned_str;
+            opj_event_msg(p_manager, EVT_WARNING,
+                    "JPEG 2000 Profile-3 (2k dc profile) requires:\n"
+                    "Precision of each component shall be 12 bits unsigned"
+                    "-> At least component %d of input image (%d bits, %s) is not compliant\n"
+                    "-> Non-profile-3 codestream will be generated\n",
+                    i,image->comps[i].bpp, tmp_str);
+            return OPJ_FALSE;
+        }
+    }
+
+    /* Image size */
+    switch (rsiz){
+    case OPJ_PROFILE_CINEMA_2K:
+        if (((image->comps[0].w > 2048) | (image->comps[0].h > 1080))){
+            opj_event_msg(p_manager, EVT_WARNING,
+                    "JPEG 2000 Profile-3 (2k dc profile) requires:\n"
+                    "width <= 2048 and height <= 1080\n"
+                    "-> Input image size %d x %d is not compliant\n"
+                    "-> Non-profile-3 codestream will be generated\n",
+                    image->comps[0].w,image->comps[0].h);
+            return OPJ_FALSE;
+        }
+        break;
+    case OPJ_PROFILE_CINEMA_4K:
+        if (((image->comps[0].w > 4096) | (image->comps[0].h > 2160))){
+            opj_event_msg(p_manager, EVT_WARNING,
+                    "JPEG 2000 Profile-4 (4k dc profile) requires:\n"
+                    "width <= 4096 and height <= 2160\n"
+                    "-> Image size %d x %d is not compliant\n"
+                    "-> Non-profile-4 codestream will be generated\n",
+                    image->comps[0].w,image->comps[0].h);
+            return OPJ_FALSE;
+        }
+        break;
+    default :
+        break;
+    }
+
+    return OPJ_TRUE;
+}
+
+void opj_j2k_setup_encoder(     opj_j2k_t *p_j2k,
+                                                    opj_cparameters_t *parameters,
+                                                    opj_image_t *image,
+                                                    opj_event_mgr_t * p_manager)
+{
+        OPJ_UINT32 i, j, tileno, numpocs_tile;
+        opj_cp_t *cp = 00;
+
+        if(!p_j2k || !parameters || ! image) {
+                return;
+        }
+
+        /* keep a link to cp so that we can destroy it later in j2k_destroy_compress */
+        cp = &(p_j2k->m_cp);
+
+        /* set default values for cp */
+        cp->tw = 1;
+        cp->th = 1;
+
+        /* FIXME ADE: to be removed once deprecated cp_cinema and cp_rsiz have been removed */
+        if (parameters->rsiz == OPJ_PROFILE_NONE) { /* consider deprecated fields only if RSIZ has not been set */
+            OPJ_BOOL deprecated_used = OPJ_FALSE;
+            switch (parameters->cp_cinema){
+            case OPJ_CINEMA2K_24:
+                parameters->rsiz = OPJ_PROFILE_CINEMA_2K;
+                parameters->max_cs_size = OPJ_CINEMA_24_CS;
+                parameters->max_comp_size = OPJ_CINEMA_24_COMP;
+                deprecated_used = OPJ_TRUE;
+                break;
+            case OPJ_CINEMA2K_48:
+                parameters->rsiz = OPJ_PROFILE_CINEMA_2K;
+                parameters->max_cs_size = OPJ_CINEMA_48_CS;
+                parameters->max_comp_size = OPJ_CINEMA_48_COMP;
+                deprecated_used = OPJ_TRUE;
+                break;
+            case OPJ_CINEMA4K_24:
+                parameters->rsiz = OPJ_PROFILE_CINEMA_4K;
+                parameters->max_cs_size = OPJ_CINEMA_24_CS;
+                parameters->max_comp_size = OPJ_CINEMA_24_COMP;
+                deprecated_used = OPJ_TRUE;
+                break;
+            case OPJ_OFF:
+            default:
+                break;
+            }
+            switch (parameters->cp_rsiz){
+            case OPJ_CINEMA2K:
+                parameters->rsiz = OPJ_PROFILE_CINEMA_2K;
+                deprecated_used = OPJ_TRUE;
+                break;
+            case OPJ_CINEMA4K:
+                parameters->rsiz = OPJ_PROFILE_CINEMA_4K;
+                deprecated_used = OPJ_TRUE;
+                break;
+            case OPJ_MCT:
+                parameters->rsiz = OPJ_PROFILE_PART2 | OPJ_EXTENSION_MCT;
+                deprecated_used = OPJ_TRUE;
+            case OPJ_STD_RSIZ:
+            default:
+                break;
+            }
+            if (deprecated_used) {
+                opj_event_msg(p_manager, EVT_WARNING,
+                        "Deprecated fields cp_cinema or cp_rsiz are used\n"
+                        "Please consider using only the rsiz field\n"
+                        "See openjpeg.h documentation for more details\n");
+            }
+        }
+
+        /* see if max_codestream_size does limit input rate */
+        if (parameters->max_cs_size <= 0) {
+            if (parameters->tcp_rates[parameters->tcp_numlayers-1] > 0) {
+                OPJ_FLOAT32 temp_size;
+                temp_size =(OPJ_FLOAT32)(image->numcomps * image->comps[0].w * image->comps[0].h * image->comps[0].prec)/
+                        (parameters->tcp_rates[parameters->tcp_numlayers-1] * 8 * (OPJ_FLOAT32)image->comps[0].dx * (OPJ_FLOAT32)image->comps[0].dy);
+                parameters->max_cs_size = (int) floor(temp_size);
+            } else {
+                parameters->max_cs_size = 0;
+            }
+        } else {
+            OPJ_FLOAT32 temp_rate;
+            OPJ_BOOL cap = OPJ_FALSE;
+            temp_rate = (OPJ_FLOAT32) (image->numcomps * image->comps[0].w * image->comps[0].h * image->comps[0].prec)/
+                    (OPJ_FLOAT32)(((OPJ_UINT32)parameters->max_cs_size) * 8 * image->comps[0].dx * image->comps[0].dy);
+            for (i = 0; i < (OPJ_UINT32) parameters->tcp_numlayers; i++) {
+                if (parameters->tcp_rates[i] < temp_rate) {
+                    parameters->tcp_rates[i] = temp_rate;
+                    cap = OPJ_TRUE;
+                }
+            }
+            if (cap) {
+                opj_event_msg(p_manager, EVT_WARNING,
+                        "The desired maximum codestream size has limited\n"
+                        "at least one of the desired quality layers\n");
+            }
+        }
+
+        /* Manage profiles and applications and set RSIZ */
+        /* set cinema parameters if required */
+        if (OPJ_IS_CINEMA(parameters->rsiz)){
+            if ((parameters->rsiz == OPJ_PROFILE_CINEMA_S2K)
+                    || (parameters->rsiz == OPJ_PROFILE_CINEMA_S4K)){
+                opj_event_msg(p_manager, EVT_WARNING,
+                        "JPEG 2000 Scalable Digital Cinema profiles not yet supported\n");
+                parameters->rsiz = OPJ_PROFILE_NONE;
+            } else {
+                opj_j2k_set_cinema_parameters(parameters,image,p_manager);
+                if (!opj_j2k_is_cinema_compliant(image,parameters->rsiz,p_manager)) {
+                    parameters->rsiz = OPJ_PROFILE_NONE;
+                }
+            }
+        } else if (OPJ_IS_STORAGE(parameters->rsiz)) {
+            opj_event_msg(p_manager, EVT_WARNING,
+                    "JPEG 2000 Long Term Storage profile not yet supported\n");
+            parameters->rsiz = OPJ_PROFILE_NONE;
+        } else if (OPJ_IS_BROADCAST(parameters->rsiz)) {
+            opj_event_msg(p_manager, EVT_WARNING,
+                    "JPEG 2000 Broadcast profiles not yet supported\n");
+            parameters->rsiz = OPJ_PROFILE_NONE;
+        } else if (OPJ_IS_IMF(parameters->rsiz)) {
+            opj_event_msg(p_manager, EVT_WARNING,
+                    "JPEG 2000 IMF profiles not yet supported\n");
+            parameters->rsiz = OPJ_PROFILE_NONE;
+        } else if (OPJ_IS_PART2(parameters->rsiz)) {
+            if (parameters->rsiz == ((OPJ_PROFILE_PART2) | (OPJ_EXTENSION_NONE))) {
+                opj_event_msg(p_manager, EVT_WARNING,
+                              "JPEG 2000 Part-2 profile defined\n"
+                              "but no Part-2 extension enabled.\n"
+                              "Profile set to NONE.\n");
+                parameters->rsiz = OPJ_PROFILE_NONE;
+            } else if (parameters->rsiz != ((OPJ_PROFILE_PART2) | (OPJ_EXTENSION_MCT))) {
+                opj_event_msg(p_manager, EVT_WARNING,
+                              "Unsupported Part-2 extension enabled\n"
+                              "Profile set to NONE.\n");
+                parameters->rsiz = OPJ_PROFILE_NONE;
+            }
+        }
+
+        /*
+        copy user encoding parameters
+        */
+        cp->m_specific_param.m_enc.m_max_comp_size = (OPJ_UINT32)parameters->max_comp_size;
+        cp->rsiz = parameters->rsiz;
+        cp->m_specific_param.m_enc.m_disto_alloc = (OPJ_UINT32)parameters->cp_disto_alloc & 1u;
+        cp->m_specific_param.m_enc.m_fixed_alloc = (OPJ_UINT32)parameters->cp_fixed_alloc & 1u;
+        cp->m_specific_param.m_enc.m_fixed_quality = (OPJ_UINT32)parameters->cp_fixed_quality & 1u;
+
+        /* mod fixed_quality */
+        if (parameters->cp_fixed_alloc && parameters->cp_matrice) {
+                size_t array_size = (size_t)parameters->tcp_numlayers * (size_t)parameters->numresolution * 3 * sizeof(OPJ_INT32);
+                cp->m_specific_param.m_enc.m_matrice = (OPJ_INT32 *) opj_malloc(array_size);
+                memcpy(cp->m_specific_param.m_enc.m_matrice, parameters->cp_matrice, array_size);
+        }
+
+        /* tiles */
+        cp->tdx = (OPJ_UINT32)parameters->cp_tdx;
+        cp->tdy = (OPJ_UINT32)parameters->cp_tdy;
+
+        /* tile offset */
+        cp->tx0 = (OPJ_UINT32)parameters->cp_tx0;
+        cp->ty0 = (OPJ_UINT32)parameters->cp_ty0;
+
+        /* comment string */
+        if(parameters->cp_comment) {
+                cp->comment = (char*)opj_malloc(strlen(parameters->cp_comment) + 1);
+                if(cp->comment) {
+                        strcpy(cp->comment, parameters->cp_comment);
+                }
+        }
+
+        /*
+        calculate other encoding parameters
+        */
+
+        if (parameters->tile_size_on) {
+                cp->tw = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(image->x1 - cp->tx0), (OPJ_INT32)cp->tdx);
+                cp->th = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)(image->y1 - cp->ty0), (OPJ_INT32)cp->tdy);
+        } else {
+                cp->tdx = image->x1 - cp->tx0;
+                cp->tdy = image->y1 - cp->ty0;
+        }
+
+        if (parameters->tp_on) {
+                cp->m_specific_param.m_enc.m_tp_flag = (OPJ_BYTE)parameters->tp_flag;
+                cp->m_specific_param.m_enc.m_tp_on = 1;
+        }
+
+#ifdef USE_JPWL
+        /*
+        calculate JPWL encoding parameters
+        */
+
+        if (parameters->jpwl_epc_on) {
+                OPJ_INT32 i;
+
+                /* set JPWL on */
+                cp->epc_on = OPJ_TRUE;
+                cp->info_on = OPJ_FALSE; /* no informative technique */
+
+                /* set EPB on */
+                if ((parameters->jpwl_hprot_MH > 0) || (parameters->jpwl_hprot_TPH[0] > 0)) {
+                        cp->epb_on = OPJ_TRUE;
+
+                        cp->hprot_MH = parameters->jpwl_hprot_MH;
+                        for (i = 0; i < JPWL_MAX_NO_TILESPECS; i++) {
+                                cp->hprot_TPH_tileno[i] = parameters->jpwl_hprot_TPH_tileno[i];
+                                cp->hprot_TPH[i] = parameters->jpwl_hprot_TPH[i];
+                        }
+                        /* if tile specs are not specified, copy MH specs */
+                        if (cp->hprot_TPH[0] == -1) {
+                                cp->hprot_TPH_tileno[0] = 0;
+                                cp->hprot_TPH[0] = parameters->jpwl_hprot_MH;
+                        }
+                        for (i = 0; i < JPWL_MAX_NO_PACKSPECS; i++) {
+                                cp->pprot_tileno[i] = parameters->jpwl_pprot_tileno[i];
+                                cp->pprot_packno[i] = parameters->jpwl_pprot_packno[i];
+                                cp->pprot[i] = parameters->jpwl_pprot[i];
+                        }
+                }
+
+                /* set ESD writing */
+                if ((parameters->jpwl_sens_size == 1) || (parameters->jpwl_sens_size == 2)) {
+                        cp->esd_on = OPJ_TRUE;
+
+                        cp->sens_size = parameters->jpwl_sens_size;
+                        cp->sens_addr = parameters->jpwl_sens_addr;
+                        cp->sens_range = parameters->jpwl_sens_range;
+
+                        cp->sens_MH = parameters->jpwl_sens_MH;
+                        for (i = 0; i < JPWL_MAX_NO_TILESPECS; i++) {
+                                cp->sens_TPH_tileno[i] = parameters->jpwl_sens_TPH_tileno[i];
+                                cp->sens_TPH[i] = parameters->jpwl_sens_TPH[i];
+                        }
+                }
+
+                /* always set RED writing to false: we are at the encoder */
+                cp->red_on = OPJ_FALSE;
+
+        } else {
+                cp->epc_on = OPJ_FALSE;
+        }
+#endif /* USE_JPWL */
+
+        /* initialize the mutiple tiles */
+        /* ---------------------------- */
+        cp->tcps = (opj_tcp_t*) opj_calloc(cp->tw * cp->th, sizeof(opj_tcp_t));
+        if (parameters->numpocs) {
+                /* initialisation of POC */
+                opj_j2k_check_poc_val(parameters->POC,parameters->numpocs, (OPJ_UINT32)parameters->numresolution, image->numcomps, (OPJ_UINT32)parameters->tcp_numlayers, p_manager);
+                /* TODO MSD use the return value*/
+        }
+
+        for (tileno = 0; tileno < cp->tw * cp->th; tileno++) {
+                opj_tcp_t *tcp = &cp->tcps[tileno];
+                tcp->numlayers = (OPJ_UINT32)parameters->tcp_numlayers;
+
+                for (j = 0; j < tcp->numlayers; j++) {
+                        if(OPJ_IS_CINEMA(cp->rsiz)){
+                                if (cp->m_specific_param.m_enc.m_fixed_quality) {
+                                        tcp->distoratio[j] = parameters->tcp_distoratio[j];
+                                }
+                                tcp->rates[j] = parameters->tcp_rates[j];
+                        }else{
+                                if (cp->m_specific_param.m_enc.m_fixed_quality) {       /* add fixed_quality */
+                                        tcp->distoratio[j] = parameters->tcp_distoratio[j];
+                                } else {
+                                        tcp->rates[j] = parameters->tcp_rates[j];
+                                }
+                        }
+                }
+
+                tcp->csty = (OPJ_UINT32)parameters->csty;
+                tcp->prg = parameters->prog_order;
+                tcp->mct = (OPJ_UINT32)parameters->tcp_mct;
+
+                numpocs_tile = 0;
+                tcp->POC = 0;
+
+                if (parameters->numpocs) {
+                        /* initialisation of POC */
+                        tcp->POC = 1;
+                        for (i = 0; i < parameters->numpocs; i++) {
+                                if (tileno + 1 == parameters->POC[i].tile )  {
+                                        opj_poc_t *tcp_poc = &tcp->pocs[numpocs_tile];
+
+                                        tcp_poc->resno0         = parameters->POC[numpocs_tile].resno0;
+                                        tcp_poc->compno0        = parameters->POC[numpocs_tile].compno0;
+                                        tcp_poc->layno1         = parameters->POC[numpocs_tile].layno1;
+                                        tcp_poc->resno1         = parameters->POC[numpocs_tile].resno1;
+                                        tcp_poc->compno1        = parameters->POC[numpocs_tile].compno1;
+                                        tcp_poc->prg1           = parameters->POC[numpocs_tile].prg1;
+                                        tcp_poc->tile           = parameters->POC[numpocs_tile].tile;
+
+                                        numpocs_tile++;
+                                }
+                        }
+
+                        tcp->numpocs = numpocs_tile -1 ;
+                }else{
+                        tcp->numpocs = 0;
+                }
+
+                tcp->tccps = (opj_tccp_t*) opj_calloc(image->numcomps, sizeof(opj_tccp_t));
+
+                if (parameters->mct_data) {
+                      
+                    OPJ_UINT32 lMctSize = image->numcomps * image->numcomps * (OPJ_UINT32)sizeof(OPJ_FLOAT32);
+                    OPJ_FLOAT32 * lTmpBuf = (OPJ_FLOAT32*)opj_malloc(lMctSize);
+                    OPJ_INT32 * l_dc_shift = (OPJ_INT32 *) ((OPJ_BYTE *) parameters->mct_data + lMctSize);
+
+                    tcp->mct = 2;
+                    tcp->m_mct_coding_matrix = (OPJ_FLOAT32*)opj_malloc(lMctSize);
+                    memcpy(tcp->m_mct_coding_matrix,parameters->mct_data,lMctSize);
+                    memcpy(lTmpBuf,parameters->mct_data,lMctSize);
+
+                    tcp->m_mct_decoding_matrix = (OPJ_FLOAT32*)opj_malloc(lMctSize);
+                    assert(opj_matrix_inversion_f(lTmpBuf,(tcp->m_mct_decoding_matrix),image->numcomps));
+
+                    tcp->mct_norms = (OPJ_FLOAT64*)
+                                    opj_malloc(image->numcomps * sizeof(OPJ_FLOAT64));
+
+                    opj_calculate_norms(tcp->mct_norms,image->numcomps,tcp->m_mct_decoding_matrix);
+                    opj_free(lTmpBuf);
+
+                    for (i = 0; i < image->numcomps; i++) {
+                            opj_tccp_t *tccp = &tcp->tccps[i];
+                            tccp->m_dc_level_shift = l_dc_shift[i];
+                    }
+
+                    opj_j2k_setup_mct_encoding(tcp,image);                        
+                }
+                else {
+                        for (i = 0; i < image->numcomps; i++) {
+                                opj_tccp_t *tccp = &tcp->tccps[i];
+                                opj_image_comp_t * l_comp = &(image->comps[i]);
+
+                                if (! l_comp->sgnd) {
+                                        tccp->m_dc_level_shift = 1 << (l_comp->prec - 1);
+                                }
+                        }
+                }
+
+                for (i = 0; i < image->numcomps; i++) {
+                        opj_tccp_t *tccp = &tcp->tccps[i];
+
+                        tccp->csty = parameters->csty & 0x01;   /* 0 => one precinct || 1 => custom precinct  */
+                        tccp->numresolutions = (OPJ_UINT32)parameters->numresolution;
+                        tccp->cblkw = (OPJ_UINT32)opj_int_floorlog2(parameters->cblockw_init);
+                        tccp->cblkh = (OPJ_UINT32)opj_int_floorlog2(parameters->cblockh_init);
+                        tccp->cblksty = (OPJ_UINT32)parameters->mode;
+                        tccp->qmfbid = parameters->irreversible ? 0 : 1;
+                        tccp->qntsty = parameters->irreversible ? J2K_CCP_QNTSTY_SEQNT : J2K_CCP_QNTSTY_NOQNT;
+                        tccp->numgbits = 2;
+
+                        if ((OPJ_INT32)i == parameters->roi_compno) {
+                                tccp->roishift = parameters->roi_shift;
+                        } else {
+                                tccp->roishift = 0;
+                        }
+
+                                if (parameters->csty & J2K_CCP_CSTY_PRT) {
+                                        OPJ_INT32 p = 0, it_res;
+                                        assert( tccp->numresolutions > 0 );
+                                        for (it_res = (OPJ_INT32)tccp->numresolutions - 1; it_res >= 0; it_res--) {
+                                                if (p < parameters->res_spec) {
+
+                                                        if (parameters->prcw_init[p] < 1) {
+                                                                tccp->prcw[it_res] = 1;
+                                                        } else {
+                                                                tccp->prcw[it_res] = (OPJ_UINT32)opj_int_floorlog2(parameters->prcw_init[p]);
+                                                        }
+
+                                                        if (parameters->prch_init[p] < 1) {
+                                                                tccp->prch[it_res] = 1;
+                                                        }else {
+                                                                tccp->prch[it_res] = (OPJ_UINT32)opj_int_floorlog2(parameters->prch_init[p]);
+                                                        }
+
+                                                } else {
+                                                        OPJ_INT32 res_spec = parameters->res_spec;
+                                                        OPJ_INT32 size_prcw = 0;
+                                                        OPJ_INT32 size_prch = 0;
+
+                                                        assert(res_spec>0); /* issue 189 */
+                                                        size_prcw = parameters->prcw_init[res_spec - 1] >> (p - (res_spec - 1));
+                                                        size_prch = parameters->prch_init[res_spec - 1] >> (p - (res_spec - 1));
+
+
+                                                        if (size_prcw < 1) {
+                                                                tccp->prcw[it_res] = 1;
+                                                        } else {
+                                                                tccp->prcw[it_res] = (OPJ_UINT32)opj_int_floorlog2(size_prcw);
+                                                        }
+
+                                                        if (size_prch < 1) {
+                                                                tccp->prch[it_res] = 1;
+                                                        } else {
+                                                                tccp->prch[it_res] = (OPJ_UINT32)opj_int_floorlog2(size_prch);
+                                                        }
+                                                }
+                                                p++;
+                                                /*printf("\nsize precinct for level %d : %d,%d\n", it_res,tccp->prcw[it_res], tccp->prch[it_res]); */
+                                        }       /*end for*/
+                                } else {
+                                        for (j = 0; j < tccp->numresolutions; j++) {
+                                                tccp->prcw[j] = 15;
+                                                tccp->prch[j] = 15;
+                                        }
+                                }
+
+                        opj_dwt_calc_explicit_stepsizes(tccp, image->comps[i].prec);
+                }
+        }
+
+        if (parameters->mct_data) {
+                opj_free(parameters->mct_data);
+                parameters->mct_data = 00;
+        }
+}
+
+static OPJ_BOOL opj_j2k_add_mhmarker(opj_codestream_index_t *cstr_index, OPJ_UINT32 type, OPJ_OFF_T pos, OPJ_UINT32 len)
+{
+        assert(cstr_index != 00);
+
+        /* expand the list? */
+        if ((cstr_index->marknum + 1) > cstr_index->maxmarknum) {
+                opj_marker_info_t *new_marker;
+                cstr_index->maxmarknum = (OPJ_UINT32)(100 + (OPJ_FLOAT32) cstr_index->maxmarknum);
+                new_marker = (opj_marker_info_t *) opj_realloc(cstr_index->marker, cstr_index->maxmarknum *sizeof(opj_marker_info_t));
+                if (! new_marker) {
+                        opj_free(cstr_index->marker);
+                        cstr_index->marker = NULL;
+                        cstr_index->maxmarknum = 0;
+                        cstr_index->marknum = 0;
+                        /* opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to add mh marker\n"); */
+                        return OPJ_FALSE;
+                }
+                cstr_index->marker = new_marker;
+        }
+
+        /* add the marker */
+        cstr_index->marker[cstr_index->marknum].type = (OPJ_UINT16)type;
+        cstr_index->marker[cstr_index->marknum].pos = (OPJ_INT32)pos;
+        cstr_index->marker[cstr_index->marknum].len = (OPJ_INT32)len;
+        cstr_index->marknum++;
+        return OPJ_TRUE;
+}
+
+static OPJ_BOOL opj_j2k_add_tlmarker(OPJ_UINT32 tileno, opj_codestream_index_t *cstr_index, OPJ_UINT32 type, OPJ_OFF_T pos, OPJ_UINT32 len)
+{
+        assert(cstr_index != 00);
+        assert(cstr_index->tile_index != 00);
+
+        /* expand the list? */
+        if ((cstr_index->tile_index[tileno].marknum + 1) > cstr_index->tile_index[tileno].maxmarknum) {
+                opj_marker_info_t *new_marker;
+                cstr_index->tile_index[tileno].maxmarknum = (OPJ_UINT32)(100 + (OPJ_FLOAT32) cstr_index->tile_index[tileno].maxmarknum);
+                new_marker = (opj_marker_info_t *) opj_realloc(
+                                cstr_index->tile_index[tileno].marker,
+                                cstr_index->tile_index[tileno].maxmarknum *sizeof(opj_marker_info_t));
+                if (! new_marker) {
+                        opj_free(cstr_index->tile_index[tileno].marker);
+                        cstr_index->tile_index[tileno].marker = NULL;
+                        cstr_index->tile_index[tileno].maxmarknum = 0;
+                        cstr_index->tile_index[tileno].marknum = 0;
+                        /* opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to add tl marker\n"); */
+                        return OPJ_FALSE;
+                }
+                cstr_index->tile_index[tileno].marker = new_marker;
+        }
+
+        /* add the marker */
+        cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].type = (OPJ_UINT16)type;
+        cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].pos = (OPJ_INT32)pos;
+        cstr_index->tile_index[tileno].marker[cstr_index->tile_index[tileno].marknum].len = (OPJ_INT32)len;
+        cstr_index->tile_index[tileno].marknum++;
+
+        if (type == J2K_MS_SOT) {
+                OPJ_UINT32 l_current_tile_part = cstr_index->tile_index[tileno].current_tpsno;
+
+                if (cstr_index->tile_index[tileno].tp_index)
+                        cstr_index->tile_index[tileno].tp_index[l_current_tile_part].start_pos = pos;
+
+        }
+        return OPJ_TRUE;
+}
+
+/*
+ * -----------------------------------------------------------------------
+ * -----------------------------------------------------------------------
+ * -----------------------------------------------------------------------
+ */
+
+OPJ_BOOL opj_j2k_end_decompress(opj_j2k_t *p_j2k,
+                                opj_stream_private_t *p_stream,
+                                opj_event_mgr_t * p_manager
+                                )
+{
+    (void)p_j2k;
+    (void)p_stream;
+    (void)p_manager;
+    return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_j2k_read_header(   opj_stream_private_t *p_stream,
+                                                            opj_j2k_t* p_j2k,
+                                                            opj_image_t** p_image,
+                                                            opj_event_mgr_t* p_manager )
+{
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_stream != 00);
+        assert(p_manager != 00);
+
+        /* create an empty image header */
+        p_j2k->m_private_image = opj_image_create0();
+        if (! p_j2k->m_private_image) {
+                return OPJ_FALSE;
+        }
+
+        /* customization of the validation */
+        opj_j2k_setup_decoding_validation(p_j2k);
+
+        /* validation of the parameters codec */
+        if (! opj_j2k_exec(p_j2k, p_j2k->m_validation_list, p_stream,p_manager)) {
+                opj_image_destroy(p_j2k->m_private_image);
+                p_j2k->m_private_image = NULL;
+                return OPJ_FALSE;
+        }
+
+        /* customization of the encoding */
+        opj_j2k_setup_header_reading(p_j2k);
+
+        /* read header */
+        if (! opj_j2k_exec (p_j2k,p_j2k->m_procedure_list,p_stream,p_manager)) {
+                opj_image_destroy(p_j2k->m_private_image);
+                p_j2k->m_private_image = NULL;
+                return OPJ_FALSE;
+        }
+
+        *p_image = opj_image_create0();
+        if (! (*p_image)) {
+                return OPJ_FALSE;
+        }
+
+        /* Copy codestream image information to the output image */
+        opj_copy_image_header(p_j2k->m_private_image, *p_image);
+
+    /*Allocate and initialize some elements of codestrem index*/
+        if (!opj_j2k_allocate_tile_element_cstr_index(p_j2k)){
+                return OPJ_FALSE;
+        }
+
+        return OPJ_TRUE;
+}
+
+void opj_j2k_setup_header_reading (opj_j2k_t *p_j2k)
+{
+        /* preconditions*/
+        assert(p_j2k != 00);
+
+        opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_read_header_procedure);
+
+        /* DEVELOPER CORNER, add your custom procedures */
+        opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_copy_default_tcp_and_create_tcd);
+
+}
+
+void opj_j2k_setup_decoding_validation (opj_j2k_t *p_j2k)
+{
+        /* preconditions*/
+        assert(p_j2k != 00);
+
+        opj_procedure_list_add_procedure(p_j2k->m_validation_list, (opj_procedure)opj_j2k_build_decoder);
+        opj_procedure_list_add_procedure(p_j2k->m_validation_list, (opj_procedure)opj_j2k_decoding_validation);
+        /* DEVELOPER CORNER, add your custom validation procedure */
+
+}
+
+OPJ_BOOL opj_j2k_mct_validation (       opj_j2k_t * p_j2k,
+                                                                opj_stream_private_t *p_stream,
+                                                                opj_event_mgr_t * p_manager )
+{
+        OPJ_BOOL l_is_valid = OPJ_TRUE;
+        OPJ_UINT32 i,j;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_stream != 00);
+        assert(p_manager != 00);
+
+        if ((p_j2k->m_cp.rsiz & 0x8200) == 0x8200) {
+                OPJ_UINT32 l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
+                opj_tcp_t * l_tcp = p_j2k->m_cp.tcps;
+
+                for (i=0;i<l_nb_tiles;++i) {
+                        if (l_tcp->mct == 2) {
+                                opj_tccp_t * l_tccp = l_tcp->tccps;
+                                l_is_valid &= (l_tcp->m_mct_coding_matrix != 00);
+
+                                for (j=0;j<p_j2k->m_private_image->numcomps;++j) {
+                                        l_is_valid &= ! (l_tccp->qmfbid & 1);
+                                        ++l_tccp;
+                                }
+                        }
+                        ++l_tcp;
+                }
+        }
+
+        return l_is_valid;
+}
+
+OPJ_BOOL opj_j2k_setup_mct_encoding(opj_tcp_t * p_tcp, opj_image_t * p_image)
+{
+        OPJ_UINT32 i;
+        OPJ_UINT32 l_indix = 1;
+        opj_mct_data_t * l_mct_deco_data = 00,* l_mct_offset_data = 00;
+        opj_simple_mcc_decorrelation_data_t * l_mcc_data;
+        OPJ_UINT32 l_mct_size,l_nb_elem;
+        OPJ_FLOAT32 * l_data, * l_current_data;
+        opj_tccp_t * l_tccp;
+
+        /* preconditions */
+        assert(p_tcp != 00);
+
+        if (p_tcp->mct != 2) {
+                return OPJ_TRUE;
+        }
+
+        if (p_tcp->m_mct_decoding_matrix) {
+                if (p_tcp->m_nb_mct_records == p_tcp->m_nb_max_mct_records) {
+                        opj_mct_data_t *new_mct_records;
+                        p_tcp->m_nb_max_mct_records += OPJ_J2K_MCT_DEFAULT_NB_RECORDS;
+
+                        new_mct_records = (opj_mct_data_t *) opj_realloc(p_tcp->m_mct_records, p_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t));
+                        if (! new_mct_records) {
+                                opj_free(p_tcp->m_mct_records);
+                                p_tcp->m_mct_records = NULL;
+                                p_tcp->m_nb_max_mct_records = 0;
+                                p_tcp->m_nb_mct_records = 0;
+                                /* opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to setup mct encoding\n"); */
+                                return OPJ_FALSE;
+                        }
+                        p_tcp->m_mct_records = new_mct_records;
+                        l_mct_deco_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;
+
+                        memset(l_mct_deco_data ,0,(p_tcp->m_nb_max_mct_records - p_tcp->m_nb_mct_records) * sizeof(opj_mct_data_t));
+                }
+                l_mct_deco_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;
+
+                if (l_mct_deco_data->m_data) {
+                        opj_free(l_mct_deco_data->m_data);
+                        l_mct_deco_data->m_data = 00;
+                }
+
+                l_mct_deco_data->m_index = l_indix++;
+                l_mct_deco_data->m_array_type = MCT_TYPE_DECORRELATION;
+                l_mct_deco_data->m_element_type = MCT_TYPE_FLOAT;
+                l_nb_elem = p_image->numcomps * p_image->numcomps;
+                l_mct_size = l_nb_elem * MCT_ELEMENT_SIZE[l_mct_deco_data->m_element_type];
+                l_mct_deco_data->m_data = (OPJ_BYTE*)opj_malloc(l_mct_size );
+
+                if (! l_mct_deco_data->m_data) {
+                        return OPJ_FALSE;
+                }
+
+                j2k_mct_write_functions_from_float[l_mct_deco_data->m_element_type](p_tcp->m_mct_decoding_matrix,l_mct_deco_data->m_data,l_nb_elem);
+
+                l_mct_deco_data->m_data_size = l_mct_size;
+                ++p_tcp->m_nb_mct_records;
+        }
+
+        if (p_tcp->m_nb_mct_records == p_tcp->m_nb_max_mct_records) {
+                opj_mct_data_t *new_mct_records;
+                p_tcp->m_nb_max_mct_records += OPJ_J2K_MCT_DEFAULT_NB_RECORDS;
+                new_mct_records = (opj_mct_data_t *) opj_realloc(p_tcp->m_mct_records, p_tcp->m_nb_max_mct_records * sizeof(opj_mct_data_t));
+                if (! new_mct_records) {
+                        opj_free(p_tcp->m_mct_records);
+                        p_tcp->m_mct_records = NULL;
+                        p_tcp->m_nb_max_mct_records = 0;
+                        p_tcp->m_nb_mct_records = 0;
+                        /* opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to setup mct encoding\n"); */
+                        return OPJ_FALSE;
+                }
+                p_tcp->m_mct_records = new_mct_records;
+                l_mct_offset_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;
+
+                memset(l_mct_offset_data ,0,(p_tcp->m_nb_max_mct_records - p_tcp->m_nb_mct_records) * sizeof(opj_mct_data_t));
+
+                if (l_mct_deco_data) {
+                        l_mct_deco_data = l_mct_offset_data - 1;
+                }
+        }
+
+        l_mct_offset_data = p_tcp->m_mct_records + p_tcp->m_nb_mct_records;
+
+        if (l_mct_offset_data->m_data) {
+                opj_free(l_mct_offset_data->m_data);
+                l_mct_offset_data->m_data = 00;
+        }
+
+        l_mct_offset_data->m_index = l_indix++;
+        l_mct_offset_data->m_array_type = MCT_TYPE_OFFSET;
+        l_mct_offset_data->m_element_type = MCT_TYPE_FLOAT;
+        l_nb_elem = p_image->numcomps;
+        l_mct_size = l_nb_elem * MCT_ELEMENT_SIZE[l_mct_offset_data->m_element_type];
+        l_mct_offset_data->m_data = (OPJ_BYTE*)opj_malloc(l_mct_size );
+
+        if (! l_mct_offset_data->m_data) {
+                return OPJ_FALSE;
+        }
+
+        l_data = (OPJ_FLOAT32*)opj_malloc(l_nb_elem * sizeof(OPJ_FLOAT32));
+        if (! l_data) {
+                opj_free(l_mct_offset_data->m_data);
+                l_mct_offset_data->m_data = 00;
+                return OPJ_FALSE;
+        }
+
+        l_tccp = p_tcp->tccps;
+        l_current_data = l_data;
+
+        for (i=0;i<l_nb_elem;++i) {
+                *(l_current_data++) = (OPJ_FLOAT32) (l_tccp->m_dc_level_shift);
+                ++l_tccp;
+        }
+
+        j2k_mct_write_functions_from_float[l_mct_offset_data->m_element_type](l_data,l_mct_offset_data->m_data,l_nb_elem);
+
+        opj_free(l_data);
+
+        l_mct_offset_data->m_data_size = l_mct_size;
+
+        ++p_tcp->m_nb_mct_records;
+
+        if (p_tcp->m_nb_mcc_records == p_tcp->m_nb_max_mcc_records) {
+                opj_simple_mcc_decorrelation_data_t *new_mcc_records;
+                p_tcp->m_nb_max_mcc_records += OPJ_J2K_MCT_DEFAULT_NB_RECORDS;
+                new_mcc_records = (opj_simple_mcc_decorrelation_data_t *) opj_realloc(
+                                p_tcp->m_mcc_records, p_tcp->m_nb_max_mcc_records * sizeof(opj_simple_mcc_decorrelation_data_t));
+                if (! new_mcc_records) {
+                        opj_free(p_tcp->m_mcc_records);
+                        p_tcp->m_mcc_records = NULL;
+                        p_tcp->m_nb_max_mcc_records = 0;
+                        p_tcp->m_nb_mcc_records = 0;
+                        /* opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to setup mct encoding\n"); */
+                        return OPJ_FALSE;
+                }
+                p_tcp->m_mcc_records = new_mcc_records;
+                l_mcc_data = p_tcp->m_mcc_records + p_tcp->m_nb_mcc_records;
+                memset(l_mcc_data ,0,(p_tcp->m_nb_max_mcc_records - p_tcp->m_nb_mcc_records) * sizeof(opj_simple_mcc_decorrelation_data_t));
+
+        }
+
+        l_mcc_data = p_tcp->m_mcc_records + p_tcp->m_nb_mcc_records;
+        l_mcc_data->m_decorrelation_array = l_mct_deco_data;
+        l_mcc_data->m_is_irreversible = 1;
+        l_mcc_data->m_nb_comps = p_image->numcomps;
+        l_mcc_data->m_index = l_indix++;
+        l_mcc_data->m_offset_array = l_mct_offset_data;
+        ++p_tcp->m_nb_mcc_records;
+
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_j2k_build_decoder (opj_j2k_t * p_j2k,
+                                                            opj_stream_private_t *p_stream,
+                                                            opj_event_mgr_t * p_manager )
+{
+        /* add here initialization of cp
+           copy paste of setup_decoder */
+  (void)p_j2k;
+  (void)p_stream;
+  (void)p_manager;
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_j2k_build_encoder (opj_j2k_t * p_j2k,
+                                                        opj_stream_private_t *p_stream,
+                                                        opj_event_mgr_t * p_manager )
+{
+        /* add here initialization of cp
+           copy paste of setup_encoder */
+  (void)p_j2k;
+  (void)p_stream;
+  (void)p_manager;
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_j2k_encoding_validation (  opj_j2k_t * p_j2k,
+                                                                            opj_stream_private_t *p_stream,
+                                                                            opj_event_mgr_t * p_manager )
+{
+        OPJ_BOOL l_is_valid = OPJ_TRUE;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_stream != 00);
+        assert(p_manager != 00);
+
+        /* STATE checking */
+        /* make sure the state is at 0 */
+        l_is_valid &= (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_NONE);
+
+        /* POINTER validation */
+        /* make sure a p_j2k codec is present */
+        l_is_valid &= (p_j2k->m_procedure_list != 00);
+        /* make sure a validation list is present */
+        l_is_valid &= (p_j2k->m_validation_list != 00);
+
+        if ((p_j2k->m_cp.tdx) < (OPJ_UINT32) (1 << p_j2k->m_cp.tcps->tccps->numresolutions)) {
+                opj_event_msg(p_manager, EVT_ERROR, "Number of resolutions is too high in comparison to the size of tiles\n");
+                return OPJ_FALSE;
+        }
+
+        if ((p_j2k->m_cp.tdy) < (OPJ_UINT32) (1 << p_j2k->m_cp.tcps->tccps->numresolutions)) {
+                opj_event_msg(p_manager, EVT_ERROR, "Number of resolutions is too high in comparison to the size of tiles\n");
+                return OPJ_FALSE;
+        }
+
+        /* PARAMETER VALIDATION */
+        return l_is_valid;
+}
+
+OPJ_BOOL opj_j2k_decoding_validation (  opj_j2k_t *p_j2k,
+                                        opj_stream_private_t *p_stream,
+                                        opj_event_mgr_t * p_manager
+                                        )
+{
+        OPJ_BOOL l_is_valid = OPJ_TRUE;
+
+        /* preconditions*/
+        assert(p_j2k != 00);
+        assert(p_stream != 00);
+        assert(p_manager != 00);
+
+        /* STATE checking */
+        /* make sure the state is at 0 */
+#ifdef TODO_MSD
+        l_is_valid &= (p_j2k->m_specific_param.m_decoder.m_state == J2K_DEC_STATE_NONE);
+#endif
+        l_is_valid &= (p_j2k->m_specific_param.m_decoder.m_state == 0x0000);
+
+        /* POINTER validation */
+        /* make sure a p_j2k codec is present */
+        /* make sure a procedure list is present */
+        l_is_valid &= (p_j2k->m_procedure_list != 00);
+        /* make sure a validation list is present */
+        l_is_valid &= (p_j2k->m_validation_list != 00);
+
+        /* PARAMETER VALIDATION */
+        return l_is_valid;
+}
+
+OPJ_BOOL opj_j2k_read_header_procedure( opj_j2k_t *p_j2k,
+                                                                            opj_stream_private_t *p_stream,
+                                                                            opj_event_mgr_t * p_manager)
+{
+        OPJ_UINT32 l_current_marker;
+        OPJ_UINT32 l_marker_size;
+        const opj_dec_memory_marker_handler_t * l_marker_handler = 00;
+
+        /* preconditions */
+        assert(p_stream != 00);
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+
+        /*  We enter in the main header */
+        p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_MHSOC;
+
+        /* Try to read the SOC marker, the codestream must begin with SOC marker */
+        if (! opj_j2k_read_soc(p_j2k,p_stream,p_manager)) {
+                opj_event_msg(p_manager, EVT_ERROR, "Expected a SOC marker \n");
+                return OPJ_FALSE;
+        }
+
+        /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer */
+        if (opj_stream_read_data(p_stream,p_j2k->m_specific_param.m_decoder.m_header_data,2,p_manager) != 2) {
+                opj_event_msg(p_manager, EVT_ERROR, "Stream too short\n");
+                return OPJ_FALSE;
+        }
+
+        /* Read 2 bytes as the new marker ID */
+        opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,&l_current_marker,2);
+
+        /* Try to read until the SOT is detected */
+        while (l_current_marker != J2K_MS_SOT) {
+
+                /* Check if the current marker ID is valid */
+                if (l_current_marker < 0xff00) {
+                        opj_event_msg(p_manager, EVT_ERROR, "We expected read a marker ID (0xff--) instead of %.8x\n", l_current_marker);
+                        return OPJ_FALSE;
+                }
+
+                /* Get the marker handler from the marker ID */
+                l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);
+
+                /* Manage case where marker is unknown */
+                if (l_marker_handler->id == J2K_MS_UNK) {
+                        if (! opj_j2k_read_unk(p_j2k, p_stream, &l_current_marker, p_manager)){
+                                opj_event_msg(p_manager, EVT_ERROR, "Unknow marker have been detected and generated error.\n");
+                                return OPJ_FALSE;
+                        }
+
+                        if (l_current_marker == J2K_MS_SOT)
+                                break; /* SOT marker is detected main header is completely read */
+                        else    /* Get the marker handler from the marker ID */
+                                l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);
+                }
+
+                /* Check if the marker is known and if it is the right place to find it */
+                if (! (p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states) ) {
+                        opj_event_msg(p_manager, EVT_ERROR, "Marker is not compliant with its position\n");
+                        return OPJ_FALSE;
+                }
+
+                /* Try to read 2 bytes (the marker size) from stream and copy them into the buffer */
+                if (opj_stream_read_data(p_stream,p_j2k->m_specific_param.m_decoder.m_header_data,2,p_manager) != 2) {
+                        opj_event_msg(p_manager, EVT_ERROR, "Stream too short\n");
+                        return OPJ_FALSE;
+                }
+
+                /* read 2 bytes as the marker size */
+                opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,&l_marker_size,2);
+                l_marker_size -= 2; /* Subtract the size of the marker ID already read */
+
+                /* Check if the marker size is compatible with the header data size */
+                if (l_marker_size > p_j2k->m_specific_param.m_decoder.m_header_data_size) {
+                        OPJ_BYTE *new_header_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_decoder.m_header_data, l_marker_size);
+                        if (! new_header_data) {
+                                opj_free(p_j2k->m_specific_param.m_decoder.m_header_data);
+                                p_j2k->m_specific_param.m_decoder.m_header_data = NULL;
+                                p_j2k->m_specific_param.m_decoder.m_header_data_size = 0;
+                                opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to read header\n");
+                                return OPJ_FALSE;
+                        }
+                        p_j2k->m_specific_param.m_decoder.m_header_data = new_header_data;
+                        p_j2k->m_specific_param.m_decoder.m_header_data_size = l_marker_size;
+                }
+
+                /* Try to read the rest of the marker segment from stream and copy them into the buffer */
+                if (opj_stream_read_data(p_stream,p_j2k->m_specific_param.m_decoder.m_header_data,l_marker_size,p_manager) != l_marker_size) {
+                        opj_event_msg(p_manager, EVT_ERROR, "Stream too short\n");
+                        return OPJ_FALSE;
+                }
+
+                /* Read the marker segment with the correct marker handler */
+                if (! (*(l_marker_handler->handler))(p_j2k,p_j2k->m_specific_param.m_decoder.m_header_data,l_marker_size,p_manager)) {
+                        opj_event_msg(p_manager, EVT_ERROR, "Marker handler function failed to read the marker segment\n");
+                        return OPJ_FALSE;
+                }
+
+                /* Add the marker to the codestream index*/
+                if (OPJ_FALSE == opj_j2k_add_mhmarker(
+                                        p_j2k->cstr_index,
+                                        l_marker_handler->id,
+                                        (OPJ_UINT32) opj_stream_tell(p_stream) - l_marker_size - 4,
+                                        l_marker_size + 4 )) {
+                        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to add mh marker\n");
+                        return OPJ_FALSE;
+                }
+
+                /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer */
+                if (opj_stream_read_data(p_stream,p_j2k->m_specific_param.m_decoder.m_header_data,2,p_manager) != 2) {
+                        opj_event_msg(p_manager, EVT_ERROR, "Stream too short\n");
+                        return OPJ_FALSE;
+                }
+
+                /* read 2 bytes as the new marker ID */
+                opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,&l_current_marker,2);
+        }
+
+        opj_event_msg(p_manager, EVT_INFO, "Main header has been correctly decoded.\n");
+
+        /* Position of the last element if the main header */
+        p_j2k->cstr_index->main_head_end = (OPJ_UINT32) opj_stream_tell(p_stream) - 2;
+
+        /* Next step: read a tile-part header */
+        p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_TPHSOT;
+
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_j2k_exec ( opj_j2k_t * p_j2k,
+                                        opj_procedure_list_t * p_procedure_list,
+                                        opj_stream_private_t *p_stream,
+                                        opj_event_mgr_t * p_manager )
+{
+        OPJ_BOOL (** l_procedure) (opj_j2k_t * ,opj_stream_private_t *,opj_event_mgr_t *) = 00;
+        OPJ_BOOL l_result = OPJ_TRUE;
+        OPJ_UINT32 l_nb_proc, i;
+
+        /* preconditions*/
+        assert(p_procedure_list != 00);
+        assert(p_j2k != 00);
+        assert(p_stream != 00);
+        assert(p_manager != 00);
+
+        l_nb_proc = opj_procedure_list_get_nb_procedures(p_procedure_list);
+        l_procedure = (OPJ_BOOL (**) (opj_j2k_t * ,opj_stream_private_t *,opj_event_mgr_t *)) opj_procedure_list_get_first_procedure(p_procedure_list);
+
+        for     (i=0;i<l_nb_proc;++i) {
+                l_result = l_result && ((*l_procedure) (p_j2k,p_stream,p_manager));
+                ++l_procedure;
+        }
+
+        /* and clear the procedure list at the end.*/
+        opj_procedure_list_clear(p_procedure_list);
+        return l_result;
+}
+
+/* FIXME DOC*/
+static OPJ_BOOL opj_j2k_copy_default_tcp_and_create_tcd (       opj_j2k_t * p_j2k,
+                                                            opj_stream_private_t *p_stream,
+                                                            opj_event_mgr_t * p_manager
+                                                            )
+{
+        opj_tcp_t * l_tcp = 00;
+        opj_tcp_t * l_default_tcp = 00;
+        OPJ_UINT32 l_nb_tiles;
+        OPJ_UINT32 i,j;
+        opj_tccp_t *l_current_tccp = 00;
+        OPJ_UINT32 l_tccp_size;
+        OPJ_UINT32 l_mct_size;
+        opj_image_t * l_image;
+        OPJ_UINT32 l_mcc_records_size,l_mct_records_size;
+        opj_mct_data_t * l_src_mct_rec, *l_dest_mct_rec;
+        opj_simple_mcc_decorrelation_data_t * l_src_mcc_rec, *l_dest_mcc_rec;
+        OPJ_UINT32 l_offset;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_stream != 00);
+        assert(p_manager != 00);
+
+        l_image = p_j2k->m_private_image;
+        l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
+        l_tcp = p_j2k->m_cp.tcps;
+        l_tccp_size = l_image->numcomps * (OPJ_UINT32)sizeof(opj_tccp_t);
+        l_default_tcp = p_j2k->m_specific_param.m_decoder.m_default_tcp;
+        l_mct_size = l_image->numcomps * l_image->numcomps * (OPJ_UINT32)sizeof(OPJ_FLOAT32);
+
+        /* For each tile */
+        for (i=0; i<l_nb_tiles; ++i) {
+                /* keep the tile-compo coding parameters pointer of the current tile coding parameters*/
+                l_current_tccp = l_tcp->tccps;
+                /*Copy default coding parameters into the current tile coding parameters*/
+                memcpy(l_tcp, l_default_tcp, sizeof(opj_tcp_t));
+                /* Initialize some values of the current tile coding parameters*/
+                l_tcp->ppt = 0;
+                l_tcp->ppt_data = 00;
+                /* Reconnect the tile-compo coding parameters pointer to the current tile coding parameters*/
+                l_tcp->tccps = l_current_tccp;
+
+                /* Get the mct_decoding_matrix of the dflt_tile_cp and copy them into the current tile cp*/
+                if (l_default_tcp->m_mct_decoding_matrix) {
+                        l_tcp->m_mct_decoding_matrix = (OPJ_FLOAT32*)opj_malloc(l_mct_size);
+                        if (! l_tcp->m_mct_decoding_matrix ) {
+                                return OPJ_FALSE;
+                        }
+                        memcpy(l_tcp->m_mct_decoding_matrix,l_default_tcp->m_mct_decoding_matrix,l_mct_size);
+                }
+
+                /* Get the mct_record of the dflt_tile_cp and copy them into the current tile cp*/
+                l_mct_records_size = l_default_tcp->m_nb_max_mct_records * (OPJ_UINT32)sizeof(opj_mct_data_t);
+                l_tcp->m_mct_records = (opj_mct_data_t*)opj_malloc(l_mct_records_size);
+                if (! l_tcp->m_mct_records) {
+                        return OPJ_FALSE;
+                }
+                memcpy(l_tcp->m_mct_records, l_default_tcp->m_mct_records,l_mct_records_size);
+
+                /* Copy the mct record data from dflt_tile_cp to the current tile*/
+                l_src_mct_rec = l_default_tcp->m_mct_records;
+                l_dest_mct_rec = l_tcp->m_mct_records;
+
+                for (j=0;j<l_default_tcp->m_nb_mct_records;++j) {
+
+                        if (l_src_mct_rec->m_data) {
+
+                                l_dest_mct_rec->m_data = (OPJ_BYTE*) opj_malloc(l_src_mct_rec->m_data_size);
+                                if(! l_dest_mct_rec->m_data) {
+                                        return OPJ_FALSE;
+                                }
+                                memcpy(l_dest_mct_rec->m_data,l_src_mct_rec->m_data,l_src_mct_rec->m_data_size);
+                        }
+
+                        ++l_src_mct_rec;
+                        ++l_dest_mct_rec;
+                }
+
+                /* Get the mcc_record of the dflt_tile_cp and copy them into the current tile cp*/
+                l_mcc_records_size = l_default_tcp->m_nb_max_mcc_records * (OPJ_UINT32)sizeof(opj_simple_mcc_decorrelation_data_t);
+                l_tcp->m_mcc_records = (opj_simple_mcc_decorrelation_data_t*) opj_malloc(l_mcc_records_size);
+                if (! l_tcp->m_mcc_records) {
+                        return OPJ_FALSE;
+                }
+                memcpy(l_tcp->m_mcc_records,l_default_tcp->m_mcc_records,l_mcc_records_size);
+
+                /* Copy the mcc record data from dflt_tile_cp to the current tile*/
+                l_src_mcc_rec = l_default_tcp->m_mcc_records;
+                l_dest_mcc_rec = l_tcp->m_mcc_records;
+
+                for (j=0;j<l_default_tcp->m_nb_max_mcc_records;++j) {
+
+                        if (l_src_mcc_rec->m_decorrelation_array) {
+                                l_offset = (OPJ_UINT32)(l_src_mcc_rec->m_decorrelation_array - l_default_tcp->m_mct_records);
+                                l_dest_mcc_rec->m_decorrelation_array = l_tcp->m_mct_records + l_offset;
+                        }
+
+                        if (l_src_mcc_rec->m_offset_array) {
+                                l_offset = (OPJ_UINT32)(l_src_mcc_rec->m_offset_array - l_default_tcp->m_mct_records);
+                                l_dest_mcc_rec->m_offset_array = l_tcp->m_mct_records + l_offset;
+                        }
+
+                        ++l_src_mcc_rec;
+                        ++l_dest_mcc_rec;
+                }
+
+                /* Copy all the dflt_tile_compo_cp to the current tile cp */
+                memcpy(l_current_tccp,l_default_tcp->tccps,l_tccp_size);
+
+                /* Move to next tile cp*/
+                ++l_tcp;
+        }
+
+        /* Create the current tile decoder*/
+        p_j2k->m_tcd = (opj_tcd_t*)opj_tcd_create(OPJ_TRUE); /* FIXME why a cast ? */
+        if (! p_j2k->m_tcd ) {
+                return OPJ_FALSE;
+        }
+
+        if ( !opj_tcd_init(p_j2k->m_tcd, l_image, &(p_j2k->m_cp)) ) {
+                opj_tcd_destroy(p_j2k->m_tcd);
+                p_j2k->m_tcd = 00;
+                opj_event_msg(p_manager, EVT_ERROR, "Cannot decode tile, memory error\n");
+                return OPJ_FALSE;
+        }
+
+        return OPJ_TRUE;
+}
+
+const opj_dec_memory_marker_handler_t * opj_j2k_get_marker_handler (OPJ_UINT32 p_id)
+{
+        const opj_dec_memory_marker_handler_t *e;
+        for (e = j2k_memory_marker_handler_tab; e->id != 0; ++e) {
+                if (e->id == p_id) {
+                        break; /* we find a handler corresponding to the marker ID*/
+                }
+        }
+        return e;
+}
+
+void opj_j2k_destroy (opj_j2k_t *p_j2k)
+{
+        if (p_j2k == 00) {
+                return;
+        }
+
+        if (p_j2k->m_is_decoder) {
+
+                if (p_j2k->m_specific_param.m_decoder.m_default_tcp != 00) {
+                        opj_j2k_tcp_destroy(p_j2k->m_specific_param.m_decoder.m_default_tcp);
+                        opj_free(p_j2k->m_specific_param.m_decoder.m_default_tcp);
+                        p_j2k->m_specific_param.m_decoder.m_default_tcp = 00;
+                }
+
+                if (p_j2k->m_specific_param.m_decoder.m_header_data != 00) {
+                        opj_free(p_j2k->m_specific_param.m_decoder.m_header_data);
+                        p_j2k->m_specific_param.m_decoder.m_header_data = 00;
+                        p_j2k->m_specific_param.m_decoder.m_header_data_size = 0;
+                }
+        }
+        else {
+
+                if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data) {
+                        opj_free(p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);
+                        p_j2k->m_specific_param.m_encoder.m_encoded_tile_data = 00;
+                }
+
+                if (p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {
+                        opj_free(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer);
+                        p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = 00;
+                        p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current = 00;
+                }
+
+                if (p_j2k->m_specific_param.m_encoder.m_header_tile_data) {
+                        opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
+                        p_j2k->m_specific_param.m_encoder.m_header_tile_data = 00;
+                        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;
+                }
+        }
+
+        opj_tcd_destroy(p_j2k->m_tcd);
+
+        opj_j2k_cp_destroy(&(p_j2k->m_cp));
+        memset(&(p_j2k->m_cp),0,sizeof(opj_cp_t));
+
+        opj_procedure_list_destroy(p_j2k->m_procedure_list);
+        p_j2k->m_procedure_list = 00;
+
+        opj_procedure_list_destroy(p_j2k->m_validation_list);
+        p_j2k->m_procedure_list = 00;
+
+        j2k_destroy_cstr_index(p_j2k->cstr_index);
+        p_j2k->cstr_index = NULL;
+
+        opj_image_destroy(p_j2k->m_private_image);
+        p_j2k->m_private_image = NULL;
+
+        opj_image_destroy(p_j2k->m_output_image);
+        p_j2k->m_output_image = NULL;
+
+        opj_free(p_j2k);
+}
+
+void j2k_destroy_cstr_index (opj_codestream_index_t *p_cstr_ind)
+{
+        if (p_cstr_ind) {
+
+                if (p_cstr_ind->marker) {
+                        opj_free(p_cstr_ind->marker);
+                        p_cstr_ind->marker = NULL;
+                }
+
+                if (p_cstr_ind->tile_index) {
+                        OPJ_UINT32 it_tile = 0;
+
+                        for (it_tile=0; it_tile < p_cstr_ind->nb_of_tiles; it_tile++) {
+
+                                if(p_cstr_ind->tile_index[it_tile].packet_index) {
+                                        opj_free(p_cstr_ind->tile_index[it_tile].packet_index);
+                                        p_cstr_ind->tile_index[it_tile].packet_index = NULL;
+                                }
+
+                                if(p_cstr_ind->tile_index[it_tile].tp_index){
+                                        opj_free(p_cstr_ind->tile_index[it_tile].tp_index);
+                                        p_cstr_ind->tile_index[it_tile].tp_index = NULL;
+                                }
+
+                                if(p_cstr_ind->tile_index[it_tile].marker){
+                                        opj_free(p_cstr_ind->tile_index[it_tile].marker);
+                                        p_cstr_ind->tile_index[it_tile].marker = NULL;
+
+                                }
+                        }
+
+                        opj_free( p_cstr_ind->tile_index);
+                        p_cstr_ind->tile_index = NULL;
+                }
+
+                opj_free(p_cstr_ind);
+        }
+}
+
+void opj_j2k_tcp_destroy (opj_tcp_t *p_tcp)
+{
+        if (p_tcp == 00) {
+                return;
+        }
+
+        if (p_tcp->ppt_buffer != 00) {
+                opj_free(p_tcp->ppt_buffer);
+                p_tcp->ppt_buffer = 00;
+        }
+
+        if (p_tcp->tccps != 00) {
+                opj_free(p_tcp->tccps);
+                p_tcp->tccps = 00;
+        }
+
+        if (p_tcp->m_mct_coding_matrix != 00) {
+                opj_free(p_tcp->m_mct_coding_matrix);
+                p_tcp->m_mct_coding_matrix = 00;
+        }
+
+        if (p_tcp->m_mct_decoding_matrix != 00) {
+                opj_free(p_tcp->m_mct_decoding_matrix);
+                p_tcp->m_mct_decoding_matrix = 00;
+        }
+
+        if (p_tcp->m_mcc_records) {
+                opj_free(p_tcp->m_mcc_records);
+                p_tcp->m_mcc_records = 00;
+                p_tcp->m_nb_max_mcc_records = 0;
+                p_tcp->m_nb_mcc_records = 0;
+        }
+
+        if (p_tcp->m_mct_records) {
+                opj_mct_data_t * l_mct_data = p_tcp->m_mct_records;
+                OPJ_UINT32 i;
+
+                for (i=0;i<p_tcp->m_nb_mct_records;++i) {
+                        if (l_mct_data->m_data) {
+                                opj_free(l_mct_data->m_data);
+                                l_mct_data->m_data = 00;
+                        }
+
+                        ++l_mct_data;
+                }
+
+                opj_free(p_tcp->m_mct_records);
+                p_tcp->m_mct_records = 00;
+        }
+
+        if (p_tcp->mct_norms != 00) {
+                opj_free(p_tcp->mct_norms);
+                p_tcp->mct_norms = 00;
+        }
+
+        opj_j2k_tcp_data_destroy(p_tcp);
+
+}
+
+void opj_j2k_tcp_data_destroy (opj_tcp_t *p_tcp)
+{
+        if (p_tcp->m_data) {
+                opj_free(p_tcp->m_data);
+                p_tcp->m_data = NULL;
+                p_tcp->m_data_size = 0;
+        }
+}
+
+void opj_j2k_cp_destroy (opj_cp_t *p_cp)
+{
+        OPJ_UINT32 l_nb_tiles;
+        opj_tcp_t * l_current_tile = 00;
+        OPJ_UINT32 i;
+
+        if (p_cp == 00)
+        {
+                return;
+        }
+        if (p_cp->tcps != 00)
+        {
+                l_current_tile = p_cp->tcps;
+                l_nb_tiles = p_cp->th * p_cp->tw;
+
+                for (i = 0; i < l_nb_tiles; ++i)
+                {
+                        opj_j2k_tcp_destroy(l_current_tile);
+                        ++l_current_tile;
+                }
+                opj_free(p_cp->tcps);
+                p_cp->tcps = 00;
+        }
+        opj_free(p_cp->ppm_buffer);
+        p_cp->ppm_buffer = 00;
+        p_cp->ppm_data = NULL; /* ppm_data belongs to the allocated buffer pointed by ppm_buffer */
+        opj_free(p_cp->comment);
+        p_cp->comment = 00;
+        if (! p_cp->m_is_decoder)
+        {
+                opj_free(p_cp->m_specific_param.m_enc.m_matrice);
+                p_cp->m_specific_param.m_enc.m_matrice = 00;
+        }
+}
+
+OPJ_BOOL opj_j2k_read_tile_header(      opj_j2k_t * p_j2k,
+                                                                    OPJ_UINT32 * p_tile_index,
+                                                                    OPJ_UINT32 * p_data_size,
+                                                                    OPJ_INT32 * p_tile_x0, OPJ_INT32 * p_tile_y0,
+                                                                    OPJ_INT32 * p_tile_x1, OPJ_INT32 * p_tile_y1,
+                                                                    OPJ_UINT32 * p_nb_comps,
+                                                                    OPJ_BOOL * p_go_on,
+                                                                    opj_stream_private_t *p_stream,
+                                                                    opj_event_mgr_t * p_manager )
+{
+        OPJ_UINT32 l_current_marker = J2K_MS_SOT;
+        OPJ_UINT32 l_marker_size;
+        const opj_dec_memory_marker_handler_t * l_marker_handler = 00;
+        opj_tcp_t * l_tcp = NULL;
+        OPJ_UINT32 l_nb_tiles;
+
+        /* preconditions */
+        assert(p_stream != 00);
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+
+        /* Reach the End Of Codestream ?*/
+        if (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_EOC){
+                l_current_marker = J2K_MS_EOC;
+        }
+        /* We need to encounter a SOT marker (a new tile-part header) */
+        else if (p_j2k->m_specific_param.m_decoder.m_state != J2K_STATE_TPHSOT){
+                return OPJ_FALSE;
+        }
+
+        /* Read into the codestream until reach the EOC or ! can_decode ??? FIXME */
+        while ( (!p_j2k->m_specific_param.m_decoder.m_can_decode) && (l_current_marker != J2K_MS_EOC) ) {
+
+                /* Try to read until the Start Of Data is detected */
+                while (l_current_marker != J2K_MS_SOD) {
+                    
+                    if(opj_stream_get_number_byte_left(p_stream) == 0)
+                    {
+                        p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_NEOC;
+                        break;
+                    }
+
+                        /* Try to read 2 bytes (the marker size) from stream and copy them into the buffer */
+                        if (opj_stream_read_data(p_stream,p_j2k->m_specific_param.m_decoder.m_header_data,2,p_manager) != 2) {
+                                opj_event_msg(p_manager, EVT_ERROR, "Stream too short\n");
+                                return OPJ_FALSE;
+                        }
+
+                        /* Read 2 bytes from the buffer as the marker size */
+                        opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,&l_marker_size,2);
+
+                        /* cf. https://code.google.com/p/openjpeg/issues/detail?id=226 */
+                        if (l_current_marker == 0x8080 && opj_stream_get_number_byte_left(p_stream) == 0) {
+                                p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_NEOC;
+                                break;
+                        }
+
+                        /* Why this condition? FIXME */
+                        if (p_j2k->m_specific_param.m_decoder.m_state & J2K_STATE_TPH){
+                                p_j2k->m_specific_param.m_decoder.m_sot_length -= (l_marker_size + 2);
+                        }
+                        l_marker_size -= 2; /* Subtract the size of the marker ID already read */
+
+                        /* Get the marker handler from the marker ID */
+                        l_marker_handler = opj_j2k_get_marker_handler(l_current_marker);
+
+                        /* Check if the marker is known and if it is the right place to find it */
+                        if (! (p_j2k->m_specific_param.m_decoder.m_state & l_marker_handler->states) ) {
+                                opj_event_msg(p_manager, EVT_ERROR, "Marker is not compliant with its position\n");
+                                return OPJ_FALSE;
+                        }
+/* FIXME manage case of unknown marker as in the main header ? */
+
+                        /* Check if the marker size is compatible with the header data size */
+                        if (l_marker_size > p_j2k->m_specific_param.m_decoder.m_header_data_size) {
+                                OPJ_BYTE *new_header_data = (OPJ_BYTE *) opj_realloc(p_j2k->m_specific_param.m_decoder.m_header_data, l_marker_size);
+                                if (! new_header_data) {
+                                        opj_free(p_j2k->m_specific_param.m_decoder.m_header_data);
+                                        p_j2k->m_specific_param.m_decoder.m_header_data = NULL;
+                                        p_j2k->m_specific_param.m_decoder.m_header_data_size = 0;
+                                        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to read header\n");
+                                        return OPJ_FALSE;
+                                }
+                                p_j2k->m_specific_param.m_decoder.m_header_data = new_header_data;
+                                p_j2k->m_specific_param.m_decoder.m_header_data_size = l_marker_size;
+                        }
+
+                        /* Try to read the rest of the marker segment from stream and copy them into the buffer */
+                        if (opj_stream_read_data(p_stream,p_j2k->m_specific_param.m_decoder.m_header_data,l_marker_size,p_manager) != l_marker_size) {
+                                opj_event_msg(p_manager, EVT_ERROR, "Stream too short\n");
+                                return OPJ_FALSE;
+                        }
+
+                        if (!l_marker_handler->handler) {
+                                /* See issue #175 */
+                                opj_event_msg(p_manager, EVT_ERROR, "Not sure how that happened.\n");
+                                return OPJ_FALSE;
+                        }
+                        /* Read the marker segment with the correct marker handler */
+                        if (! (*(l_marker_handler->handler))(p_j2k,p_j2k->m_specific_param.m_decoder.m_header_data,l_marker_size,p_manager)) {
+                                opj_event_msg(p_manager, EVT_ERROR, "Fail to read the current marker segment (%#x)\n", l_current_marker);
+                                return OPJ_FALSE;
+                        }
+
+                        /* Add the marker to the codestream index*/
+                        if (OPJ_FALSE == opj_j2k_add_tlmarker(p_j2k->m_current_tile_number,
+                                                p_j2k->cstr_index,
+                                                l_marker_handler->id,
+                                                (OPJ_UINT32) opj_stream_tell(p_stream) - l_marker_size - 4,
+                                                l_marker_size + 4 )) {
+                                opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to add tl marker\n");
+                                return OPJ_FALSE;
+                        }
+
+                        /* Keep the position of the last SOT marker read */
+                        if ( l_marker_handler->id == J2K_MS_SOT ) {
+                                OPJ_UINT32 sot_pos = (OPJ_UINT32) opj_stream_tell(p_stream) - l_marker_size - 4 ;
+                                if (sot_pos > p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos)
+                                {
+                                        p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos = sot_pos;
+                                }
+                        }
+
+                        if (p_j2k->m_specific_param.m_decoder.m_skip_data) {
+                                /* Skip the rest of the tile part header*/
+                                if (opj_stream_skip(p_stream,p_j2k->m_specific_param.m_decoder.m_sot_length,p_manager) != p_j2k->m_specific_param.m_decoder.m_sot_length) {
+                                        opj_event_msg(p_manager, EVT_ERROR, "Stream too short\n");
+                                        return OPJ_FALSE;
+                                }
+                                l_current_marker = J2K_MS_SOD; /* Normally we reached a SOD */
+                        }
+                        else {
+                                /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer*/
+                                if (opj_stream_read_data(p_stream,p_j2k->m_specific_param.m_decoder.m_header_data,2,p_manager) != 2) {
+                                        opj_event_msg(p_manager, EVT_ERROR, "Stream too short\n");
+                                        return OPJ_FALSE;
+                                }
+                                /* Read 2 bytes from the buffer as the new marker ID */
+                                opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,&l_current_marker,2);
+                        }
+                }
+                if(opj_stream_get_number_byte_left(p_stream) == 0
+                    && p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_NEOC)
+                    break;
+
+                /* If we didn't skip data before, we need to read the SOD marker*/
+                if (! p_j2k->m_specific_param.m_decoder.m_skip_data) {
+                        /* Try to read the SOD marker and skip data ? FIXME */
+                        if (! opj_j2k_read_sod(p_j2k, p_stream, p_manager)) {
+                                return OPJ_FALSE;
+                        }
+
+                        if (! p_j2k->m_specific_param.m_decoder.m_can_decode){
+                                /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer */
+                                if (opj_stream_read_data(p_stream,p_j2k->m_specific_param.m_decoder.m_header_data,2,p_manager) != 2) {
+                                        opj_event_msg(p_manager, EVT_ERROR, "Stream too short\n");
+                                        return OPJ_FALSE;
+                                }
+
+                                /* Read 2 bytes from buffer as the new marker ID */
+                                opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,&l_current_marker,2);
+                        }
+                }
+                else {
+                        /* Indicate we will try to read a new tile-part header*/
+                        p_j2k->m_specific_param.m_decoder.m_skip_data = 0;
+                        p_j2k->m_specific_param.m_decoder.m_can_decode = 0;
+                        p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_TPHSOT;
+
+                        /* Try to read 2 bytes (the next marker ID) from stream and copy them into the buffer */
+                        if (opj_stream_read_data(p_stream,p_j2k->m_specific_param.m_decoder.m_header_data,2,p_manager) != 2) {
+                                opj_event_msg(p_manager, EVT_ERROR, "Stream too short\n");
+                                return OPJ_FALSE;
+                        }
+
+                        /* Read 2 bytes from buffer as the new marker ID */
+                        opj_read_bytes(p_j2k->m_specific_param.m_decoder.m_header_data,&l_current_marker,2);
+                }
+        }
+
+        /* Current marker is the EOC marker ?*/
+        if (l_current_marker == J2K_MS_EOC) {
+                if (p_j2k->m_specific_param.m_decoder.m_state != J2K_STATE_EOC ){
+                        p_j2k->m_current_tile_number = 0;
+                        p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_EOC;
+                }
+        }
+
+        /* FIXME DOC ???*/
+        if ( ! p_j2k->m_specific_param.m_decoder.m_can_decode) {
+                l_tcp = p_j2k->m_cp.tcps + p_j2k->m_current_tile_number;
+                l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
+
+                while( (p_j2k->m_current_tile_number < l_nb_tiles) && (l_tcp->m_data == 00) ) {
+                        ++p_j2k->m_current_tile_number;
+                        ++l_tcp;
+                }
+
+                if (p_j2k->m_current_tile_number == l_nb_tiles) {
+                        *p_go_on = OPJ_FALSE;
+                        return OPJ_TRUE;
+                }
+        }
+
+        /*FIXME ???*/
+        if (! opj_tcd_init_decode_tile(p_j2k->m_tcd, p_j2k->m_current_tile_number)) {
+                opj_event_msg(p_manager, EVT_ERROR, "Cannot decode tile, memory error\n");
+                return OPJ_FALSE;
+        }
+
+        opj_event_msg(p_manager, EVT_INFO, "Header of tile %d / %d has been read.\n",
+                        p_j2k->m_current_tile_number, (p_j2k->m_cp.th * p_j2k->m_cp.tw) - 1);
+
+        *p_tile_index = p_j2k->m_current_tile_number;
+        *p_go_on = OPJ_TRUE;
+        *p_data_size = opj_tcd_get_decoded_tile_size(p_j2k->m_tcd);
+        *p_tile_x0 = p_j2k->m_tcd->tcd_image->tiles->x0;
+        *p_tile_y0 = p_j2k->m_tcd->tcd_image->tiles->y0;
+        *p_tile_x1 = p_j2k->m_tcd->tcd_image->tiles->x1;
+        *p_tile_y1 = p_j2k->m_tcd->tcd_image->tiles->y1;
+        *p_nb_comps = p_j2k->m_tcd->tcd_image->tiles->numcomps;
+
+         p_j2k->m_specific_param.m_decoder.m_state |= 0x0080;/* FIXME J2K_DEC_STATE_DATA;*/
+
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_j2k_decode_tile (  opj_j2k_t * p_j2k,
+                                                        OPJ_UINT32 p_tile_index,
+                                                        OPJ_BYTE * p_data,
+                                                        OPJ_UINT32 p_data_size,
+                                                        opj_stream_private_t *p_stream,
+                                                        opj_event_mgr_t * p_manager )
+{
+        OPJ_UINT32 l_current_marker;
+        OPJ_BYTE l_data [2];
+        opj_tcp_t * l_tcp;
+
+        /* preconditions */
+        assert(p_stream != 00);
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+
+        if ( !(p_j2k->m_specific_param.m_decoder.m_state & 0x0080/*FIXME J2K_DEC_STATE_DATA*/)
+                || (p_tile_index != p_j2k->m_current_tile_number) ) {
+                return OPJ_FALSE;
+        }
+
+        l_tcp = &(p_j2k->m_cp.tcps[p_tile_index]);
+        if (! l_tcp->m_data) {
+                opj_j2k_tcp_destroy(l_tcp);
+                return OPJ_FALSE;
+        }
+
+        if (! opj_tcd_decode_tile(      p_j2k->m_tcd,
+                                                                l_tcp->m_data,
+                                                                l_tcp->m_data_size,
+                                                                p_tile_index,
+                                                                p_j2k->cstr_index) ) {
+                opj_j2k_tcp_destroy(l_tcp);
+                p_j2k->m_specific_param.m_decoder.m_state |= 0x8000;/*FIXME J2K_DEC_STATE_ERR;*/
+                opj_event_msg(p_manager, EVT_ERROR, "Failed to decode.\n");
+                return OPJ_FALSE;
+        }
+
+        if (! opj_tcd_update_tile_data(p_j2k->m_tcd,p_data,p_data_size)) {
+                return OPJ_FALSE;
+        }
+
+        /* To avoid to destroy the tcp which can be useful when we try to decode a tile decoded before (cf j2k_random_tile_access)
+         * we destroy just the data which will be re-read in read_tile_header*/
+        /*opj_j2k_tcp_destroy(l_tcp);
+        p_j2k->m_tcd->tcp = 0;*/
+        opj_j2k_tcp_data_destroy(l_tcp);
+
+        p_j2k->m_specific_param.m_decoder.m_can_decode = 0;
+        p_j2k->m_specific_param.m_decoder.m_state &= (~ (0x0080u));/* FIXME J2K_DEC_STATE_DATA);*/
+
+        if(opj_stream_get_number_byte_left(p_stream) == 0 
+            && p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_NEOC){
+            return OPJ_TRUE;
+        }
+
+        if (p_j2k->m_specific_param.m_decoder.m_state != 0x0100){ /*FIXME J2K_DEC_STATE_EOC)*/
+                if (opj_stream_read_data(p_stream,l_data,2,p_manager) != 2) {
+                        opj_event_msg(p_manager, EVT_ERROR, "Stream too short\n");
+                        return OPJ_FALSE;
+                }
+
+                opj_read_bytes(l_data,&l_current_marker,2);
+
+                if (l_current_marker == J2K_MS_EOC) {
+                        p_j2k->m_current_tile_number = 0;
+                        p_j2k->m_specific_param.m_decoder.m_state =  0x0100;/*FIXME J2K_DEC_STATE_EOC;*/
+                }
+                else if (l_current_marker != J2K_MS_SOT)
+                {
+                        opj_event_msg(p_manager, EVT_ERROR, "Stream too short, expected SOT\n");
+                        
+                        if(opj_stream_get_number_byte_left(p_stream) == 0) {
+                            p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_NEOC;
+                            return OPJ_TRUE;
+                        }
+                        return OPJ_FALSE;
+                }
+        }
+
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_j2k_update_image_data (opj_tcd_t * p_tcd, OPJ_BYTE * p_data, opj_image_t* p_output_image)
+{
+        OPJ_UINT32 i,j,k = 0;
+        OPJ_UINT32 l_width_src,l_height_src;
+        OPJ_UINT32 l_width_dest,l_height_dest;
+        OPJ_INT32 l_offset_x0_src, l_offset_y0_src, l_offset_x1_src, l_offset_y1_src;
+        OPJ_INT32 l_start_offset_src, l_line_offset_src, l_end_offset_src ;
+        OPJ_UINT32 l_start_x_dest , l_start_y_dest;
+        OPJ_UINT32 l_x0_dest, l_y0_dest, l_x1_dest, l_y1_dest;
+        OPJ_INT32 l_start_offset_dest, l_line_offset_dest;
+
+        opj_image_comp_t * l_img_comp_src = 00;
+        opj_image_comp_t * l_img_comp_dest = 00;
+
+        opj_tcd_tilecomp_t * l_tilec = 00;
+        opj_image_t * l_image_src = 00;
+        OPJ_UINT32 l_size_comp, l_remaining;
+        OPJ_INT32 * l_dest_ptr;
+        opj_tcd_resolution_t* l_res= 00;
+
+        l_tilec = p_tcd->tcd_image->tiles->comps;
+        l_image_src = p_tcd->image;
+        l_img_comp_src = l_image_src->comps;
+
+        l_img_comp_dest = p_output_image->comps;
+
+        for (i=0; i<l_image_src->numcomps; i++) {
+
+                /* Allocate output component buffer if necessary */
+                if (!l_img_comp_dest->data) {
+
+                        l_img_comp_dest->data = (OPJ_INT32*) opj_calloc(l_img_comp_dest->w * l_img_comp_dest->h, sizeof(OPJ_INT32));
+                        if (! l_img_comp_dest->data) {
+                                return OPJ_FALSE;
+                        }
+                }
+
+                /* Copy info from decoded comp image to output image */
+                l_img_comp_dest->resno_decoded = l_img_comp_src->resno_decoded;
+
+                /*-----*/
+                /* Compute the precision of the output buffer */
+                l_size_comp = l_img_comp_src->prec >> 3; /*(/ 8)*/
+                l_remaining = l_img_comp_src->prec & 7;  /* (%8) */
+                l_res = l_tilec->resolutions + l_img_comp_src->resno_decoded;
+
+                if (l_remaining) {
+                        ++l_size_comp;
+                }
+
+                if (l_size_comp == 3) {
+                        l_size_comp = 4;
+                }
+                /*-----*/
+
+                /* Current tile component size*/
+                /*if (i == 0) {
+                fprintf(stdout, "SRC: l_res_x0=%d, l_res_x1=%d, l_res_y0=%d, l_res_y1=%d\n",
+                                l_res->x0, l_res->x1, l_res->y0, l_res->y1);
+                }*/
+
+                l_width_src = (OPJ_UINT32)(l_res->x1 - l_res->x0);
+                l_height_src = (OPJ_UINT32)(l_res->y1 - l_res->y0);
+
+                /* Border of the current output component*/
+                l_x0_dest = (OPJ_UINT32)opj_int_ceildivpow2((OPJ_INT32)l_img_comp_dest->x0, (OPJ_INT32)l_img_comp_dest->factor);
+                l_y0_dest = (OPJ_UINT32)opj_int_ceildivpow2((OPJ_INT32)l_img_comp_dest->y0, (OPJ_INT32)l_img_comp_dest->factor);
+                l_x1_dest = l_x0_dest + l_img_comp_dest->w;
+                l_y1_dest = l_y0_dest + l_img_comp_dest->h;
+
+                /*if (i == 0) {
+                fprintf(stdout, "DEST: l_x0_dest=%d, l_x1_dest=%d, l_y0_dest=%d, l_y1_dest=%d (%d)\n",
+                                l_x0_dest, l_x1_dest, l_y0_dest, l_y1_dest, l_img_comp_dest->factor );
+                }*/
+
+                /*-----*/
+                /* Compute the area (l_offset_x0_src, l_offset_y0_src, l_offset_x1_src, l_offset_y1_src)
+                 * of the input buffer (decoded tile component) which will be move
+                 * in the output buffer. Compute the area of the output buffer (l_start_x_dest,
+                 * l_start_y_dest, l_width_dest, l_height_dest)  which will be modified
+                 * by this input area.
+                 * */
+                assert( l_res->x0 >= 0);
+                assert( l_res->x1 >= 0);
+                if ( l_x0_dest < (OPJ_UINT32)l_res->x0 ) {
+                        l_start_x_dest = (OPJ_UINT32)l_res->x0 - l_x0_dest;
+                        l_offset_x0_src = 0;
+
+                        if ( l_x1_dest >= (OPJ_UINT32)l_res->x1 ) {
+                                l_width_dest = l_width_src;
+                                l_offset_x1_src = 0;
+                        }
+                        else {
+                                l_width_dest = l_x1_dest - (OPJ_UINT32)l_res->x0 ;
+                                l_offset_x1_src = (OPJ_INT32)(l_width_src - l_width_dest);
+                        }
+                }
+                else {
+                        l_start_x_dest = 0 ;
+                        l_offset_x0_src = (OPJ_INT32)l_x0_dest - l_res->x0;
+
+                        if ( l_x1_dest >= (OPJ_UINT32)l_res->x1 ) {
+                                l_width_dest = l_width_src - (OPJ_UINT32)l_offset_x0_src;
+                                l_offset_x1_src = 0;
+                        }
+                        else {
+                                l_width_dest = l_img_comp_dest->w ;
+                                l_offset_x1_src = l_res->x1 - (OPJ_INT32)l_x1_dest;
+                        }
+                }
+
+                if ( l_y0_dest < (OPJ_UINT32)l_res->y0 ) {
+                        l_start_y_dest = (OPJ_UINT32)l_res->y0 - l_y0_dest;
+                        l_offset_y0_src = 0;
+
+                        if ( l_y1_dest >= (OPJ_UINT32)l_res->y1 ) {
+                                l_height_dest = l_height_src;
+                                l_offset_y1_src = 0;
+                        }
+                        else {
+                                l_height_dest = l_y1_dest - (OPJ_UINT32)l_res->y0 ;
+                                l_offset_y1_src =  (OPJ_INT32)(l_height_src - l_height_dest);
+                        }
+                }
+                else {
+                        l_start_y_dest = 0 ;
+                        l_offset_y0_src = (OPJ_INT32)l_y0_dest - l_res->y0;
+
+                        if ( l_y1_dest >= (OPJ_UINT32)l_res->y1 ) {
+                                l_height_dest = l_height_src - (OPJ_UINT32)l_offset_y0_src;
+                                l_offset_y1_src = 0;
+                        }
+                        else {
+                                l_height_dest = l_img_comp_dest->h ;
+                                l_offset_y1_src = l_res->y1 - (OPJ_INT32)l_y1_dest;
+                        }
+                }
+
+                if( (l_offset_x0_src < 0 ) || (l_offset_y0_src < 0 ) || (l_offset_x1_src < 0 ) || (l_offset_y1_src < 0 ) ){
+                        return OPJ_FALSE;
+                }
+                /* testcase 2977.pdf.asan.67.2198 */
+                if ((OPJ_INT32)l_width_dest < 0 || (OPJ_INT32)l_height_dest < 0) {
+                        return OPJ_FALSE;
+                }
+                /*-----*/
+
+                /* Compute the input buffer offset */
+                l_start_offset_src = l_offset_x0_src + l_offset_y0_src * (OPJ_INT32)l_width_src;
+                l_line_offset_src = l_offset_x1_src + l_offset_x0_src;
+                l_end_offset_src = l_offset_y1_src * (OPJ_INT32)l_width_src - l_offset_x0_src;
+
+                /* Compute the output buffer offset */
+                l_start_offset_dest = (OPJ_INT32)(l_start_x_dest + l_start_y_dest * l_img_comp_dest->w);
+                l_line_offset_dest = (OPJ_INT32)(l_img_comp_dest->w - l_width_dest);
+
+                /* Move the output buffer to the first place where we will write*/
+                l_dest_ptr = l_img_comp_dest->data + l_start_offset_dest;
+
+                /*if (i == 0) {
+                        fprintf(stdout, "COMPO[%d]:\n",i);
+                        fprintf(stdout, "SRC: l_start_x_src=%d, l_start_y_src=%d, l_width_src=%d, l_height_src=%d\n"
+                                        "\t tile offset:%d, %d, %d, %d\n"
+                                        "\t buffer offset: %d; %d, %d\n",
+                                        l_res->x0, l_res->y0, l_width_src, l_height_src,
+                                        l_offset_x0_src, l_offset_y0_src, l_offset_x1_src, l_offset_y1_src,
+                                        l_start_offset_src, l_line_offset_src, l_end_offset_src);
+
+                        fprintf(stdout, "DEST: l_start_x_dest=%d, l_start_y_dest=%d, l_width_dest=%d, l_height_dest=%d\n"
+                                        "\t start offset: %d, line offset= %d\n",
+                                        l_start_x_dest, l_start_y_dest, l_width_dest, l_height_dest, l_start_offset_dest, l_line_offset_dest);
+                }*/
+
+                switch (l_size_comp) {
+                        case 1:
+                                {
+                                        OPJ_CHAR * l_src_ptr = (OPJ_CHAR*) p_data;
+                                        l_src_ptr += l_start_offset_src; /* Move to the first place where we will read*/
+
+                                        if (l_img_comp_src->sgnd) {
+                                                for (j = 0 ; j < l_height_dest ; ++j) {
+                                                        for ( k = 0 ; k < l_width_dest ; ++k) {
+                                                                *(l_dest_ptr++) = (OPJ_INT32) (*(l_src_ptr++)); /* Copy only the data needed for the output image */
+                                                        }
+
+                                                        l_dest_ptr+= l_line_offset_dest; /* Move to the next place where we will write */
+                                                        l_src_ptr += l_line_offset_src ; /* Move to the next place where we will read */
+                                                }
+                                        }
+                                        else {
+                                                for ( j = 0 ; j < l_height_dest ; ++j ) {
+                                                        for ( k = 0 ; k < l_width_dest ; ++k) {
+                                                                *(l_dest_ptr++) = (OPJ_INT32) ((*(l_src_ptr++))&0xff);
+                                                        }
+
+                                                        l_dest_ptr+= l_line_offset_dest;
+                                                        l_src_ptr += l_line_offset_src;
+                                                }
+                                        }
+
+                                        l_src_ptr += l_end_offset_src; /* Move to the end of this component-part of the input buffer */
+                                        p_data = (OPJ_BYTE*) l_src_ptr; /* Keep the current position for the next component-part */
+                                }
+                                break;
+                        case 2:
+                                {
+                                        OPJ_INT16 * l_src_ptr = (OPJ_INT16 *) p_data;
+                                        l_src_ptr += l_start_offset_src;
+
+                                        if (l_img_comp_src->sgnd) {
+                                                for (j=0;j<l_height_dest;++j) {
+                                                        for (k=0;k<l_width_dest;++k) {
+                                                                *(l_dest_ptr++) = *(l_src_ptr++);
+                                                        }
+
+                                                        l_dest_ptr+= l_line_offset_dest;
+                                                        l_src_ptr += l_line_offset_src ;
+                                                }
+                                        }
+                                        else {
+                                                for (j=0;j<l_height_dest;++j) {
+                                                        for (k=0;k<l_width_dest;++k) {
+                                                                *(l_dest_ptr++) = (*(l_src_ptr++))&0xffff;
+                                                        }
+
+                                                        l_dest_ptr+= l_line_offset_dest;
+                                                        l_src_ptr += l_line_offset_src ;
+                                                }
+                                        }
+
+                                        l_src_ptr += l_end_offset_src;
+                                        p_data = (OPJ_BYTE*) l_src_ptr;
+                                }
+                                break;
+                        case 4:
+                                {
+                                        OPJ_INT32 * l_src_ptr = (OPJ_INT32 *) p_data;
+                                        l_src_ptr += l_start_offset_src;
+
+                                        for (j=0;j<l_height_dest;++j) {
+                                                for (k=0;k<l_width_dest;++k) {
+                                                        *(l_dest_ptr++) = (*(l_src_ptr++));
+                                                }
+
+                                                l_dest_ptr+= l_line_offset_dest;
+                                                l_src_ptr += l_line_offset_src ;
+                                        }
+
+                                        l_src_ptr += l_end_offset_src;
+                                        p_data = (OPJ_BYTE*) l_src_ptr;
+                                }
+                                break;
+                }
+
+                ++l_img_comp_dest;
+                ++l_img_comp_src;
+                ++l_tilec;
+        }
+
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_j2k_set_decode_area(       opj_j2k_t *p_j2k,
+                                                                    opj_image_t* p_image,
+                                                                    OPJ_INT32 p_start_x, OPJ_INT32 p_start_y,
+                                                                    OPJ_INT32 p_end_x, OPJ_INT32 p_end_y,
+                                                                    opj_event_mgr_t * p_manager )
+{
+        opj_cp_t * l_cp = &(p_j2k->m_cp);
+        opj_image_t * l_image = p_j2k->m_private_image;
+
+        OPJ_UINT32 it_comp;
+        OPJ_INT32 l_comp_x1, l_comp_y1;
+        opj_image_comp_t* l_img_comp = NULL;
+
+        /* Check if we are read the main header */
+        if (p_j2k->m_specific_param.m_decoder.m_state != J2K_STATE_TPHSOT) { /* FIXME J2K_DEC_STATE_TPHSOT)*/
+                opj_event_msg(p_manager, EVT_ERROR, "Need to decode the main header before begin to decode the remaining codestream");
+                return OPJ_FALSE;
+        }
+
+        if ( !p_start_x && !p_start_y && !p_end_x && !p_end_y){
+                opj_event_msg(p_manager, EVT_INFO, "No decoded area parameters, set the decoded area to the whole image\n");
+
+                p_j2k->m_specific_param.m_decoder.m_start_tile_x = 0;
+                p_j2k->m_specific_param.m_decoder.m_start_tile_y = 0;
+                p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;
+                p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;
+
+                return OPJ_TRUE;
+        }
+
+        /* ----- */
+        /* Check if the positions provided by the user are correct */
+
+        /* Left */
+        assert(p_start_x >= 0 );
+        assert(p_start_y >= 0 );
+
+        if ((OPJ_UINT32)p_start_x > l_image->x1 ) {
+                opj_event_msg(p_manager, EVT_ERROR,
+                        "Left position of the decoded area (region_x0=%d) is outside the image area (Xsiz=%d).\n",
+                        p_start_x, l_image->x1);
+                return OPJ_FALSE;
+        }
+        else if ((OPJ_UINT32)p_start_x < l_image->x0){
+                opj_event_msg(p_manager, EVT_WARNING,
+                                "Left position of the decoded area (region_x0=%d) is outside the image area (XOsiz=%d).\n",
+                                p_start_x, l_image->x0);
+                p_j2k->m_specific_param.m_decoder.m_start_tile_x = 0;
+                p_image->x0 = l_image->x0;
+        }
+        else {
+                p_j2k->m_specific_param.m_decoder.m_start_tile_x = ((OPJ_UINT32)p_start_x - l_cp->tx0) / l_cp->tdx;
+                p_image->x0 = (OPJ_UINT32)p_start_x;
+        }
+
+        /* Up */
+        if ((OPJ_UINT32)p_start_y > l_image->y1){
+                opj_event_msg(p_manager, EVT_ERROR,
+                                "Up position of the decoded area (region_y0=%d) is outside the image area (Ysiz=%d).\n",
+                                p_start_y, l_image->y1);
+                return OPJ_FALSE;
+        }
+        else if ((OPJ_UINT32)p_start_y < l_image->y0){
+                opj_event_msg(p_manager, EVT_WARNING,
+                                "Up position of the decoded area (region_y0=%d) is outside the image area (YOsiz=%d).\n",
+                                p_start_y, l_image->y0);
+                p_j2k->m_specific_param.m_decoder.m_start_tile_y = 0;
+                p_image->y0 = l_image->y0;
+        }
+        else {
+                p_j2k->m_specific_param.m_decoder.m_start_tile_y = ((OPJ_UINT32)p_start_y - l_cp->ty0) / l_cp->tdy;
+                p_image->y0 = (OPJ_UINT32)p_start_y;
+        }
+
+        /* Right */
+        assert((OPJ_UINT32)p_end_x > 0);
+        assert((OPJ_UINT32)p_end_y > 0);
+        if ((OPJ_UINT32)p_end_x < l_image->x0) {
+                opj_event_msg(p_manager, EVT_ERROR,
+                        "Right position of the decoded area (region_x1=%d) is outside the image area (XOsiz=%d).\n",
+                        p_end_x, l_image->x0);
+                return OPJ_FALSE;
+        }
+        else if ((OPJ_UINT32)p_end_x > l_image->x1) {
+                opj_event_msg(p_manager, EVT_WARNING,
+                        "Right position of the decoded area (region_x1=%d) is outside the image area (Xsiz=%d).\n",
+                        p_end_x, l_image->x1);
+                p_j2k->m_specific_param.m_decoder.m_end_tile_x = l_cp->tw;
+                p_image->x1 = l_image->x1;
+        }
+        else {
+                p_j2k->m_specific_param.m_decoder.m_end_tile_x = (OPJ_UINT32)opj_int_ceildiv(p_end_x - (OPJ_INT32)l_cp->tx0, (OPJ_INT32)l_cp->tdx);
+                p_image->x1 = (OPJ_UINT32)p_end_x;
+        }
+
+        /* Bottom */
+        if ((OPJ_UINT32)p_end_y < l_image->y0) {
+                opj_event_msg(p_manager, EVT_ERROR,
+                        "Bottom position of the decoded area (region_y1=%d) is outside the image area (YOsiz=%d).\n",
+                        p_end_y, l_image->y0);
+                return OPJ_FALSE;
+        }
+        if ((OPJ_UINT32)p_end_y > l_image->y1){
+                opj_event_msg(p_manager, EVT_WARNING,
+                        "Bottom position of the decoded area (region_y1=%d) is outside the image area (Ysiz=%d).\n",
+                        p_end_y, l_image->y1);
+                p_j2k->m_specific_param.m_decoder.m_end_tile_y = l_cp->th;
+                p_image->y1 = l_image->y1;
+        }
+        else{
+                p_j2k->m_specific_param.m_decoder.m_end_tile_y = (OPJ_UINT32)opj_int_ceildiv(p_end_y - (OPJ_INT32)l_cp->ty0, (OPJ_INT32)l_cp->tdy);
+                p_image->y1 = (OPJ_UINT32)p_end_y;
+        }
+        /* ----- */
+
+        p_j2k->m_specific_param.m_decoder.m_discard_tiles = 1;
+
+        l_img_comp = p_image->comps;
+        for (it_comp=0; it_comp < p_image->numcomps; ++it_comp)
+        {
+                OPJ_INT32 l_h,l_w;
+
+                l_img_comp->x0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)p_image->x0, (OPJ_INT32)l_img_comp->dx);
+                l_img_comp->y0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)p_image->y0, (OPJ_INT32)l_img_comp->dy);
+                l_comp_x1 = opj_int_ceildiv((OPJ_INT32)p_image->x1, (OPJ_INT32)l_img_comp->dx);
+                l_comp_y1 = opj_int_ceildiv((OPJ_INT32)p_image->y1, (OPJ_INT32)l_img_comp->dy);
+
+                l_w = opj_int_ceildivpow2(l_comp_x1, (OPJ_INT32)l_img_comp->factor)
+                                - opj_int_ceildivpow2((OPJ_INT32)l_img_comp->x0, (OPJ_INT32)l_img_comp->factor);
+                if (l_w < 0){
+                        opj_event_msg(p_manager, EVT_ERROR,
+                                "Size x of the decoded component image is incorrect (comp[%d].w=%d).\n",
+                                it_comp, l_w);
+                        return OPJ_FALSE;
+                }
+                l_img_comp->w = (OPJ_UINT32)l_w;
+
+                l_h = opj_int_ceildivpow2(l_comp_y1, (OPJ_INT32)l_img_comp->factor)
+                                - opj_int_ceildivpow2((OPJ_INT32)l_img_comp->y0, (OPJ_INT32)l_img_comp->factor);
+                if (l_h < 0){
+                        opj_event_msg(p_manager, EVT_ERROR,
+                                "Size y of the decoded component image is incorrect (comp[%d].h=%d).\n",
+                                it_comp, l_h);
+                        return OPJ_FALSE;
+                }
+                l_img_comp->h = (OPJ_UINT32)l_h;
+
+                l_img_comp++;
+        }
+
+        opj_event_msg( p_manager, EVT_INFO,"Setting decoding area to %d,%d,%d,%d\n",
+                        p_image->x0, p_image->y0, p_image->x1, p_image->y1);
+
+        return OPJ_TRUE;
+}
+
+opj_j2k_t* opj_j2k_create_decompress(void)
+{
+        opj_j2k_t *l_j2k = (opj_j2k_t*) opj_malloc(sizeof(opj_j2k_t));
+        if (!l_j2k) {
+                return 00;
+        }
+        memset(l_j2k,0,sizeof(opj_j2k_t));
+
+        l_j2k->m_is_decoder = 1;
+        l_j2k->m_cp.m_is_decoder = 1;
+
+        l_j2k->m_specific_param.m_decoder.m_default_tcp = (opj_tcp_t*) opj_malloc(sizeof(opj_tcp_t));
+        if (!l_j2k->m_specific_param.m_decoder.m_default_tcp) {
+                opj_j2k_destroy(l_j2k);
+                return 00;
+        }
+        memset(l_j2k->m_specific_param.m_decoder.m_default_tcp,0,sizeof(opj_tcp_t));
+
+        l_j2k->m_specific_param.m_decoder.m_header_data = (OPJ_BYTE *) opj_malloc(OPJ_J2K_DEFAULT_HEADER_SIZE);
+        if (! l_j2k->m_specific_param.m_decoder.m_header_data) {
+                opj_j2k_destroy(l_j2k);
+                return 00;
+        }
+
+        l_j2k->m_specific_param.m_decoder.m_header_data_size = OPJ_J2K_DEFAULT_HEADER_SIZE;
+
+        l_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec = -1 ;
+
+        l_j2k->m_specific_param.m_decoder.m_last_sot_read_pos = 0 ;
+
+        /* codestream index creation */
+        l_j2k->cstr_index = opj_j2k_create_cstr_index();
+
+                        /*(opj_codestream_index_t*) opj_malloc(sizeof(opj_codestream_index_t));
+        if (!l_j2k->cstr_index){
+                opj_j2k_destroy(l_j2k);
+                return NULL;
+        }
+
+        l_j2k->cstr_index->marker = (opj_marker_info_t*) opj_malloc(100 * sizeof(opj_marker_info_t));
+*/
+
+        /* validation list creation */
+        l_j2k->m_validation_list = opj_procedure_list_create();
+        if (! l_j2k->m_validation_list) {
+                opj_j2k_destroy(l_j2k);
+                return 00;
+        }
+
+        /* execution list creation */
+        l_j2k->m_procedure_list = opj_procedure_list_create();
+        if (! l_j2k->m_procedure_list) {
+                opj_j2k_destroy(l_j2k);
+                return 00;
+        }
+
+        return l_j2k;
+}
+
+opj_codestream_index_t* opj_j2k_create_cstr_index(void)
+{
+        opj_codestream_index_t* cstr_index = (opj_codestream_index_t*)
+                        opj_calloc(1,sizeof(opj_codestream_index_t));
+        if (!cstr_index)
+                return NULL;
+
+        cstr_index->maxmarknum = 100;
+        cstr_index->marknum = 0;
+        cstr_index->marker = (opj_marker_info_t*)
+                        opj_calloc(cstr_index->maxmarknum, sizeof(opj_marker_info_t));
+        if (!cstr_index-> marker)
+                return NULL;
+
+        cstr_index->tile_index = NULL;
+
+        return cstr_index;
+}
+
+OPJ_UINT32 opj_j2k_get_SPCod_SPCoc_size (       opj_j2k_t *p_j2k,
+                                                                                OPJ_UINT32 p_tile_no,
+                                                                                OPJ_UINT32 p_comp_no )
+{
+        opj_cp_t *l_cp = 00;
+        opj_tcp_t *l_tcp = 00;
+        opj_tccp_t *l_tccp = 00;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+
+        l_cp = &(p_j2k->m_cp);
+        l_tcp = &l_cp->tcps[p_tile_no];
+        l_tccp = &l_tcp->tccps[p_comp_no];
+
+        /* preconditions again */
+        assert(p_tile_no < (l_cp->tw * l_cp->th));
+        assert(p_comp_no < p_j2k->m_private_image->numcomps);
+
+        if (l_tccp->csty & J2K_CCP_CSTY_PRT) {
+                return 5 + l_tccp->numresolutions;
+        }
+        else {
+                return 5;
+        }
+}
+
+OPJ_BOOL opj_j2k_write_SPCod_SPCoc(     opj_j2k_t *p_j2k,
+                                                                    OPJ_UINT32 p_tile_no,
+                                                                    OPJ_UINT32 p_comp_no,
+                                                                    OPJ_BYTE * p_data,
+                                                                    OPJ_UINT32 * p_header_size,
+                                                                    struct opj_event_mgr * p_manager )
+{
+        OPJ_UINT32 i;
+        opj_cp_t *l_cp = 00;
+        opj_tcp_t *l_tcp = 00;
+        opj_tccp_t *l_tccp = 00;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_header_size != 00);
+        assert(p_manager != 00);
+        assert(p_data != 00);
+
+        l_cp = &(p_j2k->m_cp);
+        l_tcp = &l_cp->tcps[p_tile_no];
+        l_tccp = &l_tcp->tccps[p_comp_no];
+
+        /* preconditions again */
+        assert(p_tile_no < (l_cp->tw * l_cp->th));
+        assert(p_comp_no <(p_j2k->m_private_image->numcomps));
+
+        if (*p_header_size < 5) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error writing SPCod SPCoc element\n");
+                return OPJ_FALSE;
+        }
+
+        opj_write_bytes(p_data,l_tccp->numresolutions - 1, 1);  /* SPcoc (D) */
+        ++p_data;
+
+        opj_write_bytes(p_data,l_tccp->cblkw - 2, 1);                   /* SPcoc (E) */
+        ++p_data;
+
+        opj_write_bytes(p_data,l_tccp->cblkh - 2, 1);                   /* SPcoc (F) */
+        ++p_data;
+
+        opj_write_bytes(p_data,l_tccp->cblksty, 1);                             /* SPcoc (G) */
+        ++p_data;
+
+        opj_write_bytes(p_data,l_tccp->qmfbid, 1);                              /* SPcoc (H) */
+        ++p_data;
+
+        *p_header_size = *p_header_size - 5;
+
+        if (l_tccp->csty & J2K_CCP_CSTY_PRT) {
+
+                if (*p_header_size < l_tccp->numresolutions) {
+                        opj_event_msg(p_manager, EVT_ERROR, "Error writing SPCod SPCoc element\n");
+                        return OPJ_FALSE;
+                }
+
+                for (i = 0; i < l_tccp->numresolutions; ++i) {
+                        opj_write_bytes(p_data,l_tccp->prcw[i] + (l_tccp->prch[i] << 4), 1);    /* SPcoc (I_i) */
+                        ++p_data;
+                }
+
+                *p_header_size = *p_header_size - l_tccp->numresolutions;
+        }
+
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_j2k_read_SPCod_SPCoc(  opj_j2k_t *p_j2k,
+                                                                OPJ_UINT32 compno,
+                                                                OPJ_BYTE * p_header_data,
+                                                                OPJ_UINT32 * p_header_size,
+                                                                opj_event_mgr_t * p_manager)
+{
+        OPJ_UINT32 i, l_tmp;
+        opj_cp_t *l_cp = NULL;
+        opj_tcp_t *l_tcp = NULL;
+        opj_tccp_t *l_tccp = NULL;
+        OPJ_BYTE * l_current_ptr = NULL;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_header_data != 00);
+
+        l_cp = &(p_j2k->m_cp);
+        l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ?
+                                &l_cp->tcps[p_j2k->m_current_tile_number] :
+                                p_j2k->m_specific_param.m_decoder.m_default_tcp;
+
+        /* precondition again */
+        assert(compno < p_j2k->m_private_image->numcomps);
+
+        l_tccp = &l_tcp->tccps[compno];
+        l_current_ptr = p_header_data;
+
+        /* make sure room is sufficient */
+        if (*p_header_size < 5) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading SPCod SPCoc element\n");
+                return OPJ_FALSE;
+        }
+
+        opj_read_bytes(l_current_ptr, &l_tccp->numresolutions ,1);              /* SPcox (D) */
+        ++l_tccp->numresolutions;                                                                               /* tccp->numresolutions = read() + 1 */
+        if (l_tccp->numresolutions > OPJ_J2K_MAXRLVLS) {
+                opj_event_msg(p_manager, EVT_ERROR,
+                              "Invalid value for numresolutions : %d, max value is set in openjpeg.h at %d\n",
+                              l_tccp->numresolutions, OPJ_J2K_MAXRLVLS);
+                return OPJ_FALSE;
+        }
+        ++l_current_ptr;
+
+        /* If user wants to remove more resolutions than the codestream contains, return error */
+        if (l_cp->m_specific_param.m_dec.m_reduce >= l_tccp->numresolutions) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error decoding component %d.\nThe number of resolutions to remove is higher than the number "
+                                        "of resolutions of this component\nModify the cp_reduce parameter.\n\n", compno);
+                p_j2k->m_specific_param.m_decoder.m_state |= 0x8000;/* FIXME J2K_DEC_STATE_ERR;*/
+                return OPJ_FALSE;
+        }
+
+        opj_read_bytes(l_current_ptr,&l_tccp->cblkw ,1);                /* SPcoc (E) */
+        ++l_current_ptr;
+        l_tccp->cblkw += 2;
+
+        opj_read_bytes(l_current_ptr,&l_tccp->cblkh ,1);                /* SPcoc (F) */
+        ++l_current_ptr;
+        l_tccp->cblkh += 2;
+
+        opj_read_bytes(l_current_ptr,&l_tccp->cblksty ,1);              /* SPcoc (G) */
+        ++l_current_ptr;
+
+        opj_read_bytes(l_current_ptr,&l_tccp->qmfbid ,1);               /* SPcoc (H) */
+        ++l_current_ptr;
+
+        *p_header_size = *p_header_size - 5;
+
+        /* use custom precinct size ? */
+        if (l_tccp->csty & J2K_CCP_CSTY_PRT) {
+                if (*p_header_size < l_tccp->numresolutions) {
+                        opj_event_msg(p_manager, EVT_ERROR, "Error reading SPCod SPCoc element\n");
+                        return OPJ_FALSE;
+                }
+
+                for     (i = 0; i < l_tccp->numresolutions; ++i) {
+                        opj_read_bytes(l_current_ptr,&l_tmp ,1);                /* SPcoc (I_i) */
+                        ++l_current_ptr;
+                        l_tccp->prcw[i] = l_tmp & 0xf;
+                        l_tccp->prch[i] = l_tmp >> 4;
+                }
+
+                *p_header_size = *p_header_size - l_tccp->numresolutions;
+        }
+        else {
+                /* set default size for the precinct width and height */
+                for     (i = 0; i < l_tccp->numresolutions; ++i) {
+                        l_tccp->prcw[i] = 15;
+                        l_tccp->prch[i] = 15;
+                }
+        }
+
+#ifdef WIP_REMOVE_MSD
+        /* INDEX >> */
+        if (p_j2k->cstr_info && compno == 0) {
+                OPJ_UINT32 l_data_size = l_tccp->numresolutions * sizeof(OPJ_UINT32);
+
+                p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].cblkh = l_tccp->cblkh;
+                p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].cblkw = l_tccp->cblkw;
+                p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].numresolutions = l_tccp->numresolutions;
+                p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].cblksty = l_tccp->cblksty;
+                p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].tccp_info[compno].qmfbid = l_tccp->qmfbid;
+
+                memcpy(p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].pdx,l_tccp->prcw, l_data_size);
+                memcpy(p_j2k->cstr_info->tile[p_j2k->m_current_tile_number].pdy,l_tccp->prch, l_data_size);
+        }
+        /* << INDEX */
+#endif
+
+        return OPJ_TRUE;
+}
+
+void opj_j2k_copy_tile_component_parameters( opj_j2k_t *p_j2k )
+{
+        /* loop */
+        OPJ_UINT32 i;
+        opj_cp_t *l_cp = NULL;
+        opj_tcp_t *l_tcp = NULL;
+        opj_tccp_t *l_ref_tccp = NULL, *l_copied_tccp = NULL;
+        OPJ_UINT32 l_prc_size;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+
+        l_cp = &(p_j2k->m_cp);
+        l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ? /* FIXME J2K_DEC_STATE_TPH*/
+                                &l_cp->tcps[p_j2k->m_current_tile_number] :
+                                p_j2k->m_specific_param.m_decoder.m_default_tcp;
+
+        l_ref_tccp = &l_tcp->tccps[0];
+        l_copied_tccp = l_ref_tccp + 1;
+        l_prc_size = l_ref_tccp->numresolutions * (OPJ_UINT32)sizeof(OPJ_UINT32);
+
+        for     (i=1; i<p_j2k->m_private_image->numcomps; ++i) {
+                l_copied_tccp->numresolutions = l_ref_tccp->numresolutions;
+                l_copied_tccp->cblkw = l_ref_tccp->cblkw;
+                l_copied_tccp->cblkh = l_ref_tccp->cblkh;
+                l_copied_tccp->cblksty = l_ref_tccp->cblksty;
+                l_copied_tccp->qmfbid = l_ref_tccp->qmfbid;
+                memcpy(l_copied_tccp->prcw,l_ref_tccp->prcw,l_prc_size);
+                memcpy(l_copied_tccp->prch,l_ref_tccp->prch,l_prc_size);
+                ++l_copied_tccp;
+        }
+}
+
+OPJ_UINT32 opj_j2k_get_SQcd_SQcc_size ( opj_j2k_t *p_j2k,
+                                                                        OPJ_UINT32 p_tile_no,
+                                                                        OPJ_UINT32 p_comp_no )
+{
+        OPJ_UINT32 l_num_bands;
+
+        opj_cp_t *l_cp = 00;
+        opj_tcp_t *l_tcp = 00;
+        opj_tccp_t *l_tccp = 00;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+
+        l_cp = &(p_j2k->m_cp);
+        l_tcp = &l_cp->tcps[p_tile_no];
+        l_tccp = &l_tcp->tccps[p_comp_no];
+
+        /* preconditions again */
+        assert(p_tile_no < l_cp->tw * l_cp->th);
+        assert(p_comp_no < p_j2k->m_private_image->numcomps);
+
+        l_num_bands = (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) ? 1 : (l_tccp->numresolutions * 3 - 2);
+
+        if (l_tccp->qntsty == J2K_CCP_QNTSTY_NOQNT)  {
+                return 1 + l_num_bands;
+        }
+        else {
+                return 1 + 2*l_num_bands;
+        }
+}
+
+OPJ_BOOL opj_j2k_write_SQcd_SQcc(       opj_j2k_t *p_j2k,
+                                                                OPJ_UINT32 p_tile_no,
+                                                                OPJ_UINT32 p_comp_no,
+                                                                OPJ_BYTE * p_data,
+                                                                OPJ_UINT32 * p_header_size,
+                                                                struct opj_event_mgr * p_manager )
+{
+        OPJ_UINT32 l_header_size;
+        OPJ_UINT32 l_band_no, l_num_bands;
+        OPJ_UINT32 l_expn,l_mant;
+
+        opj_cp_t *l_cp = 00;
+        opj_tcp_t *l_tcp = 00;
+        opj_tccp_t *l_tccp = 00;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_header_size != 00);
+        assert(p_manager != 00);
+        assert(p_data != 00);
+
+        l_cp = &(p_j2k->m_cp);
+        l_tcp = &l_cp->tcps[p_tile_no];
+        l_tccp = &l_tcp->tccps[p_comp_no];
+
+        /* preconditions again */
+        assert(p_tile_no < l_cp->tw * l_cp->th);
+        assert(p_comp_no <p_j2k->m_private_image->numcomps);
+
+        l_num_bands = (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) ? 1 : (l_tccp->numresolutions * 3 - 2);
+
+        if (l_tccp->qntsty == J2K_CCP_QNTSTY_NOQNT)  {
+                l_header_size = 1 + l_num_bands;
+
+                if (*p_header_size < l_header_size) {
+                        opj_event_msg(p_manager, EVT_ERROR, "Error writing SQcd SQcc element\n");
+                        return OPJ_FALSE;
+                }
+
+                opj_write_bytes(p_data,l_tccp->qntsty + (l_tccp->numgbits << 5), 1);    /* Sqcx */
+                ++p_data;
+
+                for (l_band_no = 0; l_band_no < l_num_bands; ++l_band_no) {
+                        l_expn = (OPJ_UINT32)l_tccp->stepsizes[l_band_no].expn;
+                        opj_write_bytes(p_data, l_expn << 3, 1);        /* SPqcx_i */
+                        ++p_data;
+                }
+        }
+        else {
+                l_header_size = 1 + 2*l_num_bands;
+
+                if (*p_header_size < l_header_size) {
+                        opj_event_msg(p_manager, EVT_ERROR, "Error writing SQcd SQcc element\n");
+                        return OPJ_FALSE;
+                }
+
+                opj_write_bytes(p_data,l_tccp->qntsty + (l_tccp->numgbits << 5), 1);    /* Sqcx */
+                ++p_data;
+
+                for (l_band_no = 0; l_band_no < l_num_bands; ++l_band_no) {
+                        l_expn = (OPJ_UINT32)l_tccp->stepsizes[l_band_no].expn;
+                        l_mant = (OPJ_UINT32)l_tccp->stepsizes[l_band_no].mant;
+
+                        opj_write_bytes(p_data, (l_expn << 11) + l_mant, 2);    /* SPqcx_i */
+                        p_data += 2;
+                }
+        }
+
+        *p_header_size = *p_header_size - l_header_size;
+
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_j2k_read_SQcd_SQcc(opj_j2k_t *p_j2k,
+                                                            OPJ_UINT32 p_comp_no,
+                                                            OPJ_BYTE* p_header_data,
+                                                            OPJ_UINT32 * p_header_size,
+                                                            opj_event_mgr_t * p_manager
+                                                            )
+{
+        /* loop*/
+        OPJ_UINT32 l_band_no;
+        opj_cp_t *l_cp = 00;
+        opj_tcp_t *l_tcp = 00;
+        opj_tccp_t *l_tccp = 00;
+        OPJ_BYTE * l_current_ptr = 00;
+        OPJ_UINT32 l_tmp, l_num_band;
+
+        /* preconditions*/
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_header_data != 00);
+
+        l_cp = &(p_j2k->m_cp);
+        /* come from tile part header or main header ?*/
+        l_tcp = (p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH) ? /*FIXME J2K_DEC_STATE_TPH*/
+                                &l_cp->tcps[p_j2k->m_current_tile_number] :
+                                p_j2k->m_specific_param.m_decoder.m_default_tcp;
+
+        /* precondition again*/
+        assert(p_comp_no <  p_j2k->m_private_image->numcomps);
+
+        l_tccp = &l_tcp->tccps[p_comp_no];
+        l_current_ptr = p_header_data;
+
+        if (*p_header_size < 1) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error reading SQcd or SQcc element\n");
+                return OPJ_FALSE;
+        }
+        *p_header_size -= 1;
+
+        opj_read_bytes(l_current_ptr, &l_tmp ,1);                       /* Sqcx */
+        ++l_current_ptr;
+
+        l_tccp->qntsty = l_tmp & 0x1f;
+        l_tccp->numgbits = l_tmp >> 5;
+        if (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) {
+        l_num_band = 1;
+        }
+        else {
+                l_num_band = (l_tccp->qntsty == J2K_CCP_QNTSTY_NOQNT) ?
+                        (*p_header_size) :
+                        (*p_header_size) / 2;
+
+                if( l_num_band > OPJ_J2K_MAXBANDS ) {
+                        opj_event_msg(p_manager, EVT_WARNING, "While reading CCP_QNTSTY element inside QCD or QCC marker segment, "
+                                "number of subbands (%d) is greater to OPJ_J2K_MAXBANDS (%d). So we limit the number of elements stored to "
+                                "OPJ_J2K_MAXBANDS (%d) and skip the rest. \n", l_num_band, OPJ_J2K_MAXBANDS, OPJ_J2K_MAXBANDS);
+                        /*return OPJ_FALSE;*/
+                }
+        }
+
+#ifdef USE_JPWL
+        if (l_cp->correct) {
+
+                /* if JPWL is on, we check whether there are too many subbands */
+                if (/*(l_num_band < 0) ||*/ (l_num_band >= OPJ_J2K_MAXBANDS)) {
+                        opj_event_msg(p_manager, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,
+                                "JPWL: bad number of subbands in Sqcx (%d)\n",
+                                l_num_band);
+                        if (!JPWL_ASSUME) {
+                                opj_event_msg(p_manager, EVT_ERROR, "JPWL: giving up\n");
+                                return OPJ_FALSE;
+                        }
+                        /* we try to correct */
+                        l_num_band = 1;
+                        opj_event_msg(p_manager, EVT_WARNING, "- trying to adjust them\n"
+                                "- setting number of bands to %d => HYPOTHESIS!!!\n",
+                                l_num_band);
+                };
+
+        };
+#endif /* USE_JPWL */
+
+        if (l_tccp->qntsty == J2K_CCP_QNTSTY_NOQNT) {
+                for     (l_band_no = 0; l_band_no < l_num_band; l_band_no++) {
+                        opj_read_bytes(l_current_ptr, &l_tmp ,1);                       /* SPqcx_i */
+                        ++l_current_ptr;
+                        if (l_band_no < OPJ_J2K_MAXBANDS){
+                                l_tccp->stepsizes[l_band_no].expn = (OPJ_INT32)(l_tmp >> 3);
+                                l_tccp->stepsizes[l_band_no].mant = 0;
+                        }
+                }
+                *p_header_size = *p_header_size - l_num_band;
+        }
+        else {
+                for     (l_band_no = 0; l_band_no < l_num_band; l_band_no++) {
+                        opj_read_bytes(l_current_ptr, &l_tmp ,2);                       /* SPqcx_i */
+                        l_current_ptr+=2;
+                        if (l_band_no < OPJ_J2K_MAXBANDS){
+                                l_tccp->stepsizes[l_band_no].expn = (OPJ_INT32)(l_tmp >> 11);
+                                l_tccp->stepsizes[l_band_no].mant = l_tmp & 0x7ff;
+                        }
+                }
+                *p_header_size = *p_header_size - 2*l_num_band;
+        }
+
+        /* Add Antonin : if scalar_derived -> compute other stepsizes */
+        if (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) {
+                for (l_band_no = 1; l_band_no < OPJ_J2K_MAXBANDS; l_band_no++) {
+                        l_tccp->stepsizes[l_band_no].expn =
+                                ((OPJ_INT32)(l_tccp->stepsizes[0].expn) - (OPJ_INT32)((l_band_no - 1) / 3) > 0) ?
+                                        (OPJ_INT32)(l_tccp->stepsizes[0].expn) - (OPJ_INT32)((l_band_no - 1) / 3) : 0;
+                        l_tccp->stepsizes[l_band_no].mant = l_tccp->stepsizes[0].mant;
+                }
+        }
+
+        return OPJ_TRUE;
+}
+
+void opj_j2k_copy_tile_quantization_parameters( opj_j2k_t *p_j2k )
+{
+        OPJ_UINT32 i;
+        opj_cp_t *l_cp = NULL;
+        opj_tcp_t *l_tcp = NULL;
+        opj_tccp_t *l_ref_tccp = NULL;
+        opj_tccp_t *l_copied_tccp = NULL;
+        OPJ_UINT32 l_size;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+
+        l_cp = &(p_j2k->m_cp);
+        l_tcp = p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_TPH ?
+                        &l_cp->tcps[p_j2k->m_current_tile_number] :
+                        p_j2k->m_specific_param.m_decoder.m_default_tcp;
+
+        l_ref_tccp = &l_tcp->tccps[0];
+        l_copied_tccp = l_ref_tccp + 1;
+        l_size = OPJ_J2K_MAXBANDS * sizeof(opj_stepsize_t);
+
+        for     (i=1;i<p_j2k->m_private_image->numcomps;++i) {
+                l_copied_tccp->qntsty = l_ref_tccp->qntsty;
+                l_copied_tccp->numgbits = l_ref_tccp->numgbits;
+                memcpy(l_copied_tccp->stepsizes,l_ref_tccp->stepsizes,l_size);
+                ++l_copied_tccp;
+        }
+}
+
+static void opj_j2k_dump_tile_info( opj_tcp_t * l_default_tile,OPJ_INT32 numcomps,FILE* out_stream)
+{
+        if (l_default_tile)
+        {
+                OPJ_INT32 compno;
+
+                fprintf(out_stream, "\t default tile {\n");
+                fprintf(out_stream, "\t\t csty=%#x\n", l_default_tile->csty);
+                fprintf(out_stream, "\t\t prg=%#x\n", l_default_tile->prg);
+                fprintf(out_stream, "\t\t numlayers=%d\n", l_default_tile->numlayers);
+                fprintf(out_stream, "\t\t mct=%x\n", l_default_tile->mct);
+
+                for (compno = 0; compno < numcomps; compno++) {
+                        opj_tccp_t *l_tccp = &(l_default_tile->tccps[compno]);
+                        OPJ_UINT32 resno;
+      OPJ_INT32 bandno, numbands;
+
+                        /* coding style*/
+                        fprintf(out_stream, "\t\t comp %d {\n", compno);
+                        fprintf(out_stream, "\t\t\t csty=%#x\n", l_tccp->csty);
+                        fprintf(out_stream, "\t\t\t numresolutions=%d\n", l_tccp->numresolutions);
+                        fprintf(out_stream, "\t\t\t cblkw=2^%d\n", l_tccp->cblkw);
+                        fprintf(out_stream, "\t\t\t cblkh=2^%d\n", l_tccp->cblkh);
+                        fprintf(out_stream, "\t\t\t cblksty=%#x\n", l_tccp->cblksty);
+                        fprintf(out_stream, "\t\t\t qmfbid=%d\n", l_tccp->qmfbid);
+
+                        fprintf(out_stream, "\t\t\t preccintsize (w,h)=");
+                        for (resno = 0; resno < l_tccp->numresolutions; resno++) {
+                                fprintf(out_stream, "(%d,%d) ", l_tccp->prcw[resno], l_tccp->prch[resno]);
+                        }
+                        fprintf(out_stream, "\n");
+
+                        /* quantization style*/
+                        fprintf(out_stream, "\t\t\t qntsty=%d\n", l_tccp->qntsty);
+                        fprintf(out_stream, "\t\t\t numgbits=%d\n", l_tccp->numgbits);
+                        fprintf(out_stream, "\t\t\t stepsizes (m,e)=");
+                        numbands = (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) ? 1 : (OPJ_INT32)l_tccp->numresolutions * 3 - 2;
+                        for (bandno = 0; bandno < numbands; bandno++) {
+                                fprintf(out_stream, "(%d,%d) ", l_tccp->stepsizes[bandno].mant,
+                                        l_tccp->stepsizes[bandno].expn);
+                        }
+                        fprintf(out_stream, "\n");
+
+                        /* RGN value*/
+                        fprintf(out_stream, "\t\t\t roishift=%d\n", l_tccp->roishift);
+
+                        fprintf(out_stream, "\t\t }\n");
+                } /*end of component of default tile*/
+                fprintf(out_stream, "\t }\n"); /*end of default tile*/
+            }
+}
+
+void j2k_dump (opj_j2k_t* p_j2k, OPJ_INT32 flag, FILE* out_stream)
+{
+        /* Check if the flag is compatible with j2k file*/
+        if ( (flag & OPJ_JP2_INFO) || (flag & OPJ_JP2_IND)){
+                fprintf(out_stream, "Wrong flag\n");
+                return;
+        }
+
+        /* Dump the image_header */
+        if (flag & OPJ_IMG_INFO){
+                if (p_j2k->m_private_image)
+                        j2k_dump_image_header(p_j2k->m_private_image, 0, out_stream);
+        }
+
+        /* Dump the codestream info from main header */
+        if (flag & OPJ_J2K_MH_INFO){
+                opj_j2k_dump_MH_info(p_j2k, out_stream);
+        }
+        /* Dump all tile/codestream info */
+        if (flag & OPJ_J2K_TCH_INFO){
+          OPJ_UINT32 l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
+          OPJ_UINT32 i;
+          opj_tcp_t * l_tcp = p_j2k->m_cp.tcps;
+          for (i=0;i<l_nb_tiles;++i) {
+            opj_j2k_dump_tile_info( l_tcp,(OPJ_INT32)p_j2k->m_private_image->numcomps, out_stream);
+            ++l_tcp;
+          }
+        }
+
+        /* Dump the codestream info of the current tile */
+        if (flag & OPJ_J2K_TH_INFO){
+
+        }
+
+        /* Dump the codestream index from main header */
+        if (flag & OPJ_J2K_MH_IND){
+                opj_j2k_dump_MH_index(p_j2k, out_stream);
+        }
+
+        /* Dump the codestream index of the current tile */
+        if (flag & OPJ_J2K_TH_IND){
+
+        }
+
+}
+
+void opj_j2k_dump_MH_index(opj_j2k_t* p_j2k, FILE* out_stream)
+{
+        opj_codestream_index_t* cstr_index = p_j2k->cstr_index;
+        OPJ_UINT32 it_marker, it_tile, it_tile_part;
+
+        fprintf(out_stream, "Codestream index from main header: {\n");
+
+        fprintf(out_stream, "\t Main header start position=%" PRIi64 "\n"
+                                    "\t Main header end position=%" PRIi64 "\n",
+                        cstr_index->main_head_start, cstr_index->main_head_end);
+
+        fprintf(out_stream, "\t Marker list: {\n");
+
+        if (cstr_index->marker){
+                for (it_marker=0; it_marker < cstr_index->marknum ; it_marker++){
+                        fprintf(out_stream, "\t\t type=%#x, pos=%" PRIi64 ", len=%d\n",
+                                        cstr_index->marker[it_marker].type,
+                                        cstr_index->marker[it_marker].pos,
+                                        cstr_index->marker[it_marker].len );
+                }
+        }
+
+        fprintf(out_stream, "\t }\n");
+
+        if (cstr_index->tile_index){
+
+        /* Simple test to avoid to write empty information*/
+        OPJ_UINT32 l_acc_nb_of_tile_part = 0;
+        for (it_tile=0; it_tile < cstr_index->nb_of_tiles ; it_tile++){
+                        l_acc_nb_of_tile_part += cstr_index->tile_index[it_tile].nb_tps;
+        }
+
+        if (l_acc_nb_of_tile_part)
+        {
+            fprintf(out_stream, "\t Tile index: {\n");
+
+                    for (it_tile=0; it_tile < cstr_index->nb_of_tiles ; it_tile++){
+                            OPJ_UINT32 nb_of_tile_part = cstr_index->tile_index[it_tile].nb_tps;
+
+                            fprintf(out_stream, "\t\t nb of tile-part in tile [%d]=%d\n", it_tile, nb_of_tile_part);
+
+                            if (cstr_index->tile_index[it_tile].tp_index){
+                                    for (it_tile_part =0; it_tile_part < nb_of_tile_part; it_tile_part++){
+                                            fprintf(out_stream, "\t\t\t tile-part[%d]: star_pos=%" PRIi64 ", end_header=%" PRIi64 ", end_pos=%" PRIi64 ".\n",
+                                                            it_tile_part,
+                                                            cstr_index->tile_index[it_tile].tp_index[it_tile_part].start_pos,
+                                                            cstr_index->tile_index[it_tile].tp_index[it_tile_part].end_header,
+                                                            cstr_index->tile_index[it_tile].tp_index[it_tile_part].end_pos);
+                                    }
+                            }
+
+                            if (cstr_index->tile_index[it_tile].marker){
+                                    for (it_marker=0; it_marker < cstr_index->tile_index[it_tile].marknum ; it_marker++){
+                                            fprintf(out_stream, "\t\t type=%#x, pos=%" PRIi64 ", len=%d\n",
+                                                            cstr_index->tile_index[it_tile].marker[it_marker].type,
+                                                            cstr_index->tile_index[it_tile].marker[it_marker].pos,
+                                                            cstr_index->tile_index[it_tile].marker[it_marker].len );
+                                    }
+                            }
+                    }
+                    fprintf(out_stream,"\t }\n");
+        }
+        }
+
+        fprintf(out_stream,"}\n");
+
+}
+
+
+void opj_j2k_dump_MH_info(opj_j2k_t* p_j2k, FILE* out_stream)
+{
+
+        fprintf(out_stream, "Codestream info from main header: {\n");
+
+        fprintf(out_stream, "\t tx0=%d, ty0=%d\n", p_j2k->m_cp.tx0, p_j2k->m_cp.ty0);
+        fprintf(out_stream, "\t tdx=%d, tdy=%d\n", p_j2k->m_cp.tdx, p_j2k->m_cp.tdy);
+        fprintf(out_stream, "\t tw=%d, th=%d\n", p_j2k->m_cp.tw, p_j2k->m_cp.th);
+        opj_j2k_dump_tile_info(p_j2k->m_specific_param.m_decoder.m_default_tcp,(OPJ_INT32)p_j2k->m_private_image->numcomps, out_stream);
+        fprintf(out_stream, "}\n");
+}
+
+void j2k_dump_image_header(opj_image_t* img_header, OPJ_BOOL dev_dump_flag, FILE* out_stream)
+{
+        char tab[2];
+
+        if (dev_dump_flag){
+                fprintf(stdout, "[DEV] Dump an image_header struct {\n");
+                tab[0] = '\0';
+        }
+        else {
+                fprintf(out_stream, "Image info {\n");
+                tab[0] = '\t';tab[1] = '\0';
+        }
+
+        fprintf(out_stream, "%s x0=%d, y0=%d\n", tab, img_header->x0, img_header->y0);
+        fprintf(out_stream,     "%s x1=%d, y1=%d\n", tab, img_header->x1, img_header->y1);
+        fprintf(out_stream, "%s numcomps=%d\n", tab, img_header->numcomps);
+
+        if (img_header->comps){
+                OPJ_UINT32 compno;
+                for (compno = 0; compno < img_header->numcomps; compno++) {
+                        fprintf(out_stream, "%s\t component %d {\n", tab, compno);
+                        j2k_dump_image_comp_header(&(img_header->comps[compno]), dev_dump_flag, out_stream);
+                        fprintf(out_stream,"%s}\n",tab);
+                }
+        }
+
+        fprintf(out_stream, "}\n");
+}
+
+void j2k_dump_image_comp_header(opj_image_comp_t* comp_header, OPJ_BOOL dev_dump_flag, FILE* out_stream)
+{
+        char tab[3];
+
+        if (dev_dump_flag){
+                fprintf(stdout, "[DEV] Dump an image_comp_header struct {\n");
+                tab[0] = '\0';
+        }       else {
+                tab[0] = '\t';tab[1] = '\t';tab[2] = '\0';
+        }
+
+        fprintf(out_stream, "%s dx=%d, dy=%d\n", tab, comp_header->dx, comp_header->dy);
+        fprintf(out_stream, "%s prec=%d\n", tab, comp_header->prec);
+        fprintf(out_stream, "%s sgnd=%d\n", tab, comp_header->sgnd);
+
+        if (dev_dump_flag)
+                fprintf(out_stream, "}\n");
+}
+
+opj_codestream_info_v2_t* j2k_get_cstr_info(opj_j2k_t* p_j2k)
+{
+        OPJ_UINT32 compno;
+        OPJ_UINT32 numcomps = p_j2k->m_private_image->numcomps;
+        opj_tcp_t *l_default_tile;
+        opj_codestream_info_v2_t* cstr_info = (opj_codestream_info_v2_t*) opj_calloc(1,sizeof(opj_codestream_info_v2_t));
+		if (!cstr_info)
+			return NULL;
+
+        cstr_info->nbcomps = p_j2k->m_private_image->numcomps;
+
+        cstr_info->tx0 = p_j2k->m_cp.tx0;
+        cstr_info->ty0 = p_j2k->m_cp.ty0;
+        cstr_info->tdx = p_j2k->m_cp.tdx;
+        cstr_info->tdy = p_j2k->m_cp.tdy;
+        cstr_info->tw = p_j2k->m_cp.tw;
+        cstr_info->th = p_j2k->m_cp.th;
+
+        cstr_info->tile_info = NULL; /* Not fill from the main header*/
+
+        l_default_tile = p_j2k->m_specific_param.m_decoder.m_default_tcp;
+
+        cstr_info->m_default_tile_info.csty = l_default_tile->csty;
+        cstr_info->m_default_tile_info.prg = l_default_tile->prg;
+        cstr_info->m_default_tile_info.numlayers = l_default_tile->numlayers;
+        cstr_info->m_default_tile_info.mct = l_default_tile->mct;
+
+        cstr_info->m_default_tile_info.tccp_info = (opj_tccp_info_t*) opj_calloc(cstr_info->nbcomps, sizeof(opj_tccp_info_t));
+		if (!cstr_info->m_default_tile_info.tccp_info)
+		{
+			opj_destroy_cstr_info(&cstr_info);
+			return NULL;
+		}
+
+        for (compno = 0; compno < numcomps; compno++) {
+                opj_tccp_t *l_tccp = &(l_default_tile->tccps[compno]);
+                opj_tccp_info_t *l_tccp_info = &(cstr_info->m_default_tile_info.tccp_info[compno]);
+                OPJ_INT32 bandno, numbands;
+
+                /* coding style*/
+                l_tccp_info->csty = l_tccp->csty;
+                l_tccp_info->numresolutions = l_tccp->numresolutions;
+                l_tccp_info->cblkw = l_tccp->cblkw;
+                l_tccp_info->cblkh = l_tccp->cblkh;
+                l_tccp_info->cblksty = l_tccp->cblksty;
+                l_tccp_info->qmfbid = l_tccp->qmfbid;
+                if (l_tccp->numresolutions < OPJ_J2K_MAXRLVLS)
+                {
+                        memcpy(l_tccp_info->prch, l_tccp->prch, l_tccp->numresolutions);
+                        memcpy(l_tccp_info->prcw, l_tccp->prcw, l_tccp->numresolutions);
+                }
+
+                /* quantization style*/
+                l_tccp_info->qntsty = l_tccp->qntsty;
+                l_tccp_info->numgbits = l_tccp->numgbits;
+
+                numbands = (l_tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) ? 1 : (OPJ_INT32)l_tccp->numresolutions * 3 - 2;
+                if (numbands < OPJ_J2K_MAXBANDS) {
+                        for (bandno = 0; bandno < numbands; bandno++) {
+                                l_tccp_info->stepsizes_mant[bandno] = (OPJ_UINT32)l_tccp->stepsizes[bandno].mant;
+                                l_tccp_info->stepsizes_expn[bandno] = (OPJ_UINT32)l_tccp->stepsizes[bandno].expn;
+                        }
+                }
+
+                /* RGN value*/
+                l_tccp_info->roishift = l_tccp->roishift;
+        }
+
+        return cstr_info;
+}
+
+opj_codestream_index_t* j2k_get_cstr_index(opj_j2k_t* p_j2k)
+{
+        opj_codestream_index_t* l_cstr_index = (opj_codestream_index_t*)
+                        opj_calloc(1,sizeof(opj_codestream_index_t));
+        if (!l_cstr_index)
+                return NULL;
+
+        l_cstr_index->main_head_start = p_j2k->cstr_index->main_head_start;
+        l_cstr_index->main_head_end = p_j2k->cstr_index->main_head_end;
+        l_cstr_index->codestream_size = p_j2k->cstr_index->codestream_size;
+
+        l_cstr_index->marknum = p_j2k->cstr_index->marknum;
+        l_cstr_index->marker = (opj_marker_info_t*)opj_malloc(l_cstr_index->marknum*sizeof(opj_marker_info_t));
+        if (!l_cstr_index->marker){
+                opj_free( l_cstr_index);
+                return NULL;
+        }
+
+        if (p_j2k->cstr_index->marker)
+                memcpy(l_cstr_index->marker, p_j2k->cstr_index->marker, l_cstr_index->marknum * sizeof(opj_marker_info_t) );
+        else{
+                opj_free(l_cstr_index->marker);
+                l_cstr_index->marker = NULL;
+        }
+
+        l_cstr_index->nb_of_tiles = p_j2k->cstr_index->nb_of_tiles;
+        l_cstr_index->tile_index = (opj_tile_index_t*)opj_calloc(l_cstr_index->nb_of_tiles, sizeof(opj_tile_index_t) );
+        if (!l_cstr_index->tile_index){
+                opj_free( l_cstr_index->marker);
+                opj_free( l_cstr_index);
+                return NULL;
+        }
+
+        if (!p_j2k->cstr_index->tile_index){
+                opj_free(l_cstr_index->tile_index);
+                l_cstr_index->tile_index = NULL;
+        }
+        else {
+                OPJ_UINT32 it_tile = 0;
+                for (it_tile = 0; it_tile < l_cstr_index->nb_of_tiles; it_tile++ ){
+
+                        /* Tile Marker*/
+                        l_cstr_index->tile_index[it_tile].marknum = p_j2k->cstr_index->tile_index[it_tile].marknum;
+
+                        l_cstr_index->tile_index[it_tile].marker =
+                                (opj_marker_info_t*)opj_malloc(l_cstr_index->tile_index[it_tile].marknum*sizeof(opj_marker_info_t));
+
+                        if (!l_cstr_index->tile_index[it_tile].marker) {
+                                OPJ_UINT32 it_tile_free;
+
+                                for (it_tile_free=0; it_tile_free < it_tile; it_tile_free++){
+                                        opj_free(l_cstr_index->tile_index[it_tile_free].marker);
+                                }
+
+                                opj_free( l_cstr_index->tile_index);
+                                opj_free( l_cstr_index->marker);
+                                opj_free( l_cstr_index);
+                                return NULL;
+                        }
+
+                        if (p_j2k->cstr_index->tile_index[it_tile].marker)
+                                memcpy( l_cstr_index->tile_index[it_tile].marker,
+                                                p_j2k->cstr_index->tile_index[it_tile].marker,
+                                                l_cstr_index->tile_index[it_tile].marknum * sizeof(opj_marker_info_t) );
+                        else{
+                                opj_free(l_cstr_index->tile_index[it_tile].marker);
+                                l_cstr_index->tile_index[it_tile].marker = NULL;
+                        }
+
+                        /* Tile part index*/
+                        l_cstr_index->tile_index[it_tile].nb_tps = p_j2k->cstr_index->tile_index[it_tile].nb_tps;
+
+                        l_cstr_index->tile_index[it_tile].tp_index =
+                                (opj_tp_index_t*)opj_malloc(l_cstr_index->tile_index[it_tile].nb_tps*sizeof(opj_tp_index_t));
+
+                        if(!l_cstr_index->tile_index[it_tile].tp_index){
+                                OPJ_UINT32 it_tile_free;
+
+                                for (it_tile_free=0; it_tile_free < it_tile; it_tile_free++){
+                                        opj_free(l_cstr_index->tile_index[it_tile_free].marker);
+                                        opj_free(l_cstr_index->tile_index[it_tile_free].tp_index);
+                                }
+
+                                opj_free( l_cstr_index->tile_index);
+                                opj_free( l_cstr_index->marker);
+                                opj_free( l_cstr_index);
+                                return NULL;
+                        }
+
+                        if (p_j2k->cstr_index->tile_index[it_tile].tp_index){
+                                memcpy( l_cstr_index->tile_index[it_tile].tp_index,
+                                                p_j2k->cstr_index->tile_index[it_tile].tp_index,
+                                                l_cstr_index->tile_index[it_tile].nb_tps * sizeof(opj_tp_index_t) );
+                        }
+                        else{
+                                opj_free(l_cstr_index->tile_index[it_tile].tp_index);
+                                l_cstr_index->tile_index[it_tile].tp_index = NULL;
+                        }
+
+                        /* Packet index (NOT USED)*/
+                        l_cstr_index->tile_index[it_tile].nb_packet = 0;
+                        l_cstr_index->tile_index[it_tile].packet_index = NULL;
+
+                }
+        }
+
+        return l_cstr_index;
+}
+
+OPJ_BOOL opj_j2k_allocate_tile_element_cstr_index(opj_j2k_t *p_j2k)
+{
+        OPJ_UINT32 it_tile=0;
+
+        p_j2k->cstr_index->nb_of_tiles = p_j2k->m_cp.tw * p_j2k->m_cp.th;
+        p_j2k->cstr_index->tile_index = (opj_tile_index_t*)opj_calloc(p_j2k->cstr_index->nb_of_tiles, sizeof(opj_tile_index_t));
+        if (!p_j2k->cstr_index->tile_index)
+                return OPJ_FALSE;
+
+        for (it_tile=0; it_tile < p_j2k->cstr_index->nb_of_tiles; it_tile++){
+                p_j2k->cstr_index->tile_index[it_tile].maxmarknum = 100;
+                p_j2k->cstr_index->tile_index[it_tile].marknum = 0;
+                p_j2k->cstr_index->tile_index[it_tile].marker = (opj_marker_info_t*)
+                                opj_calloc(p_j2k->cstr_index->tile_index[it_tile].maxmarknum, sizeof(opj_marker_info_t));
+                if (!p_j2k->cstr_index->tile_index[it_tile].marker)
+                        return OPJ_FALSE;
+        }
+
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_j2k_decode_tiles ( opj_j2k_t *p_j2k,
+                                                            opj_stream_private_t *p_stream,
+                                                            opj_event_mgr_t * p_manager)
+{
+        OPJ_BOOL l_go_on = OPJ_TRUE;
+        OPJ_UINT32 l_current_tile_no;
+        OPJ_UINT32 l_data_size,l_max_data_size;
+        OPJ_INT32 l_tile_x0,l_tile_y0,l_tile_x1,l_tile_y1;
+        OPJ_UINT32 l_nb_comps;
+        OPJ_BYTE * l_current_data;
+        OPJ_UINT32 nr_tiles = 0;
+
+        l_current_data = (OPJ_BYTE*)opj_malloc(1000);
+        if (! l_current_data) {
+                opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to decode tiles\n");
+                return OPJ_FALSE;
+        }
+        l_max_data_size = 1000;
+
+        while (OPJ_TRUE) {
+                if (! opj_j2k_read_tile_header( p_j2k,
+                                        &l_current_tile_no,
+                                        &l_data_size,
+                                        &l_tile_x0, &l_tile_y0,
+                                        &l_tile_x1, &l_tile_y1,
+                                        &l_nb_comps,
+                                        &l_go_on,
+                                        p_stream,
+                                        p_manager)) {
+                        opj_free(l_current_data);
+                        return OPJ_FALSE;
+                }
+
+                if (! l_go_on) {
+                        break;
+                }
+
+                if (l_data_size > l_max_data_size) {
+                        OPJ_BYTE *l_new_current_data = (OPJ_BYTE *) opj_realloc(l_current_data, l_data_size);
+                        if (! l_new_current_data) {
+                                opj_free(l_current_data);
+                                opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to decode tile %d/%d\n", l_current_tile_no +1, p_j2k->m_cp.th * p_j2k->m_cp.tw);
+                                return OPJ_FALSE;
+                        }
+                        l_current_data = l_new_current_data;
+                        l_max_data_size = l_data_size;
+                }
+
+                if (! opj_j2k_decode_tile(p_j2k,l_current_tile_no,l_current_data,l_data_size,p_stream,p_manager)) {
+                        opj_free(l_current_data);
+                        opj_event_msg(p_manager, EVT_ERROR, "Failed to decode tile %d/%d\n", l_current_tile_no +1, p_j2k->m_cp.th * p_j2k->m_cp.tw);
+                        return OPJ_FALSE;
+                }
+                opj_event_msg(p_manager, EVT_INFO, "Tile %d/%d has been decoded.\n", l_current_tile_no +1, p_j2k->m_cp.th * p_j2k->m_cp.tw);
+
+                if (! opj_j2k_update_image_data(p_j2k->m_tcd,l_current_data, p_j2k->m_output_image)) {
+                        opj_free(l_current_data);
+                        return OPJ_FALSE;
+                }
+                opj_event_msg(p_manager, EVT_INFO, "Image data has been updated with tile %d.\n\n", l_current_tile_no + 1);
+                
+                if(opj_stream_get_number_byte_left(p_stream) == 0  
+                    && p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_NEOC)
+                    break;
+                if(++nr_tiles ==  p_j2k->m_cp.th * p_j2k->m_cp.tw) 
+                    break;
+        }
+
+        opj_free(l_current_data);
+
+        return OPJ_TRUE;
+}
+
+/**
+ * Sets up the procedures to do on decoding data. Developpers wanting to extend the library can add their own reading procedures.
+ */
+static void opj_j2k_setup_decoding (opj_j2k_t *p_j2k)
+{
+        /* preconditions*/
+        assert(p_j2k != 00);
+
+        opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_decode_tiles);
+        /* DEVELOPER CORNER, add your custom procedures */
 
-/*@}*/
+}
 
-/*@}*/
+/*
+ * Read and decode one tile.
+ */
+static OPJ_BOOL opj_j2k_decode_one_tile (       opj_j2k_t *p_j2k,
+                                                                            opj_stream_private_t *p_stream,
+                                                                            opj_event_mgr_t * p_manager)
+{
+        OPJ_BOOL l_go_on = OPJ_TRUE;
+        OPJ_UINT32 l_current_tile_no;
+        OPJ_UINT32 l_tile_no_to_dec;
+        OPJ_UINT32 l_data_size,l_max_data_size;
+        OPJ_INT32 l_tile_x0,l_tile_y0,l_tile_x1,l_tile_y1;
+        OPJ_UINT32 l_nb_comps;
+        OPJ_BYTE * l_current_data;
+
+        l_current_data = (OPJ_BYTE*)opj_malloc(1000);
+        if (! l_current_data) {
+                opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to decode one tile\n");
+                return OPJ_FALSE;
+        }
+        l_max_data_size = 1000;
 
-/* ----------------------------------------------------------------------- */
-typedef struct j2k_prog_order{
-	OPJ_PROG_ORDER enum_prog;
-	char str_prog[5];
-}j2k_prog_order_t;
+        /*Allocate and initialize some elements of codestrem index if not already done*/
+        if( !p_j2k->cstr_index->tile_index)
+        {
+                if (!opj_j2k_allocate_tile_element_cstr_index(p_j2k)){
+                        opj_free(l_current_data);
+                        return OPJ_FALSE;
+                }
+        }
+        /* Move into the codestream to the first SOT used to decode the desired tile */
+        l_tile_no_to_dec = (OPJ_UINT32)p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec;
+        if (p_j2k->cstr_index->tile_index)
+                if(p_j2k->cstr_index->tile_index->tp_index)
+                {
+                        if ( ! p_j2k->cstr_index->tile_index[l_tile_no_to_dec].nb_tps) {
+                                /* the index for this tile has not been built,
+                                 *  so move to the last SOT read */
+                                if ( !(opj_stream_read_seek(p_stream, p_j2k->m_specific_param.m_decoder.m_last_sot_read_pos+2, p_manager)) ){
+                                        opj_event_msg(p_manager, EVT_ERROR, "Problem with seek function\n");
+                        opj_free(l_current_data);
+                                        return OPJ_FALSE;
+                                }
+                        }
+                        else{
+                                if ( !(opj_stream_read_seek(p_stream, p_j2k->cstr_index->tile_index[l_tile_no_to_dec].tp_index[0].start_pos+2, p_manager)) ) {
+                                        opj_event_msg(p_manager, EVT_ERROR, "Problem with seek function\n");
+                        opj_free(l_current_data);
+                                        return OPJ_FALSE;
+                                }
+                        }
+                        /* Special case if we have previously read the EOC marker (if the previous tile getted is the last ) */
+                        if(p_j2k->m_specific_param.m_decoder.m_state == J2K_STATE_EOC)
+                                p_j2k->m_specific_param.m_decoder.m_state = J2K_STATE_TPHSOT;
+                }
+
+        while (OPJ_TRUE) {
+                if (! opj_j2k_read_tile_header( p_j2k,
+                                        &l_current_tile_no,
+                                        &l_data_size,
+                                        &l_tile_x0, &l_tile_y0,
+                                        &l_tile_x1, &l_tile_y1,
+                                        &l_nb_comps,
+                                        &l_go_on,
+                                        p_stream,
+                                        p_manager)) {
+                        opj_free(l_current_data);
+                        return OPJ_FALSE;
+                }
+
+                if (! l_go_on) {
+                        break;
+                }
+
+                if (l_data_size > l_max_data_size) {
+                        OPJ_BYTE *l_new_current_data = (OPJ_BYTE *) opj_realloc(l_current_data, l_data_size);
+                        if (! l_new_current_data) {
+                                opj_free(l_current_data);
+                                l_current_data = NULL;
+                                /* TODO: LH: why tile numbering policy used in messages differs from
+                                   the one used in opj_j2k_decode_tiles() ? */
+                                opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to decode tile %d/%d\n", l_current_tile_no, (p_j2k->m_cp.th * p_j2k->m_cp.tw) - 1);
+                                return OPJ_FALSE;
+                        }
+                        l_current_data = l_new_current_data;
+                        l_max_data_size = l_data_size;
+                }
+
+                if (! opj_j2k_decode_tile(p_j2k,l_current_tile_no,l_current_data,l_data_size,p_stream,p_manager)) {
+                        opj_free(l_current_data);
+                        return OPJ_FALSE;
+                }
+                opj_event_msg(p_manager, EVT_INFO, "Tile %d/%d has been decoded.\n", l_current_tile_no, (p_j2k->m_cp.th * p_j2k->m_cp.tw) - 1);
+
+                if (! opj_j2k_update_image_data(p_j2k->m_tcd,l_current_data, p_j2k->m_output_image)) {
+                        opj_free(l_current_data);
+                        return OPJ_FALSE;
+                }
+                opj_event_msg(p_manager, EVT_INFO, "Image data has been updated with tile %d.\n\n", l_current_tile_no);
+
+                if(l_current_tile_no == l_tile_no_to_dec)
+                {
+                        /* move into the codestream to the the first SOT (FIXME or not move?)*/
+                        if (!(opj_stream_read_seek(p_stream, p_j2k->cstr_index->main_head_end + 2, p_manager) ) ) {
+                                opj_event_msg(p_manager, EVT_ERROR, "Problem with seek function\n");
+                                return OPJ_FALSE;
+                        }
+                        break;
+                }
+                else {
+                        opj_event_msg(p_manager, EVT_WARNING, "Tile read, decode and updated is not the desired (%d vs %d).\n", l_current_tile_no, l_tile_no_to_dec);
+                }
 
-j2k_prog_order_t j2k_prog_order_list[] = {
-	{CPRL, "CPRL"},
-	{LRCP, "LRCP"},
-	{PCRL, "PCRL"},
-	{RLCP, "RLCP"},
-	{RPCL, "RPCL"},
-	{(OPJ_PROG_ORDER)-1, ""}
-};
+        }
 
-char *j2k_convert_progression_order(OPJ_PROG_ORDER prg_order){
-	j2k_prog_order_t *po;
-	for(po = j2k_prog_order_list; po->enum_prog != -1; po++ ){
-		if(po->enum_prog == prg_order){
-			break;
-		}
-	}
-	return po->str_prog;
+        opj_free(l_current_data);
+
+        return OPJ_TRUE;
 }
 
-/* ----------------------------------------------------------------------- */
-static int j2k_get_num_tp(opj_cp_t *cp,int pino,int tileno){
-	char *prog;
-	int i;
-	int tpnum=1,tpend=0;
-	opj_tcp_t *tcp = &cp->tcps[tileno];
-	prog = j2k_convert_progression_order(tcp->prg);
-	
-	if(cp->tp_on == 1){
-		for(i=0;i<4;i++){
-			if(tpend!=1){
-				if( cp->tp_flag == prog[i] ){
-					tpend=1;cp->tp_pos=i;
-				}
-				switch(prog[i]){
-				case 'C':
-					tpnum= tpnum * tcp->pocs[pino].compE;
-					break;
-				case 'R':
-					tpnum= tpnum * tcp->pocs[pino].resE;
-					break;
-				case 'P':
-					tpnum= tpnum * tcp->pocs[pino].prcE;
-					break;
-				case 'L':
-					tpnum= tpnum * tcp->pocs[pino].layE;
-					break;
-				}
-			}
-		}
-	}else{
-		tpnum=1;
-	}
-	return tpnum;
-}
-
-/**	mem allocation for TLM marker*/
-int j2k_calculate_tp(opj_cp_t *cp,int img_numcomp,opj_image_t *image,opj_j2k_t *j2k ){
-	int pino,tileno,totnum_tp=0;
-
-	OPJ_ARG_NOT_USED(img_numcomp);
-
-	j2k->cur_totnum_tp = (int *) opj_malloc(cp->tw * cp->th * sizeof(int));
-	for (tileno = 0; tileno < cp->tw * cp->th; tileno++) {
-		int cur_totnum_tp = 0;
-		opj_tcp_t *tcp = &cp->tcps[tileno];
-		for(pino = 0; pino <= tcp->numpocs; pino++) {
-			int tp_num=0;
-			opj_pi_iterator_t *pi = pi_initialise_encode(image, cp, tileno,FINAL_PASS);
-			if(!pi) { return -1;}
-			tp_num = j2k_get_num_tp(cp,pino,tileno);
-			totnum_tp = totnum_tp + tp_num;
-			cur_totnum_tp = cur_totnum_tp + tp_num;
-			pi_destroy(pi, cp, tileno);
-		}
-		j2k->cur_totnum_tp[tileno] = cur_totnum_tp;
-		/* INDEX >> */
-		if (j2k->cstr_info) {
-			j2k->cstr_info->tile[tileno].num_tps = cur_totnum_tp;
-			j2k->cstr_info->tile[tileno].tp = (opj_tp_info_t *) opj_malloc(cur_totnum_tp * sizeof(opj_tp_info_t));
-		}
-		/* << INDEX */
-	}
-	return totnum_tp;
+/**
+ * Sets up the procedures to do on decoding one tile. Developpers wanting to extend the library can add their own reading procedures.
+ */
+static void opj_j2k_setup_decoding_tile (opj_j2k_t *p_j2k)
+{
+        /* preconditions*/
+        assert(p_j2k != 00);
+
+        opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_decode_one_tile);
+        /* DEVELOPER CORNER, add your custom procedures */
+
 }
 
-static void j2k_write_soc(opj_j2k_t *j2k) {
-	opj_cio_t *cio = j2k->cio;
-	cio_write(cio, J2K_MS_SOC, 2);
+OPJ_BOOL opj_j2k_decode(opj_j2k_t * p_j2k,
+                                                opj_stream_private_t * p_stream,
+                                                opj_image_t * p_image,
+                                                opj_event_mgr_t * p_manager)
+{
+        OPJ_UINT32 compno;
 
-	if(j2k->cstr_info)
-	  j2k_add_mhmarker(j2k->cstr_info, J2K_MS_SOC, cio_tell(cio), 0);
+        if (!p_image)
+                return OPJ_FALSE;
 
-/* UniPG>> */
-#ifdef USE_JPWL
+        p_j2k->m_output_image = opj_image_create0();
+        if (! (p_j2k->m_output_image)) {
+                return OPJ_FALSE;
+        }
+        opj_copy_image_header(p_image, p_j2k->m_output_image);
 
-	/* update markers struct */
-	j2k_add_marker(j2k->cstr_info, J2K_MS_SOC, cio_tell(cio) - 2, 2);
-#endif /* USE_JPWL */
-/* <<UniPG */
+        /* customization of the decoding */
+        opj_j2k_setup_decoding(p_j2k);
+
+        /* Decode the codestream */
+        if (! opj_j2k_exec (p_j2k,p_j2k->m_procedure_list,p_stream,p_manager)) {
+                opj_image_destroy(p_j2k->m_private_image);
+                p_j2k->m_private_image = NULL;
+                return OPJ_FALSE;
+        }
+
+        /* Move data and copy one information from codec to output image*/
+        for (compno = 0; compno < p_image->numcomps; compno++) {
+                p_image->comps[compno].resno_decoded = p_j2k->m_output_image->comps[compno].resno_decoded;
+                p_image->comps[compno].data = p_j2k->m_output_image->comps[compno].data;
+#if 0
+                char fn[256];
+                sprintf( fn, "/tmp/%d.raw", compno );
+                FILE *debug = fopen( fn, "wb" );
+                fwrite( p_image->comps[compno].data, sizeof(OPJ_INT32), p_image->comps[compno].w * p_image->comps[compno].h, debug );
+                fclose( debug );
+#endif
+                p_j2k->m_output_image->comps[compno].data = NULL;
+        }
+
+        return OPJ_TRUE;
 }
 
-static void j2k_read_soc(opj_j2k_t *j2k) {	
-	j2k->state = J2K_STATE_MHSIZ;
-	/* Index */
-	if (j2k->cstr_info) {
-		j2k->cstr_info->main_head_start = cio_tell(j2k->cio) - 2;
-		j2k->cstr_info->codestream_size = cio_numbytesleft(j2k->cio) + 2 - j2k->cstr_info->main_head_start;
-	}
-}
-
-static void j2k_write_siz(opj_j2k_t *j2k) {
-	int i;
-	int lenp, len;
-
-	opj_cio_t *cio = j2k->cio;
-	opj_image_t *image = j2k->image;
-	opj_cp_t *cp = j2k->cp;
-
-	cio_write(cio, J2K_MS_SIZ, 2);	/* SIZ */
-	lenp = cio_tell(cio);
-	cio_skip(cio, 2);
-	cio_write(cio, cp->rsiz, 2);			/* Rsiz (capabilities) */
-	cio_write(cio, image->x1, 4);	/* Xsiz */
-	cio_write(cio, image->y1, 4);	/* Ysiz */
-	cio_write(cio, image->x0, 4);	/* X0siz */
-	cio_write(cio, image->y0, 4);	/* Y0siz */
-	cio_write(cio, cp->tdx, 4);		/* XTsiz */
-	cio_write(cio, cp->tdy, 4);		/* YTsiz */
-	cio_write(cio, cp->tx0, 4);		/* XT0siz */
-	cio_write(cio, cp->ty0, 4);		/* YT0siz */
-	cio_write(cio, image->numcomps, 2);	/* Csiz */
-	for (i = 0; i < image->numcomps; i++) {
-		cio_write(cio, image->comps[i].prec - 1 + (image->comps[i].sgnd << 7), 1);	/* Ssiz_i */
-		cio_write(cio, image->comps[i].dx, 1);	/* XRsiz_i */
-		cio_write(cio, image->comps[i].dy, 1);	/* YRsiz_i */
-	}
-	len = cio_tell(cio) - lenp;
-	cio_seek(cio, lenp);
-	cio_write(cio, len, 2);		/* Lsiz */
-	cio_seek(cio, lenp + len);
-	
-	if(j2k->cstr_info)
-	  j2k_add_mhmarker(j2k->cstr_info, J2K_MS_SIZ, lenp, len);
-}
-
-static void j2k_read_siz(opj_j2k_t *j2k) {
-	int len, i;
-  int n_comps;
-	
-	opj_cio_t *cio = j2k->cio;
-	opj_image_t *image = j2k->image;
-	opj_cp_t *cp = j2k->cp;
-	
-	len = cio_read(cio, 2);			/* Lsiz */
-	cio_read(cio, 2);				/* Rsiz (capabilities) */
-	image->x1 = cio_read(cio, 4);	/* Xsiz */
-	image->y1 = cio_read(cio, 4);	/* Ysiz */
-	image->x0 = cio_read(cio, 4);	/* X0siz */
-	image->y0 = cio_read(cio, 4);	/* Y0siz */
-	cp->tdx = cio_read(cio, 4);		/* XTsiz */
-	cp->tdy = cio_read(cio, 4);		/* YTsiz */
-	cp->tx0 = cio_read(cio, 4);		/* XT0siz */
-	cp->ty0 = cio_read(cio, 4);		/* YT0siz */
-	
-	if ((image->x0<0)||(image->x1<0)||(image->y0<0)||(image->y1<0)) {
-		opj_event_msg(j2k->cinfo, EVT_ERROR,
-									"invalid image size (x0:%d, x1:%d, y0:%d, y1:%d)\n",
-									image->x0,image->x1,image->y0,image->y1);
-		return;
-	}
-	
-  n_comps = (len - 36 - 2 ) / 3;
-  assert( (len - 36 - 2 ) % 3 == 0 );
-	image->numcomps = cio_read(cio, 2);	/* Csiz */
-  assert( n_comps == image->numcomps );
-  (void)n_comps;
-
-  /* testcase 4035.pdf.SIGSEGV.d8b.3375 */
-  if (image->x0 > image->x1 || image->y0 > image->y1) {
-    opj_event_msg(j2k->cinfo, EVT_ERROR, "Error with SIZ marker: negative image size (%d x %d)\n", image->x1 - image->x0, image->y1 - image->y0);
-    return;
-  }
-  /* testcase 2539.pdf.SIGFPE.706.1712 (also 3622.pdf.SIGFPE.706.2916 and 4008.pdf.SIGFPE.706.3345 and maybe more) */
-  if (!(cp->tdx * cp->tdy)) {
-    opj_event_msg(j2k->cinfo, EVT_ERROR, "Error with SIZ marker: invalid tile size (tdx: %d, tdy: %d)\n", cp->tdx, cp->tdy);
-    return;
-  }
-
-  /* testcase 1610.pdf.SIGSEGV.59c.681 */
-  if (((int64)image->x1) * ((int64)image->y1) != (image->x1 * image->y1)) {
-    opj_event_msg(j2k->cinfo, EVT_ERROR, "Prevent buffer overflow (x1: %d, y1: %d)\n", image->x1, image->y1);
-    return;
-  }
+OPJ_BOOL opj_j2k_get_tile(      opj_j2k_t *p_j2k,
+                                                    opj_stream_private_t *p_stream,
+                                                    opj_image_t* p_image,
+                                                    opj_event_mgr_t * p_manager,
+                                                    OPJ_UINT32 tile_index )
+{
+        OPJ_UINT32 compno;
+        OPJ_UINT32 l_tile_x, l_tile_y;
+        opj_image_comp_t* l_img_comp;
+
+        if (!p_image) {
+                opj_event_msg(p_manager, EVT_ERROR, "We need an image previously created.\n");
+                return OPJ_FALSE;
+        }
 
-#ifdef USE_JPWL
-	if (j2k->cp->correct) {
-		/* if JPWL is on, we check whether TX errors have damaged
-		  too much the SIZ parameters */
-		if (!(image->x1 * image->y1)) {
-			opj_event_msg(j2k->cinfo, EVT_ERROR,
-				"JPWL: bad image size (%d x %d)\n",
-				image->x1, image->y1);
-			if (!JPWL_ASSUME || JPWL_ASSUME) {
-				opj_event_msg(j2k->cinfo, EVT_ERROR, "JPWL: giving up\n");
-				return;
-			}
-		}
-		if (image->numcomps != ((len - 38) / 3)) {
-			opj_event_msg(j2k->cinfo, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,
-				"JPWL: Csiz is %d => space in SIZ only for %d comps.!!!\n",
-				image->numcomps, ((len - 38) / 3));
-			if (!JPWL_ASSUME) {
-				opj_event_msg(j2k->cinfo, EVT_ERROR, "JPWL: giving up\n");
-				return;
-			}
-			/* we try to correct */
-			opj_event_msg(j2k->cinfo, EVT_WARNING, "- trying to adjust this\n");
-			if (image->numcomps < ((len - 38) / 3)) {
-				len = 38 + 3 * image->numcomps;
-				opj_event_msg(j2k->cinfo, EVT_WARNING, "- setting Lsiz to %d => HYPOTHESIS!!!\n",
-					len);				
-			} else {
-				image->numcomps = ((len - 38) / 3);
-				opj_event_msg(j2k->cinfo, EVT_WARNING, "- setting Csiz to %d => HYPOTHESIS!!!\n",
-					image->numcomps);				
-			}
-		}
+        if ( /*(tile_index < 0) &&*/ (tile_index >= p_j2k->m_cp.tw * p_j2k->m_cp.th) ){
+                opj_event_msg(p_manager, EVT_ERROR, "Tile index provided by the user is incorrect %d (max = %d) \n", tile_index, (p_j2k->m_cp.tw * p_j2k->m_cp.th) - 1);
+                return OPJ_FALSE;
+        }
 
-		/* update components number in the jpwl_exp_comps filed */
-		cp->exp_comps = image->numcomps;
-	}
-#else
-  (void)len;
-#endif /* USE_JPWL */
+        /* Compute the dimension of the desired tile*/
+        l_tile_x = tile_index % p_j2k->m_cp.tw;
+        l_tile_y = tile_index / p_j2k->m_cp.tw;
+
+        p_image->x0 = l_tile_x * p_j2k->m_cp.tdx + p_j2k->m_cp.tx0;
+        if (p_image->x0 < p_j2k->m_private_image->x0)
+                p_image->x0 = p_j2k->m_private_image->x0;
+        p_image->x1 = (l_tile_x + 1) * p_j2k->m_cp.tdx + p_j2k->m_cp.tx0;
+        if (p_image->x1 > p_j2k->m_private_image->x1)
+                p_image->x1 = p_j2k->m_private_image->x1;
+
+        p_image->y0 = l_tile_y * p_j2k->m_cp.tdy + p_j2k->m_cp.ty0;
+        if (p_image->y0 < p_j2k->m_private_image->y0)
+                p_image->y0 = p_j2k->m_private_image->y0;
+        p_image->y1 = (l_tile_y + 1) * p_j2k->m_cp.tdy + p_j2k->m_cp.ty0;
+        if (p_image->y1 > p_j2k->m_private_image->y1)
+                p_image->y1 = p_j2k->m_private_image->y1;
+
+        l_img_comp = p_image->comps;
+        for (compno=0; compno < p_image->numcomps; ++compno)
+        {
+                OPJ_INT32 l_comp_x1, l_comp_y1;
 
-  /* prevent division by zero */
-  if (!(cp->tdx * cp->tdy)) {
-    opj_event_msg(j2k->cinfo, EVT_ERROR, "invalid tile size (tdx: %d, tdy: %d)\n", cp->tdx, cp->tdy);
-    return;
-  }
-
-	image->comps = (opj_image_comp_t*) opj_calloc(image->numcomps, sizeof(opj_image_comp_t));
-	for (i = 0; i < image->numcomps; i++) {
-		int tmp;
-		tmp = cio_read(cio, 1);		/* Ssiz_i */
-		image->comps[i].prec = (tmp & 0x7f) + 1;
-		image->comps[i].sgnd = tmp >> 7;
-		image->comps[i].dx = cio_read(cio, 1);	/* XRsiz_i */
-		image->comps[i].dy = cio_read(cio, 1);	/* YRsiz_i */
-		
-#ifdef USE_JPWL
-		if (j2k->cp->correct) {
-		/* if JPWL is on, we check whether TX errors have damaged
-			too much the SIZ parameters, again */
-			if (!(image->comps[i].dx * image->comps[i].dy)) {
-				opj_event_msg(j2k->cinfo, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,
-					"JPWL: bad XRsiz_%d/YRsiz_%d (%d x %d)\n",
-					i, i, image->comps[i].dx, image->comps[i].dy);
-				if (!JPWL_ASSUME) {
-					opj_event_msg(j2k->cinfo, EVT_ERROR, "JPWL: giving up\n");
-					return;
-				}
-				/* we try to correct */
-				opj_event_msg(j2k->cinfo, EVT_WARNING, "- trying to adjust them\n");
-				if (!image->comps[i].dx) {
-					image->comps[i].dx = 1;
-					opj_event_msg(j2k->cinfo, EVT_WARNING, "- setting XRsiz_%d to %d => HYPOTHESIS!!!\n",
-						i, image->comps[i].dx);
-				}
-				if (!image->comps[i].dy) {
-					image->comps[i].dy = 1;
-					opj_event_msg(j2k->cinfo, EVT_WARNING, "- setting YRsiz_%d to %d => HYPOTHESIS!!!\n",
-						i, image->comps[i].dy);
-				}
-			}
-			
-		}
-#endif /* USE_JPWL */
+                l_img_comp->factor = p_j2k->m_private_image->comps[compno].factor;
 
-    /* prevent division by zero */
-    if (!(image->comps[i].dx * image->comps[i].dy)) {
-      opj_event_msg(j2k->cinfo, EVT_ERROR, "JPWL: invalid component size (dx: %d, dy: %d)\n", image->comps[i].dx, image->comps[i].dy);
-      return;
-    }
+                l_img_comp->x0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)p_image->x0, (OPJ_INT32)l_img_comp->dx);
+                l_img_comp->y0 = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)p_image->y0, (OPJ_INT32)l_img_comp->dy);
+                l_comp_x1 = opj_int_ceildiv((OPJ_INT32)p_image->x1, (OPJ_INT32)l_img_comp->dx);
+                l_comp_y1 = opj_int_ceildiv((OPJ_INT32)p_image->y1, (OPJ_INT32)l_img_comp->dy);
 
-		image->comps[i].resno_decoded = 0;	/* number of resolution decoded */
-		image->comps[i].factor = cp->reduce; /* reducing factor per component */
-	}
-	
-	cp->tw = int_ceildiv(image->x1 - cp->tx0, cp->tdx);
-	cp->th = int_ceildiv(image->y1 - cp->ty0, cp->tdy);
+                l_img_comp->w = (OPJ_UINT32)(opj_int_ceildivpow2(l_comp_x1, (OPJ_INT32)l_img_comp->factor) - opj_int_ceildivpow2((OPJ_INT32)l_img_comp->x0, (OPJ_INT32)l_img_comp->factor));
+                l_img_comp->h = (OPJ_UINT32)(opj_int_ceildivpow2(l_comp_y1, (OPJ_INT32)l_img_comp->factor) - opj_int_ceildivpow2((OPJ_INT32)l_img_comp->y0, (OPJ_INT32)l_img_comp->factor));
 
-  /* gdal_fuzzer_check_number_of_tiles.jp2 */
-  if (cp->tw == 0 || cp->th == 0 || cp->tw > 65535 / cp->th) {
-    opj_event_msg(j2k->cinfo, EVT_ERROR, 
-                            "Invalid number of tiles : %u x %u (maximum fixed by jpeg2000 norm is 65535 tiles)\n",
-                            cp->tw, cp->th);
-    return;
-  }
+                l_img_comp++;
+        }
 
+        /* Destroy the previous output image*/
+        if (p_j2k->m_output_image)
+                opj_image_destroy(p_j2k->m_output_image);
 
-#ifdef USE_JPWL
-	if (j2k->cp->correct) {
-		/* if JPWL is on, we check whether TX errors have damaged
-		  too much the SIZ parameters */
-		if ((cp->tw < 1) || (cp->th < 1) || (cp->tw > cp->max_tiles) || (cp->th > cp->max_tiles)) {
-			opj_event_msg(j2k->cinfo, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,
-				"JPWL: bad number of tiles (%d x %d)\n",
-				cp->tw, cp->th);
-			if (!JPWL_ASSUME) {
-				opj_event_msg(j2k->cinfo, EVT_ERROR, "JPWL: giving up\n");
-				return;
-			}
-			/* we try to correct */
-			opj_event_msg(j2k->cinfo, EVT_WARNING, "- trying to adjust them\n");
-			if (cp->tw < 1) {
-				cp->tw= 1;
-				opj_event_msg(j2k->cinfo, EVT_WARNING, "- setting %d tiles in x => HYPOTHESIS!!!\n",
-					cp->tw);
-			}
-			if (cp->tw > cp->max_tiles) {
-				cp->tw= 1;
-				opj_event_msg(j2k->cinfo, EVT_WARNING, "- too large x, increase expectance of %d\n"
-					"- setting %d tiles in x => HYPOTHESIS!!!\n",
-					cp->max_tiles, cp->tw);
-			}
-			if (cp->th < 1) {
-				cp->th= 1;
-				opj_event_msg(j2k->cinfo, EVT_WARNING, "- setting %d tiles in y => HYPOTHESIS!!!\n",
-					cp->th);
-			}
-			if (cp->th > cp->max_tiles) {
-				cp->th= 1;
-				opj_event_msg(j2k->cinfo, EVT_WARNING, "- too large y, increase expectance of %d to continue\n",
-					"- setting %d tiles in y => HYPOTHESIS!!!\n",
-					cp->max_tiles, cp->th);
-			}
-		}
-	}
-#endif /* USE_JPWL */
+        /* Create the ouput image from the information previously computed*/
+        p_j2k->m_output_image = opj_image_create0();
+        if (! (p_j2k->m_output_image)) {
+                return OPJ_FALSE;
+        }
+        opj_copy_image_header(p_image, p_j2k->m_output_image);
 
-	cp->tcps = (opj_tcp_t*) opj_calloc(cp->tw * cp->th, sizeof(opj_tcp_t));
-    if (cp->tcps == NULL)
-    {
-        opj_event_msg(j2k->cinfo, EVT_ERROR, "Out of memory\n");
-        return;
-    }
-	cp->tileno = (int*) opj_malloc(cp->tw * cp->th * sizeof(int));
-    if (cp->tileno == NULL)
-    {
-        opj_event_msg(j2k->cinfo, EVT_ERROR, "Out of memory\n");
-        return;
-    }
-	cp->tileno_size = 0;
-	
-#ifdef USE_JPWL
-	if (j2k->cp->correct) {
-		if (!cp->tcps) {
-			opj_event_msg(j2k->cinfo, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,
-				"JPWL: could not alloc tcps field of cp\n");
-			if (!JPWL_ASSUME || JPWL_ASSUME) {
-				opj_event_msg(j2k->cinfo, EVT_ERROR, "JPWL: giving up\n");
-				return;
-			}
-		}
-	}
-#endif /* USE_JPWL */
+        p_j2k->m_specific_param.m_decoder.m_tile_ind_to_dec = (OPJ_INT32)tile_index;
 
-	for (i = 0; i < cp->tw * cp->th; i++) {
-		cp->tcps[i].POC = 0;
-		cp->tcps[i].numpocs = 0;
-		cp->tcps[i].first = 1;
-	}
-	
-	/* Initialization for PPM marker */
-	cp->ppm = 0;
-	cp->ppm_data = NULL;
-	cp->ppm_data_first = NULL;
-	cp->ppm_previous = 0;
-	cp->ppm_store = 0;
-
-	j2k->default_tcp->tccps = (opj_tccp_t*) opj_calloc(image->numcomps, sizeof(opj_tccp_t));
-	for (i = 0; i < cp->tw * cp->th; i++) {
-		cp->tcps[i].tccps = (opj_tccp_t*) opj_malloc(image->numcomps * sizeof(opj_tccp_t));
-	}	
-	j2k->tile_data = (unsigned char**) opj_calloc(cp->tw * cp->th, sizeof(unsigned char*));
-	j2k->tile_len = (int*) opj_calloc(cp->tw * cp->th, sizeof(int));
-	j2k->state = J2K_STATE_MH;
-
-	/* Index */
-	if (j2k->cstr_info) {
-		opj_codestream_info_t *cstr_info = j2k->cstr_info;
-		cstr_info->image_w = image->x1 - image->x0;
-		cstr_info->image_h = image->y1 - image->y0;
-		cstr_info->numcomps = image->numcomps;
-		cstr_info->tw = cp->tw;
-		cstr_info->th = cp->th;
-		cstr_info->tile_x = cp->tdx;	
-		cstr_info->tile_y = cp->tdy;	
-		cstr_info->tile_Ox = cp->tx0;	
-		cstr_info->tile_Oy = cp->ty0;			
-		cstr_info->tile = (opj_tile_info_t*) opj_calloc(cp->tw * cp->th, sizeof(opj_tile_info_t));		
-	}
-}
-
-static void j2k_write_com(opj_j2k_t *j2k) {
-	unsigned int i;
-	int lenp, len;
-
-	if(j2k->cp->comment) {
-		opj_cio_t *cio = j2k->cio;
-		char *comment = j2k->cp->comment;
-
-		cio_write(cio, J2K_MS_COM, 2);
-		lenp = cio_tell(cio);
-		cio_skip(cio, 2);
-		cio_write(cio, 1, 2);		/* General use (IS 8859-15:1999 (Latin) values) */
-		for (i = 0; i < strlen(comment); i++) {
-			cio_write(cio, comment[i], 1);
-		}
-		len = cio_tell(cio) - lenp;
-		cio_seek(cio, lenp);
-		cio_write(cio, len, 2);
-		cio_seek(cio, lenp + len);
-
-		
-		if(j2k->cstr_info)
-		  j2k_add_mhmarker(j2k->cstr_info, J2K_MS_COM, lenp, len);
-
-	}
-}
-
-static void j2k_read_com(opj_j2k_t *j2k) {
-	int len;
-	
-	opj_cio_t *cio = j2k->cio;
-
-	len = cio_read(cio, 2);
-	cio_skip(cio, len - 2);  
-}
-
-static void j2k_write_cox(opj_j2k_t *j2k, int compno) {
-	int i;
-
-	opj_cp_t *cp = j2k->cp;
-	opj_tcp_t *tcp = &cp->tcps[j2k->curtileno];
-	opj_tccp_t *tccp = &tcp->tccps[compno];
-	opj_cio_t *cio = j2k->cio;
-	
-	cio_write(cio, tccp->numresolutions - 1, 1);	/* SPcox (D) */
-	cio_write(cio, tccp->cblkw - 2, 1);				/* SPcox (E) */
-	cio_write(cio, tccp->cblkh - 2, 1);				/* SPcox (F) */
-	cio_write(cio, tccp->cblksty, 1);				/* SPcox (G) */
-	cio_write(cio, tccp->qmfbid, 1);				/* SPcox (H) */
-	
-	if (tccp->csty & J2K_CCP_CSTY_PRT) {
-		for (i = 0; i < tccp->numresolutions; i++) {
-			cio_write(cio, tccp->prcw[i] + (tccp->prch[i] << 4), 1);	/* SPcox (I_i) */
-		}
-	}
-}
-
-static void j2k_read_cox(opj_j2k_t *j2k, int compno) {
-	int i;
-
-	opj_cp_t *cp = j2k->cp;
-	opj_tcp_t *tcp = j2k->state == J2K_STATE_TPH ? &cp->tcps[j2k->curtileno] : j2k->default_tcp;
-	opj_tccp_t *tccp = &tcp->tccps[compno];
-	opj_cio_t *cio = j2k->cio;
-
-	tccp->numresolutions = cio_read(cio, 1) + 1;	/* SPcox (D) */
-
-	/* If user wants to remove more resolutions than the codestream contains, return error*/
-	if (cp->reduce >= tccp->numresolutions) {
-		opj_event_msg(j2k->cinfo, EVT_ERROR, "Error decoding component %d.\nThe number of resolutions to remove is higher than the number "
-					"of resolutions of this component\nModify the cp_reduce parameter.\n\n", compno);
-		j2k->state |= J2K_STATE_ERR;
-	}
-  if( tccp->numresolutions > J2K_MAXRLVLS ) {
-    opj_event_msg(j2k->cinfo, EVT_ERROR, "Error decoding component %d.\nThe number of resolutions is too big: %d vs max= %d. Truncating.\n\n",
-      compno, tccp->numresolutions, J2K_MAXRLVLS);
-		j2k->state |= J2K_STATE_ERR;
-    tccp->numresolutions = J2K_MAXRLVLS;
- }
-
-	tccp->cblkw = cio_read(cio, 1) + 2;	/* SPcox (E) */
-	tccp->cblkh = cio_read(cio, 1) + 2;	/* SPcox (F) */
-	tccp->cblksty = cio_read(cio, 1);	/* SPcox (G) */
-	tccp->qmfbid = cio_read(cio, 1);	/* SPcox (H) */
-	if (tccp->csty & J2K_CP_CSTY_PRT) {
-		for (i = 0; i < tccp->numresolutions; i++) {
-			int tmp = cio_read(cio, 1);	/* SPcox (I_i) */
-			tccp->prcw[i] = tmp & 0xf;
-			tccp->prch[i] = tmp >> 4;
-		}
-	}
-
-	/* INDEX >> */
-	if(j2k->cstr_info && compno == 0) {
-		for (i = 0; i < tccp->numresolutions; i++) {
-			if (tccp->csty & J2K_CP_CSTY_PRT) {
-				j2k->cstr_info->tile[j2k->curtileno].pdx[i] = tccp->prcw[i];
-				j2k->cstr_info->tile[j2k->curtileno].pdy[i] = tccp->prch[i];
-			}
-			else {
-				j2k->cstr_info->tile[j2k->curtileno].pdx[i] = 15;
-				j2k->cstr_info->tile[j2k->curtileno].pdx[i] = 15;
-			}
-		}
-	}
-	/* << INDEX */
-}
-
-static void j2k_write_cod(opj_j2k_t *j2k) {
-	opj_cp_t *cp = NULL;
-	opj_tcp_t *tcp = NULL;
-	int lenp, len;
-
-	opj_cio_t *cio = j2k->cio;
-	
-	cio_write(cio, J2K_MS_COD, 2);	/* COD */
-	
-	lenp = cio_tell(cio);
-	cio_skip(cio, 2);
-	
-	cp = j2k->cp;
-	tcp = &cp->tcps[j2k->curtileno];
-
-	cio_write(cio, tcp->csty, 1);		/* Scod */
-	cio_write(cio, tcp->prg, 1);		/* SGcod (A) */
-	cio_write(cio, tcp->numlayers, 2);	/* SGcod (B) */
-	cio_write(cio, tcp->mct, 1);		/* SGcod (C) */
-	
-	j2k_write_cox(j2k, 0);
-	len = cio_tell(cio) - lenp;
-	cio_seek(cio, lenp);
-	cio_write(cio, len, 2);		/* Lcod */
-	cio_seek(cio, lenp + len);
-
-	if(j2k->cstr_info)
-	  j2k_add_mhmarker(j2k->cstr_info, J2K_MS_COD, lenp, len);
-
-}
-
-static void j2k_read_cod(opj_j2k_t *j2k) {
-	int len, i, pos;
-	
-	opj_cio_t *cio = j2k->cio;
-	opj_cp_t *cp = j2k->cp;
-	opj_tcp_t *tcp = j2k->state == J2K_STATE_TPH ? &cp->tcps[j2k->curtileno] : j2k->default_tcp;
-	opj_image_t *image = j2k->image;
-	
-	len = cio_read(cio, 2);				/* Lcod */
-  (void)len;
-	tcp->csty = cio_read(cio, 1);		/* Scod */
-	tcp->prg = (OPJ_PROG_ORDER)cio_read(cio, 1);		/* SGcod (A) */
-	tcp->numlayers = cio_read(cio, 2);	/* SGcod (B) */
-	tcp->mct = cio_read(cio, 1);		/* SGcod (C) */
-	
-	pos = cio_tell(cio);
-	for (i = 0; i < image->numcomps; i++) {
-		tcp->tccps[i].csty = tcp->csty & J2K_CP_CSTY_PRT;
-		cio_seek(cio, pos);
-		j2k_read_cox(j2k, i);
-	}
-
-	/* Index */
-	if (j2k->cstr_info) {
-		opj_codestream_info_t *cstr_info = j2k->cstr_info;
-		cstr_info->prog = tcp->prg;
-		cstr_info->numlayers = tcp->numlayers;
-		cstr_info->numdecompos = (int*) opj_malloc(image->numcomps * sizeof(int));
-		for (i = 0; i < image->numcomps; i++) {
-			cstr_info->numdecompos[i] = tcp->tccps[i].numresolutions - 1;
-		}
-	}
-}
-
-static void j2k_write_coc(opj_j2k_t *j2k, int compno) {
-	int lenp, len;
-
-	opj_cp_t *cp = j2k->cp;
-	opj_tcp_t *tcp = &cp->tcps[j2k->curtileno];
-	opj_image_t *image = j2k->image;
-	opj_cio_t *cio = j2k->cio;
-	
-	cio_write(cio, J2K_MS_COC, 2);	/* COC */
-	lenp = cio_tell(cio);
-	cio_skip(cio, 2);
-	cio_write(cio, compno, image->numcomps <= 256 ? 1 : 2);	/* Ccoc */
-	cio_write(cio, tcp->tccps[compno].csty, 1);	/* Scoc */
-	j2k_write_cox(j2k, compno);
-	len = cio_tell(cio) - lenp;
-	cio_seek(cio, lenp);
-	cio_write(cio, len, 2);			/* Lcoc */
-	cio_seek(cio, lenp + len);
-}
-
-static void j2k_read_coc(opj_j2k_t *j2k) {
-	int len, compno;
-
-	opj_cp_t *cp = j2k->cp;
-	opj_tcp_t *tcp = j2k->state == J2K_STATE_TPH ? &cp->tcps[j2k->curtileno] : j2k->default_tcp;
-	opj_image_t *image = j2k->image;
-	opj_cio_t *cio = j2k->cio;
-	
-	len = cio_read(cio, 2);		/* Lcoc */
-  (void)len;
-	compno = cio_read(cio, image->numcomps <= 256 ? 1 : 2);	/* Ccoc */
-  if (compno >= image->numcomps) {
-    opj_event_msg(j2k->cinfo, EVT_ERROR,
-      "bad component number in COC (%d out of a maximum of %d)\n",
-      compno, image->numcomps);
-    return;
-  }
-	tcp->tccps[compno].csty = cio_read(cio, 1);	/* Scoc */
-	j2k_read_cox(j2k, compno);
-}
-
-static void j2k_write_qcx(opj_j2k_t *j2k, int compno) {
-	int bandno, numbands;
-	int expn, mant;
-	
-	opj_cp_t *cp = j2k->cp;
-	opj_tcp_t *tcp = &cp->tcps[j2k->curtileno];
-	opj_tccp_t *tccp = &tcp->tccps[compno];
-	opj_cio_t *cio = j2k->cio;
-	
-	cio_write(cio, tccp->qntsty + (tccp->numgbits << 5), 1);	/* Sqcx */
-	numbands = tccp->qntsty == J2K_CCP_QNTSTY_SIQNT ? 1 : tccp->numresolutions * 3 - 2;
-	
-	for (bandno = 0; bandno < numbands; bandno++) {
-		expn = tccp->stepsizes[bandno].expn;
-		mant = tccp->stepsizes[bandno].mant;
-		
-		if (tccp->qntsty == J2K_CCP_QNTSTY_NOQNT) {
-			cio_write(cio, expn << 3, 1);	/* SPqcx_i */
-		} else {
-			cio_write(cio, (expn << 11) + mant, 2);	/* SPqcx_i */
-		}
-	}
-}
+        /* customization of the decoding */
+        opj_j2k_setup_decoding_tile(p_j2k);
 
-static void j2k_read_qcx(opj_j2k_t *j2k, int compno, int len) {
-	int tmp;
-	int bandno, numbands;
+        /* Decode the codestream */
+        if (! opj_j2k_exec (p_j2k,p_j2k->m_procedure_list,p_stream,p_manager)) {
+                opj_image_destroy(p_j2k->m_private_image);
+                p_j2k->m_private_image = NULL;
+                return OPJ_FALSE;
+        }
 
-	opj_cp_t *cp = j2k->cp;
-	opj_tcp_t *tcp = j2k->state == J2K_STATE_TPH ? &cp->tcps[j2k->curtileno] : j2k->default_tcp;
-	opj_tccp_t *tccp = &tcp->tccps[compno];
-	opj_cio_t *cio = j2k->cio;
+        /* Move data and copy one information from codec to output image*/
+        for (compno = 0; compno < p_image->numcomps; compno++) {
+                p_image->comps[compno].resno_decoded = p_j2k->m_output_image->comps[compno].resno_decoded;
 
-	tmp = cio_read(cio, 1);		/* Sqcx */
-	tccp->qntsty = tmp & 0x1f;
-	tccp->numgbits = tmp >> 5;
-	numbands = (tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) ? 
-		1 : ((tccp->qntsty == J2K_CCP_QNTSTY_NOQNT) ? len - 1 : (len - 1) / 2);
+                if (p_image->comps[compno].data)
+                        opj_free(p_image->comps[compno].data);
 
-#ifdef USE_JPWL
-	if (j2k->cp->correct) {
-
-		/* if JPWL is on, we check whether there are too many subbands */
-		if ((numbands < 0) || (numbands >= J2K_MAXBANDS)) {
-			opj_event_msg(j2k->cinfo, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,
-				"JPWL: bad number of subbands in Sqcx (%d)\n",
-				numbands);
-			if (!JPWL_ASSUME) {
-				opj_event_msg(j2k->cinfo, EVT_ERROR, "JPWL: giving up\n");
-				return;
-			}
-			/* we try to correct */
-			numbands = 1;
-			opj_event_msg(j2k->cinfo, EVT_WARNING, "- trying to adjust them\n"
-				"- setting number of bands to %d => HYPOTHESIS!!!\n",
-				numbands);
-		};
-
-	};
-
-#else
-	/* We check whether there are too many subbands */
-	if ((numbands < 0) || (numbands >= J2K_MAXBANDS)) {
-		opj_event_msg(j2k->cinfo, EVT_WARNING ,
-					"bad number of subbands in Sqcx (%d) regarding to J2K_MAXBANDS (%d) \n"
-				    "- limiting number of bands to J2K_MAXBANDS and try to move to the next markers\n", numbands, J2K_MAXBANDS);
-    /* edf_c2_1013627.jp2 */
-    numbands = 1;
-	}
+                p_image->comps[compno].data = p_j2k->m_output_image->comps[compno].data;
 
-#endif /* USE_JPWL */
+                p_j2k->m_output_image->comps[compno].data = NULL;
+        }
 
-	for (bandno = 0; bandno < numbands; bandno++) {
-		int expn, mant;
-		if (tccp->qntsty == J2K_CCP_QNTSTY_NOQNT) {
-			expn = cio_read(cio, 1) >> 3;	/* SPqcx_i */
-			mant = 0;
-		} else {
-			tmp = cio_read(cio, 2);	/* SPqcx_i */
-			expn = tmp >> 11;
-			mant = tmp & 0x7ff;
-		}
-		if (bandno < J2K_MAXBANDS){
-			tccp->stepsizes[bandno].expn = expn;
-			tccp->stepsizes[bandno].mant = mant;
-		}
-	}
-	
-	/* Add Antonin : if scalar_derived -> compute other stepsizes */
-	if (tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) {
-		for (bandno = 1; bandno < J2K_MAXBANDS; bandno++) {
-			tccp->stepsizes[bandno].expn = 
-				((tccp->stepsizes[0].expn) - ((bandno - 1) / 3) > 0) ? 
-					(tccp->stepsizes[0].expn) - ((bandno - 1) / 3) : 0;
-			tccp->stepsizes[bandno].mant = tccp->stepsizes[0].mant;
-		}
-	}
-	/* ddA */
-}
-
-static void j2k_write_qcd(opj_j2k_t *j2k) {
-	int lenp, len;
-
-	opj_cio_t *cio = j2k->cio;
-	
-	cio_write(cio, J2K_MS_QCD, 2);	/* QCD */
-	lenp = cio_tell(cio);
-	cio_skip(cio, 2);
-	j2k_write_qcx(j2k, 0);
-	len = cio_tell(cio) - lenp;
-	cio_seek(cio, lenp);
-	cio_write(cio, len, 2);			/* Lqcd */
-	cio_seek(cio, lenp + len);
-
-	if(j2k->cstr_info)
-	  j2k_add_mhmarker(j2k->cstr_info, J2K_MS_QCD, lenp, len);
-}
-
-static void j2k_read_qcd(opj_j2k_t *j2k) {
-	int len, i, pos;
-
-	opj_cio_t *cio = j2k->cio;
-	opj_image_t *image = j2k->image;
-	
-	len = cio_read(cio, 2);		/* Lqcd */
-	pos = cio_tell(cio);
-	for (i = 0; i < image->numcomps; i++) {
-		cio_seek(cio, pos);
-		j2k_read_qcx(j2k, i, len - 2);
-	}
-}
-
-static void j2k_write_qcc(opj_j2k_t *j2k, int compno) {
-	int lenp, len;
-
-	opj_cio_t *cio = j2k->cio;
-	
-	cio_write(cio, J2K_MS_QCC, 2);	/* QCC */
-	lenp = cio_tell(cio);
-	cio_skip(cio, 2);
-	cio_write(cio, compno, j2k->image->numcomps <= 256 ? 1 : 2);	/* Cqcc */
-	j2k_write_qcx(j2k, compno);
-	len = cio_tell(cio) - lenp;
-	cio_seek(cio, lenp);
-	cio_write(cio, len, 2);			/* Lqcc */
-	cio_seek(cio, lenp + len);
-}
-
-static void j2k_read_qcc(opj_j2k_t *j2k) {
-	int len, compno;
-	int numcomp = j2k->image->numcomps;
-	opj_cio_t *cio = j2k->cio;
-
-	len = cio_read(cio, 2);	/* Lqcc */
-	compno = cio_read(cio, numcomp <= 256 ? 1 : 2);	/* Cqcc */
+        return OPJ_TRUE;
+}
 
-#ifdef USE_JPWL
-	if (j2k->cp->correct) {
-
-		static int backup_compno = 0;
-
-		/* compno is negative or larger than the number of components!!! */
-		if ((compno < 0) || (compno >= numcomp)) {
-			opj_event_msg(j2k->cinfo, EVT_ERROR,
-				"JPWL: bad component number in QCC (%d out of a maximum of %d)\n",
-				compno, numcomp);
-			if (!JPWL_ASSUME) {
-				opj_event_msg(j2k->cinfo, EVT_ERROR, "JPWL: giving up\n");
-				return;
-			}
-			/* we try to correct */
-			compno = backup_compno % numcomp;
-			opj_event_msg(j2k->cinfo, EVT_WARNING, "- trying to adjust this\n"
-				"- setting component number to %d\n",
-				compno);
-		}
+OPJ_BOOL opj_j2k_set_decoded_resolution_factor(opj_j2k_t *p_j2k,
+                                               OPJ_UINT32 res_factor,
+                                               opj_event_mgr_t * p_manager)
+{
+        OPJ_UINT32 it_comp;
+
+        p_j2k->m_cp.m_specific_param.m_dec.m_reduce = res_factor;
+
+        if (p_j2k->m_private_image) {
+                if (p_j2k->m_private_image->comps) {
+                        if (p_j2k->m_specific_param.m_decoder.m_default_tcp) {
+                                if (p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps) {
+                                        for (it_comp = 0 ; it_comp < p_j2k->m_private_image->numcomps; it_comp++) {
+                                                OPJ_UINT32 max_res = p_j2k->m_specific_param.m_decoder.m_default_tcp->tccps[it_comp].numresolutions;
+                                                if ( res_factor >= max_res){
+                                                        opj_event_msg(p_manager, EVT_ERROR, "Resolution factor is greater than the maximum resolution in the component.\n");
+                                                        return OPJ_FALSE;
+                                                }
+                                                p_j2k->m_private_image->comps[it_comp].factor = res_factor;
+                                        }
+                                        return OPJ_TRUE;
+                                }
+                        }
+                }
+        }
 
-		/* keep your private count of tiles */
-		backup_compno++;
-	}
-#endif /* USE_JPWL */
+        return OPJ_FALSE;
+}
 
-  if ((compno < 0) || (compno >= numcomp)) {
-    opj_event_msg(j2k->cinfo, EVT_ERROR,
-      "bad component number in QCC (%d out of a maximum of %d)\n",
-      compno, j2k->image->numcomps);
-    return;
-  }
-
-	j2k_read_qcx(j2k, compno, len - 2 - (numcomp <= 256 ? 1 : 2));
-}
-
-static void j2k_write_poc(opj_j2k_t *j2k) {
-	int len, numpchgs, i;
-
-	int numcomps = j2k->image->numcomps;
-	
-	opj_cp_t *cp = j2k->cp;
-	opj_tcp_t *tcp = &cp->tcps[j2k->curtileno];
-	opj_tccp_t *tccp = &tcp->tccps[0];
-	opj_cio_t *cio = j2k->cio;
-
-	numpchgs = 1 + tcp->numpocs;
-	cio_write(cio, J2K_MS_POC, 2);	/* POC  */
-	len = 2 + (5 + 2 * (numcomps <= 256 ? 1 : 2)) * numpchgs;
-	cio_write(cio, len, 2);		/* Lpoc */
-	for (i = 0; i < numpchgs; i++) {
-		opj_poc_t *poc = &tcp->pocs[i];
-		cio_write(cio, poc->resno0, 1);	/* RSpoc_i */
-		cio_write(cio, poc->compno0, (numcomps <= 256 ? 1 : 2));	/* CSpoc_i */
-		cio_write(cio, poc->layno1, 2);	/* LYEpoc_i */
-		poc->layno1 = int_min(poc->layno1, tcp->numlayers);
-		cio_write(cio, poc->resno1, 1);	/* REpoc_i */
-		poc->resno1 = int_min(poc->resno1, tccp->numresolutions);
-		cio_write(cio, poc->compno1, (numcomps <= 256 ? 1 : 2));	/* CEpoc_i */
-		poc->compno1 = int_min(poc->compno1, numcomps);
-		cio_write(cio, poc->prg, 1);	/* Ppoc_i */
-	}
-}
-
-static void j2k_read_poc(opj_j2k_t *j2k) {
-	int len, numpchgs, i, old_poc;
-
-	int numcomps = j2k->image->numcomps;
-	
-	opj_cp_t *cp = j2k->cp;
-	opj_tcp_t *tcp = j2k->state == J2K_STATE_TPH ? &cp->tcps[j2k->curtileno] : j2k->default_tcp;
-	opj_cio_t *cio = j2k->cio;
-	
-	old_poc = tcp->POC ? tcp->numpocs + 1 : 0;
-	tcp->POC = 1;
-	len = cio_read(cio, 2);		/* Lpoc */
-	numpchgs = (len - 2) / (5 + 2 * (numcomps <= 256 ? 1 : 2));
-	
-  if( numpchgs >= 32 )
-    {
-    /* edf_c2_1103421.jp2 */
-    opj_event_msg(j2k->cinfo, EVT_ERROR,
-      "bad number of POCS (%d out of a maximum of %d)\n",
-      numpchgs, 32);
-    numpchgs = 0;
-    }
+OPJ_BOOL opj_j2k_encode(opj_j2k_t * p_j2k,
+                        opj_stream_private_t *p_stream,
+                        opj_event_mgr_t * p_manager )
+{
+        OPJ_UINT32 i;
+        OPJ_UINT32 l_nb_tiles;
+        OPJ_UINT32 l_max_tile_size, l_current_tile_size;
+        OPJ_BYTE * l_current_data;
+
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_stream != 00);
+        assert(p_manager != 00);
+
+        l_current_data = (OPJ_BYTE*)opj_malloc(1000);
+        if (! l_current_data) {
+                opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to encode all tiles\n");
+                return OPJ_FALSE;
+        }
+        l_max_tile_size = 1000;
+
+        l_nb_tiles = p_j2k->m_cp.th * p_j2k->m_cp.tw;
+        for (i=0;i<l_nb_tiles;++i) {
+                if (! opj_j2k_pre_write_tile(p_j2k,i,p_stream,p_manager)) {
+                        opj_free(l_current_data);
+                        return OPJ_FALSE;
+                }
+
+                l_current_tile_size = opj_tcd_get_encoded_tile_size(p_j2k->m_tcd);
+                if (l_current_tile_size > l_max_tile_size) {
+                        OPJ_BYTE *l_new_current_data = (OPJ_BYTE *) opj_realloc(l_current_data, l_current_tile_size);
+                        if (! l_new_current_data) {
+                                opj_free(l_current_data);
+                                opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to encode all tiles\n");
+                                return OPJ_FALSE;
+                        }
+                        l_current_data = l_new_current_data;
+                        l_max_tile_size = l_current_tile_size;
+                }
+
+                opj_j2k_get_tile_data(p_j2k->m_tcd,l_current_data);
+
+                if (! opj_j2k_post_write_tile (p_j2k,l_current_data,l_current_tile_size,p_stream,p_manager)) {
+                        return OPJ_FALSE;
+                }
+        }
 
-	for (i = old_poc; i < numpchgs + old_poc; i++) {
-		opj_poc_t *poc;
-		poc = &tcp->pocs[i];
-		poc->resno0 = cio_read(cio, 1);	/* RSpoc_i */
-		poc->compno0 = cio_read(cio, numcomps <= 256 ? 1 : 2);	/* CSpoc_i */
-		poc->layno1 = cio_read(cio, 2);    /* LYEpoc_i */
-		poc->resno1 = cio_read(cio, 1);    /* REpoc_i */
-		poc->compno1 = int_min(
-			cio_read(cio, numcomps <= 256 ? 1 : 2), (unsigned int) numcomps);	/* CEpoc_i */
-		poc->prg = (OPJ_PROG_ORDER)cio_read(cio, 1);	/* Ppoc_i */
-	}
-	
-	tcp->numpocs = numpchgs + old_poc - 1;
-}
-
-static void j2k_read_crg(opj_j2k_t *j2k) {
-	int len, i, Xcrg_i, Ycrg_i;
-	
-	opj_cio_t *cio = j2k->cio;
-	int numcomps = j2k->image->numcomps;
-	
-	len = cio_read(cio, 2);			/* Lcrg */
-  (void)len;
-	for (i = 0; i < numcomps; i++) {
-		Xcrg_i = cio_read(cio, 2);	/* Xcrg_i */
-    (void)Xcrg_i;
-		Ycrg_i = cio_read(cio, 2);	/* Ycrg_i */
-    (void)Ycrg_i;
-	}
-}
-
-static void j2k_read_tlm(opj_j2k_t *j2k) {
-	int len, Ztlm, Stlm, ST, SP, tile_tlm, i;
-	long int Ttlm_i, Ptlm_i;
-
-	opj_cio_t *cio = j2k->cio;
-	
-	len = cio_read(cio, 2);		/* Ltlm */
-	Ztlm = cio_read(cio, 1);	/* Ztlm */
-  (void)Ztlm;
-	Stlm = cio_read(cio, 1);	/* Stlm */
-	ST = ((Stlm >> 4) & 0x01) + ((Stlm >> 4) & 0x02);
-	SP = (Stlm >> 6) & 0x01;
-	tile_tlm = (len - 4) / ((SP + 1) * 2 + ST);
-	for (i = 0; i < tile_tlm; i++) {
-		Ttlm_i = cio_read(cio, ST);	/* Ttlm_i */
-    (void)Ttlm_i;
-		Ptlm_i = cio_read(cio, SP ? 4 : 2);	/* Ptlm_i */
-    (void)Ptlm_i;
-	}
-}
-
-static void j2k_read_plm(opj_j2k_t *j2k) {
-	int len, i, Zplm, Nplm, add, packet_len = 0;
-	
-	opj_cio_t *cio = j2k->cio;
-
-	len = cio_read(cio, 2);		/* Lplm */
-	Zplm = cio_read(cio, 1);	/* Zplm */
-  (void)Zplm;
-	len -= 3;
-	while (len > 0) {
-		Nplm = cio_read(cio, 4);		/* Nplm */
-		len -= 4;
-		for (i = Nplm; i > 0; i--) {
-			add = cio_read(cio, 1);
-			len--;
-			packet_len = (packet_len << 7) + add;	/* Iplm_ij */
-			if ((add & 0x80) == 0) {
-				/* New packet */
-				packet_len = 0;
-			}
-			if (len <= 0)
-				break;
-		}
-	}
-}
-
-static void j2k_read_plt(opj_j2k_t *j2k) {
-	int len, i, Zplt, packet_len = 0, add;
-	
-	opj_cio_t *cio = j2k->cio;
-	
-	len = cio_read(cio, 2);		/* Lplt */
-	Zplt = cio_read(cio, 1);	/* Zplt */
-  (void)Zplt;
-	for (i = len - 3; i > 0; i--) {
-		add = cio_read(cio, 1);
-		packet_len = (packet_len << 7) + add;	/* Iplt_i */
-		if ((add & 0x80) == 0) {
-			/* New packet */
-			packet_len = 0;
-		}
-	}
-}
-
-static void j2k_read_ppm(opj_j2k_t *j2k) {
-	int len, Z_ppm, i, j;
-	int N_ppm;
-
-	opj_cp_t *cp = j2k->cp;
-	opj_cio_t *cio = j2k->cio;
-	
-	len = cio_read(cio, 2);
-	cp->ppm = 1;
-	
-	Z_ppm = cio_read(cio, 1);	/* Z_ppm */
-	len -= 3;
-	while (len > 0) {
-		if (cp->ppm_previous == 0) {
-			N_ppm = cio_read(cio, 4);	/* N_ppm */
-			len -= 4;
-		} else {
-			N_ppm = cp->ppm_previous;
-		}
-		j = cp->ppm_store;
-		if (Z_ppm == 0) {	/* First PPM marker */
-			cp->ppm_data = (unsigned char *) opj_malloc(N_ppm * sizeof(unsigned char));
-			cp->ppm_data_first = cp->ppm_data;
-			cp->ppm_len = N_ppm;
-		} else {			/* NON-first PPM marker */
-			cp->ppm_data = (unsigned char *) opj_realloc(cp->ppm_data, (N_ppm +	cp->ppm_store) * sizeof(unsigned char));
+        opj_free(l_current_data);
+        return OPJ_TRUE;
+}
 
-#ifdef USE_JPWL
-			/* this memory allocation check could be done even in non-JPWL cases */
-			if (cp->correct) {
-				if (!cp->ppm_data) {
-					opj_event_msg(j2k->cinfo, EVT_ERROR,
-						"JPWL: failed memory allocation during PPM marker parsing (pos. %x)\n",
-						cio_tell(cio));
-					if (!JPWL_ASSUME || JPWL_ASSUME) {
-						opj_free(cp->ppm_data);
-						opj_event_msg(j2k->cinfo, EVT_ERROR, "JPWL: giving up\n");
-						return;
-					}
-				}
-			}
-#endif
+OPJ_BOOL opj_j2k_end_compress(  opj_j2k_t *p_j2k,
+                                                        opj_stream_private_t *p_stream,
+                                                        opj_event_mgr_t * p_manager)
+{
+        /* customization of the encoding */
+        opj_j2k_setup_end_compress(p_j2k);
 
-			cp->ppm_data_first = cp->ppm_data;
-			cp->ppm_len = N_ppm + cp->ppm_store;
-		}
-		for (i = N_ppm; i > 0; i--) {	/* Read packet header */
-			cp->ppm_data[j] = cio_read(cio, 1);
-			j++;
-			len--;
-			if (len == 0)
-				break;			/* Case of non-finished packet header in present marker but finished in next one */
-		}
-		cp->ppm_previous = i - 1;
-		cp->ppm_store = j;
-	}
-}
-
-static void j2k_read_ppt(opj_j2k_t *j2k) {
-	int len, Z_ppt, i, j = 0;
-
-	opj_cp_t *cp = j2k->cp;
-	opj_tcp_t *tcp = cp->tcps + j2k->curtileno;
-	opj_cio_t *cio = j2k->cio;
-
-	len = cio_read(cio, 2);
-	Z_ppt = cio_read(cio, 1);
-	tcp->ppt = 1;
-	if (Z_ppt == 0) {		/* First PPT marker */
-		tcp->ppt_data = (unsigned char *) opj_malloc((len - 3) * sizeof(unsigned char));
-		tcp->ppt_data_first = tcp->ppt_data;
-		tcp->ppt_store = 0;
-		tcp->ppt_len = len - 3;
-	} else {			/* NON-first PPT marker */
-		tcp->ppt_data =	(unsigned char *) opj_realloc(tcp->ppt_data, (len - 3 + tcp->ppt_store) * sizeof(unsigned char));
-		tcp->ppt_data_first = tcp->ppt_data;
-		tcp->ppt_len = len - 3 + tcp->ppt_store;
-	}
-	j = tcp->ppt_store;
-	for (i = len - 3; i > 0; i--) {
-		tcp->ppt_data[j] = cio_read(cio, 1);
-		j++;
-	}
-	tcp->ppt_store = j;
-}
-
-static void j2k_write_tlm(opj_j2k_t *j2k){
-	int lenp;
-	opj_cio_t *cio = j2k->cio;
-	j2k->tlm_start = cio_tell(cio);
-	cio_write(cio, J2K_MS_TLM, 2);/* TLM */
-	lenp = 4 + (5*j2k->totnum_tp);
-	cio_write(cio,lenp,2);				/* Ltlm */
-	cio_write(cio, 0,1);					/* Ztlm=0*/
-	cio_write(cio,80,1);					/* Stlm ST=1(8bits-255 tiles max),SP=1(Ptlm=32bits) */
-	cio_skip(cio,5*j2k->totnum_tp);
-}
-
-static void j2k_write_sot(opj_j2k_t *j2k) {
-	int lenp, len;
-
-	opj_cio_t *cio = j2k->cio;
-
-	j2k->sot_start = cio_tell(cio);
-	cio_write(cio, J2K_MS_SOT, 2);		/* SOT */
-	lenp = cio_tell(cio);
-	cio_skip(cio, 2);					/* Lsot (further) */
-	cio_write(cio, j2k->curtileno, 2);	/* Isot */
-	cio_skip(cio, 4);					/* Psot (further in j2k_write_sod) */
-	cio_write(cio, j2k->cur_tp_num , 1);	/* TPsot */
-	cio_write(cio, j2k->cur_totnum_tp[j2k->curtileno], 1);		/* TNsot */
-	len = cio_tell(cio) - lenp;
-	cio_seek(cio, lenp);
-	cio_write(cio, len, 2);				/* Lsot */
-	cio_seek(cio, lenp + len);
-
-	/* UniPG>> */
-#ifdef USE_JPWL
-	/* update markers struct */
-	j2k_add_marker(j2k->cstr_info, J2K_MS_SOT, j2k->sot_start, len + 2);
-#endif /* USE_JPWL */
-	/* <<UniPG */
+        if (! opj_j2k_exec (p_j2k, p_j2k->m_procedure_list, p_stream, p_manager))
+        {
+                return OPJ_FALSE;
+        }
 
-	if( j2k->cstr_info && j2k->cur_tp_num==0){
-	  j2k_add_tlmarker( j2k->curtileno, j2k->cstr_info, J2K_MS_SOT, lenp, len);
-	}
+        return OPJ_TRUE;
 }
 
-static void j2k_read_sot(opj_j2k_t *j2k) {
-	int len, tileno, totlen, partno, numparts, i;
-	opj_tcp_t *tcp = NULL;
-	char status = 0;
+OPJ_BOOL opj_j2k_start_compress(opj_j2k_t *p_j2k,
+                                                            opj_stream_private_t *p_stream,
+                                                            opj_image_t * p_image,
+                                                            opj_event_mgr_t * p_manager)
+{
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_stream != 00);
+        assert(p_manager != 00);
+
+        p_j2k->m_private_image = opj_image_create0();
+        opj_copy_image_header(p_image, p_j2k->m_private_image);
+
+        /* TODO_MSD: Find a better way */
+        if (p_image->comps) {
+                OPJ_UINT32 it_comp;
+                for (it_comp = 0 ; it_comp < p_image->numcomps; it_comp++) {
+                        if (p_image->comps[it_comp].data) {
+                                p_j2k->m_private_image->comps[it_comp].data =p_image->comps[it_comp].data;
+                                p_image->comps[it_comp].data = NULL;
+
+                        }
+                }
+        }
 
-	opj_cp_t *cp = j2k->cp;
-	opj_cio_t *cio = j2k->cio;
+        /* customization of the validation */
+        opj_j2k_setup_encoding_validation (p_j2k);
 
-	len = cio_read(cio, 2);
-  (void)len;
-	tileno = cio_read(cio, 2);
+        /* validation of the parameters codec */
+        if (! opj_j2k_exec(p_j2k,p_j2k->m_validation_list,p_stream,p_manager)) {
+                return OPJ_FALSE;
+        }
 
-#ifdef USE_JPWL
-	if (j2k->cp->correct) {
-
-		static int backup_tileno = 0;
-
-		/* tileno is negative or larger than the number of tiles!!! */
-		if ((tileno < 0) || (tileno >= (cp->tw * cp->th))) {
-			opj_event_msg(j2k->cinfo, EVT_ERROR,
-				"JPWL: bad tile number (%d out of a maximum of %d)\n",
-				tileno, (cp->tw * cp->th));
-			if (!JPWL_ASSUME) {
-				opj_event_msg(j2k->cinfo, EVT_ERROR, "JPWL: giving up\n");
-				return;
-			}
-			/* we try to correct */
-			tileno = backup_tileno;
-			opj_event_msg(j2k->cinfo, EVT_WARNING, "- trying to adjust this\n"
-				"- setting tile number to %d\n",
-				tileno);
-		}
+        /* customization of the encoding */
+        opj_j2k_setup_header_writing(p_j2k);
 
-		/* keep your private count of tiles */
-		backup_tileno++;
-	}
-  else
-#endif /* USE_JPWL */
-  {
-    /* tileno is negative or larger than the number of tiles!!! */
-    if ((tileno < 0) || (tileno >= (cp->tw * cp->th))) {
-      opj_event_msg(j2k->cinfo, EVT_ERROR,
-        "JPWL: bad tile number (%d out of a maximum of %d)\n",
-        tileno, (cp->tw * cp->th));
-      return;
-    }
-  }
-	
-	if (cp->tileno_size == 0) {
-		cp->tileno[cp->tileno_size] = tileno;
-		cp->tileno_size++;
-	} else {
-		i = 0;
-		while (i < cp->tileno_size && status == 0) {
-			status = cp->tileno[i] == tileno ? 1 : 0;
-			i++;
-		}
-		if (status == 0) {
-			cp->tileno[cp->tileno_size] = tileno;
-			cp->tileno_size++;
-		}
-	}
-	
-	totlen = cio_read(cio, 4);
+        /* write header */
+        if (! opj_j2k_exec (p_j2k,p_j2k->m_procedure_list,p_stream,p_manager)) {
+                return OPJ_FALSE;
+        }
 
-#ifdef USE_JPWL
-	if (j2k->cp->correct) {
-
-		/* totlen is negative or larger than the bytes left!!! */
-		if ((totlen < 0) || (totlen > (cio_numbytesleft(cio) + 8))) {
-			opj_event_msg(j2k->cinfo, EVT_ERROR,
-				"JPWL: bad tile byte size (%d bytes against %d bytes left)\n",
-				totlen, cio_numbytesleft(cio) + 8);
-			if (!JPWL_ASSUME) {
-				opj_event_msg(j2k->cinfo, EVT_ERROR, "JPWL: giving up\n");
-				return;
-			}
-			/* we try to correct */
-			totlen = 0;
-			opj_event_msg(j2k->cinfo, EVT_WARNING, "- trying to adjust this\n"
-				"- setting Psot to %d => assuming it is the last tile\n",
-				totlen);
-		}
+        return OPJ_TRUE;
+}
 
-	}
-  else
-#endif /* USE_JPWL */
-  {
-    /* totlen is negative or larger than the bytes left!!! */
-    if ((totlen < 0) || (totlen > (cio_numbytesleft(cio) + 8))) {
-      opj_event_msg(j2k->cinfo, EVT_ERROR,
-        "JPWL: bad tile byte size (%d bytes against %d bytes left)\n",
-        totlen, cio_numbytesleft(cio) + 8);
-      return;
-    }
-  }
-
-	if (!totlen)
-		totlen = cio_numbytesleft(cio) + 8;
-	
-	partno = cio_read(cio, 1);
-	numparts = cio_read(cio, 1);
-  
-  if (partno >= numparts) {
-    opj_event_msg(j2k->cinfo, EVT_WARNING, "SOT marker inconsistency in tile %d: tile-part index greater (%d) than number of tile-parts (%d)\n", tileno, partno, numparts);
-    numparts = partno+1;
-  }
-	
-	j2k->curtileno = tileno;
-	j2k->cur_tp_num = partno;
-	j2k->eot = cio_getbp(cio) - 12 + totlen;
-	j2k->state = J2K_STATE_TPH;
-	tcp = &cp->tcps[j2k->curtileno];
-
-	/* Index */
-	if (j2k->cstr_info) {
-		if (tcp->first) {
-			if (tileno == 0) 
-				j2k->cstr_info->main_head_end = cio_tell(cio) - 13;
-			j2k->cstr_info->tile[tileno].tileno = tileno;
-			j2k->cstr_info->tile[tileno].start_pos = cio_tell(cio) - 12;
-			j2k->cstr_info->tile[tileno].end_pos = j2k->cstr_info->tile[tileno].start_pos + totlen - 1;				
-    } else {
-			j2k->cstr_info->tile[tileno].end_pos += totlen;
-		}
-    j2k->cstr_info->tile[tileno].num_tps = numparts;
-    if (numparts)
-      j2k->cstr_info->tile[tileno].tp = (opj_tp_info_t *) opj_realloc(j2k->cstr_info->tile[tileno].tp, numparts * sizeof(opj_tp_info_t));
-    else
-      j2k->cstr_info->tile[tileno].tp = (opj_tp_info_t *) opj_realloc(j2k->cstr_info->tile[tileno].tp, 10 * sizeof(opj_tp_info_t)); /* Fixme (10)*/
-		j2k->cstr_info->tile[tileno].tp[partno].tp_start_pos = cio_tell(cio) - 12;
-		j2k->cstr_info->tile[tileno].tp[partno].tp_end_pos = 
-			j2k->cstr_info->tile[tileno].tp[partno].tp_start_pos + totlen - 1;
-	}
-	
-	if (tcp->first == 1) {		
-		/* Initialization PPT */
-		opj_tccp_t *tmp = tcp->tccps;
-		memcpy(tcp, j2k->default_tcp, sizeof(opj_tcp_t));
-		tcp->ppt = 0;
-		tcp->ppt_data = NULL;
-		tcp->ppt_data_first = NULL;
-		tcp->tccps = tmp;
-
-		for (i = 0; i < j2k->image->numcomps; i++) {
-			tcp->tccps[i] = j2k->default_tcp->tccps[i];
-		}
-		cp->tcps[j2k->curtileno].first = 0;
-	}
-}
-
-static void j2k_write_sod(opj_j2k_t *j2k, void *tile_coder) {
-	int l, layno;
-	int totlen;
-	opj_tcp_t *tcp = NULL;
-	opj_codestream_info_t *cstr_info = NULL;
-	
-	opj_tcd_t *tcd = (opj_tcd_t*)tile_coder;	/* cast is needed because of conflicts in header inclusions */
-	opj_cp_t *cp = j2k->cp;
-	opj_cio_t *cio = j2k->cio;
-
-	tcd->tp_num = j2k->tp_num ;
-	tcd->cur_tp_num = j2k->cur_tp_num;
-	
-	cio_write(cio, J2K_MS_SOD, 2);
-
-	if( j2k->cstr_info && j2k->cur_tp_num==0){
-	  j2k_add_tlmarker( j2k->curtileno, j2k->cstr_info, J2K_MS_SOD, cio_tell(cio), 0);
-	}
-
-	if (j2k->curtileno == 0) {
-		j2k->sod_start = cio_tell(cio) + j2k->pos_correction;
-	}
-
-	/* INDEX >> */
-	cstr_info = j2k->cstr_info;
-	if (cstr_info) {
-		if (!j2k->cur_tp_num ) {
-			cstr_info->tile[j2k->curtileno].end_header = cio_tell(cio) + j2k->pos_correction - 1;
-			j2k->cstr_info->tile[j2k->curtileno].tileno = j2k->curtileno;
-		}
-		else{
-			if(cstr_info->tile[j2k->curtileno].packet[cstr_info->packno - 1].end_pos < cio_tell(cio))
-				cstr_info->tile[j2k->curtileno].packet[cstr_info->packno].start_pos = cio_tell(cio);
-		}
-		/* UniPG>> */
-#ifdef USE_JPWL
-		/* update markers struct */
-		j2k_add_marker(j2k->cstr_info, J2K_MS_SOD, j2k->sod_start, 2);
-#endif /* USE_JPWL */
-		/* <<UniPG */
-	}
-	/* << INDEX */
-	
-	tcp = &cp->tcps[j2k->curtileno];
-	for (layno = 0; layno < tcp->numlayers; layno++) {
-		if (tcp->rates[layno]>(j2k->sod_start / (cp->th * cp->tw))) {
-			tcp->rates[layno]-=(j2k->sod_start / (cp->th * cp->tw));
-		} else if (tcp->rates[layno]) {
-			tcp->rates[layno]=1;
-		}
-	}
-	if(j2k->cur_tp_num == 0){
-		tcd->tcd_image->tiles->packno = 0;
-		if(cstr_info)
-			cstr_info->packno = 0;
-	}
-	
-	l = tcd_encode_tile(tcd, j2k->curtileno, cio_getbp(cio), cio_numbytesleft(cio) - 2, cstr_info);
-	
-	/* Writing Psot in SOT marker */
-	totlen = cio_tell(cio) + l - j2k->sot_start;
-	cio_seek(cio, j2k->sot_start + 6);
-	cio_write(cio, totlen, 4);
-	cio_seek(cio, j2k->sot_start + totlen);
-	/* Writing Ttlm and Ptlm in TLM marker */
-	if(cp->cinema){
-		cio_seek(cio, j2k->tlm_start + 6 + (5*j2k->cur_tp_num));
-		cio_write(cio, j2k->curtileno, 1);
-		cio_write(cio, totlen, 4);
-	}
-	cio_seek(cio, j2k->sot_start + totlen);
-}
-
-static void j2k_read_sod(opj_j2k_t *j2k) {
-	int len, truncate = 0, i;
-	unsigned char *data = NULL, *data_ptr = NULL;
-
-	opj_cio_t *cio = j2k->cio;
-	int curtileno = j2k->curtileno;
-
-	/* Index */
-	if (j2k->cstr_info) {
-		j2k->cstr_info->tile[j2k->curtileno].tp[j2k->cur_tp_num].tp_end_header =
-			cio_tell(cio) + j2k->pos_correction - 1;
-		if (j2k->cur_tp_num == 0)
-			j2k->cstr_info->tile[j2k->curtileno].end_header = cio_tell(cio) + j2k->pos_correction - 1;
-		j2k->cstr_info->packno = 0;
-	}
-	
-	len = int_min(j2k->eot - cio_getbp(cio), cio_numbytesleft(cio) + 1);
-
-	if (len == cio_numbytesleft(cio) + 1) {
-		truncate = 1;		/* Case of a truncate codestream */
-	}	
-
-	data = j2k->tile_data[curtileno];
-  data_ptr = data; /* store in case of failure */
-	data = (unsigned char*) opj_realloc(data, (j2k->tile_len[curtileno] + len) * sizeof(unsigned char));
-  if( data == NULL ) {
-    opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not reallocated\n" );
-    opj_free( data_ptr );
-    return;
-    }
+OPJ_BOOL opj_j2k_pre_write_tile (       opj_j2k_t * p_j2k,
+                                                                OPJ_UINT32 p_tile_index,
+                                                                opj_stream_private_t *p_stream,
+                                                                opj_event_mgr_t * p_manager )
+{
+  (void)p_stream;
+        if (p_tile_index != p_j2k->m_current_tile_number) {
+                opj_event_msg(p_manager, EVT_ERROR, "The given tile index does not match." );
+                return OPJ_FALSE;
+        }
 
-	data_ptr = data + j2k->tile_len[curtileno];
-	for (i = 0; i < len; i++) {
-		data_ptr[i] = cio_read(cio, 1);
-	}
-
-	j2k->tile_len[curtileno] += len;
-	j2k->tile_data[curtileno] = data;
-	
-	if (!truncate) {
-		j2k->state = J2K_STATE_TPHSOT;
-	} else {
-		j2k->state = J2K_STATE_NEOC;	/* RAJOUTE !! */
-	}
-	j2k->cur_tp_num++;
-}
-
-static void j2k_write_rgn(opj_j2k_t *j2k, int compno, int tileno) {
-	opj_cp_t *cp = j2k->cp;
-	opj_tcp_t *tcp = &cp->tcps[tileno];
-	opj_cio_t *cio = j2k->cio;
-	int numcomps = j2k->image->numcomps;
-	
-	cio_write(cio, J2K_MS_RGN, 2);						/* RGN  */
-	cio_write(cio, numcomps <= 256 ? 5 : 6, 2);			/* Lrgn */
-	cio_write(cio, compno, numcomps <= 256 ? 1 : 2);	/* Crgn */
-	cio_write(cio, 0, 1);								/* Srgn */
-	cio_write(cio, tcp->tccps[compno].roishift, 1);		/* SPrgn */
-}
-
-static void j2k_read_rgn(opj_j2k_t *j2k) {
-	int len, compno, roisty;
-
-	opj_cp_t *cp = j2k->cp;
-	opj_tcp_t *tcp = j2k->state == J2K_STATE_TPH ? &cp->tcps[j2k->curtileno] : j2k->default_tcp;
-	opj_cio_t *cio = j2k->cio;
-	int numcomps = j2k->image->numcomps;
-
-	len = cio_read(cio, 2);										/* Lrgn */
-  (void)len;
-	compno = cio_read(cio, numcomps <= 256 ? 1 : 2);			/* Crgn */
-	roisty = cio_read(cio, 1);									/* Srgn */
-  (void)roisty;
+        opj_event_msg(p_manager, EVT_INFO, "tile number %d / %d\n", p_j2k->m_current_tile_number + 1, p_j2k->m_cp.tw * p_j2k->m_cp.th);
 
-#ifdef USE_JPWL
-	if (j2k->cp->correct) {
-		/* totlen is negative or larger than the bytes left!!! */
-		if (compno >= numcomps) {
-			opj_event_msg(j2k->cinfo, EVT_ERROR,
-				"JPWL: bad component number in RGN (%d when there are only %d)\n",
-				compno, numcomps);
-			if (!JPWL_ASSUME || JPWL_ASSUME) {
-				opj_event_msg(j2k->cinfo, EVT_ERROR, "JPWL: giving up\n");
-				return;
-			}
-		}
-	};
-#endif /* USE_JPWL */
+        p_j2k->m_specific_param.m_encoder.m_current_tile_part_number = 0;
+        p_j2k->m_tcd->cur_totnum_tp = p_j2k->m_cp.tcps[p_tile_index].m_nb_tile_parts;
+        p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = 0;
 
-  if (compno >= numcomps) {
-    opj_event_msg(j2k->cinfo, EVT_ERROR,
-      "bad component number in RGN (%d out of a maximum of %d)\n",
-      compno, j2k->image->numcomps);
-    return;
-  }
+        /* initialisation before tile encoding  */
+        if (! opj_tcd_init_encode_tile(p_j2k->m_tcd, p_j2k->m_current_tile_number)) {
+                return OPJ_FALSE;
+        }
 
-	tcp->tccps[compno].roishift = cio_read(cio, 1);				/* SPrgn */
+        return OPJ_TRUE;
 }
 
-static void j2k_write_eoc(opj_j2k_t *j2k) {
-	opj_cio_t *cio = j2k->cio;
-	/* opj_event_msg(j2k->cinfo, "%.8x: EOC\n", cio_tell(cio) + j2k->pos_correction); */
-	cio_write(cio, J2K_MS_EOC, 2);
-
-/* UniPG>> */
-#ifdef USE_JPWL
-	/* update markers struct */
-	j2k_add_marker(j2k->cstr_info, J2K_MS_EOC, cio_tell(cio) - 2, 2);
-#endif /* USE_JPWL */
-/* <<UniPG */
+void opj_j2k_get_tile_data (opj_tcd_t * p_tcd, OPJ_BYTE * p_data)
+{
+        OPJ_UINT32 i,j,k = 0;
+        OPJ_UINT32 l_width,l_height,l_stride, l_offset_x,l_offset_y, l_image_width;
+        opj_image_comp_t * l_img_comp = 00;
+        opj_tcd_tilecomp_t * l_tilec = 00;
+        opj_image_t * l_image = 00;
+        OPJ_UINT32 l_size_comp, l_remaining;
+        OPJ_INT32 * l_src_ptr;
+        l_tilec = p_tcd->tcd_image->tiles->comps;
+        l_image = p_tcd->image;
+        l_img_comp = l_image->comps;
+
+        for (i=0;i<p_tcd->image->numcomps;++i) {
+                l_size_comp = l_img_comp->prec >> 3; /* (/8) */
+                l_remaining = l_img_comp->prec & 7;  /* (%8) */
+                if (l_remaining) {
+                        ++l_size_comp;
+                }
+
+                if (l_size_comp == 3) {
+                        l_size_comp = 4;
+                }
+
+                l_width  = (OPJ_UINT32)(l_tilec->x1 - l_tilec->x0);
+                l_height = (OPJ_UINT32)(l_tilec->y1 - l_tilec->y0);
+                l_offset_x = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)l_image->x0, (OPJ_INT32)l_img_comp->dx);
+                l_offset_y = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)l_image->y0, (OPJ_INT32)l_img_comp->dy);
+                l_image_width = (OPJ_UINT32)opj_int_ceildiv((OPJ_INT32)l_image->x1 - (OPJ_INT32)l_image->x0, (OPJ_INT32)l_img_comp->dx);
+                l_stride = l_image_width - l_width;
+                l_src_ptr = l_img_comp->data + ((OPJ_UINT32)l_tilec->x0 - l_offset_x) + ((OPJ_UINT32)l_tilec->y0 - l_offset_y) * l_image_width;
+
+                switch (l_size_comp) {
+                        case 1:
+                                {
+                                        OPJ_CHAR * l_dest_ptr = (OPJ_CHAR*) p_data;
+                                        if (l_img_comp->sgnd) {
+                                                for     (j=0;j<l_height;++j) {
+                                                        for (k=0;k<l_width;++k) {
+                                                                *(l_dest_ptr) = (OPJ_CHAR) (*l_src_ptr);
+                                                                ++l_dest_ptr;
+                                                                ++l_src_ptr;
+                                                        }
+                                                        l_src_ptr += l_stride;
+                                                }
+                                        }
+                                        else {
+                                                for (j=0;j<l_height;++j) {
+                                                        for (k=0;k<l_width;++k) {
+                                                                *(l_dest_ptr) = (OPJ_CHAR)((*l_src_ptr)&0xff);
+                                                                ++l_dest_ptr;
+                                                                ++l_src_ptr;
+                                                        }
+                                                        l_src_ptr += l_stride;
+                                                }
+                                        }
+
+                                        p_data = (OPJ_BYTE*) l_dest_ptr;
+                                }
+                                break;
+                        case 2:
+                                {
+                                        OPJ_INT16 * l_dest_ptr = (OPJ_INT16 *) p_data;
+                                        if (l_img_comp->sgnd) {
+                                                for (j=0;j<l_height;++j) {
+                                                        for (k=0;k<l_width;++k) {
+                                                                *(l_dest_ptr++) = (OPJ_INT16) (*(l_src_ptr++));
+                                                        }
+                                                        l_src_ptr += l_stride;
+                                                }
+                                        }
+                                        else {
+                                                for (j=0;j<l_height;++j) {
+                                                        for (k=0;k<l_width;++k) {
+                                                                *(l_dest_ptr++) = (OPJ_INT16)((*(l_src_ptr++)) & 0xffff);
+                                                        }
+                                                        l_src_ptr += l_stride;
+                                                }
+                                        }
+
+                                        p_data = (OPJ_BYTE*) l_dest_ptr;
+                                }
+                                break;
+                        case 4:
+                                {
+                                        OPJ_INT32 * l_dest_ptr = (OPJ_INT32 *) p_data;
+                                        for (j=0;j<l_height;++j) {
+                                                for (k=0;k<l_width;++k) {
+                                                        *(l_dest_ptr++) = *(l_src_ptr++);
+                                                }
+                                                l_src_ptr += l_stride;
+                                        }
+
+                                        p_data = (OPJ_BYTE*) l_dest_ptr;
+                                }
+                                break;
+                }
+
+                ++l_img_comp;
+                ++l_tilec;
+        }
 }
 
-static void j2k_read_eoc(opj_j2k_t *j2k) {
-	int i, tileno;
-	opj_bool success = OPJ_FALSE;
-
-	/* if packets should be decoded */
-	if (j2k->cp->limit_decoding != DECODE_ALL_BUT_PACKETS) {
-		opj_tcd_t *tcd = tcd_create(j2k->cinfo);
-		tcd_malloc_decode(tcd, j2k->image, j2k->cp);
-		for (i = 0; i < j2k->cp->tileno_size; i++) {
-			tcd_malloc_decode_tile(tcd, j2k->image, j2k->cp, i, j2k->cstr_info);
-			if (j2k->cp->tileno[i] != -1)
-			{
-				tileno = j2k->cp->tileno[i];
-				success = tcd_decode_tile(tcd, j2k->tile_data[tileno], j2k->tile_len[tileno], tileno, j2k->cstr_info);
-        assert( tileno != -1 );
-				opj_free(j2k->tile_data[tileno]);
-				j2k->tile_data[tileno] = NULL;
-				tcd_free_decode_tile(tcd, i);
-			}
-			else
-				success = OPJ_FALSE;
-			if (success == OPJ_FALSE) {
-				j2k->state |= J2K_STATE_ERR;
-				break;
-			}
-		}
-		tcd_free_decode(tcd);
-		tcd_destroy(tcd);
-	}
-	/* if packets should not be decoded  */
-	else {
-		for (i = 0; i < j2k->cp->tileno_size; i++) {
-			tileno = j2k->cp->tileno[i];
-			opj_free(j2k->tile_data[tileno]);
-			j2k->tile_data[tileno] = NULL;
-		}
-	}	
-	if (j2k->state & J2K_STATE_ERR)
-		j2k->state = J2K_STATE_MT + J2K_STATE_ERR;
-	else
-		j2k->state = J2K_STATE_MT; 
-}
-
-typedef struct opj_dec_mstabent {
-	/** marker value */
-	int id;
-	/** value of the state when the marker can appear */
-	int states;
-	/** action linked to the marker */
-	void (*handler) (opj_j2k_t *j2k);
-} opj_dec_mstabent_t;
-
-opj_dec_mstabent_t j2k_dec_mstab[] = {
-  {J2K_MS_SOC, J2K_STATE_MHSOC, j2k_read_soc},
-  {J2K_MS_SOT, J2K_STATE_MH | J2K_STATE_TPHSOT, j2k_read_sot},
-  {J2K_MS_SOD, J2K_STATE_TPH, j2k_read_sod},
-  {J2K_MS_EOC, J2K_STATE_TPHSOT, j2k_read_eoc},
-  {J2K_MS_SIZ, J2K_STATE_MHSIZ, j2k_read_siz},
-  {J2K_MS_COD, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_cod},
-  {J2K_MS_COC, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_coc},
-  {J2K_MS_RGN, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_rgn},
-  {J2K_MS_QCD, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_qcd},
-  {J2K_MS_QCC, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_qcc},
-  {J2K_MS_POC, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_poc},
-  {J2K_MS_TLM, J2K_STATE_MH, j2k_read_tlm},
-  {J2K_MS_PLM, J2K_STATE_MH, j2k_read_plm},
-  {J2K_MS_PLT, J2K_STATE_TPH, j2k_read_plt},
-  {J2K_MS_PPM, J2K_STATE_MH, j2k_read_ppm},
-  {J2K_MS_PPT, J2K_STATE_TPH, j2k_read_ppt},
-  {J2K_MS_SOP, 0, 0},
-  {J2K_MS_CRG, J2K_STATE_MH, j2k_read_crg},
-  {J2K_MS_COM, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_com},
+OPJ_BOOL opj_j2k_post_write_tile (      opj_j2k_t * p_j2k,
+                                                                OPJ_BYTE * p_data,
+                                                                OPJ_UINT32 p_data_size,
+                                                                opj_stream_private_t *p_stream,
+                                                                opj_event_mgr_t * p_manager )
+{
+        opj_tcd_t * l_tcd = 00;
+        OPJ_UINT32 l_nb_bytes_written;
+        OPJ_BYTE * l_current_data = 00;
+        OPJ_UINT32 l_tile_size = 0;
+        OPJ_UINT32 l_available_data;
+
+        /* preconditions */
+        assert(p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);
+
+        l_tcd = p_j2k->m_tcd;
+        
+        l_tile_size = p_j2k->m_specific_param.m_encoder.m_encoded_tile_size;
+        l_available_data = l_tile_size;
+        l_current_data = p_j2k->m_specific_param.m_encoder.m_encoded_tile_data;
+
+        if (! opj_tcd_copy_tile_data(l_tcd,p_data,p_data_size)) {
+                opj_event_msg(p_manager, EVT_ERROR, "Size mismatch between tile data and sent data." );
+                return OPJ_FALSE;
+        }
 
-#ifdef USE_JPWL
-  {J2K_MS_EPC, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_epc},
-  {J2K_MS_EPB, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_epb},
-  {J2K_MS_ESD, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_esd},
-  {J2K_MS_RED, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_red},
-#endif /* USE_JPWL */
-#ifdef USE_JPSEC
-  {J2K_MS_SEC, J2K_STATE_MH, j2k_read_sec},
-  {J2K_MS_INSEC, 0, j2k_read_insec},
-#endif /* USE_JPSEC */
+        l_nb_bytes_written = 0;
+        if (! opj_j2k_write_first_tile_part(p_j2k,l_current_data,&l_nb_bytes_written,l_available_data,p_stream,p_manager)) {
+                return OPJ_FALSE;
+        }
+        l_current_data += l_nb_bytes_written;
+        l_available_data -= l_nb_bytes_written;
 
-  {0, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_unk}
-};
+        l_nb_bytes_written = 0;
+        if (! opj_j2k_write_all_tile_parts(p_j2k,l_current_data,&l_nb_bytes_written,l_available_data,p_stream,p_manager)) {
+                return OPJ_FALSE;
+        }
 
-static void j2k_read_unk(opj_j2k_t *j2k) {
-	opj_event_msg(j2k->cinfo, EVT_WARNING, "Unknown marker\n");
+        l_available_data -= l_nb_bytes_written;
+        l_nb_bytes_written = l_tile_size - l_available_data;
 
-#ifdef USE_JPWL
-	if (j2k->cp->correct) {
-		int m = 0, id, i;
-		int min_id = 0, min_dist = 17, cur_dist = 0, tmp_id;
-		cio_seek(j2k->cio, cio_tell(j2k->cio) - 2);
-		id = cio_read(j2k->cio, 2);
-		opj_event_msg(j2k->cinfo, EVT_ERROR,
-			"JPWL: really don't know this marker %x\n",
-			id);
-		if (!JPWL_ASSUME) {
-			opj_event_msg(j2k->cinfo, EVT_ERROR,
-				"- possible synch loss due to uncorrectable codestream errors => giving up\n");
-			return;
-		}
-		/* OK, activate this at your own risk!!! */
-		/* we look for the marker at the minimum hamming distance from this */
-		while (j2k_dec_mstab[m].id) {
-			
-			/* 1's where they differ */
-			tmp_id = j2k_dec_mstab[m].id ^ id;
-
-			/* compute the hamming distance between our id and the current */
-			cur_dist = 0;
-			for (i = 0; i < 16; i++) {
-				if ((tmp_id >> i) & 0x0001) {
-					cur_dist++;
-				}
-			}
-
-			/* if current distance is smaller, set the minimum */
-			if (cur_dist < min_dist) {
-				min_dist = cur_dist;
-				min_id = j2k_dec_mstab[m].id;
-			}
-			
-			/* jump to the next marker */
-			m++;
-		}
+        if ( opj_stream_write_data(     p_stream,
+                                                                p_j2k->m_specific_param.m_encoder.m_encoded_tile_data,
+                                                                l_nb_bytes_written,p_manager) != l_nb_bytes_written) {
+                return OPJ_FALSE;
+        }
 
-		/* do we substitute the marker? */
-		if (min_dist < JPWL_MAXIMUM_HAMMING) {
-			opj_event_msg(j2k->cinfo, EVT_ERROR,
-				"- marker %x is at distance %d from the read %x\n",
-				min_id, min_dist, id);
-			opj_event_msg(j2k->cinfo, EVT_ERROR,
-				"- trying to substitute in place and crossing fingers!\n");
-			cio_seek(j2k->cio, cio_tell(j2k->cio) - 2);
-			cio_write(j2k->cio, min_id, 2);
+        ++p_j2k->m_current_tile_number;
 
-			/* rewind */
-			cio_seek(j2k->cio, cio_tell(j2k->cio) - 2);
+        return OPJ_TRUE;
+}
 
-		}
+void opj_j2k_setup_end_compress (opj_j2k_t *p_j2k)
+{
+        /* preconditions */
+        assert(p_j2k != 00);
 
-	};
-#endif /* USE_JPWL */
+        /* DEVELOPER CORNER, insert your custom procedures */
+        opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_eoc );
 
-}
+        if (OPJ_IS_CINEMA(p_j2k->m_cp.rsiz)) {
+                opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_updated_tlm);
+        }
 
-/**
-Read the lookup table containing all the marker, status and action
-@param id Marker value
-*/
-static opj_dec_mstabent_t *j2k_dec_mstab_lookup(int id) {
-	opj_dec_mstabent_t *e;
-	for (e = j2k_dec_mstab; e->id != 0; e++) {
-		if (e->id == id) {
-			break;
-		}
-	}
-	return e;
+        opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_epc );
+        opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_end_encoding );
+        opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_destroy_header_memory);
 }
 
-/* ----------------------------------------------------------------------- */
-/* J2K / JPT decoder interface                                             */
-/* ----------------------------------------------------------------------- */
+void opj_j2k_setup_encoding_validation (opj_j2k_t *p_j2k)
+{
+        /* preconditions */
+        assert(p_j2k != 00);
 
-opj_j2k_t* j2k_create_decompress(opj_common_ptr cinfo) {
-	opj_j2k_t *j2k = (opj_j2k_t*) opj_calloc(1, sizeof(opj_j2k_t));
-	if(!j2k)
-		return NULL;
+        opj_procedure_list_add_procedure(p_j2k->m_validation_list, (opj_procedure)opj_j2k_build_encoder);
+        opj_procedure_list_add_procedure(p_j2k->m_validation_list, (opj_procedure)opj_j2k_encoding_validation);
 
-	j2k->default_tcp = (opj_tcp_t*) opj_calloc(1, sizeof(opj_tcp_t));
-	if(!j2k->default_tcp) {
-		opj_free(j2k);
-		return NULL;
-	}
+        /* DEVELOPER CORNER, add your custom validation procedure */
+        opj_procedure_list_add_procedure(p_j2k->m_validation_list, (opj_procedure)opj_j2k_mct_validation);
+}
 
-	j2k->cinfo = cinfo;
-	j2k->tile_data = NULL;
+void opj_j2k_setup_header_writing (opj_j2k_t *p_j2k)
+{
+        /* preconditions */
+        assert(p_j2k != 00);
+
+        opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_init_info );
+        opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_soc );
+        opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_siz );
+        opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_cod );
+        opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_qcd );
+
+        if (OPJ_IS_CINEMA(p_j2k->m_cp.rsiz)) {
+                /* No need for COC or QCC, QCD and COD are used
+                opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_all_coc );
+                opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_all_qcc );
+                */
+                opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_tlm );
+
+                if (p_j2k->m_cp.rsiz == OPJ_PROFILE_CINEMA_4K) {
+                        opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_poc );
+                }
+        }
 
-	return j2k;
-}
+        opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_regions);
 
-void j2k_destroy_decompress(opj_j2k_t *j2k) {
-	int i = 0;
+        if (p_j2k->m_cp.comment != 00)  {
+                opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_com);
+        }
 
-	if(j2k->tile_len != NULL) {
-		opj_free(j2k->tile_len);
-	}
-	if(j2k->tile_data != NULL) {
-        if(j2k->cp != NULL) {
-            for (i = 0; i < j2k->cp->tileno_size; i++) {
-                int tileno = j2k->cp->tileno[i];
-                if( tileno != -1 )
-                  {
-                  opj_free(j2k->tile_data[tileno]);
-                  j2k->tile_data[tileno] = NULL;
-                  }
-            }
+        /* DEVELOPER CORNER, insert your custom procedures */
+        if (p_j2k->m_cp.rsiz & OPJ_EXTENSION_MCT) {
+                opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_write_mct_data_group );
         }
+        /* End of Developer Corner */
 
-		opj_free(j2k->tile_data);
-	}
-	if(j2k->default_tcp != NULL) {
-		opj_tcp_t *default_tcp = j2k->default_tcp;
-		if(default_tcp->ppt_data_first != NULL) {
-			opj_free(default_tcp->ppt_data_first);
-		}
-		if(j2k->default_tcp->tccps != NULL) {
-			opj_free(j2k->default_tcp->tccps);
-		}
-		opj_free(j2k->default_tcp);
-	}
-	if(j2k->cp != NULL) {
-		opj_cp_t *cp = j2k->cp;
-		if(cp->tcps != NULL) {
-			for(i = 0; i < cp->tw * cp->th; i++) {
-				if(cp->tcps[i].ppt_data_first != NULL) {
-					opj_free(cp->tcps[i].ppt_data_first);
-				}
-				if(cp->tcps[i].tccps != NULL) {
-					opj_free(cp->tcps[i].tccps);
-				}
-			}
-			opj_free(cp->tcps);
-		}
-		if(cp->ppm_data_first != NULL) {
-			opj_free(cp->ppm_data_first);
-		}
-		if(cp->tileno != NULL) {
-			opj_free(cp->tileno);  
-		}
-		if(cp->comment != NULL) {
-			opj_free(cp->comment);
-		}
+        if (p_j2k->cstr_index) {
+                opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_get_end_header );
+        }
 
-		opj_free(cp);
-	}
-	opj_free(j2k);
+        opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_create_tcd);
+        opj_procedure_list_add_procedure(p_j2k->m_procedure_list,(opj_procedure)opj_j2k_update_rates);
 }
 
-void j2k_setup_decoder(opj_j2k_t *j2k, opj_dparameters_t *parameters) {
-	if(j2k && parameters) {
-		/* create and initialize the coding parameters structure */
-		opj_cp_t *cp = (opj_cp_t*) opj_calloc(1, sizeof(opj_cp_t));
-		cp->reduce = parameters->cp_reduce;	
-		cp->layer = parameters->cp_layer;
-		cp->limit_decoding = parameters->cp_limit_decoding;
+OPJ_BOOL opj_j2k_write_first_tile_part (opj_j2k_t *p_j2k,
+                                                                        OPJ_BYTE * p_data,
+                                                                        OPJ_UINT32 * p_data_written,
+                                                                        OPJ_UINT32 p_total_data_size,
+                                                                        opj_stream_private_t *p_stream,
+                                                                        struct opj_event_mgr * p_manager )
+{
+        OPJ_UINT32 l_nb_bytes_written = 0;
+        OPJ_UINT32 l_current_nb_bytes_written;
+        OPJ_BYTE * l_begin_data = 00;
 
-#ifdef USE_JPWL
-		cp->correct = parameters->jpwl_correct;
-		cp->exp_comps = parameters->jpwl_exp_comps;
-		cp->max_tiles = parameters->jpwl_max_tiles;
-#endif /* USE_JPWL */
+        opj_tcd_t * l_tcd = 00;
+        opj_cp_t * l_cp = 00;
 
+        l_tcd = p_j2k->m_tcd;
+        l_cp = &(p_j2k->m_cp);
 
-		/* keep a link to cp so that we can destroy it later in j2k_destroy_decompress */
-		j2k->cp = cp;
-	}
-}
+        l_tcd->cur_pino = 0;
 
-opj_image_t* j2k_decode(opj_j2k_t *j2k, opj_cio_t *cio, opj_codestream_info_t *cstr_info) {
-	opj_image_t *image = NULL;
+        /*Get number of tile parts*/
+        p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = 0;
 
-	opj_common_ptr cinfo = j2k->cinfo;	
+        /* INDEX >> */
+        /* << INDEX */
 
-	j2k->cio = cio;
-	j2k->cstr_info = cstr_info;
-	if (cstr_info)
-		memset(cstr_info, 0, sizeof(opj_codestream_info_t));
+        l_current_nb_bytes_written = 0;
+        l_begin_data = p_data;
+        if (! opj_j2k_write_sot(p_j2k,p_data,&l_current_nb_bytes_written,p_stream,p_manager))
+        {
+                return OPJ_FALSE;
+        }
 
-	/* create an empty image */
-	image = opj_image_create0();
-	j2k->image = image;
+        l_nb_bytes_written += l_current_nb_bytes_written;
+        p_data += l_current_nb_bytes_written;
+        p_total_data_size -= l_current_nb_bytes_written;
+
+        if (!OPJ_IS_CINEMA(l_cp->rsiz)) {
+#if 0
+                for (compno = 1; compno < p_j2k->m_private_image->numcomps; compno++) {
+                        l_current_nb_bytes_written = 0;
+                        opj_j2k_write_coc_in_memory(p_j2k,compno,p_data,&l_current_nb_bytes_written,p_manager);
+                        l_nb_bytes_written += l_current_nb_bytes_written;
+                        p_data += l_current_nb_bytes_written;
+                        p_total_data_size -= l_current_nb_bytes_written;
+
+                        l_current_nb_bytes_written = 0;
+                        opj_j2k_write_qcc_in_memory(p_j2k,compno,p_data,&l_current_nb_bytes_written,p_manager);
+                        l_nb_bytes_written += l_current_nb_bytes_written;
+                        p_data += l_current_nb_bytes_written;
+                        p_total_data_size -= l_current_nb_bytes_written;
+                }
+#endif
 
-	j2k->state = J2K_STATE_MHSOC;
+                if (l_cp->tcps[p_j2k->m_current_tile_number].numpocs) {
+                        l_current_nb_bytes_written = 0;
+                        opj_j2k_write_poc_in_memory(p_j2k,p_data,&l_current_nb_bytes_written,p_manager);
+                        l_nb_bytes_written += l_current_nb_bytes_written;
+                        p_data += l_current_nb_bytes_written;
+                        p_total_data_size -= l_current_nb_bytes_written;
+                }
+        }
 
-	for (;;) {
-		opj_dec_mstabent_t *e;
-		int id = cio_read(cio, 2);
+        l_current_nb_bytes_written = 0;
+        if (! opj_j2k_write_sod(p_j2k,l_tcd,p_data,&l_current_nb_bytes_written,p_total_data_size,p_stream,p_manager)) {
+                return OPJ_FALSE;
+        }
 
-#ifdef USE_JPWL
-		/* we try to honor JPWL correction power */
-		if (j2k->cp->correct) {
-
-			int orig_pos = cio_tell(cio);
-			opj_bool status;
-
-			/* call the corrector */
-			status = jpwl_correct(j2k);
-
-			/* go back to where you were */
-			cio_seek(cio, orig_pos - 2);
-
-			/* re-read the marker */
-			id = cio_read(cio, 2);
-
-			/* check whether it begins with ff */
-			if (id >> 8 != 0xff) {
-				opj_event_msg(cinfo, EVT_ERROR,
-					"JPWL: possible bad marker %x at %d\n",
-					id, cio_tell(cio) - 2);
-				if (!JPWL_ASSUME) {
-					opj_image_destroy(image);
-					opj_event_msg(cinfo, EVT_ERROR, "JPWL: giving up\n");
-					return 0;
-				}
-				/* we try to correct */
-				id = id | 0xff00;
-				cio_seek(cio, cio_tell(cio) - 2);
-				cio_write(cio, id, 2);
-				opj_event_msg(cinfo, EVT_WARNING, "- trying to adjust this\n"
-					"- setting marker to %x\n",
-					id);
-			}
+        l_nb_bytes_written += l_current_nb_bytes_written;
+        * p_data_written = l_nb_bytes_written;
 
-		}
-#endif /* USE_JPWL */
+        /* Writing Psot in SOT marker */
+        opj_write_bytes(l_begin_data + 6,l_nb_bytes_written,4);                                 /* PSOT */
 
-		if (id >> 8 != 0xff) {
-		if(cio_numbytesleft(cio) != 0) /* not end of file reached and no EOC */
-	   {
-		opj_event_msg(cinfo, EVT_ERROR, "%.8x: expected a marker instead of %x\n", cio_tell(cio) - 2, id);
-		opj_image_destroy(image);
-		return 0;
-	   }
-		opj_event_msg(cinfo, EVT_WARNING, "%.8x: expected a marker instead of %x\n", cio_tell(cio) - 2, id);
-		j2k->state = J2K_STATE_NEOC;
-		break;
-		}
-		e = j2k_dec_mstab_lookup(id);
-		/* Check if the marker is known*/
-		if (!(j2k->state & e->states)) {
-			opj_image_destroy(image);
-			opj_event_msg(cinfo, EVT_ERROR, "%.8x: unexpected marker %x\n", cio_tell(cio) - 2, id);
-			return 0;
-		}
-		/* Check if the decoding is limited to the main header*/
-		if (e->id == J2K_MS_SOT && j2k->cp->limit_decoding == LIMIT_TO_MAIN_HEADER) {
-			opj_event_msg(cinfo, EVT_INFO, "Main Header decoded.\n");
-			return image;
-		}		
-
-		if (e->handler) {
-			(*e->handler)(j2k);
-		}
-		if (j2k->state & J2K_STATE_ERR) 
-        {
-            opj_image_destroy(image);
-			return NULL;	
+        if (OPJ_IS_CINEMA(l_cp->rsiz)){
+                opj_j2k_update_tlm(p_j2k,l_nb_bytes_written);
         }
 
-		if (j2k->state == J2K_STATE_MT) {
-			break;
-		}
-		if (j2k->state == J2K_STATE_NEOC) {
-			break;
-		}
-	}
-	if (j2k->state == J2K_STATE_NEOC) {
-		j2k_read_eoc(j2k);
-		/* Check one last time for errors during decoding before returning */
-		if (j2k->state & J2K_STATE_ERR) {
-			opj_image_destroy(image);
-			return NULL;
-		}
-	}
-
-	if (j2k->state != J2K_STATE_MT) {
-		opj_event_msg(cinfo, EVT_WARNING, "Incomplete bitstream\n");
-	}
-	return image;
+        return OPJ_TRUE;
 }
 
-/*
-* Read a JPT-stream and decode file
-*
-*/
-opj_image_t* j2k_decode_jpt_stream(opj_j2k_t *j2k, opj_cio_t *cio,  opj_codestream_info_t *cstr_info) {
-	opj_image_t *image = NULL;
-	opj_jpt_msg_header_t header;
-	int position;
-	opj_common_ptr cinfo = j2k->cinfo;
-
-	OPJ_ARG_NOT_USED(cstr_info);
-
-	j2k->cio = cio;
-
-	/* create an empty image */
-	image = opj_image_create0();
-	j2k->image = image;
-
-	j2k->state = J2K_STATE_MHSOC;
-	
-	/* Initialize the header */
-	jpt_init_msg_header(&header);
-	/* Read the first header of the message */
-	jpt_read_msg_header(cinfo, cio, &header);
-	
-	position = cio_tell(cio);
-	if (header.Class_Id != 6) {	/* 6 : Main header data-bin message */
-		opj_image_destroy(image);
-		opj_event_msg(cinfo, EVT_ERROR, "[JPT-stream] : Expecting Main header first [class_Id %d] !\n", header.Class_Id);
-		return 0;
-	}
-	
-	for (;;) {
-		opj_dec_mstabent_t *e = NULL;
-		int id;
-		
-		if (!cio_numbytesleft(cio)) {
-			j2k_read_eoc(j2k);
-			return image;
-		}
-		/* data-bin read -> need to read a new header */
-		if ((unsigned int) (cio_tell(cio) - position) == header.Msg_length) {
-			jpt_read_msg_header(cinfo, cio, &header);
-			position = cio_tell(cio);
-			if (header.Class_Id != 4) {	/* 4 : Tile data-bin message */
-				opj_image_destroy(image);
-				opj_event_msg(cinfo, EVT_ERROR, "[JPT-stream] : Expecting Tile info !\n");
-				return 0;
-			}
-		}
-		
-		id = cio_read(cio, 2);
-		if (id >> 8 != 0xff) {
-        if(cio_numbytesleft(cio) != 0) /* no end of file reached and no EOC */
-	  {
-		opj_event_msg(cinfo, EVT_ERROR, "%.8x: expected a marker instead of %x\n", cio_tell(cio) - 2, id);
-		opj_image_destroy(image);
-		return 0;
-	  }
-		opj_event_msg(cinfo, EVT_WARNING, "%.8x: expected a marker instead of %x\n", cio_tell(cio) - 2, id);
-		j2k->state = J2K_STATE_NEOC;
-		break;
-		}
-		e = j2k_dec_mstab_lookup(id);
-		if (!(j2k->state & e->states)) {
-			opj_image_destroy(image);
-			opj_event_msg(cinfo, EVT_ERROR, "%.8x: unexpected marker %x\n", cio_tell(cio) - 2, id);
-			return 0;
-		}
-		if (e->handler) {
-			(*e->handler)(j2k);
-		}
-		if (j2k->state == J2K_STATE_MT) {
-			break;
-		}
-		if (j2k->state == J2K_STATE_NEOC) {
-			break;
-		}
-	}
-	if (j2k->state == J2K_STATE_NEOC) {
-		j2k_read_eoc(j2k);
-	}
-	
-	if (j2k->state != J2K_STATE_MT) {
-		opj_event_msg(cinfo, EVT_WARNING, "Incomplete bitstream\n");
-	}
+OPJ_BOOL opj_j2k_write_all_tile_parts(  opj_j2k_t *p_j2k,
+                                                                        OPJ_BYTE * p_data,
+                                                                        OPJ_UINT32 * p_data_written,
+                                                                        OPJ_UINT32 p_total_data_size,
+                                                                        opj_stream_private_t *p_stream,
+                                                                        struct opj_event_mgr * p_manager
+                                                                )
+{
+        OPJ_UINT32 tilepartno=0;
+        OPJ_UINT32 l_nb_bytes_written = 0;
+        OPJ_UINT32 l_current_nb_bytes_written;
+        OPJ_UINT32 l_part_tile_size;
+        OPJ_UINT32 tot_num_tp;
+        OPJ_UINT32 pino;
+
+        OPJ_BYTE * l_begin_data;
+        opj_tcp_t *l_tcp = 00;
+        opj_tcd_t * l_tcd = 00;
+        opj_cp_t * l_cp = 00;
+
+        l_tcd = p_j2k->m_tcd;
+        l_cp = &(p_j2k->m_cp);
+        l_tcp = l_cp->tcps + p_j2k->m_current_tile_number;
+
+        /*Get number of tile parts*/
+        tot_num_tp = opj_j2k_get_num_tp(l_cp,0,p_j2k->m_current_tile_number);
+
+        /* start writing remaining tile parts */
+        ++p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;
+        for (tilepartno = 1; tilepartno < tot_num_tp ; ++tilepartno) {
+                p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = tilepartno;
+                l_current_nb_bytes_written = 0;
+                l_part_tile_size = 0;
+                l_begin_data = p_data;
+
+                if (! opj_j2k_write_sot(p_j2k,p_data,&l_current_nb_bytes_written,p_stream,p_manager)) {
+                        return OPJ_FALSE;
+                }
+
+                l_nb_bytes_written += l_current_nb_bytes_written;
+                p_data += l_current_nb_bytes_written;
+                p_total_data_size -= l_current_nb_bytes_written;
+                l_part_tile_size += l_current_nb_bytes_written;
+
+                l_current_nb_bytes_written = 0;
+                if (! opj_j2k_write_sod(p_j2k,l_tcd,p_data,&l_current_nb_bytes_written,p_total_data_size,p_stream,p_manager)) {
+                        return OPJ_FALSE;
+                }
+
+                p_data += l_current_nb_bytes_written;
+                l_nb_bytes_written += l_current_nb_bytes_written;
+                p_total_data_size -= l_current_nb_bytes_written;
+                l_part_tile_size += l_current_nb_bytes_written;
+
+                /* Writing Psot in SOT marker */
+                opj_write_bytes(l_begin_data + 6,l_part_tile_size,4);                                   /* PSOT */
+
+                if (OPJ_IS_CINEMA(l_cp->rsiz)) {
+                        opj_j2k_update_tlm(p_j2k,l_part_tile_size);
+                }
+
+                ++p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;
+        }
 
-	return image;
-}
+        for (pino = 1; pino <= l_tcp->numpocs; ++pino) {
+                l_tcd->cur_pino = pino;
 
-/* ----------------------------------------------------------------------- */
-/* J2K encoder interface                                                       */
-/* ----------------------------------------------------------------------- */
+                /*Get number of tile parts*/
+                tot_num_tp = opj_j2k_get_num_tp(l_cp,pino,p_j2k->m_current_tile_number);
+                for (tilepartno = 0; tilepartno < tot_num_tp ; ++tilepartno) {
+                        p_j2k->m_specific_param.m_encoder.m_current_poc_tile_part_number = tilepartno;
+                        l_current_nb_bytes_written = 0;
+                        l_part_tile_size = 0;
+                        l_begin_data = p_data;
+
+                        if (! opj_j2k_write_sot(p_j2k,p_data,&l_current_nb_bytes_written,p_stream,p_manager)) {
+                                return OPJ_FALSE;
+                        }
+
+                        l_nb_bytes_written += l_current_nb_bytes_written;
+                        p_data += l_current_nb_bytes_written;
+                        p_total_data_size -= l_current_nb_bytes_written;
+                        l_part_tile_size += l_current_nb_bytes_written;
+
+                        l_current_nb_bytes_written = 0;
+
+                        if (! opj_j2k_write_sod(p_j2k,l_tcd,p_data,&l_current_nb_bytes_written,p_total_data_size,p_stream,p_manager)) {
+                                return OPJ_FALSE;
+                        }
+
+                        l_nb_bytes_written += l_current_nb_bytes_written;
+                        p_data += l_current_nb_bytes_written;
+                        p_total_data_size -= l_current_nb_bytes_written;
+                        l_part_tile_size += l_current_nb_bytes_written;
 
-opj_j2k_t* j2k_create_compress(opj_common_ptr cinfo) {
-	opj_j2k_t *j2k = (opj_j2k_t*) opj_calloc(1, sizeof(opj_j2k_t));
-	if(j2k) {
-		j2k->cinfo = cinfo;
-	}
-	return j2k;
+                        /* Writing Psot in SOT marker */
+                        opj_write_bytes(l_begin_data + 6,l_part_tile_size,4);                                   /* PSOT */
+
+                        if (OPJ_IS_CINEMA(l_cp->rsiz)) {
+                                opj_j2k_update_tlm(p_j2k,l_part_tile_size);
+                        }
+
+                        ++p_j2k->m_specific_param.m_encoder.m_current_tile_part_number;
+                }
+        }
+
+        *p_data_written = l_nb_bytes_written;
+
+        return OPJ_TRUE;
 }
 
-void j2k_destroy_compress(opj_j2k_t *j2k) {
-	int tileno;
+OPJ_BOOL opj_j2k_write_updated_tlm( opj_j2k_t *p_j2k,
+                                                                    struct opj_stream_private *p_stream,
+                                                                    struct opj_event_mgr * p_manager )
+{
+        OPJ_UINT32 l_tlm_size;
+        OPJ_OFF_T l_tlm_position, l_current_position;
 
-	if(!j2k) return;
-	if(j2k->cp != NULL) {
-		opj_cp_t *cp = j2k->cp;
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_stream != 00);
 
-		if(cp->comment) {
-			opj_free(cp->comment);
-		}
-		if(cp->matrice) {
-			opj_free(cp->matrice);
-		}
-		for (tileno = 0; tileno < cp->tw * cp->th; tileno++) {
-			opj_free(cp->tcps[tileno].tccps);
-		}
-		opj_free(cp->tcps);
-		opj_free(cp);
-	}
-
-	opj_free(j2k);
-}
-
-void j2k_setup_encoder(opj_j2k_t *j2k, opj_cparameters_t *parameters, opj_image_t *image) {
-	int i, j, tileno, numpocs_tile;
-	opj_cp_t *cp = NULL;
-
-	if(!j2k || !parameters || ! image) {
-		return;
-	}
-
-	/* create and initialize the coding parameters structure */
-	cp = (opj_cp_t*) opj_calloc(1, sizeof(opj_cp_t));
-
-	/* keep a link to cp so that we can destroy it later in j2k_destroy_compress */
-	j2k->cp = cp;
-
-	/* set default values for cp */
-	cp->tw = 1;
-	cp->th = 1;
-
-	/* 
-	copy user encoding parameters 
-	*/
-	cp->cinema = parameters->cp_cinema;
-	cp->max_comp_size =	parameters->max_comp_size;
-	cp->rsiz   = parameters->cp_rsiz;
-	cp->disto_alloc = parameters->cp_disto_alloc;
-	cp->fixed_alloc = parameters->cp_fixed_alloc;
-	cp->fixed_quality = parameters->cp_fixed_quality;
-
-	/* mod fixed_quality */
-	if(parameters->cp_matrice) {
-		size_t array_size = parameters->tcp_numlayers * parameters->numresolution * 3 * sizeof(int);
-		cp->matrice = (int *) opj_malloc(array_size);
-		memcpy(cp->matrice, parameters->cp_matrice, array_size);
-	}
-
-	/* tiles */
-	cp->tdx = parameters->cp_tdx;
-	cp->tdy = parameters->cp_tdy;
-
-	/* tile offset */
-	cp->tx0 = parameters->cp_tx0;
-	cp->ty0 = parameters->cp_ty0;
-
-	/* comment string */
-	if(parameters->cp_comment) {
-		cp->comment = (char*)opj_malloc(strlen(parameters->cp_comment) + 1);
-		if(cp->comment) {
-			strcpy(cp->comment, parameters->cp_comment);
-		}
-	}
-
-	/*
-	calculate other encoding parameters
-	*/
-
-	if (parameters->tile_size_on) {
-		cp->tw = int_ceildiv(image->x1 - cp->tx0, cp->tdx);
-		cp->th = int_ceildiv(image->y1 - cp->ty0, cp->tdy);
-	} else {
-		cp->tdx = image->x1 - cp->tx0;
-		cp->tdy = image->y1 - cp->ty0;
-	}
-
-	if(parameters->tp_on){
-		cp->tp_flag = parameters->tp_flag;
-		cp->tp_on = 1;
-	}
-	
-	cp->img_size = 0;
-	for(i=0;i<image->numcomps ;i++){
-	cp->img_size += (image->comps[i].w *image->comps[i].h * image->comps[i].prec);
-	}
+        l_tlm_size = 5 * p_j2k->m_specific_param.m_encoder.m_total_tile_parts;
+        l_tlm_position = 6 + p_j2k->m_specific_param.m_encoder.m_tlm_start;
+        l_current_position = opj_stream_tell(p_stream);
 
+        if (! opj_stream_seek(p_stream,l_tlm_position,p_manager)) {
+                return OPJ_FALSE;
+        }
 
-#ifdef USE_JPWL
-	/*
-	calculate JPWL encoding parameters
-	*/
-
-	if (parameters->jpwl_epc_on) {
-		int i;
-
-		/* set JPWL on */
-		cp->epc_on = OPJ_TRUE;
-		cp->info_on = OPJ_FALSE; /* no informative technique */
-
-		/* set EPB on */
-		if ((parameters->jpwl_hprot_MH > 0) || (parameters->jpwl_hprot_TPH[0] > 0)) {
-			cp->epb_on = OPJ_TRUE;
-			
-			cp->hprot_MH = parameters->jpwl_hprot_MH;
-			for (i = 0; i < JPWL_MAX_NO_TILESPECS; i++) {
-				cp->hprot_TPH_tileno[i] = parameters->jpwl_hprot_TPH_tileno[i];
-				cp->hprot_TPH[i] = parameters->jpwl_hprot_TPH[i];
-			}
-			/* if tile specs are not specified, copy MH specs */
-			if (cp->hprot_TPH[0] == -1) {
-				cp->hprot_TPH_tileno[0] = 0;
-				cp->hprot_TPH[0] = parameters->jpwl_hprot_MH;
-			}
-			for (i = 0; i < JPWL_MAX_NO_PACKSPECS; i++) {
-				cp->pprot_tileno[i] = parameters->jpwl_pprot_tileno[i];
-				cp->pprot_packno[i] = parameters->jpwl_pprot_packno[i];
-				cp->pprot[i] = parameters->jpwl_pprot[i];
-			}
-		}
+        if (opj_stream_write_data(p_stream,p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer,l_tlm_size,p_manager) != l_tlm_size) {
+                return OPJ_FALSE;
+        }
 
-		/* set ESD writing */
-		if ((parameters->jpwl_sens_size == 1) || (parameters->jpwl_sens_size == 2)) {
-			cp->esd_on = OPJ_TRUE;
+        if (! opj_stream_seek(p_stream,l_current_position,p_manager)) {
+                return OPJ_FALSE;
+        }
 
-			cp->sens_size = parameters->jpwl_sens_size;
-			cp->sens_addr = parameters->jpwl_sens_addr;
-			cp->sens_range = parameters->jpwl_sens_range;
+        return OPJ_TRUE;
+}
 
-			cp->sens_MH = parameters->jpwl_sens_MH;
-			for (i = 0; i < JPWL_MAX_NO_TILESPECS; i++) {
-				cp->sens_TPH_tileno[i] = parameters->jpwl_sens_TPH_tileno[i];
-				cp->sens_TPH[i] = parameters->jpwl_sens_TPH[i];
-			}
-		}
+OPJ_BOOL opj_j2k_end_encoding(  opj_j2k_t *p_j2k,
+                                                        struct opj_stream_private *p_stream,
+                                                        struct opj_event_mgr * p_manager )
+{
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_stream != 00);
+
+        opj_tcd_destroy(p_j2k->m_tcd);
+        p_j2k->m_tcd = 00;
+
+        if (p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer) {
+                opj_free(p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer);
+                p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_buffer = 0;
+                p_j2k->m_specific_param.m_encoder.m_tlm_sot_offsets_current = 0;
+        }
 
-		/* always set RED writing to false: we are at the encoder */
-		cp->red_on = OPJ_FALSE;
+        if (p_j2k->m_specific_param.m_encoder.m_encoded_tile_data) {
+                opj_free(p_j2k->m_specific_param.m_encoder.m_encoded_tile_data);
+                p_j2k->m_specific_param.m_encoder.m_encoded_tile_data = 0;
+        }
 
-	} else {
-		cp->epc_on = OPJ_FALSE;
-	}
-#endif /* USE_JPWL */
+        p_j2k->m_specific_param.m_encoder.m_encoded_tile_size = 0;
 
+        return OPJ_TRUE;
+}
 
-	/* initialize the mutiple tiles */
-	/* ---------------------------- */
-	cp->tcps = (opj_tcp_t*) opj_calloc(cp->tw * cp->th, sizeof(opj_tcp_t));
-
-	for (tileno = 0; tileno < cp->tw * cp->th; tileno++) {
-		opj_tcp_t *tcp = &cp->tcps[tileno];
-		tcp->numlayers = parameters->tcp_numlayers;
-		for (j = 0; j < tcp->numlayers; j++) {
-			if(cp->cinema){
-				if (cp->fixed_quality) {
-					tcp->distoratio[j] = parameters->tcp_distoratio[j];
-				}
-				tcp->rates[j] = parameters->tcp_rates[j];
-			}else{
-				if (cp->fixed_quality) {	/* add fixed_quality */
-					tcp->distoratio[j] = parameters->tcp_distoratio[j];
-				} else {
-					tcp->rates[j] = parameters->tcp_rates[j];
-				}
-			}
-		}
-		tcp->csty = parameters->csty;
-		tcp->prg = parameters->prog_order;
-		tcp->mct = parameters->tcp_mct; 
-
-		numpocs_tile = 0;
-		tcp->POC = 0;
-		if (parameters->numpocs) {
-			/* initialisation of POC */
-			tcp->POC = 1;
-			for (i = 0; i < parameters->numpocs; i++) {
-				if((tileno == parameters->POC[i].tile - 1) || (parameters->POC[i].tile == -1)) {
-					opj_poc_t *tcp_poc = &tcp->pocs[numpocs_tile];
-					tcp_poc->resno0		= parameters->POC[numpocs_tile].resno0;
-					tcp_poc->compno0	= parameters->POC[numpocs_tile].compno0;
-					tcp_poc->layno1		= parameters->POC[numpocs_tile].layno1;
-					tcp_poc->resno1		= parameters->POC[numpocs_tile].resno1;
-					tcp_poc->compno1	= parameters->POC[numpocs_tile].compno1;
-					tcp_poc->prg1		= parameters->POC[numpocs_tile].prg1;
-					tcp_poc->tile		= parameters->POC[numpocs_tile].tile;
-					numpocs_tile++;
-				}
-			}
-			tcp->numpocs = numpocs_tile -1 ;
-		}else{ 
-			tcp->numpocs = 0;
-		}
+/**
+ * Destroys the memory associated with the decoding of headers.
+ */
+static OPJ_BOOL opj_j2k_destroy_header_memory ( opj_j2k_t * p_j2k,
+                                                opj_stream_private_t *p_stream,
+                                                opj_event_mgr_t * p_manager
+                                                )
+{
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_stream != 00);
+        assert(p_manager != 00);
+
+        if (p_j2k->m_specific_param.m_encoder.m_header_tile_data) {
+                opj_free(p_j2k->m_specific_param.m_encoder.m_header_tile_data);
+                p_j2k->m_specific_param.m_encoder.m_header_tile_data = 0;
+        }
 
-		tcp->tccps = (opj_tccp_t*) opj_calloc(image->numcomps, sizeof(opj_tccp_t));
-
-		for (i = 0; i < image->numcomps; i++) {
-			opj_tccp_t *tccp = &tcp->tccps[i];
-			tccp->csty = parameters->csty & 0x01;	/* 0 => one precinct || 1 => custom precinct  */
-			tccp->numresolutions = parameters->numresolution;
-			tccp->cblkw = int_floorlog2(parameters->cblockw_init);
-			tccp->cblkh = int_floorlog2(parameters->cblockh_init);
-			tccp->cblksty = parameters->mode;
-			tccp->qmfbid = parameters->irreversible ? 0 : 1;
-			tccp->qntsty = parameters->irreversible ? J2K_CCP_QNTSTY_SEQNT : J2K_CCP_QNTSTY_NOQNT;
-			tccp->numgbits = 2;
-			if (i == parameters->roi_compno) {
-				tccp->roishift = parameters->roi_shift;
-			} else {
-				tccp->roishift = 0;
-			}
-
-			if(parameters->cp_cinema)
-			{
-				/*Precinct size for lowest frequency subband=128*/
-				tccp->prcw[0] = 7;
-				tccp->prch[0] = 7;
-				/*Precinct size at all other resolutions = 256*/
-				for (j = 1; j < tccp->numresolutions; j++) {
-					tccp->prcw[j] = 8;
-					tccp->prch[j] = 8;
-				}
-			}else{
-				if (parameters->csty & J2K_CCP_CSTY_PRT) {
-					int p = 0;
-					for (j = tccp->numresolutions - 1; j >= 0; j--) {
-						if (p < parameters->res_spec) {
-							
-							if (parameters->prcw_init[p] < 1) {
-								tccp->prcw[j] = 1;
-							} else {
-								tccp->prcw[j] = int_floorlog2(parameters->prcw_init[p]);
-							}
-							
-							if (parameters->prch_init[p] < 1) {
-								tccp->prch[j] = 1;
-							}else {
-								tccp->prch[j] = int_floorlog2(parameters->prch_init[p]);
-							}
-
-						} else {
-							int res_spec = parameters->res_spec;
-							int size_prcw = parameters->prcw_init[res_spec - 1] >> (p - (res_spec - 1));
-							int size_prch = parameters->prch_init[res_spec - 1] >> (p - (res_spec - 1));
-							
-							if (size_prcw < 1) {
-								tccp->prcw[j] = 1;
-							} else {
-								tccp->prcw[j] = int_floorlog2(size_prcw);
-							}
-							
-							if (size_prch < 1) {
-								tccp->prch[j] = 1;
-							} else {
-								tccp->prch[j] = int_floorlog2(size_prch);
-							}
-						}
-						p++;
-						/*printf("\nsize precinct for level %d : %d,%d\n", j,tccp->prcw[j], tccp->prch[j]); */
-					}	/*end for*/
-				} else {
-					for (j = 0; j < tccp->numresolutions; j++) {
-						tccp->prcw[j] = 15;
-						tccp->prch[j] = 15;
-					}
-				}
-			}
-
-			dwt_calc_explicit_stepsizes(tccp, image->comps[i].prec);
-		}
-	}
-}
-
-opj_bool j2k_encode(opj_j2k_t *j2k, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info) {
-	int tileno, compno;
-	opj_cp_t *cp = NULL;
-
-	opj_tcd_t *tcd = NULL;	/* TCD component */
-
-	j2k->cio = cio;	
-	j2k->image = image;
-
-	cp = j2k->cp;
-
-	/* INDEX >> */
-	j2k->cstr_info = cstr_info;
-	if (cstr_info) {
-		int compno;
-		cstr_info->tile = (opj_tile_info_t *) opj_malloc(cp->tw * cp->th * sizeof(opj_tile_info_t));
-		cstr_info->image_w = image->x1 - image->x0;
-		cstr_info->image_h = image->y1 - image->y0;
-		cstr_info->prog = (&cp->tcps[0])->prg;
-		cstr_info->tw = cp->tw;
-		cstr_info->th = cp->th;
-		cstr_info->tile_x = cp->tdx;	/* new version parser */
-		cstr_info->tile_y = cp->tdy;	/* new version parser */
-		cstr_info->tile_Ox = cp->tx0;	/* new version parser */
-		cstr_info->tile_Oy = cp->ty0;	/* new version parser */
-		cstr_info->numcomps = image->numcomps;
-		cstr_info->numlayers = (&cp->tcps[0])->numlayers;
-		cstr_info->numdecompos = (int*) opj_malloc(image->numcomps * sizeof(int));
-		for (compno=0; compno < image->numcomps; compno++) {
-			cstr_info->numdecompos[compno] = (&cp->tcps[0])->tccps->numresolutions - 1;
-		}
-		cstr_info->D_max = 0.0;		/* ADD Marcela */
-		cstr_info->main_head_start = cio_tell(cio); /* position of SOC */
-		cstr_info->maxmarknum = 100;
-		cstr_info->marker = (opj_marker_info_t *) opj_malloc(cstr_info->maxmarknum * sizeof(opj_marker_info_t));
-		cstr_info->marknum = 0;
-	}
-	/* << INDEX */
-
-	j2k_write_soc(j2k);
-	j2k_write_siz(j2k);
-	j2k_write_cod(j2k);
-	j2k_write_qcd(j2k);
-
-	if(cp->cinema){
-		for (compno = 1; compno < image->numcomps; compno++) {
-			j2k_write_coc(j2k, compno);
-			j2k_write_qcc(j2k, compno);
-		}
-	}
-
-	for (compno = 0; compno < image->numcomps; compno++) {
-		opj_tcp_t *tcp = &cp->tcps[0];
-		if (tcp->tccps[compno].roishift)
-			j2k_write_rgn(j2k, compno, 0);
-	}
-	if (cp->comment != NULL) {
-		j2k_write_com(j2k);
-	}
-
-	j2k->totnum_tp = j2k_calculate_tp(cp,image->numcomps,image,j2k);
-	/* TLM Marker*/
-	if(cp->cinema){
-		j2k_write_tlm(j2k);
-		if (cp->cinema == CINEMA4K_24) {
-			j2k_write_poc(j2k);
-		}
-	}
-
-	/* uncomment only for testing JPSEC marker writing */
-	/* j2k_write_sec(j2k); */
-
-	/* INDEX >> */
-	if(cstr_info) {
-		cstr_info->main_head_end = cio_tell(cio) - 1;
-	}
-	/* << INDEX */
-	/**** Main Header ENDS here ***/
-
-	/* create the tile encoder */
-	tcd = tcd_create(j2k->cinfo);
-
-	/* encode each tile */
-	for (tileno = 0; tileno < cp->tw * cp->th; tileno++) {
-		int pino;
-		int tilepartno=0;
-		/* UniPG>> */
-		int acc_pack_num = 0;
-		/* <<UniPG */
-
-
-		opj_tcp_t *tcp = &cp->tcps[tileno];
-		opj_event_msg(j2k->cinfo, EVT_INFO, "tile number %d / %d\n", tileno + 1, cp->tw * cp->th);
-
-		j2k->curtileno = tileno;
-		j2k->cur_tp_num = 0;
-		tcd->cur_totnum_tp = j2k->cur_totnum_tp[j2k->curtileno];
-		/* initialisation before tile encoding  */
-		if (tileno == 0) {
-			tcd_malloc_encode(tcd, image, cp, j2k->curtileno);
-		} else {
-			tcd_init_encode(tcd, image, cp, j2k->curtileno);
-		}
+        p_j2k->m_specific_param.m_encoder.m_header_tile_data_size = 0;
 
-		/* INDEX >> */
-		if(cstr_info) {
-			cstr_info->tile[j2k->curtileno].start_pos = cio_tell(cio) + j2k->pos_correction;
-			cstr_info->tile[j2k->curtileno].maxmarknum = 10;
-			cstr_info->tile[j2k->curtileno].marker = (opj_marker_info_t *) opj_malloc(cstr_info->tile[j2k->curtileno].maxmarknum * sizeof(opj_marker_info_t));
-			cstr_info->tile[j2k->curtileno].marknum = 0;
-		}
-		/* << INDEX */
-
-		for(pino = 0; pino <= tcp->numpocs; pino++) {
-			int tot_num_tp;
-			tcd->cur_pino=pino;
-
-			/*Get number of tile parts*/
-			tot_num_tp = j2k_get_num_tp(cp,pino,tileno);
-			tcd->tp_pos = cp->tp_pos;
-
-			for(tilepartno = 0; tilepartno < tot_num_tp ; tilepartno++){
-				j2k->tp_num = tilepartno;
-				/* INDEX >> */
-				if(cstr_info)
-					cstr_info->tile[j2k->curtileno].tp[j2k->cur_tp_num].tp_start_pos =
-					cio_tell(cio) + j2k->pos_correction;
-				/* << INDEX */
-				j2k_write_sot(j2k);
-
-				if(j2k->cur_tp_num == 0 && cp->cinema == 0){
-					for (compno = 1; compno < image->numcomps; compno++) {
-						j2k_write_coc(j2k, compno);
-						j2k_write_qcc(j2k, compno);
-					}
-					if (cp->tcps[tileno].numpocs) {
-						j2k_write_poc(j2k);
-					}
-				}
-
-				/* INDEX >> */
-				if(cstr_info)
-					cstr_info->tile[j2k->curtileno].tp[j2k->cur_tp_num].tp_end_header =
-					cio_tell(cio) + j2k->pos_correction + 1;
-				/* << INDEX */
-
-				j2k_write_sod(j2k, tcd);
-
-				/* INDEX >> */
-				if(cstr_info) {
-					cstr_info->tile[j2k->curtileno].tp[j2k->cur_tp_num].tp_end_pos =
-						cio_tell(cio) + j2k->pos_correction - 1;
-					cstr_info->tile[j2k->curtileno].tp[j2k->cur_tp_num].tp_start_pack =
-						acc_pack_num;
-					cstr_info->tile[j2k->curtileno].tp[j2k->cur_tp_num].tp_numpacks =
-						cstr_info->packno - acc_pack_num;
-					acc_pack_num = cstr_info->packno;
-				}
-				/* << INDEX */
-
-				j2k->cur_tp_num++;
-			}			
-		}
-		if(cstr_info) {
-			cstr_info->tile[j2k->curtileno].end_pos = cio_tell(cio) + j2k->pos_correction - 1;
-		}
+        return OPJ_TRUE;
+}
 
+OPJ_BOOL opj_j2k_init_info(     opj_j2k_t *p_j2k,
+                                                struct opj_stream_private *p_stream,
+                                                struct opj_event_mgr * p_manager )
+{
+        opj_codestream_info_t * l_cstr_info = 00;
 
-		/*
-		if (tile->PPT) { // BAD PPT !!! 
-		FILE *PPT_file;
-		int i;
-		PPT_file=fopen("PPT","rb");
-		fprintf(stderr,"%c%c%c%c",255,97,tile->len_ppt/256,tile->len_ppt%256);
-		for (i=0;i<tile->len_ppt;i++) {
-		unsigned char elmt;
-		fread(&elmt, 1, 1, PPT_file);
-		fwrite(&elmt,1,1,f);
-		}
-		fclose(PPT_file);
-		unlink("PPT");
-		}
-		*/
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_stream != 00);
+  (void)l_cstr_info;
 
-	}
+        /* TODO mergeV2: check this part which use cstr_info */
+        /*l_cstr_info = p_j2k->cstr_info;
 
-	/* destroy the tile encoder */
-	tcd_free_encode(tcd);
-	tcd_destroy(tcd);
+        if (l_cstr_info)  {
+                OPJ_UINT32 compno;
+                l_cstr_info->tile = (opj_tile_info_t *) opj_malloc(p_j2k->m_cp.tw * p_j2k->m_cp.th * sizeof(opj_tile_info_t));
 
-	opj_free(j2k->cur_totnum_tp);
+                l_cstr_info->image_w = p_j2k->m_image->x1 - p_j2k->m_image->x0;
+                l_cstr_info->image_h = p_j2k->m_image->y1 - p_j2k->m_image->y0;
 
-	j2k_write_eoc(j2k);
+                l_cstr_info->prog = (&p_j2k->m_cp.tcps[0])->prg;
 
-	if(cstr_info) {
-		cstr_info->codestream_size = cio_tell(cio) + j2k->pos_correction;
-		/* UniPG>> */
-		/* The following adjustment is done to adjust the codestream size */
-		/* if SOD is not at 0 in the buffer. Useful in case of JP2, where */
-		/* the first bunch of bytes is not in the codestream              */
-		cstr_info->codestream_size -= cstr_info->main_head_start;
-		/* <<UniPG */
-	}
+                l_cstr_info->tw = p_j2k->m_cp.tw;
+                l_cstr_info->th = p_j2k->m_cp.th;
 
-#ifdef USE_JPWL
-	/*
-	preparation of JPWL marker segments
-	*/
-	if(cp->epc_on) {
+                l_cstr_info->tile_x = p_j2k->m_cp.tdx;*/        /* new version parser */
+                /*l_cstr_info->tile_y = p_j2k->m_cp.tdy;*/      /* new version parser */
+                /*l_cstr_info->tile_Ox = p_j2k->m_cp.tx0;*/     /* new version parser */
+                /*l_cstr_info->tile_Oy = p_j2k->m_cp.ty0;*/     /* new version parser */
 
-		/* encode according to JPWL */
-		jpwl_encode(j2k, cio, image);
+                /*l_cstr_info->numcomps = p_j2k->m_image->numcomps;
 
-	}
-#endif /* USE_JPWL */
+                l_cstr_info->numlayers = (&p_j2k->m_cp.tcps[0])->numlayers;
 
-	return OPJ_TRUE;
-}
+                l_cstr_info->numdecompos = (OPJ_INT32*) opj_malloc(p_j2k->m_image->numcomps * sizeof(OPJ_INT32));
 
-static void j2k_add_mhmarker(opj_codestream_info_t *cstr_info, unsigned short int type, int pos, int len) {
+                for (compno=0; compno < p_j2k->m_image->numcomps; compno++) {
+                        l_cstr_info->numdecompos[compno] = (&p_j2k->m_cp.tcps[0])->tccps->numresolutions - 1;
+                }
 
-	if (!cstr_info)
-		return;
+                l_cstr_info->D_max = 0.0;       */      /* ADD Marcela */
 
-	/* expand the list? */
-	if ((cstr_info->marknum + 1) > cstr_info->maxmarknum) {
-		cstr_info->maxmarknum = 100 + (int) ((float) cstr_info->maxmarknum * 1.0F);
-		cstr_info->marker = (opj_marker_info_t*)opj_realloc(cstr_info->marker, cstr_info->maxmarknum);
-	}
+                /*l_cstr_info->main_head_start = opj_stream_tell(p_stream);*/ /* position of SOC */
 
-	/* add the marker */
-	cstr_info->marker[cstr_info->marknum].type = type;
-	cstr_info->marker[cstr_info->marknum].pos = pos;
-	cstr_info->marker[cstr_info->marknum].len = len;
-	cstr_info->marknum++;
+                /*l_cstr_info->maxmarknum = 100;
+                l_cstr_info->marker = (opj_marker_info_t *) opj_malloc(l_cstr_info->maxmarknum * sizeof(opj_marker_info_t));
+                l_cstr_info->marknum = 0;
+        }*/
 
+        return opj_j2k_calculate_tp(p_j2k,&(p_j2k->m_cp),&p_j2k->m_specific_param.m_encoder.m_total_tile_parts,p_j2k->m_private_image,p_manager);
 }
 
-static void j2k_add_tlmarker( int tileno, opj_codestream_info_t *cstr_info, unsigned short int type, int pos, int len) {
-
-  opj_marker_info_t *marker;
+/**
+ * Creates a tile-coder decoder.
+ *
+ * @param       p_stream                the stream to write data to.
+ * @param       p_j2k                   J2K codec.
+ * @param       p_manager               the user event manager.
+*/
+static OPJ_BOOL opj_j2k_create_tcd(     opj_j2k_t *p_j2k,
+                                                                    opj_stream_private_t *p_stream,
+                                                                    opj_event_mgr_t * p_manager
+                                    )
+{
+        /* preconditions */
+        assert(p_j2k != 00);
+        assert(p_manager != 00);
+        assert(p_stream != 00);
+
+        p_j2k->m_tcd = opj_tcd_create(OPJ_FALSE);
+
+        if (! p_j2k->m_tcd) {
+                opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to create Tile Coder\n");
+                return OPJ_FALSE;
+        }
 
-	if (!cstr_info)
-		return;
+        if (!opj_tcd_init(p_j2k->m_tcd,p_j2k->m_private_image,&p_j2k->m_cp)) {
+                opj_tcd_destroy(p_j2k->m_tcd);
+                p_j2k->m_tcd = 00;
+                return OPJ_FALSE;
+        }
 
-	/* expand the list? */
-	if ((cstr_info->tile[tileno].marknum + 1) > cstr_info->tile[tileno].maxmarknum) {
-		cstr_info->tile[tileno].maxmarknum = 100 + (int) ((float) cstr_info->tile[tileno].maxmarknum * 1.0F);
-		cstr_info->tile[tileno].marker = (opj_marker_info_t*)opj_realloc(cstr_info->tile[tileno].marker, cstr_info->maxmarknum);
-	}
+        return OPJ_TRUE;
+}
 
-	marker = &(cstr_info->tile[tileno].marker[cstr_info->tile[tileno].marknum]);
+OPJ_BOOL opj_j2k_write_tile (opj_j2k_t * p_j2k,
+                                                 OPJ_UINT32 p_tile_index,
+                                                 OPJ_BYTE * p_data,
+                                                 OPJ_UINT32 p_data_size,
+                                                 opj_stream_private_t *p_stream,
+                                                 opj_event_mgr_t * p_manager )
+{
+        if (! opj_j2k_pre_write_tile(p_j2k,p_tile_index,p_stream,p_manager)) {
+                opj_event_msg(p_manager, EVT_ERROR, "Error while opj_j2k_pre_write_tile with tile index = %d\n", p_tile_index);
+                return OPJ_FALSE;
+        }
+        else {
+                if (! opj_j2k_post_write_tile(p_j2k,p_data,p_data_size,p_stream,p_manager)) {
+                        opj_event_msg(p_manager, EVT_ERROR, "Error while opj_j2k_post_write_tile with tile index = %d\n", p_tile_index);
+                        return OPJ_FALSE;
+                }
+        }
 
-	/* add the marker */
-	marker->type = type;
-	marker->pos = pos;
-	marker->len = len;
-	cstr_info->tile[tileno].marknum++;
+        return OPJ_TRUE;
 }
diff --git a/extern/libopenjpeg/j2k.h b/extern/libopenjpeg/j2k.h
index 6338c29..d0f59d7 100644
--- a/extern/libopenjpeg/j2k.h
+++ b/extern/libopenjpeg/j2k.h
@@ -1,11 +1,21 @@
 /*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2001-2003, David Janssens
  * Copyright (c) 2002-2003, Yannick Verschueren
- * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * Copyright (c) 2003-2014, Antonin Descampe
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
  * Copyright (c) 2006-2007, Parvatha Elangovan
+ * Copyright (c) 2008, Jerome Fimes, Communications & Systemes <jerome.fimes@c-s.fr>
+ * Copyright (c) 2011-2012, Centre National d'Etudes Spatiales (CNES), France 
+ * Copyright (c) 2012, CS Systemes d'Information, France
+ *
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -55,6 +65,8 @@ The functions in J2K.C have for goal to read/write the several parts of the code
 #define J2K_CCP_QNTSTY_SIQNT 1
 #define J2K_CCP_QNTSTY_SEQNT 2
 
+#define OPJ_J2K_DEFAULT_CBLK_DATA_SIZE 8192
+
 /* ----------------------------------------------------------------------- */
 
 #define J2K_MS_SOC 0xff4f	/**< SOC marker value */
@@ -77,6 +89,13 @@ The functions in J2K.C have for goal to read/write the several parts of the code
 #define J2K_MS_EPH 0xff92	/**< EPH marker value */
 #define J2K_MS_CRG 0xff63	/**< CRG marker value */
 #define J2K_MS_COM 0xff64	/**< COM marker value */
+#define J2K_MS_CBD 0xff78	/**< CBD marker value */
+#define J2K_MS_MCC 0xff75	/**< MCC marker value */
+#define J2K_MS_MCT 0xff74	/**< MCT marker value */
+#define J2K_MS_MCO 0xff77	/**< MCO marker value */
+
+#define J2K_MS_UNK 0		/**< UNKNOWN marker value */
+
 /* UniPG>> */
 #ifdef USE_JPWL
 #define J2K_MS_EPC 0xff68	/**< EPC marker value (Part 11: JPEG 2000 for Wireless) */
@@ -90,14 +109,14 @@ The functions in J2K.C have for goal to read/write the several parts of the code
 #endif /* USE_JPSEC */
 /* <<UniPG */
 
-
 /* ----------------------------------------------------------------------- */
 
 /**
-Values that specify the status of the decoding process when decoding the main header. 
-These values may be combined with a | operator. 
-*/
+ * Values that specify the status of the decoding process when decoding the main header.
+ * These values may be combined with a | operator.
+ * */
 typedef enum J2K_STATUS {
+	J2K_STATE_NONE  =  0x0000, /**< a SOC marker is expected */
 	J2K_STATE_MHSOC  = 0x0001, /**< a SOC marker is expected */
 	J2K_STATE_MHSIZ  = 0x0002, /**< a SIZ marker is expected */
 	J2K_STATE_MH     = 0x0004, /**< the decoding process is in the main header */
@@ -105,9 +124,32 @@ typedef enum J2K_STATUS {
 	J2K_STATE_TPH    = 0x0010, /**< the decoding process is in a tile part header */
 	J2K_STATE_MT     = 0x0020, /**< the EOC marker has just been read */
 	J2K_STATE_NEOC   = 0x0040, /**< the decoding process must not expect a EOC marker because the codestream is truncated */
-	J2K_STATE_ERR    = 0x0080  /**< the decoding process has encountered an error */
+
+	J2K_STATE_EOC	 = 0x0100, /**< the decoding process has encountered the EOC marker */
+	J2K_STATE_ERR    = 0x8000  /**< the decoding process has encountered an error (FIXME warning V1 = 0x0080)*/
 } J2K_STATUS;
 
+/**
+ * Type of elements storing in the MCT data
+ */
+typedef enum MCT_ELEMENT_TYPE
+{
+	MCT_TYPE_INT16 = 0,		/** MCT data is stored as signed shorts*/
+	MCT_TYPE_INT32 = 1,		/** MCT data is stored as signed integers*/
+	MCT_TYPE_FLOAT = 2,		/** MCT data is stored as floats*/
+	MCT_TYPE_DOUBLE = 3		/** MCT data is stored as doubles*/
+} J2K_MCT_ELEMENT_TYPE;
+
+/**
+ * Type of MCT array
+ */
+typedef enum MCT_ARRAY_TYPE
+{
+	MCT_TYPE_DEPENDENCY = 0,
+	MCT_TYPE_DECORRELATION = 1,
+	MCT_TYPE_OFFSET = 2
+} J2K_MCT_ARRAY_TYPE;
+
 /* ----------------------------------------------------------------------- */
 
 /** 
@@ -119,161 +161,245 @@ typedef enum T2_MODE {
 }J2K_T2_MODE;
 
 /**
-Quantization stepsize
-*/
+ * Quantization stepsize
+ */
 typedef struct opj_stepsize {
 	/** exponent */
-	int expn;
+	OPJ_INT32 expn;
 	/** mantissa */
-	int mant;
+	OPJ_INT32 mant;
 } opj_stepsize_t;
 
 /**
 Tile-component coding parameters
 */
-typedef struct opj_tccp {
+typedef struct opj_tccp
+{
 	/** coding style */
-	int csty;
+	OPJ_UINT32 csty;
 	/** number of resolutions */
-	int numresolutions;
+	OPJ_UINT32 numresolutions;
 	/** code-blocks width */
-	int cblkw;
+	OPJ_UINT32 cblkw;
 	/** code-blocks height */
-	int cblkh;
+	OPJ_UINT32 cblkh;
 	/** code-block coding style */
-	int cblksty;
+	OPJ_UINT32 cblksty;
 	/** discrete wavelet transform identifier */
-	int qmfbid;
+	OPJ_UINT32 qmfbid;
 	/** quantisation style */
-	int qntsty;
+	OPJ_UINT32 qntsty;
 	/** stepsizes used for quantization */
-	opj_stepsize_t stepsizes[J2K_MAXBANDS];
+	opj_stepsize_t stepsizes[OPJ_J2K_MAXBANDS];
 	/** number of guard bits */
-	int numgbits;
+	OPJ_UINT32 numgbits;
 	/** Region Of Interest shift */
-	int roishift;
+	OPJ_INT32 roishift;
 	/** precinct width */
-	int prcw[J2K_MAXRLVLS];
+	OPJ_UINT32 prcw[OPJ_J2K_MAXRLVLS];
 	/** precinct height */
-	int prch[J2K_MAXRLVLS];	
-} opj_tccp_t;
+	OPJ_UINT32 prch[OPJ_J2K_MAXRLVLS];
+	/** the dc_level_shift **/
+	OPJ_INT32 m_dc_level_shift;
+}
+opj_tccp_t;
+
+
 
 /**
-Tile coding parameters : 
+ * FIXME DOC
+ */
+typedef struct opj_mct_data
+{
+	J2K_MCT_ELEMENT_TYPE m_element_type;
+	J2K_MCT_ARRAY_TYPE	 m_array_type;
+	OPJ_UINT32			 m_index;
+	OPJ_BYTE *			 m_data;
+	OPJ_UINT32			 m_data_size;
+}
+opj_mct_data_t;
+
+/**
+ * FIXME DOC
+ */
+typedef struct opj_simple_mcc_decorrelation_data
+{
+	OPJ_UINT32			 m_index;
+	OPJ_UINT32			 m_nb_comps;
+	opj_mct_data_t *	 m_decorrelation_array;
+	opj_mct_data_t *	 m_offset_array;
+	OPJ_UINT32			 m_is_irreversible : 1;
+}
+opj_simple_mcc_decorrelation_data_t;
+
+/**
+Tile coding parameters :
 this structure is used to store coding/decoding parameters common to all
 tiles (information like COD, COC in main header)
 */
-typedef struct opj_tcp {
-	/** 1 : first part-tile of a tile */
-	int first;
+typedef struct opj_tcp
+{
 	/** coding style */
-	int csty;
+	OPJ_UINT32 csty;
 	/** progression order */
 	OPJ_PROG_ORDER prg;
 	/** number of layers */
-	int numlayers;
+	OPJ_UINT32 numlayers;
+	OPJ_UINT32 num_layers_to_decode;
 	/** multi-component transform identifier */
-	int mct;
+	OPJ_UINT32 mct;
 	/** rates of layers */
-	float rates[100];
+	OPJ_FLOAT32 rates[100];
 	/** number of progression order changes */
-	int numpocs;
-	/** indicates if a POC marker has been used O:NO, 1:YES */
-	int POC;
+	OPJ_UINT32 numpocs;
 	/** progression order changes */
 	opj_poc_t pocs[32];
 	/** packet header store there for futur use in t2_decode_packet */
-	unsigned char *ppt_data;
-	/** pointer remaining on the first byte of the first header if ppt is used */
-	unsigned char *ppt_data_first;
-	/** If ppt == 1 --> there was a PPT marker for the present tile */
-	int ppt;
-	/** used in case of multiple marker PPT (number of info already stored) */
-	int ppt_store;
-	/** ppmbug1 */
-	int ppt_len;
+	OPJ_BYTE *ppt_data;
+	/** used to keep a track of the allocated memory */
+	OPJ_BYTE *ppt_buffer;
+	/** Number of bytes stored inside ppt_data*/
+	OPJ_UINT32 ppt_data_size;
+	/** size of ppt_data*/
+	OPJ_UINT32 ppt_len;
 	/** add fixed_quality */
-	float distoratio[100];
+	OPJ_FLOAT32 distoratio[100];
 	/** tile-component coding parameters */
 	opj_tccp_t *tccps;
+	/** number of tile parts for the tile. */
+	OPJ_UINT32 m_nb_tile_parts;
+	/** data for the tile */
+	OPJ_BYTE *		m_data;
+	/** size of data */
+	OPJ_UINT32		m_data_size;
+	/** encoding norms */
+	OPJ_FLOAT64 *	mct_norms;
+	/** the mct decoding matrix */
+	OPJ_FLOAT32 *	m_mct_decoding_matrix;
+	/** the mct coding matrix */
+	OPJ_FLOAT32 *	m_mct_coding_matrix;
+	/** mct records */
+	opj_mct_data_t * m_mct_records;
+	/** the number of mct records. */
+	OPJ_UINT32 m_nb_mct_records;
+	/** the max number of mct records. */
+	OPJ_UINT32 m_nb_max_mct_records;
+	/** mcc records */
+	opj_simple_mcc_decorrelation_data_t * m_mcc_records;
+	/** the number of mct records. */
+	OPJ_UINT32 m_nb_mcc_records;
+	/** the max number of mct records. */
+	OPJ_UINT32 m_nb_max_mcc_records;
+
+
+	/***** FLAGS *******/
+	/** If ppt == 1 --> there was a PPT marker for the present tile */
+	OPJ_UINT32 ppt : 1;
+	/** indicates if a POC marker has been used O:NO, 1:YES */
+	OPJ_UINT32 POC : 1;
 } opj_tcp_t;
 
-/**
-Coding parameters
-*/
-typedef struct opj_cp {
-	/** Digital cinema profile*/
-	OPJ_CINEMA_MODE cinema;
+
+
+
+typedef struct opj_encoding_param
+{
 	/** Maximum rate for each component. If == 0, component size limitation is not considered */
-	int max_comp_size;
-	/** Size of the image in bits*/
-	int img_size;
-	/** Rsiz*/
-	OPJ_RSIZ_CAPABILITIES rsiz;
-	/** Enabling Tile part generation*/
-	char tp_on;
-	/** Flag determining tile part generation*/
-	char tp_flag;
+	OPJ_UINT32 m_max_comp_size;
 	/** Position of tile part flag in progression order*/
-	int tp_pos;
+	OPJ_INT32 m_tp_pos;
+	/** fixed layer */
+	OPJ_INT32 *m_matrice;
+	/** Flag determining tile part generation*/
+	OPJ_BYTE m_tp_flag;
 	/** allocation by rate/distortion */
-	int disto_alloc;
+	OPJ_UINT32 m_disto_alloc : 1;
 	/** allocation by fixed layer */
-	int fixed_alloc;
+	OPJ_UINT32 m_fixed_alloc : 1;
 	/** add fixed_quality */
-	int fixed_quality;
+	OPJ_UINT32 m_fixed_quality : 1;
+	/** Enabling Tile part generation*/
+	OPJ_UINT32 m_tp_on : 1;
+}
+opj_encoding_param_t;
+
+typedef struct opj_decoding_param
+{
 	/** if != 0, then original dimension divided by 2^(reduce); if == 0 or not used, image is decoded to the full resolution */
-	int reduce;
+	OPJ_UINT32 m_reduce;
 	/** if != 0, then only the first "layer" layers are decoded; if == 0 or not used, all the quality layers are decoded */
-	int layer;
-	/** if == NO_LIMITATION, decode entire codestream; if == LIMIT_TO_MAIN_HEADER then only decode the main header */
-	OPJ_LIMIT_DECODING limit_decoding;
+	OPJ_UINT32 m_layer;
+}
+opj_decoding_param_t;
+
+
+/**
+ * Coding parameters
+ */
+typedef struct opj_cp
+{
+	/** Size of the image in bits*/
+	/*int img_size;*/
+	/** Rsiz*/
+    OPJ_UINT16 rsiz;
 	/** XTOsiz */
-	int tx0;
+	OPJ_UINT32 tx0; /* MSD see norm */
 	/** YTOsiz */
-	int ty0;
+	OPJ_UINT32 ty0; /* MSD see norm */
 	/** XTsiz */
-	int tdx;
+	OPJ_UINT32 tdx;
 	/** YTsiz */
-	int tdy;
-	/** comment for coding */
-	char *comment;
+	OPJ_UINT32 tdy;
+	/** comment */
+	OPJ_CHAR *comment;
 	/** number of tiles in width */
-	int tw;
+	OPJ_UINT32 tw;
 	/** number of tiles in heigth */
-	int th;
-	/** ID number of the tiles present in the codestream */
-	int *tileno;
-	/** size of the vector tileno */
-	int tileno_size;
+	OPJ_UINT32 th;
+
 	/** packet header store there for futur use in t2_decode_packet */
-	unsigned char *ppm_data;
+	OPJ_BYTE *ppm_data;
+	/** size of the ppm_data*/
+	OPJ_UINT32 ppm_len;
+	/** size of the ppm_data*/
+	OPJ_UINT32 ppm_data_read;
+
+	OPJ_BYTE *ppm_data_current;
+
+	/** packet header storage original buffer */
+	OPJ_BYTE *ppm_buffer;
 	/** pointer remaining on the first byte of the first header if ppm is used */
-	unsigned char *ppm_data_first;
-	/** if ppm == 1 --> there was a PPM marker for the present tile */
-	int ppm;
+	OPJ_BYTE *ppm_data_first;
+	/** Number of bytes actually stored inside the ppm_data */
+	OPJ_UINT32 ppm_data_size;
 	/** use in case of multiple marker PPM (number of info already store) */
-	int ppm_store;
+	OPJ_INT32 ppm_store;
 	/** use in case of multiple marker PPM (case on non-finished previous info) */
-	int ppm_previous;
-	/** ppmbug1 */
-	int ppm_len;
+	OPJ_INT32 ppm_previous;
+
 	/** tile coding parameters */
 	opj_tcp_t *tcps;
-	/** fixed layer */
-	int *matrice;
+
+	union
+	{
+		opj_decoding_param_t m_dec;
+		opj_encoding_param_t m_enc;
+	}
+	m_specific_param;
+
+
 /* UniPG>> */
 #ifdef USE_JPWL
 	/** enables writing of EPC in MH, thus activating JPWL */
-	opj_bool epc_on;
+	OPJ_BOOL epc_on;
 	/** enables writing of EPB, in case of activated JPWL */
-	opj_bool epb_on;
+	OPJ_BOOL epb_on;
 	/** enables writing of ESD, in case of activated JPWL */
-	opj_bool esd_on;
+	OPJ_BOOL esd_on;
 	/** enables writing of informative techniques of ESD, in case of activated JPWL */
-	opj_bool info_on;
+	OPJ_BOOL info_on;
 	/** enables writing of RED, in case of activated JPWL */
-	opj_bool red_on;
+	OPJ_BOOL red_on;
 	/** error protection method for MH (0,1,16,32,37-128) */
 	int hprot_MH;
 	/** tile number of header protection specification (>=0) */
@@ -299,148 +425,418 @@ typedef struct opj_cp {
 	/** sensitivity methods for TPHs (-1,0-7) */
 	int sens_TPH[JPWL_MAX_NO_TILESPECS];
 	/** enables JPWL correction at the decoder */
-	opj_bool correct;
+	OPJ_BOOL correct;
 	/** expected number of components at the decoder */
 	int exp_comps;
 	/** maximum number of tiles at the decoder */
-	int max_tiles;
+	OPJ_UINT32 max_tiles;
 #endif /* USE_JPWL */
+
+	/******** FLAGS *********/
+	/** if ppm == 1 --> there was a PPM marker*/
+	OPJ_UINT32 ppm : 1;
+	/** tells if the parameter is a coding or decoding one */
+	OPJ_UINT32 m_is_decoder : 1;
 /* <<UniPG */
 } opj_cp_t;
 
-/**
-JPEG-2000 codestream reader/writer
-*/
-typedef struct opj_j2k {
-	/** codec context */
-	opj_common_ptr cinfo;
 
+typedef struct opj_j2k_dec
+{
 	/** locate in which part of the codestream the decoder is (main header, tile header, end) */
-	int state;
-	/** number of the tile curently concern by coding/decoding */
-	int curtileno;
-	/** Tile part number*/
-	int tp_num;
-	/** Tilepart number currently coding*/
-	int cur_tp_num;
-	/** Total number of tileparts of the current tile*/
-	int *cur_totnum_tp;
+	OPJ_UINT32 m_state;
 	/**
-	locate the start position of the TLM marker  
-	after encoding the tilepart, a jump (in j2k_write_sod) is done to the TLM marker to store the value of its length. 
-	*/
-	int tlm_start;
-	/** Total num of tile parts in whole image = num tiles* num tileparts in each tile*/
-	/** used in TLMmarker*/
-	int totnum_tp;	
-	/** 
-	locate the position of the end of the tile in the codestream, 
-	used to detect a truncated codestream (in j2k_read_sod)
-	*/
-	unsigned char *eot;
+	 * store decoding parameters common to all tiles (information like COD, COC in main header)
+	 */
+	opj_tcp_t *m_default_tcp;
+	OPJ_BYTE  *m_header_data;
+	OPJ_UINT32 m_header_data_size;
+	/** to tell the tile part length */
+	OPJ_UINT32 m_sot_length;
+	/** Only tiles index in the correct range will be decoded.*/
+	OPJ_UINT32 m_start_tile_x;
+	OPJ_UINT32 m_start_tile_y;
+	OPJ_UINT32 m_end_tile_x;
+	OPJ_UINT32 m_end_tile_y;
 	/**
-	locate the start position of the SOT marker of the current coded tile:  
-	after encoding the tile, a jump (in j2k_write_sod) is done to the SOT marker to store the value of its length. 
-	*/
-	int sot_start;
-	int sod_start;
+	 * Decoded area set by the user
+	 */
+	OPJ_UINT32 m_DA_x0;
+	OPJ_UINT32 m_DA_y0;
+	OPJ_UINT32 m_DA_x1;
+	OPJ_UINT32 m_DA_y1;
+
+	/** Index of the tile to decode (used in get_tile) */
+	OPJ_INT32 m_tile_ind_to_dec;
+	/** Position of the last SOT marker read */
+	OPJ_OFF_T m_last_sot_read_pos;
+
 	/**
-	as the J2K-file is written in several parts during encoding, 
-	it enables to make the right correction in position return by cio_tell
-	*/
-	int pos_correction;
-	/** array used to store the data of each tile */
-	unsigned char **tile_data;
-	/** array used to store the length of each tile */
-	int *tile_len;
-	/** 
-	decompression only : 
-	store decoding parameters common to all tiles (information like COD, COC in main header)
+	 * Indicate that the current tile-part is assume as the last tile part of the codestream.
+	 * It is useful in the case of PSot is equal to zero. The sot length will be compute in the
+	 * SOD reader function. FIXME NOT USED for the moment
+	 */
+	OPJ_BOOL   m_last_tile_part;
+	/** to tell that a tile can be decoded. */
+	OPJ_UINT32 m_can_decode			: 1;
+	OPJ_UINT32 m_discard_tiles		: 1;
+	OPJ_UINT32 m_skip_data			: 1;
+
+} opj_j2k_dec_t;
+
+typedef struct opj_j2k_enc
+{
+	/** Tile part number, regardless of poc, for each new poc, tp is reset to 1*/
+	OPJ_UINT32 m_current_poc_tile_part_number; /* tp_num */
+
+	/** Tile part number currently coding, taking into account POC. m_current_tile_part_number holds the total number of tile parts while encoding the last tile part.*/
+	OPJ_UINT32 m_current_tile_part_number; /*cur_tp_num */
+
+	/**
+	locate the start position of the TLM marker
+	after encoding the tilepart, a jump (in j2k_write_sod) is done to the TLM marker to store the value of its length.
 	*/
-	opj_tcp_t *default_tcp;
-	/** pointer to the encoded / decoded image */
-	opj_image_t *image;
-	/** pointer to the coding parameters */
-	opj_cp_t *cp;
+    OPJ_OFF_T m_tlm_start;
+	/**
+	 * Stores the sizes of the tlm.
+	 */
+	OPJ_BYTE * m_tlm_sot_offsets_buffer;
+	/**
+	 * The current offset of the tlm buffer.
+	 */
+	OPJ_BYTE * m_tlm_sot_offsets_current;
+
+	/** Total num of tile parts in whole image = num tiles* num tileparts in each tile*/
+	/** used in TLMmarker*/
+	OPJ_UINT32 m_total_tile_parts;	 /* totnum_tp */
+
+	/* encoded data for a tile */
+	OPJ_BYTE * m_encoded_tile_data;
+
+	/* size of the encoded_data */
+	OPJ_UINT32 m_encoded_tile_size;
+
+	/* encoded data for a tile */
+	OPJ_BYTE * m_header_tile_data;
+
+	/* size of the encoded_data */
+	OPJ_UINT32 m_header_tile_data_size;
+
+
+} opj_j2k_enc_t;
+
+
+
+struct opj_tcd;
+/**
+JPEG-2000 codestream reader/writer
+*/
+typedef struct opj_j2k
+{
+	/* J2K codestream is decoded*/
+	OPJ_BOOL m_is_decoder;
+
+	/* FIXME DOC*/
+	union
+	{
+		opj_j2k_dec_t m_decoder;
+		opj_j2k_enc_t m_encoder;
+	}
+	m_specific_param;
+
+	/** pointer to the internal/private encoded / decoded image */
+	opj_image_t* m_private_image;
+
+	/* pointer to the output image (decoded)*/
+	opj_image_t* m_output_image;
+
+	/** Coding parameters */
+	opj_cp_t m_cp;
+
+	/** the list of procedures to exec **/
+	opj_procedure_list_t *	m_procedure_list;
+
+	/** the list of validation procedures to follow to make sure the code is valid **/
+	opj_procedure_list_t *	m_validation_list;
+
 	/** helper used to write the index file */
-	opj_codestream_info_t *cstr_info;
-	/** pointer to the byte i/o stream */
-	opj_cio_t *cio;
-} opj_j2k_t;
+	opj_codestream_index_t *cstr_index;
+
+	/** number of the tile curently concern by coding/decoding */
+	OPJ_UINT32 m_current_tile_number;
+
+	/** the current tile coder/decoder **/
+	struct opj_tcd *	m_tcd;
+
+}
+opj_j2k_t;
+
+
+
 
 /** @name Exported functions */
 /*@{*/
 /* ----------------------------------------------------------------------- */
-/**
-Creates a J2K decompression structure
-@param cinfo Codec context info
-@return Returns a handle to a J2K decompressor if successful, returns NULL otherwise
-*/
-opj_j2k_t* j2k_create_decompress(opj_common_ptr cinfo);
-/**
-Destroy a J2K decompressor handle
-@param j2k J2K decompressor handle to destroy
-*/
-void j2k_destroy_decompress(opj_j2k_t *j2k);
+
 /**
 Setup the decoder decoding parameters using user parameters.
 Decoding parameters are returned in j2k->cp. 
 @param j2k J2K decompressor handle
 @param parameters decompression parameters
 */
-void j2k_setup_decoder(opj_j2k_t *j2k, opj_dparameters_t *parameters);
+void opj_j2k_setup_decoder(opj_j2k_t *j2k, opj_dparameters_t *parameters);
+
 /**
-Decode an image from a JPEG-2000 codestream
-@param j2k J2K decompressor handle
-@param cio Input buffer stream
-@param cstr_info Codestream information structure if required, NULL otherwise
-@return Returns a decoded image if successful, returns NULL otherwise
+ * Creates a J2K compression structure
+ *
+ * @return Returns a handle to a J2K compressor if successful, returns NULL otherwise
 */
-opj_image_t* j2k_decode(opj_j2k_t *j2k, opj_cio_t *cio, opj_codestream_info_t *cstr_info);
+opj_j2k_t* opj_j2k_create_compress(void);
+
+
+void opj_j2k_setup_encoder(	opj_j2k_t *p_j2k,
+						    opj_cparameters_t *parameters,
+						    opj_image_t *image,
+						    opj_event_mgr_t * p_manager);
+
 /**
-Decode an image form a JPT-stream (JPEG 2000, JPIP)
-@param j2k J2K decompressor handle
-@param cio Input buffer stream
-@param cstr_info Codestream information structure if required, NULL otherwise
-@return Returns a decoded image if successful, returns NULL otherwise
+Converts an enum type progression order to string type
 */
-opj_image_t* j2k_decode_jpt_stream(opj_j2k_t *j2k, opj_cio_t *cio, opj_codestream_info_t *cstr_info);
+char *opj_j2k_convert_progression_order(OPJ_PROG_ORDER prg_order);
+
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
 /**
-Creates a J2K compression structure
-@param cinfo Codec context info
-@return Returns a handle to a J2K compressor if successful, returns NULL otherwise
-*/
-opj_j2k_t* j2k_create_compress(opj_common_ptr cinfo);
+ * Ends the decompression procedures and possibiliy add data to be read after the
+ * codestream.
+ */
+OPJ_BOOL opj_j2k_end_decompress(opj_j2k_t *j2k,
+                                opj_stream_private_t *p_stream,
+                                opj_event_mgr_t * p_manager);
+
 /**
-Destroy a J2K compressor handle
-@param j2k J2K compressor handle to destroy
-*/
-void j2k_destroy_compress(opj_j2k_t *j2k);
+ * Reads a jpeg2000 codestream header structure.
+ *
+ * @param p_stream the stream to read data from.
+ * @param p_j2k the jpeg2000 codec.
+ * @param p_image FIXME DOC
+ * @param p_manager the user event manager.
+ *
+ * @return true if the box is valid.
+ */
+OPJ_BOOL opj_j2k_read_header(	opj_stream_private_t *p_stream,
+                                opj_j2k_t* p_j2k,
+                                opj_image_t** p_image,
+                                opj_event_mgr_t* p_manager );
+
+
 /**
-Setup the encoder parameters using the current image and using user parameters. 
-Coding parameters are returned in j2k->cp. 
-@param j2k J2K compressor handle
-@param parameters compression parameters
-@param image input filled image
-*/
-void j2k_setup_encoder(opj_j2k_t *j2k, opj_cparameters_t *parameters, opj_image_t *image);
+ * Destroys a jpeg2000 codec.
+ *
+ * @param	p_j2k	the jpeg20000 structure to destroy.
+ */
+void opj_j2k_destroy (opj_j2k_t *p_j2k);
+
 /**
-Converts an enum type progression order to string type
+ * Destroys a codestream index structure.
+ *
+ * @param	p_cstr_ind	the codestream index parameter to destroy.
+ */
+void j2k_destroy_cstr_index (opj_codestream_index_t *p_cstr_ind);
+
+/**
+ * Decode tile data.
+ * @param	p_j2k		the jpeg2000 codec.
+ * @param	p_tile_index
+ * @param p_data       FIXME DOC
+ * @param p_data_size  FIXME DOC
+ * @param	p_stream			the stream to write data to.
+ * @param	p_manager	the user event manager.
+ */
+OPJ_BOOL opj_j2k_decode_tile (  opj_j2k_t * p_j2k,
+                                OPJ_UINT32 p_tile_index,
+                                OPJ_BYTE * p_data,
+                                OPJ_UINT32 p_data_size,
+                                opj_stream_private_t *p_stream,
+                                opj_event_mgr_t * p_manager );
+
+/**
+ * Reads a tile header.
+ * @param	p_j2k		the jpeg2000 codec.
+ * @param	p_tile_index FIXME DOC
+ * @param	p_data_size FIXME DOC
+ * @param	p_tile_x0 FIXME DOC
+ * @param	p_tile_y0 FIXME DOC
+ * @param	p_tile_x1 FIXME DOC
+ * @param	p_tile_y1 FIXME DOC
+ * @param	p_nb_comps FIXME DOC
+ * @param	p_go_on FIXME DOC
+ * @param	p_stream			the stream to write data to.
+ * @param	p_manager	the user event manager.
+ */
+OPJ_BOOL opj_j2k_read_tile_header ( opj_j2k_t * p_j2k,
+                                    OPJ_UINT32 * p_tile_index,
+                                    OPJ_UINT32 * p_data_size,
+                                    OPJ_INT32 * p_tile_x0,
+                                    OPJ_INT32 * p_tile_y0,
+                                    OPJ_INT32 * p_tile_x1,
+                                    OPJ_INT32 * p_tile_y1,
+                                    OPJ_UINT32 * p_nb_comps,
+                                    OPJ_BOOL * p_go_on,
+                                    opj_stream_private_t *p_stream,
+                                    opj_event_mgr_t * p_manager );
+
+
+/**
+ * Sets the given area to be decoded. This function should be called right after opj_read_header and before any tile header reading.
+ *
+ * @param	p_j2k			the jpeg2000 codec.
+ * @param	p_image     FIXME DOC
+ * @param	p_start_x		the left position of the rectangle to decode (in image coordinates).
+ * @param	p_start_y		the up position of the rectangle to decode (in image coordinates).
+ * @param	p_end_x			the right position of the rectangle to decode (in image coordinates).
+ * @param	p_end_y			the bottom position of the rectangle to decode (in image coordinates).
+ * @param	p_manager		the user event manager
+ *
+ * @return	true			if the area could be set.
+ */
+OPJ_BOOL opj_j2k_set_decode_area(	opj_j2k_t *p_j2k,
+								    opj_image_t* p_image,
+								    OPJ_INT32 p_start_x, OPJ_INT32 p_start_y,
+								    OPJ_INT32 p_end_x, OPJ_INT32 p_end_y,
+								    opj_event_mgr_t * p_manager );
+
+/**
+ * Creates a J2K decompression structure.
+ *
+ * @return a handle to a J2K decompressor if successful, NULL otherwise.
+ */
+opj_j2k_t* opj_j2k_create_decompress(void);
+
+
+/**
+ * Dump some elements from the J2K decompression structure .
+ *
+ *@param p_j2k				the jpeg2000 codec.
+ *@param flag				flag to describe what elments are dump.
+ *@param out_stream			output stream where dump the elements.
+ *
 */
-char *j2k_convert_progression_order(OPJ_PROG_ORDER prg_order);
-/**
-Encode an image into a JPEG-2000 codestream
-@param j2k J2K compressor handle
-@param cio Output buffer stream
-@param image Image to encode
-@param cstr_info Codestream information structure if required, NULL otherwise
-@return Returns true if successful, returns false otherwise
+void j2k_dump (opj_j2k_t* p_j2k, OPJ_INT32 flag, FILE* out_stream);
+
+
+
+/**
+ * Dump an image header structure.
+ *
+ *@param image			the image header to dump.
+ *@param dev_dump_flag		flag to describe if we are in the case of this function is use outside j2k_dump function
+ *@param out_stream			output stream where dump the elements.
+ */
+void j2k_dump_image_header(opj_image_t* image, OPJ_BOOL dev_dump_flag, FILE* out_stream);
+
+/**
+ * Dump a component image header structure.
+ *
+ *@param comp		the component image header to dump.
+ *@param dev_dump_flag		flag to describe if we are in the case of this function is use outside j2k_dump function
+ *@param out_stream			output stream where dump the elements.
+ */
+void j2k_dump_image_comp_header(opj_image_comp_t* comp, OPJ_BOOL dev_dump_flag, FILE* out_stream);
+
+/**
+ * Get the codestream info from a JPEG2000 codec.
+ *
+ *@param	p_j2k				the component image header to dump.
+ *
+ *@return	the codestream information extract from the jpg2000 codec
+ */
+opj_codestream_info_v2_t* j2k_get_cstr_info(opj_j2k_t* p_j2k);
+
+/**
+ * Get the codestream index from a JPEG2000 codec.
+ *
+ *@param	p_j2k				the component image header to dump.
+ *
+ *@return	the codestream index extract from the jpg2000 codec
+ */
+opj_codestream_index_t* j2k_get_cstr_index(opj_j2k_t* p_j2k);
+
+/**
+ * Decode an image from a JPEG-2000 codestream
+ * @param j2k J2K decompressor handle
+ * @param p_stream  FIXME DOC
+ * @param p_image   FIXME DOC
+ * @param p_manager FIXME DOC
+ * @return FIXME DOC
 */
-opj_bool j2k_encode(opj_j2k_t *j2k, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info);
+OPJ_BOOL opj_j2k_decode(opj_j2k_t *j2k,
+                        opj_stream_private_t *p_stream,
+                        opj_image_t *p_image,
+                        opj_event_mgr_t *p_manager);
 
-/* ----------------------------------------------------------------------- */
-/*@}*/
 
-/*@}*/
+OPJ_BOOL opj_j2k_get_tile(	opj_j2k_t *p_j2k,
+			    			opj_stream_private_t *p_stream,
+				    		opj_image_t* p_image,
+					    	opj_event_mgr_t * p_manager,
+						    OPJ_UINT32 tile_index );
+
+OPJ_BOOL opj_j2k_set_decoded_resolution_factor(opj_j2k_t *p_j2k, 
+                                               OPJ_UINT32 res_factor,
+                                               opj_event_mgr_t * p_manager);
+
+
+/**
+ * Writes a tile.
+ * @param	p_j2k		the jpeg2000 codec.
+ * @param p_tile_index FIXME DOC
+ * @param p_data FIXME DOC
+ * @param p_data_size FIXME DOC
+ * @param	p_stream			the stream to write data to.
+ * @param	p_manager	the user event manager.
+ */
+OPJ_BOOL opj_j2k_write_tile (	opj_j2k_t * p_j2k,
+							    OPJ_UINT32 p_tile_index,
+							    OPJ_BYTE * p_data,
+							    OPJ_UINT32 p_data_size,
+							    opj_stream_private_t *p_stream,
+							    opj_event_mgr_t * p_manager );
+
+/**
+ * Encodes an image into a JPEG-2000 codestream
+ */
+OPJ_BOOL opj_j2k_encode(	opj_j2k_t * p_j2k,
+			    			opj_stream_private_t *cio,
+				    		opj_event_mgr_t * p_manager );
+
+/**
+ * Starts a compression scheme, i.e. validates the codec parameters, writes the header.
+ *
+ * @param	p_j2k		the jpeg2000 codec.
+ * @param	p_stream			the stream object.
+ * @param	p_image FIXME DOC
+ * @param	p_manager	the user event manager.
+ *
+ * @return true if the codec is valid.
+ */
+OPJ_BOOL opj_j2k_start_compress(opj_j2k_t *p_j2k,
+							    opj_stream_private_t *p_stream,
+							    opj_image_t * p_image,
+							    opj_event_mgr_t * p_manager);
+
+/**
+ * Ends the compression procedures and possibiliy add data to be read after the
+ * codestream.
+ */
+OPJ_BOOL opj_j2k_end_compress( 	opj_j2k_t *p_j2k,
+							    opj_stream_private_t *cio,
+							    opj_event_mgr_t * p_manager);
+
+OPJ_BOOL opj_j2k_setup_mct_encoding (opj_tcp_t * p_tcp, opj_image_t * p_image);
+
 
 #endif /* __J2K_H */
diff --git a/extern/libopenjpeg/j2k_lib.c b/extern/libopenjpeg/j2k_lib.c
deleted file mode 100644
index a66e31e..0000000
--- a/extern/libopenjpeg/j2k_lib.c
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (c) 2005, Herve Drolon, FreeImage Team
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifdef _WIN32
-#include <windows.h>
-#else
-#include <sys/time.h>
-#include <sys/resource.h>
-#include <sys/times.h>
-#endif /* _WIN32 */
-#include "opj_includes.h"
-
-double opj_clock(void) {
-#ifdef _WIN32
-	/* _WIN32: use QueryPerformance (very accurate) */
-    LARGE_INTEGER freq , t ;
-    /* freq is the clock speed of the CPU */
-    QueryPerformanceFrequency(&freq) ;
-	/* cout << "freq = " << ((double) freq.QuadPart) << endl; */
-    /* t is the high resolution performance counter (see MSDN) */
-    QueryPerformanceCounter ( & t ) ;
-    return ( t.QuadPart /(double) freq.QuadPart ) ;
-#else
-	/* Unix or Linux: use resource usage */
-    struct rusage t;
-    double procTime;
-    /* (1) Get the rusage data structure at this moment (man getrusage) */
-    getrusage(0,&t);
-    /* (2) What is the elapsed time ? - CPU time = User time + System time */
-	/* (2a) Get the seconds */
-    procTime = t.ru_utime.tv_sec + t.ru_stime.tv_sec;
-    /* (2b) More precisely! Get the microseconds part ! */
-    return ( procTime + (t.ru_utime.tv_usec + t.ru_stime.tv_usec) * 1e-6 ) ;
-#endif
-}
-
diff --git a/extern/libopenjpeg/j2k_lib.h b/extern/libopenjpeg/j2k_lib.h
deleted file mode 100644
index 5f3406e..0000000
--- a/extern/libopenjpeg/j2k_lib.h
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (c) 2005, Herve Drolon, FreeImage Team
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-#ifndef __J2K_LIB_H
-#define __J2K_LIB_H
-/**
-@file j2k_lib.h
-@brief Internal functions
-
-The functions in J2K_LIB.C are internal utilities mainly used for timing.
-*/
-
-/** @defgroup MISC MISC - Miscellaneous internal functions */
-/*@{*/
-
-/** @name Exported functions */
-/*@{*/
-/* ----------------------------------------------------------------------- */
-
-/**
-Difference in successive opj_clock() calls tells you the elapsed time
-@return Returns time in seconds
-*/
-double opj_clock(void);
-
-/* ----------------------------------------------------------------------- */
-/*@}*/
-
-/*@}*/
-
-#endif /* __J2K_LIB_H */
-
diff --git a/extern/libopenjpeg/jp2.c b/extern/libopenjpeg/jp2.c
index d332260..5c88c4d 100644
--- a/extern/libopenjpeg/jp2.c
+++ b/extern/libopenjpeg/jp2.c
@@ -1,11 +1,19 @@
 /*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2001-2003, David Janssens
  * Copyright (c) 2002-2003, Yannick Verschueren
- * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * Copyright (c) 2003-2014, Antonin Descampe
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
  * Copyright (c) 2010-2011, Kaori Hagihara
+ * Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR 
+ * Copyright (c) 2012, CS Systemes d'Information, France
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -30,160 +38,461 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 #include "opj_includes.h"
-#include <assert.h>
 
 /** @defgroup JP2 JP2 - JPEG-2000 file format reader/writer */
 /*@{*/
 
+#define OPJ_BOX_SIZE	1024
+
 /** @name Local static functions */
 /*@{*/
 
+/*static void jp2_write_url(opj_cio_t *cio, char *Idx_file);*/
+
+/**
+ * Reads a IHDR box - Image Header box
+ *
+ * @param	p_image_header_data			pointer to actual data (already read from file)
+ * @param	jp2							the jpeg2000 file codec.
+ * @param	p_image_header_size			the size of the image header
+ * @param	p_manager					the user event manager.
+ *
+ * @return	true if the image header is valid, false else.
+ */
+static OPJ_BOOL opj_jp2_read_ihdr(  opj_jp2_t *jp2,
+                                    OPJ_BYTE *p_image_header_data,
+                                    OPJ_UINT32 p_image_header_size,
+                                    opj_event_mgr_t * p_manager );
+
 /**
-Read box headers
-@param cinfo Codec context info
-@param cio Input stream
-@param box
-@return Returns true if successful, returns false otherwise
+ * Writes the Image Header box - Image Header box.
+ *
+ * @param jp2					jpeg2000 file codec.
+ * @param p_nb_bytes_written	pointer to store the nb of bytes written by the function.
+ *
+ * @return	the data being copied.
 */
-static opj_bool jp2_read_boxhdr(opj_common_ptr cinfo, opj_cio_t *cio, opj_jp2_box_t *box);
-/*static void jp2_write_url(opj_cio_t *cio, char *Idx_file);*/
+static OPJ_BYTE * opj_jp2_write_ihdr(opj_jp2_t *jp2,
+                                     OPJ_UINT32 * p_nb_bytes_written );
+
 /**
-Read the IHDR box - Image Header box
-@param jp2 JP2 handle
-@param cio Input buffer stream
-@return Returns true if successful, returns false otherwise
+ * Writes the Bit per Component box.
+ *
+ * @param	jp2						jpeg2000 file codec.
+ * @param	p_nb_bytes_written		pointer to store the nb of bytes written by the function.
+ *
+ * @return	the data being copied.
 */
-static opj_bool jp2_read_ihdr(opj_jp2_t *jp2, opj_cio_t *cio);
-static void jp2_write_ihdr(opj_jp2_t *jp2, opj_cio_t *cio);
-static void jp2_write_bpcc(opj_jp2_t *jp2, opj_cio_t *cio);
-static opj_bool jp2_read_bpcc(opj_jp2_t *jp2, opj_cio_t *cio);
-static void jp2_write_colr(opj_jp2_t *jp2, opj_cio_t *cio);
+static OPJ_BYTE * opj_jp2_write_bpcc(	opj_jp2_t *jp2,
+								        OPJ_UINT32 * p_nb_bytes_written );
+
 /**
-Write the FTYP box - File type box
-@param jp2 JP2 handle
-@param cio Output buffer stream
+ * Reads a Bit per Component box.
+ *
+ * @param	p_bpc_header_data			pointer to actual data (already read from file)
+ * @param	jp2							the jpeg2000 file codec.
+ * @param	p_bpc_header_size			the size of the bpc header
+ * @param	p_manager					the user event manager.
+ *
+ * @return	true if the bpc header is valid, fale else.
+ */
+static OPJ_BOOL opj_jp2_read_bpcc(  opj_jp2_t *jp2,
+                                    OPJ_BYTE * p_bpc_header_data,
+                                    OPJ_UINT32 p_bpc_header_size,
+                                    opj_event_mgr_t * p_manager );
+
+static OPJ_BOOL opj_jp2_read_cdef(	opj_jp2_t * jp2,
+                                    OPJ_BYTE * p_cdef_header_data,
+									OPJ_UINT32 p_cdef_header_size,
+									opj_event_mgr_t * p_manager );
+
+static void opj_jp2_apply_cdef(opj_image_t *image, opj_jp2_color_t *color);
+
+/**
+ * Writes the Colour Specification box.
+ *
+ * @param jp2					jpeg2000 file codec.
+ * @param p_nb_bytes_written	pointer to store the nb of bytes written by the function.
+ *
+ * @return	the data being copied.
 */
-static void jp2_write_ftyp(opj_jp2_t *jp2, opj_cio_t *cio);
+static OPJ_BYTE * opj_jp2_write_colr(   opj_jp2_t *jp2,
+									    OPJ_UINT32 * p_nb_bytes_written );
+
+/**
+ * Writes a FTYP box - File type box
+ *
+ * @param	cio			the stream to write data to.
+ * @param	jp2			the jpeg2000 file codec.
+ * @param	p_manager	the user event manager.
+ *
+ * @return	true if writing was successful.
+ */
+static OPJ_BOOL opj_jp2_write_ftyp(	opj_jp2_t *jp2,
+									opj_stream_private_t *cio,
+									opj_event_mgr_t * p_manager );
+
+/**
+ * Reads a a FTYP box - File type box
+ *
+ * @param	p_header_data	the data contained in the FTYP box.
+ * @param	jp2				the jpeg2000 file codec.
+ * @param	p_header_size	the size of the data contained in the FTYP box.
+ * @param	p_manager		the user event manager.
+ *
+ * @return true if the FTYP box is valid.
+ */
+static OPJ_BOOL opj_jp2_read_ftyp(	opj_jp2_t *jp2,
+									OPJ_BYTE * p_header_data,
+									OPJ_UINT32 p_header_size,
+									opj_event_mgr_t * p_manager );
+
+OPJ_BOOL opj_jp2_skip_jp2c(	opj_jp2_t *jp2,
+						    opj_stream_private_t *cio,
+						    opj_event_mgr_t * p_manager );
+
 /**
-Read the FTYP box - File type box
-@param jp2 JP2 handle
-@param cio Input buffer stream
-@return Returns true if successful, returns false otherwise
+ * Reads the Jpeg2000 file Header box - JP2 Header box (warning, this is a super box).
+ *
+ * @param	p_header_data	the data contained in the file header box.
+ * @param	jp2				the jpeg2000 file codec.
+ * @param	p_header_size	the size of the data contained in the file header box.
+ * @param	p_manager		the user event manager.
+ *
+ * @return true if the JP2 Header box was successfully reconized.
 */
-static opj_bool jp2_read_ftyp(opj_jp2_t *jp2, opj_cio_t *cio);
-static int jp2_write_jp2c(opj_jp2_t *jp2, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info);
-static opj_bool jp2_read_jp2c(opj_jp2_t *jp2, opj_cio_t *cio, unsigned int *j2k_codestream_length, unsigned int *j2k_codestream_offset);
-static void jp2_write_jp(opj_cio_t *cio);
+static OPJ_BOOL opj_jp2_read_jp2h(  opj_jp2_t *jp2,
+                                    OPJ_BYTE *p_header_data,
+                                    OPJ_UINT32 p_header_size,
+                                    opj_event_mgr_t * p_manager );
+
 /**
-Read the JP box - JPEG 2000 signature
-@param jp2 JP2 handle
-@param cio Input buffer stream
-@return Returns true if successful, returns false otherwise
+ * Writes the Jpeg2000 codestream Header box - JP2C Header box. This function must be called AFTER the coding has been done.
+ *
+ * @param	cio			the stream to write data to.
+ * @param	jp2			the jpeg2000 file codec.
+ * @param	p_manager	user event manager.
+ *
+ * @return true if writing was successful.
 */
-static opj_bool jp2_read_jp(opj_jp2_t *jp2, opj_cio_t *cio);
+static OPJ_BOOL opj_jp2_write_jp2c(	opj_jp2_t *jp2,
+								    opj_stream_private_t *cio,
+								    opj_event_mgr_t * p_manager );
+
+#ifdef USE_JPIP
 /**
-Decode the structure of a JP2 file
-@param jp2 JP2 handle
-@param cio Input buffer stream
-@param color Collector for profile, cdef and pclr data
-@return Returns true if successful, returns false otherwise
+ * Write index Finder box
+ * @param cio     the stream to write to.
+ * @param	jp2			the jpeg2000 file codec.
+ * @param	p_manager	user event manager.
 */
-static opj_bool jp2_read_struct(opj_jp2_t *jp2, opj_cio_t *cio,
-	opj_jp2_color_t *color);
+static OPJ_BOOL opj_jpip_write_iptr(	opj_jp2_t *jp2,
+								    opj_stream_private_t *cio,
+								    opj_event_mgr_t * p_manager );
+
+/**
+ * Write index Finder box
+ * @param cio     the stream to write to.
+ * @param	jp2			the jpeg2000 file codec.
+ * @param	p_manager	user event manager.
+ */
+static OPJ_BOOL opj_jpip_write_cidx(opj_jp2_t *jp2,
+  opj_stream_private_t *cio,
+  opj_event_mgr_t * p_manager );
+
+/**
+ * Write file Index (superbox)
+ * @param cio     the stream to write to.
+ * @param	jp2			the jpeg2000 file codec.
+ * @param	p_manager	user event manager.
+ */
+static OPJ_BOOL opj_jpip_write_fidx(opj_jp2_t *jp2,
+  opj_stream_private_t *cio,
+  opj_event_mgr_t * p_manager );
+#endif /* USE_JPIP */
+
+/**
+ * Reads a jpeg2000 file signature box.
+ *
+ * @param	p_header_data	the data contained in the signature box.
+ * @param	jp2				the jpeg2000 file codec.
+ * @param	p_header_size	the size of the data contained in the signature box.
+ * @param	p_manager		the user event manager.
+ *
+ * @return true if the file signature box is valid.
+ */
+static OPJ_BOOL opj_jp2_read_jp(opj_jp2_t *jp2,
+                                OPJ_BYTE * p_header_data,
+                                OPJ_UINT32 p_header_size,
+                                opj_event_mgr_t * p_manager);
+
+/**
+ * Writes a jpeg2000 file signature box.
+ *
+ * @param cio the stream to write data to.
+ * @param	jp2			the jpeg2000 file codec.
+ * @param p_manager the user event manager.
+ *
+ * @return true if writing was successful.
+ */
+static OPJ_BOOL opj_jp2_write_jp(	opj_jp2_t *jp2,
+			    	        	    opj_stream_private_t *cio,
+				            		opj_event_mgr_t * p_manager );
+
 /**
 Apply collected palette data
 @param color Collector for profile, cdef and pclr data
-@param image 
+@param image
 */
-static void jp2_apply_pclr(opj_jp2_color_t *color, opj_image_t *image, opj_common_ptr cinfo);
+static void opj_jp2_apply_pclr(opj_image_t *image, opj_jp2_color_t *color);
+
+static void opj_jp2_free_pclr(opj_jp2_color_t *color);
+
 /**
-Collect palette data
-@param jp2 JP2 handle
-@param cio Input buffer stream
-@param box
-@param color Collector for profile, cdef and pclr data
-@return Returns true if successful, returns false otherwise
+ * Collect palette data
+ *
+ * @param jp2 JP2 handle
+ * @param p_pclr_header_data    FIXME DOC
+ * @param p_pclr_header_size    FIXME DOC
+ * @param p_manager
+ *
+ * @return Returns true if successful, returns false otherwise
 */
-static opj_bool jp2_read_pclr(opj_jp2_t *jp2, opj_cio_t *cio,
-    opj_jp2_box_t *box, opj_jp2_color_t *color);
+static OPJ_BOOL opj_jp2_read_pclr(	opj_jp2_t *jp2,
+                                    OPJ_BYTE * p_pclr_header_data,
+                                    OPJ_UINT32 p_pclr_header_size,
+                                    opj_event_mgr_t * p_manager );
+
 /**
-Collect component mapping data
-@param jp2 JP2 handle
-@param cio Input buffer stream
-@param box
-@param color Collector for profile, cdef and pclr data
-@return Returns true if successful, returns false otherwise
+ * Collect component mapping data
+ *
+ * @param jp2                 JP2 handle
+ * @param p_cmap_header_data  FIXME DOC
+ * @param p_cmap_header_size  FIXME DOC
+ * @param p_manager           FIXME DOC
+ *
+ * @return Returns true if successful, returns false otherwise
 */
-static opj_bool jp2_read_cmap(opj_jp2_t *jp2, opj_cio_t *cio,
-    opj_jp2_box_t *box, opj_jp2_color_t *color);
+
+static OPJ_BOOL opj_jp2_read_cmap(	opj_jp2_t * jp2,
+                                    OPJ_BYTE * p_cmap_header_data,
+                                    OPJ_UINT32 p_cmap_header_size,
+                                    opj_event_mgr_t * p_manager );
+
 /**
-Collect colour specification data
-@param jp2 JP2 handle
-@param cio Input buffer stream
-@param box
-@param color Collector for profile, cdef and pclr data
-@return Returns true if successful, returns false otherwise
+ * Reads the Color Specification box.
+ *
+ * @param	p_colr_header_data			pointer to actual data (already read from file)
+ * @param	jp2							the jpeg2000 file codec.
+ * @param	p_colr_header_size			the size of the color header
+ * @param	p_manager					the user event manager.
+ *
+ * @return	true if the bpc header is valid, fale else.
 */
-static opj_bool jp2_read_colr(opj_jp2_t *jp2, opj_cio_t *cio,
-    opj_jp2_box_t *box, opj_jp2_color_t *color);
+static OPJ_BOOL opj_jp2_read_colr(  opj_jp2_t *jp2,
+                                    OPJ_BYTE * p_colr_header_data,
+                                    OPJ_UINT32 p_colr_header_size,
+                                    opj_event_mgr_t * p_manager );
+
+/*@}*/
+
+/*@}*/
+
 /**
-Write file Index (superbox)
-@param[in] offset_jp2c offset of jp2c box
-@param[in] length_jp2c length of jp2c box
-@param[in] offset_idx  offset of cidx box
-@param[in] length_idx  length of cidx box
-@param[in] cio         file output handle
-@return                length of fidx box
-*/
-static int write_fidx( int offset_jp2c, int length_jp2c, int offset_idx, int length_idx, opj_cio_t *cio);
+ * Sets up the procedures to do on writing header after the codestream.
+ * Developpers wanting to extend the library can add their own writing procedures.
+ */
+static void opj_jp2_setup_end_header_writing (opj_jp2_t *jp2);
+
+/**
+ * Sets up the procedures to do on reading header after the codestream.
+ * Developpers wanting to extend the library can add their own writing procedures.
+ */
+static void opj_jp2_setup_end_header_reading (opj_jp2_t *jp2);
+
+/**
+ * Reads a jpeg2000 file header structure.
+ *
+ * @param jp2 the jpeg2000 file header structure.
+ * @param stream the stream to read data from.
+ * @param p_manager the user event manager.
+ *
+ * @return true if the box is valid.
+ */
+static OPJ_BOOL opj_jp2_read_header_procedure(  opj_jp2_t *jp2,
+                                                opj_stream_private_t *stream,
+                                                opj_event_mgr_t * p_manager );
+
+/**
+ * Excutes the given procedures on the given codec.
+ *
+ * @param	p_procedure_list	the list of procedures to execute
+ * @param	jp2					the jpeg2000 file codec to execute the procedures on.
+ * @param	stream					the stream to execute the procedures on.
+ * @param	p_manager			the user manager.
+ *
+ * @return	true				if all the procedures were successfully executed.
+ */
+static OPJ_BOOL opj_jp2_exec (  opj_jp2_t * jp2,
+                                opj_procedure_list_t * p_procedure_list,
+                                opj_stream_private_t *stream,
+                                opj_event_mgr_t * p_manager );
+
 /**
-Write index Finder box
-@param[in] offset offset of fidx box
-@param[in] length length of fidx box
-@param[in] cio         file output handle
+ * Reads a box header. The box is the way data is packed inside a jpeg2000 file structure.
+ *
+ * @param	cio						the input stream to read data from.
+ * @param	box						the box structure to fill.
+ * @param	p_number_bytes_read		pointer to an int that will store the number of bytes read from the stream (shoul usually be 2).
+ * @param	p_manager				user event manager.
+ *
+ * @return	true if the box is reconized, false otherwise
 */
-static void write_iptr( int offset, int length, opj_cio_t *cio);
+static OPJ_BOOL opj_jp2_read_boxhdr(opj_jp2_box_t *box,
+                                    OPJ_UINT32 * p_number_bytes_read,
+                                    opj_stream_private_t *cio,
+                                    opj_event_mgr_t * p_manager);
+
+/**
+ * Sets up the validation ,i.e. adds the procedures to lauch to make sure the codec parameters
+ * are valid. Developpers wanting to extend the library can add their own validation procedures.
+ */
+static void opj_jp2_setup_encoding_validation (opj_jp2_t *jp2);
+
+/**
+ * Sets up the procedures to do on writing header. Developpers wanting to extend the library can add their own writing procedures.
+ */
+static void opj_jp2_setup_header_writing (opj_jp2_t *jp2);
+
+OPJ_BOOL opj_jp2_default_validation (	opj_jp2_t * jp2,
+                                        opj_stream_private_t *cio,
+                                        opj_event_mgr_t * p_manager );
+
+/**
+ * Finds the image execution function related to the given box id.
+ *
+ * @param	p_id	the id of the handler to fetch.
+ *
+ * @return	the given handler or NULL if it could not be found.
+ */
+static const opj_jp2_header_handler_t * opj_jp2_img_find_handler (OPJ_UINT32 p_id);
+
+/**
+ * Finds the execution function related to the given box id.
+ *
+ * @param	p_id	the id of the handler to fetch.
+ *
+ * @return	the given handler or NULL if it could not be found.
+ */
+static const opj_jp2_header_handler_t * opj_jp2_find_handler (OPJ_UINT32 p_id );
+
+const opj_jp2_header_handler_t jp2_header [] =
+{
+	{JP2_JP,opj_jp2_read_jp},
+	{JP2_FTYP,opj_jp2_read_ftyp},
+	{JP2_JP2H,opj_jp2_read_jp2h}
+};
+
+const opj_jp2_header_handler_t jp2_img_header [] =
+{
+	{JP2_IHDR,opj_jp2_read_ihdr},
+	{JP2_COLR,opj_jp2_read_colr},
+	{JP2_BPCC,opj_jp2_read_bpcc},
+	{JP2_PCLR,opj_jp2_read_pclr},
+	{JP2_CMAP,opj_jp2_read_cmap},
+	{JP2_CDEF,opj_jp2_read_cdef}
+
+};
+
 /**
-Write proxy box
-@param[in] offset_jp2c offset of jp2c box
-@param[in] length_jp2c length of jp2c box
-@param[in] offset_idx  offset of cidx box
-@param[in] length_idx  length of cidx box
-@param[in] cio         file output handle
+ * Reads a box header. The box is the way data is packed inside a jpeg2000 file structure. Data is read from a character string
+ *
+ * @param	box						the box structure to fill.
+ * @param	p_data					the character string to read data from.
+ * @param	p_number_bytes_read		pointer to an int that will store the number of bytes read from the stream (shoul usually be 2).
+ * @param	p_box_max_size			the maximum number of bytes in the box.
+ * @param	p_manager         FIXME DOC
+ *
+ * @return	true if the box is reconized, false otherwise
 */
-static void write_prxy( int offset_jp2c, int length_jp2c, int offset_idx, int length_idx, opj_cio_t *cio);
-/*@}*/
+static OPJ_BOOL opj_jp2_read_boxhdr_char(   opj_jp2_box_t *box,
+                                            OPJ_BYTE * p_data,
+                                            OPJ_UINT32 * p_number_bytes_read,
+                                            OPJ_UINT32 p_box_max_size,
+                                            opj_event_mgr_t * p_manager );
 
-/*@}*/
+/**
+ * Sets up the validation ,i.e. adds the procedures to lauch to make sure the codec parameters
+ * are valid. Developpers wanting to extend the library can add their own validation procedures.
+ */
+static void opj_jp2_setup_decoding_validation (opj_jp2_t *jp2);
+
+/**
+ * Sets up the procedures to do on reading header.
+ * Developpers wanting to extend the library can add their own writing procedures.
+ */
+static void opj_jp2_setup_header_reading (opj_jp2_t *jp2);
 
 /* ----------------------------------------------------------------------- */
+ OPJ_BOOL opj_jp2_read_boxhdr(opj_jp2_box_t *box,
+                              OPJ_UINT32 * p_number_bytes_read,
+                              opj_stream_private_t *cio,
+                              opj_event_mgr_t * p_manager )
+{
+	/* read header from file */
+	OPJ_BYTE l_data_header [8];
+
+	/* preconditions */
+	assert(cio != 00);
+	assert(box != 00);
+	assert(p_number_bytes_read != 00);
+	assert(p_manager != 00);
+
+	*p_number_bytes_read = (OPJ_UINT32)opj_stream_read_data(cio,l_data_header,8,p_manager);
+	if (*p_number_bytes_read != 8) {
+		return OPJ_FALSE;
+	}
+
+	/* process read data */
+	opj_read_bytes(l_data_header,&(box->length), 4);
+	opj_read_bytes(l_data_header+4,&(box->type), 4);
+    
+  if(box->length == 0)/* last box */
+    {
+    const OPJ_OFF_T bleft = opj_stream_get_number_byte_left(cio);
+    box->length = (OPJ_UINT32)bleft;
+    assert( (OPJ_OFF_T)box->length == bleft );
+    return OPJ_TRUE;
+    }
 
-static opj_bool jp2_read_boxhdr(opj_common_ptr cinfo, opj_cio_t *cio, opj_jp2_box_t *box) {
-	box->init_pos = cio_tell(cio);
-	box->length = cio_read(cio, 4);
-	box->type = cio_read(cio, 4);
+	/* do we have a "special very large box ?" */
+	/* read then the XLBox */
 	if (box->length == 1) {
-		if (cio_read(cio, 4) != 0) {
-			opj_event_msg(cinfo, EVT_ERROR, "Cannot handle box sizes higher than 2^32\n");
+		OPJ_UINT32 l_xl_part_size;
+
+		OPJ_UINT32 l_nb_bytes_read = (OPJ_UINT32)opj_stream_read_data(cio,l_data_header,8,p_manager);
+		if (l_nb_bytes_read != 8) {
+			if (l_nb_bytes_read > 0) {
+				*p_number_bytes_read += l_nb_bytes_read;
+			}
+
 			return OPJ_FALSE;
 		}
-		box->length = cio_read(cio, 4);
-		if (box->length == 0) 
-			box->length = cio_numbytesleft(cio) + 12;
-	}
-	else if (box->length == 0) {
-		box->length = cio_numbytesleft(cio) + 8;
-	} else if (box->length < 0) {
-		opj_event_msg(cinfo, EVT_ERROR, "Integer overflow in box->length\n");
-		return OPJ_FALSE; /* TODO: actually check jp2_read_boxhdr's return value */
+
+        *p_number_bytes_read = 16;
+		opj_read_bytes(l_data_header,&l_xl_part_size, 4);
+		if (l_xl_part_size != 0) {
+			opj_event_msg(p_manager, EVT_ERROR, "Cannot handle box sizes higher than 2^32\n");
+			return OPJ_FALSE;
+		}
+		opj_read_bytes(l_data_header+4,&(box->length), 4);
 	}
-	
-	return OPJ_TRUE;
+    return OPJ_TRUE;
 }
 
 #if 0
 static void jp2_write_url(opj_cio_t *cio, char *Idx_file) {
-	unsigned int i;
+	OPJ_UINT32 i;
 	opj_jp2_box_t box;
 
 	box.init_pos = cio_tell(cio);
@@ -205,131 +514,242 @@ static void jp2_write_url(opj_cio_t *cio, char *Idx_file) {
 }
 #endif
 
-static opj_bool jp2_read_ihdr(opj_jp2_t *jp2, opj_cio_t *cio) {
-	opj_jp2_box_t box;
-
-	opj_common_ptr cinfo = jp2->cinfo;
+OPJ_BOOL opj_jp2_read_ihdr( opj_jp2_t *jp2,
+                            OPJ_BYTE *p_image_header_data,
+                            OPJ_UINT32 p_image_header_size,
+                            opj_event_mgr_t * p_manager )
+{
+	/* preconditions */
+	assert(p_image_header_data != 00);
+	assert(jp2 != 00);
+	assert(p_manager != 00);
 
-  if(jp2_read_boxhdr(cinfo, cio, &box) == OPJ_FALSE ) {
-    opj_event_msg(cinfo, EVT_ERROR, "Failed to read boxhdr\n");
-    return OPJ_FALSE;
-  }
-	if (JP2_IHDR != box.type) {
-		opj_event_msg(cinfo, EVT_ERROR, "Expected IHDR Marker\n");
+	if (p_image_header_size != 14) {
+		opj_event_msg(p_manager, EVT_ERROR, "Bad image header box (bad size)\n");
 		return OPJ_FALSE;
 	}
 
-	jp2->h = cio_read(cio, 4);			/* HEIGHT */
-	jp2->w = cio_read(cio, 4);			/* WIDTH */
-	jp2->numcomps = cio_read(cio, 2);	/* NC */
+	opj_read_bytes(p_image_header_data,&(jp2->h),4);			/* HEIGHT */
+	p_image_header_data += 4;
+	opj_read_bytes(p_image_header_data,&(jp2->w),4);			/* WIDTH */
+	p_image_header_data += 4;
+	opj_read_bytes(p_image_header_data,&(jp2->numcomps),2);		/* NC */
+	p_image_header_data += 2;
+
+	/* allocate memory for components */
 	jp2->comps = (opj_jp2_comps_t*) opj_malloc(jp2->numcomps * sizeof(opj_jp2_comps_t));
+	if (jp2->comps == 0) {
+		opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to handle image header (ihdr)\n");
+		return OPJ_FALSE;
+	}
+	memset(jp2->comps,0,jp2->numcomps * sizeof(opj_jp2_comps_t));
 
-	jp2->bpc = cio_read(cio, 1);		/* BPC */
+	opj_read_bytes(p_image_header_data,&(jp2->bpc),1);			/* BPC */
+	++ p_image_header_data;
 
-	jp2->C = cio_read(cio, 1);			/* C */
-	jp2->UnkC = cio_read(cio, 1);		/* UnkC */
-	jp2->IPR = cio_read(cio, 1);		/* IPR */
+	opj_read_bytes(p_image_header_data,&(jp2->C),1);			/* C */
+	++ p_image_header_data;
 
-	if (cio_tell(cio) - box.init_pos != box.length) {
-		opj_event_msg(cinfo, EVT_ERROR, "Error with IHDR Box\n");
-		return OPJ_FALSE;
+	/* Should be equal to 7 cf. chapter about image header box of the norm */
+	if (jp2->C != 7){
+		opj_event_msg(p_manager, EVT_INFO, "JP2 IHDR box: compression type indicate that the file is not a conforming JP2 file (%d) \n", jp2->C);
 	}
 
+	opj_read_bytes(p_image_header_data,&(jp2->UnkC),1);			/* UnkC */
+	++ p_image_header_data;
+	opj_read_bytes(p_image_header_data,&(jp2->IPR),1);			/* IPR */
+	++ p_image_header_data;
+
 	return OPJ_TRUE;
 }
 
-static void jp2_write_ihdr(opj_jp2_t *jp2, opj_cio_t *cio) {
-	opj_jp2_box_t box;
-
-	box.init_pos = cio_tell(cio);
-	cio_skip(cio, 4);
-	cio_write(cio, JP2_IHDR, 4);		/* IHDR */
+OPJ_BYTE * opj_jp2_write_ihdr(opj_jp2_t *jp2,
+                              OPJ_UINT32 * p_nb_bytes_written
+                              )
+{
+	OPJ_BYTE * l_ihdr_data,* l_current_ihdr_ptr;
+	
+	/* preconditions */
+	assert(jp2 != 00);
+	assert(p_nb_bytes_written != 00);
+
+	/* default image header is 22 bytes wide */
+	l_ihdr_data = (OPJ_BYTE *) opj_malloc(22);
+	if (l_ihdr_data == 00) {
+		return 00;
+	}
+	memset(l_ihdr_data,0,22);
 
-	cio_write(cio, jp2->h, 4);			/* HEIGHT */
-	cio_write(cio, jp2->w, 4);			/* WIDTH */
-	cio_write(cio, jp2->numcomps, 2);	/* NC */
+	l_current_ihdr_ptr = l_ihdr_data;
+	
+	opj_write_bytes(l_current_ihdr_ptr,22,4);				/* write box size */
+	l_current_ihdr_ptr+=4;
 
-	cio_write(cio, jp2->bpc, 1);		/* BPC */
+	opj_write_bytes(l_current_ihdr_ptr,JP2_IHDR, 4);		/* IHDR */
+	l_current_ihdr_ptr+=4;
+	
+	opj_write_bytes(l_current_ihdr_ptr,jp2->h, 4);		/* HEIGHT */
+	l_current_ihdr_ptr+=4;
+	
+	opj_write_bytes(l_current_ihdr_ptr, jp2->w, 4);		/* WIDTH */
+	l_current_ihdr_ptr+=4;
+	
+	opj_write_bytes(l_current_ihdr_ptr, jp2->numcomps, 2);		/* NC */
+	l_current_ihdr_ptr+=2;
+	
+	opj_write_bytes(l_current_ihdr_ptr, jp2->bpc, 1);		/* BPC */
+	++l_current_ihdr_ptr;
+	
+	opj_write_bytes(l_current_ihdr_ptr, jp2->C, 1);		/* C : Always 7 */
+	++l_current_ihdr_ptr;
+	
+	opj_write_bytes(l_current_ihdr_ptr, jp2->UnkC, 1);		/* UnkC, colorspace unknown */
+	++l_current_ihdr_ptr;
+	
+	opj_write_bytes(l_current_ihdr_ptr, jp2->IPR, 1);		/* IPR, no intellectual property */
+	++l_current_ihdr_ptr;
+	
+	*p_nb_bytes_written = 22;
+	
+	return l_ihdr_data;
+}
 
-	cio_write(cio, jp2->C, 1);			/* C : Always 7 */
-	cio_write(cio, jp2->UnkC, 1);		/* UnkC, colorspace unknown */
-	cio_write(cio, jp2->IPR, 1);		/* IPR, no intellectual property */
+OPJ_BYTE * opj_jp2_write_bpcc(	opj_jp2_t *jp2,
+						        OPJ_UINT32 * p_nb_bytes_written
+                                )
+{
+	OPJ_UINT32 i;
+	/* room for 8 bytes for box and 1 byte for each component */
+	OPJ_UINT32 l_bpcc_size = 8 + jp2->numcomps;
+	OPJ_BYTE * l_bpcc_data,* l_current_bpcc_ptr;
+	
+	/* preconditions */
+	assert(jp2 != 00);
+	assert(p_nb_bytes_written != 00);
 
-	box.length = cio_tell(cio) - box.init_pos;
-	cio_seek(cio, box.init_pos);
-	cio_write(cio, box.length, 4);	/* L */
-	cio_seek(cio, box.init_pos + box.length);
-}
+	l_bpcc_data = (OPJ_BYTE *) opj_malloc(l_bpcc_size);
+	if (l_bpcc_data == 00) {
+		return 00;
+	}
+	memset(l_bpcc_data,0,l_bpcc_size);
 
-static void jp2_write_bpcc(opj_jp2_t *jp2, opj_cio_t *cio) {
-	unsigned int i;
-	opj_jp2_box_t box;
+	l_current_bpcc_ptr = l_bpcc_data;
 
-	box.init_pos = cio_tell(cio);
-	cio_skip(cio, 4);
-	cio_write(cio, JP2_BPCC, 4);	/* BPCC */
+	opj_write_bytes(l_current_bpcc_ptr,l_bpcc_size,4);				/* write box size */
+	l_current_bpcc_ptr += 4;
+	
+	opj_write_bytes(l_current_bpcc_ptr,JP2_BPCC,4);					/* BPCC */
+	l_current_bpcc_ptr += 4;
 
-	for (i = 0; i < jp2->numcomps; i++) {
-		cio_write(cio, jp2->comps[i].bpcc, 1);
+	for (i = 0; i < jp2->numcomps; ++i)  {
+		opj_write_bytes(l_current_bpcc_ptr, jp2->comps[i].bpcc, 1); /* write each component information */
+		++l_current_bpcc_ptr;
 	}
 
-	box.length = cio_tell(cio) - box.init_pos;
-	cio_seek(cio, box.init_pos);
-	cio_write(cio, box.length, 4);	/* L */
-	cio_seek(cio, box.init_pos + box.length);
+	*p_nb_bytes_written = l_bpcc_size;
+	
+	return l_bpcc_data;
 }
 
+OPJ_BOOL opj_jp2_read_bpcc( opj_jp2_t *jp2,
+                            OPJ_BYTE * p_bpc_header_data,
+                            OPJ_UINT32 p_bpc_header_size,
+                            opj_event_mgr_t * p_manager
+                            )
+{
+	OPJ_UINT32 i;
 
-static opj_bool jp2_read_bpcc(opj_jp2_t *jp2, opj_cio_t *cio) {
-	unsigned int i;
-	opj_jp2_box_t box;
-
-	opj_common_ptr cinfo = jp2->cinfo;
+	/* preconditions */
+	assert(p_bpc_header_data != 00);
+	assert(jp2 != 00);
+	assert(p_manager != 00);
 
-  if( jp2_read_boxhdr(cinfo, cio, &box) == OPJ_FALSE ) {
-    opj_event_msg(cinfo, EVT_ERROR, "Failed to read boxhdr\n");
-    return OPJ_FALSE;
-  }
-	if (JP2_BPCC != box.type) {
-		opj_event_msg(cinfo, EVT_ERROR, "Expected BPCC Marker\n");
-		return OPJ_FALSE;
+	
+	if (jp2->bpc != 255 ){
+		opj_event_msg(p_manager, EVT_WARNING, "A BPCC header box is available although BPC given by the IHDR box (%d) indicate components bit depth is constant\n",jp2->bpc);
 	}
 
-	for (i = 0; i < jp2->numcomps; i++) {
-		jp2->comps[i].bpcc = cio_read(cio, 1);
+	/* and length is relevant */
+	if (p_bpc_header_size != jp2->numcomps) {
+		opj_event_msg(p_manager, EVT_ERROR, "Bad BPCC header box (bad size)\n");
+		return OPJ_FALSE;
 	}
 
-	if (cio_tell(cio) - box.init_pos != box.length) {
-		opj_event_msg(cinfo, EVT_ERROR, "Error with BPCC Box\n");
-		return OPJ_FALSE;
+	/* read info for each component */
+	for (i = 0; i < jp2->numcomps; ++i) {
+		opj_read_bytes(p_bpc_header_data,&jp2->comps[i].bpcc ,1);	/* read each BPCC component */
+		++p_bpc_header_data;
 	}
 
 	return OPJ_TRUE;
 }
 
-static void jp2_write_colr(opj_jp2_t *jp2, opj_cio_t *cio) {
-	opj_jp2_box_t box;
-
-	box.init_pos = cio_tell(cio);
-	cio_skip(cio, 4);
-	cio_write(cio, JP2_COLR, 4);		/* COLR */
-
-	cio_write(cio, jp2->meth, 1);		/* METH */
-	cio_write(cio, jp2->precedence, 1);	/* PRECEDENCE */
-	cio_write(cio, jp2->approx, 1);		/* APPROX */
+OPJ_BYTE * opj_jp2_write_colr(  opj_jp2_t *jp2,
+							    OPJ_UINT32 * p_nb_bytes_written
+                                )
+{
+	/* room for 8 bytes for box 3 for common data and variable upon profile*/
+	OPJ_UINT32 l_colr_size = 11;
+	OPJ_BYTE * l_colr_data,* l_current_colr_ptr;
+	
+	/* preconditions */
+	assert(jp2 != 00);
+	assert(p_nb_bytes_written != 00);
+    assert(jp2->meth == 1 || jp2->meth == 2);
+
+	switch (jp2->meth) { 
+		case 1 :
+			l_colr_size += 4; /* EnumCS */
+			break;
+		case 2 :
+            assert(jp2->color.icc_profile_len);	/* ICC profile */
+            l_colr_size += jp2->color.icc_profile_len;
+			break;
+		default :
+			return 00;
+	}
 
-	if(jp2->meth == 2)
-	 jp2->enumcs = 0;
+	l_colr_data = (OPJ_BYTE *) opj_malloc(l_colr_size);
+	if (l_colr_data == 00) {
+		return 00;
+	}
+	memset(l_colr_data,0,l_colr_size);
+	
+	l_current_colr_ptr = l_colr_data;
 
-	cio_write(cio, jp2->enumcs, 4);	/* EnumCS */
+	opj_write_bytes(l_current_colr_ptr,l_colr_size,4);				/* write box size */
+	l_current_colr_ptr += 4;
+	
+	opj_write_bytes(l_current_colr_ptr,JP2_COLR,4);					/* BPCC */
+	l_current_colr_ptr += 4;
+	
+	opj_write_bytes(l_current_colr_ptr, jp2->meth,1);				/* METH */
+	++l_current_colr_ptr;
+	
+	opj_write_bytes(l_current_colr_ptr, jp2->precedence,1);			/* PRECEDENCE */
+	++l_current_colr_ptr;
+	
+	opj_write_bytes(l_current_colr_ptr, jp2->approx,1);				/* APPROX */
+	++l_current_colr_ptr;
+	
+	if (jp2->meth == 1) { /* Meth value is restricted to 1 or 2 (Table I.9 of part 1) */
+        opj_write_bytes(l_current_colr_ptr, jp2->enumcs,4); }       /* EnumCS */
+    else {
+        if (jp2->meth == 2) {                                      /* ICC profile */
+            OPJ_UINT32 i;
+            for(i = 0; i < jp2->color.icc_profile_len; ++i) {
+                opj_write_bytes(l_current_colr_ptr, jp2->color.icc_profile_buf[i], 1);
+                ++l_current_colr_ptr;
+            }
+        }
+	}
 
-	box.length = cio_tell(cio) - box.init_pos;
-	cio_seek(cio, box.init_pos);
-	cio_write(cio, box.length, 4);	/* L */
-	cio_seek(cio, box.init_pos + box.length);
+	*p_nb_bytes_written = l_colr_size;
+	
+	return l_colr_data;
 }
 
-static void jp2_free_pclr(opj_jp2_color_t *color)
+void opj_jp2_free_pclr(opj_jp2_color_t *color)
 {
     opj_free(color->jp2_pclr->channel_sign);
     opj_free(color->jp2_pclr->channel_size);
@@ -340,986 +760,2023 @@ static void jp2_free_pclr(opj_jp2_color_t *color)
     opj_free(color->jp2_pclr); color->jp2_pclr = NULL;
 }
 
-static void free_color_data(opj_jp2_color_t *color)
+static OPJ_BOOL opj_jp2_check_color(opj_image_t *image, opj_jp2_color_t *color, opj_event_mgr_t *p_manager)
 {
-	if(color->jp2_pclr)
-   {
-	jp2_free_pclr(color);
-   }
-	if(color->jp2_cdef) 
-   {
-	if(color->jp2_cdef->info) opj_free(color->jp2_cdef->info);
-	opj_free(color->jp2_cdef);
-   }
-	if(color->icc_profile_buf) opj_free(color->icc_profile_buf);
-}
-
-static void jp2_apply_pclr(opj_jp2_color_t *color, opj_image_t *image, opj_common_ptr cinfo)
-{
-	opj_image_comp_t *old_comps, *new_comps;
-	unsigned char *channel_size, *channel_sign;
-	unsigned int *entries;
-	opj_jp2_cmap_comp_t *cmap;
-	int *src, *dst;
-	unsigned int j, max;
-	unsigned short i, nr_channels, cmp, pcol;
-	int k, top_k;
+	OPJ_UINT16 i;
 
-	channel_size = color->jp2_pclr->channel_size;
-	channel_sign = color->jp2_pclr->channel_sign;
-	entries = color->jp2_pclr->entries;
-	cmap = color->jp2_pclr->cmap;
-	nr_channels = color->jp2_pclr->nr_channels;
+	/* testcase 4149.pdf.SIGSEGV.cf7.3501 */
+	if (color->jp2_cdef) {
+		opj_jp2_cdef_info_t *info = color->jp2_cdef->info;
+		OPJ_UINT16 n = color->jp2_cdef->n;
 
-	old_comps = image->comps;
-	new_comps = (opj_image_comp_t*)
-	 opj_malloc(nr_channels * sizeof(opj_image_comp_t));
+		for (i = 0; i < n; i++) {
+			if (info[i].cn >= image->numcomps) {
+				opj_event_msg(p_manager, EVT_ERROR, "Invalid component index %d (>= %d).\n", info[i].cn, image->numcomps);
+				return OPJ_FALSE;
+			}
+			if (info[i].asoc > 0 && (OPJ_UINT32)(info[i].asoc - 1) >= image->numcomps) {
+				opj_event_msg(p_manager, EVT_ERROR, "Invalid component index %d (>= %d).\n", info[i].asoc - 1, image->numcomps);
+				return OPJ_FALSE;
+			}
+		}
+	}
 
-	for(i = 0; i < nr_channels; ++i)
-   {
-	pcol = cmap[i].pcol; cmp = cmap[i].cmp;
+	/* testcases 451.pdf.SIGSEGV.f4c.3723, 451.pdf.SIGSEGV.5b5.3723 and
+	   66ea31acbb0f23a2bbc91f64d69a03f5_signal_sigsegv_13937c0_7030_5725.pdf */
+	if (color->jp2_pclr && color->jp2_pclr->cmap) {
+		OPJ_UINT16 nr_channels = color->jp2_pclr->nr_channels;
+		opj_jp2_cmap_comp_t *cmap = color->jp2_pclr->cmap;
+		OPJ_BOOL *pcol_usage, is_sane = OPJ_TRUE;
 
-  if( pcol < nr_channels )
-    new_comps[pcol] = old_comps[cmp];
-  else
-    {
-    opj_event_msg(cinfo, EVT_ERROR, "Error with pcol value %d (max: %d). skipping\n", pcol, nr_channels);
-    continue;
-    }
+		/* verify that all original components match an existing one */
+		for (i = 0; i < nr_channels; i++) {
+			if (cmap[i].cmp >= image->numcomps) {
+				opj_event_msg(p_manager, EVT_ERROR, "Invalid component index %d (>= %d).\n", cmap[i].cmp, image->numcomps);
+				is_sane = OPJ_FALSE;
+			}
+		}
+
+		pcol_usage = opj_calloc(nr_channels, sizeof(OPJ_BOOL));
+		if (!pcol_usage) {
+			opj_event_msg(p_manager, EVT_ERROR, "Unexpected OOM.\n");
+			return OPJ_FALSE;
+		}
+		/* verify that no component is targeted more than once */
+		for (i = 0; i < nr_channels; i++) {
+      OPJ_UINT16 pcol = cmap[i].pcol;
+      assert(cmap[i].mtyp == 0 || cmap[i].mtyp == 1);
+			if (pcol >= nr_channels) {
+				opj_event_msg(p_manager, EVT_ERROR, "Invalid component/palette index for direct mapping %d.\n", pcol);
+				is_sane = OPJ_FALSE;
+			}
+			else if (pcol_usage[pcol] && cmap[i].mtyp == 1) {
+				opj_event_msg(p_manager, EVT_ERROR, "Component %d is mapped twice.\n", pcol);
+				is_sane = OPJ_FALSE;
+			}
+      else if (cmap[i].mtyp == 0 && cmap[i].pcol != 0) {
+        /* I.5.3.5 PCOL: If the value of the MTYP field for this channel is 0, then
+         * the value of this field shall be 0. */
+				opj_event_msg(p_manager, EVT_ERROR, "Direct use at #%d however pcol=%d.\n", i, pcol);
+				is_sane = OPJ_FALSE;
+      }
+			else
+				pcol_usage[pcol] = OPJ_TRUE;
+		}
+		/* verify that all components are targeted at least once */
+		for (i = 0; i < nr_channels; i++) {
+			if (!pcol_usage[i] && cmap[i].mtyp != 0) {
+				opj_event_msg(p_manager, EVT_ERROR, "Component %d doesn't have a mapping.\n", i);
+				is_sane = OPJ_FALSE;
+			}
+		}
+		opj_free(pcol_usage);
+		if (!is_sane) {
+			return OPJ_FALSE;
+		}
+	}
+
+	return OPJ_TRUE;
+}
+
+/* file9.jp2 */
+void opj_jp2_apply_pclr(opj_image_t *image, opj_jp2_color_t *color)
+{
+	opj_image_comp_t *old_comps, *new_comps;
+	OPJ_BYTE *channel_size, *channel_sign;
+	OPJ_UINT32 *entries;
+	opj_jp2_cmap_comp_t *cmap;
+	OPJ_INT32 *src, *dst;
+	OPJ_UINT32 j, max;
+	OPJ_UINT16 i, nr_channels, cmp, pcol;
+	OPJ_INT32 k, top_k;
+
+	channel_size = color->jp2_pclr->channel_size;
+	channel_sign = color->jp2_pclr->channel_sign;
+	entries = color->jp2_pclr->entries;
+	cmap = color->jp2_pclr->cmap;
+	nr_channels = color->jp2_pclr->nr_channels;
+
+	old_comps = image->comps;
+	new_comps = (opj_image_comp_t*)
+			opj_malloc(nr_channels * sizeof(opj_image_comp_t));
+
+	for(i = 0; i < nr_channels; ++i) {
+		pcol = cmap[i].pcol; cmp = cmap[i].cmp;
+
+		/* Direct use */
+    if(cmap[i].mtyp == 0){
+      assert( pcol == 0 );
+      new_comps[i] = old_comps[cmp];
+    } else {
+      assert( i == pcol );
+      new_comps[pcol] = old_comps[cmp];
+    }
+
+		/* Palette mapping: */
+		new_comps[i].data = (OPJ_INT32*)
+				opj_malloc(old_comps[cmp].w * old_comps[cmp].h * sizeof(OPJ_INT32));
+		new_comps[i].prec = channel_size[i];
+		new_comps[i].sgnd = channel_sign[i];
+	}
 
-	if(cmap[i].mtyp == 0) /* Direct use */
-  {
-	old_comps[cmp].data = NULL; continue;
-  }
-/* Palette mapping: */
-	new_comps[pcol].data = (int*)
-	 opj_malloc(old_comps[cmp].w * old_comps[cmp].h * sizeof(int));
-	new_comps[pcol].prec = channel_size[i];
-	new_comps[pcol].sgnd = channel_sign[i];
-   }
 	top_k = color->jp2_pclr->nr_entries - 1;
 
-	for(i = 0; i < nr_channels; ++i)
-   {
-/* Direct use: */
-	if(cmap[i].mtyp == 0) continue;
-
-/* Palette mapping: */
-	cmp = cmap[i].cmp; pcol = cmap[i].pcol;
-	src = old_comps[cmp].data; 
-	dst = new_comps[pcol].data;
-	max = new_comps[pcol].w * new_comps[pcol].h;
-
-	for(j = 0; j < max; ++j)
-  {
-/* The index */
-	if((k = src[j]) < 0) k = 0; else if(k > top_k) k = top_k;
-/* The colour */
-	dst[j] = entries[k * nr_channels + pcol];
-  }
-   }
+	for(i = 0; i < nr_channels; ++i) {
+		/* Palette mapping: */
+		cmp = cmap[i].cmp; pcol = cmap[i].pcol;
+		src = old_comps[cmp].data;
+    assert( src );
+		max = new_comps[pcol].w * new_comps[pcol].h;
+
+		/* Direct use: */
+    if(cmap[i].mtyp == 0) {
+      assert( cmp == 0 );
+      dst = new_comps[i].data;
+      assert( dst );
+      for(j = 0; j < max; ++j) {
+        dst[j] = src[j];
+      }
+    }
+    else {
+      assert( i == pcol );
+      dst = new_comps[pcol].data;
+      assert( dst );
+      for(j = 0; j < max; ++j) {
+        /* The index */
+        if((k = src[j]) < 0) k = 0; else if(k > top_k) k = top_k;
+
+        /* The colour */
+        dst[j] = (OPJ_INT32)entries[k * nr_channels + pcol];
+        }
+    }
+	}
+
 	max = image->numcomps;
-	for(i = 0; i < max; ++i)
-   {
-	if(old_comps[i].data) opj_free(old_comps[i].data);
-   }
+	for(i = 0; i < max; ++i) {
+		if(old_comps[i].data) opj_free(old_comps[i].data);
+	}
+
 	opj_free(old_comps);
 	image->comps = new_comps;
 	image->numcomps = nr_channels;
 
-	jp2_free_pclr(color);
+	opj_jp2_free_pclr(color);
 
 }/* apply_pclr() */
 
-static opj_bool jp2_read_pclr(opj_jp2_t *jp2, opj_cio_t *cio,
-	opj_jp2_box_t *box, opj_jp2_color_t *color)
+OPJ_BOOL opj_jp2_read_pclr(	opj_jp2_t *jp2,
+                            OPJ_BYTE * p_pclr_header_data,
+                            OPJ_UINT32 p_pclr_header_size,
+                            opj_event_mgr_t * p_manager
+                            )
 {
 	opj_jp2_pclr_t *jp2_pclr;
-	unsigned char *channel_size, *channel_sign;
-	unsigned int *entries;
-	unsigned short nr_entries, nr_channels;
-	unsigned short i, j;
-	unsigned char uc;
+	OPJ_BYTE *channel_size, *channel_sign;
+	OPJ_UINT32 *entries;
+	OPJ_UINT16 nr_entries,nr_channels;
+	OPJ_UINT16 i, j;
+	OPJ_UINT32 l_value;
+	OPJ_BYTE *orig_header_data = p_pclr_header_data;
+
+	/* preconditions */
+	assert(p_pclr_header_data != 00);
+	assert(jp2 != 00);
+	assert(p_manager != 00);
+    (void)p_pclr_header_size;
+
+	if(jp2->color.jp2_pclr)
+		return OPJ_FALSE;
+
+	if (p_pclr_header_size < 3)
+		return OPJ_FALSE;
 
-	OPJ_ARG_NOT_USED(box);
-	OPJ_ARG_NOT_USED(jp2);
+	opj_read_bytes(p_pclr_header_data, &l_value , 2);	/* NE */
+	p_pclr_header_data += 2;
+	nr_entries = (OPJ_UINT16) l_value;
 
-/* Part 1, I.5.3.4: 'There shall be at most one Palette box inside
- * a JP2 Header box' :
-*/
-	if(color->jp2_pclr) return OPJ_FALSE;
+	opj_read_bytes(p_pclr_header_data, &l_value , 1);	/* NPC */
+	++p_pclr_header_data;
+	nr_channels = (OPJ_UINT16) l_value;
 
-	nr_entries = (unsigned short)cio_read(cio, 2); /* NE */
-	nr_channels = (unsigned short)cio_read(cio, 1);/* NPC */
+	if (p_pclr_header_size < 3 + (OPJ_UINT32)nr_channels || nr_channels == 0 || nr_entries >= (OPJ_UINT32)-1 / nr_channels)
+		return OPJ_FALSE;
 
-	entries = (unsigned int*)
-	 opj_malloc(nr_channels * nr_entries * sizeof(unsigned int));
-	channel_size = (unsigned char*)opj_malloc(nr_channels);
-	channel_sign = (unsigned char*)opj_malloc(nr_channels);
+	entries = (OPJ_UINT32*) opj_malloc((size_t)nr_channels * nr_entries * sizeof(OPJ_UINT32));
+    if (!entries)
+        return OPJ_FALSE;
+	channel_size = (OPJ_BYTE*) opj_malloc(nr_channels);
+    if (!channel_size)
+    {
+        opj_free(entries);
+        return OPJ_FALSE;
+    }
+	channel_sign = (OPJ_BYTE*) opj_malloc(nr_channels);
+	if (!channel_sign)
+	{
+        opj_free(entries);
+        opj_free(channel_size);
+        return OPJ_FALSE;
+	}
 
 	jp2_pclr = (opj_jp2_pclr_t*)opj_malloc(sizeof(opj_jp2_pclr_t));
+    if (!jp2_pclr)
+    {
+        opj_free(entries);
+        opj_free(channel_size);
+        opj_free(channel_sign);
+        return OPJ_FALSE;
+    }
+
 	jp2_pclr->channel_sign = channel_sign;
 	jp2_pclr->channel_size = channel_size;
 	jp2_pclr->entries = entries;
 	jp2_pclr->nr_entries = nr_entries;
-	jp2_pclr->nr_channels = nr_channels;
+	jp2_pclr->nr_channels = (OPJ_BYTE) l_value;
 	jp2_pclr->cmap = NULL;
 
-	color->jp2_pclr = jp2_pclr;
+	jp2->color.jp2_pclr = jp2_pclr;
 
-	for(i = 0; i < nr_channels; ++i)
-   {
-	uc = cio_read(cio, 1); /* Bi */
-	channel_size[i] = (uc & 0x7f) + 1;
-	channel_sign[i] = (uc & 0x80)?1:0;
-   }
+	for(i = 0; i < nr_channels; ++i) {
+		opj_read_bytes(p_pclr_header_data, &l_value , 1);	/* Bi */
+		++p_pclr_header_data;
 
-	for(j = 0; j < nr_entries; ++j)
-   {
-	for(i = 0; i < nr_channels; ++i)
-  {
-/* Cji */
-	*entries++ = cio_read(cio, (channel_size[i]+7)>>3);
-  }
-   }
+		channel_size[i] = (OPJ_BYTE)((l_value & 0x7f) + 1);
+		channel_sign[i] = (l_value & 0x80) ? 1 : 0;
+	}
+
+	for(j = 0; j < nr_entries; ++j) {
+		for(i = 0; i < nr_channels; ++i) {
+			OPJ_UINT32 bytes_to_read = (OPJ_UINT32)((channel_size[i]+7)>>3);
+
+			if (bytes_to_read > sizeof(OPJ_UINT32))
+				bytes_to_read = sizeof(OPJ_UINT32);
+			if ((ptrdiff_t)p_pclr_header_size < p_pclr_header_data - orig_header_data + (ptrdiff_t)bytes_to_read)
+				return OPJ_FALSE;
+
+			opj_read_bytes(p_pclr_header_data, &l_value , bytes_to_read);	/* Cji */
+			p_pclr_header_data += bytes_to_read;
+			*entries = (OPJ_UINT32) l_value;
+			entries++;
+		}
+	}
 
 	return OPJ_TRUE;
-}/* jp2_read_pclr() */
+}
 
-static opj_bool jp2_read_cmap(opj_jp2_t *jp2, opj_cio_t *cio,
-	opj_jp2_box_t *box, opj_jp2_color_t *color)
+OPJ_BOOL opj_jp2_read_cmap(	opj_jp2_t * jp2,
+                            OPJ_BYTE * p_cmap_header_data,
+                            OPJ_UINT32 p_cmap_header_size,
+                            opj_event_mgr_t * p_manager
+                            )
 {
 	opj_jp2_cmap_comp_t *cmap;
-	unsigned short i, nr_channels;
+	OPJ_BYTE i, nr_channels;
+	OPJ_UINT32 l_value;
+
+	/* preconditions */
+	assert(jp2 != 00);
+	assert(p_cmap_header_data != 00);
+	assert(p_manager != 00);
+    (void)p_cmap_header_size;
+
+	/* Need nr_channels: */
+	if(jp2->color.jp2_pclr == NULL) {
+		opj_event_msg(p_manager, EVT_ERROR, "Need to read a PCLR box before the CMAP box.\n");
+		return OPJ_FALSE;
+	}
 
-	OPJ_ARG_NOT_USED(box);
-	OPJ_ARG_NOT_USED(jp2);
+	/* Part 1, I.5.3.5: 'There shall be at most one Component Mapping box
+	 * inside a JP2 Header box' :
+	*/
+	if(jp2->color.jp2_pclr->cmap) {
+		opj_event_msg(p_manager, EVT_ERROR, "Only one CMAP box is allowed.\n");
+		return OPJ_FALSE;
+	}
 
-/* Need nr_channels: */
-	if(color->jp2_pclr == NULL) return OPJ_FALSE;
+	nr_channels = jp2->color.jp2_pclr->nr_channels;
+	if (p_cmap_header_size < (OPJ_UINT32)nr_channels * 4) {
+		opj_event_msg(p_manager, EVT_ERROR, "Insufficient data for CMAP box.\n");
+		return OPJ_FALSE;
+	}
 
-/* Part 1, I.5.3.5: 'There shall be at most one Component Mapping box
- * inside a JP2 Header box' :
-*/
-	if(color->jp2_pclr->cmap) return OPJ_FALSE;
+	cmap = (opj_jp2_cmap_comp_t*) opj_malloc(nr_channels * sizeof(opj_jp2_cmap_comp_t));
+    if (!cmap)
+        return OPJ_FALSE;
 
-	nr_channels = color->jp2_pclr->nr_channels;
-	cmap = (opj_jp2_cmap_comp_t*)
-	 opj_malloc(nr_channels * sizeof(opj_jp2_cmap_comp_t));
 
-	for(i = 0; i < nr_channels; ++i)
-   {
-	cmap[i].cmp = (unsigned short)cio_read(cio, 2);
-	cmap[i].mtyp = cio_read(cio, 1);
-	cmap[i].pcol = cio_read(cio, 1);
+	for(i = 0; i < nr_channels; ++i) {
+		opj_read_bytes(p_cmap_header_data, &l_value, 2);			/* CMP^i */
+		p_cmap_header_data +=2;
+		cmap[i].cmp = (OPJ_UINT16) l_value;
 
-   }
-	color->jp2_pclr->cmap = cmap;
+		opj_read_bytes(p_cmap_header_data, &l_value, 1);			/* MTYP^i */
+		++p_cmap_header_data;
+		cmap[i].mtyp = (OPJ_BYTE) l_value;
+
+		opj_read_bytes(p_cmap_header_data, &l_value, 1);			/* PCOL^i */
+		++p_cmap_header_data;
+		cmap[i].pcol = (OPJ_BYTE) l_value;
+	}
+
+	jp2->color.jp2_pclr->cmap = cmap;
 
 	return OPJ_TRUE;
-}/* jp2_read_cmap() */
+}
 
-static void jp2_apply_cdef(opj_image_t *image, opj_jp2_color_t *color)
+void opj_jp2_apply_cdef(opj_image_t *image, opj_jp2_color_t *color)
 {
 	opj_jp2_cdef_info_t *info;
-	unsigned short i, n, cn, typ, asoc, acn;
+	OPJ_UINT16 i, n, cn, asoc, acn;
 
 	info = color->jp2_cdef->info;
 	n = color->jp2_cdef->n;
 
-	for(i = 0; i < n; ++i)
-   {
-/* WATCH: acn = asoc - 1 ! */
-	if((asoc = info[i].asoc) == 0) continue;
+  for(i = 0; i < n; ++i)
+    {
+    /* WATCH: acn = asoc - 1 ! */
+    asoc = info[i].asoc;
+    if(asoc == 0 || asoc == 65535)
+      {
+      if (i < image->numcomps)
+        image->comps[i].alpha = info[i].typ;
+      continue;
+      }
+
+    cn = info[i].cn; 
+    acn = (OPJ_UINT16)(asoc - 1);
+    if( cn >= image->numcomps || acn >= image->numcomps )
+      {
+      fprintf(stderr, "cn=%d, acn=%d, numcomps=%d\n", cn, acn, image->numcomps);
+      continue;
+      }
 
-	cn = info[i].cn; typ = info[i].typ; acn = asoc - 1;
-  (void)typ;
+		if(cn != acn)
+		{
+			opj_image_comp_t saved;
 
-	if(cn != acn)
-  {
-	opj_image_comp_t saved;
+			memcpy(&saved, &image->comps[cn], sizeof(opj_image_comp_t));
+			memcpy(&image->comps[cn], &image->comps[acn], sizeof(opj_image_comp_t));
+			memcpy(&image->comps[acn], &saved, sizeof(opj_image_comp_t));
 
-	memcpy(&saved, &image->comps[cn], sizeof(opj_image_comp_t));
-	memcpy(&image->comps[cn], &image->comps[acn], sizeof(opj_image_comp_t));
-	memcpy(&image->comps[acn], &saved, sizeof(opj_image_comp_t));
+			info[i].asoc = (OPJ_UINT16)(cn + 1);
+			info[acn].asoc = (OPJ_UINT16)(info[acn].cn + 1);
+		}
+
+		image->comps[cn].alpha = info[i].typ;
+	}
 
-	info[i].asoc = cn + 1;
-	info[acn].asoc = info[acn].cn + 1;
-  }
-   }
 	if(color->jp2_cdef->info) opj_free(color->jp2_cdef->info);
 
 	opj_free(color->jp2_cdef); color->jp2_cdef = NULL;
 
 }/* jp2_apply_cdef() */
 
-static opj_bool jp2_read_cdef(opj_jp2_t *jp2, opj_cio_t *cio,
-	opj_jp2_box_t *box, opj_jp2_color_t *color)
+OPJ_BOOL opj_jp2_read_cdef(	opj_jp2_t * jp2,
+                            OPJ_BYTE * p_cdef_header_data,
+							OPJ_UINT32 p_cdef_header_size,
+							opj_event_mgr_t * p_manager
+                            )
 {
-	opj_jp2_cdef_info_t *info;
-	unsigned short i, n;
+	opj_jp2_cdef_info_t *cdef_info;
+	OPJ_UINT16 i;
+	OPJ_UINT32 l_value;
+
+	/* preconditions */
+	assert(jp2 != 00);
+	assert(p_cdef_header_data != 00);
+	assert(p_manager != 00);
+    (void)p_cdef_header_size;
+
+	/* Part 1, I.5.3.6: 'The shall be at most one Channel Definition box
+	 * inside a JP2 Header box.'*/
+	if(jp2->color.jp2_cdef) return OPJ_FALSE;
+
+	if (p_cdef_header_size < 2) {
+		opj_event_msg(p_manager, EVT_ERROR, "Insufficient data for CDEF box.\n");
+		return OPJ_FALSE;
+	}
 
-	OPJ_ARG_NOT_USED(box);
-	OPJ_ARG_NOT_USED(jp2);
+	opj_read_bytes(p_cdef_header_data,&l_value ,2);			/* N */
+	p_cdef_header_data+= 2;
 
-/* Part 1, I.5.3.6: 'The shall be at most one Channel Definition box
- * inside a JP2 Header box.' 
-*/
-	if(color->jp2_cdef) return OPJ_FALSE;
+	if ( (OPJ_UINT16)l_value == 0){ /* szukw000: FIXME */
+		opj_event_msg(p_manager, EVT_ERROR, "Number of channel description is equal to zero in CDEF box.\n");
+		return OPJ_FALSE;
+	}
+
+	if (p_cdef_header_size < 2 + (OPJ_UINT32)(OPJ_UINT16)l_value * 6) {
+		opj_event_msg(p_manager, EVT_ERROR, "Insufficient data for CDEF box.\n");
+		return OPJ_FALSE;
+	}
 
-	if((n = (unsigned short)cio_read(cio, 2)) == 0) return OPJ_FALSE; /* szukw000: FIXME */
+	cdef_info = (opj_jp2_cdef_info_t*) opj_malloc(l_value * sizeof(opj_jp2_cdef_info_t));
+    if (!cdef_info)
+        return OPJ_FALSE;
 
-	info = (opj_jp2_cdef_info_t*)
-	 opj_malloc(n * sizeof(opj_jp2_cdef_info_t));
+	jp2->color.jp2_cdef = (opj_jp2_cdef_t*)opj_malloc(sizeof(opj_jp2_cdef_t));
+    if(!jp2->color.jp2_cdef)
+    {
+        opj_free(cdef_info);
+        return OPJ_FALSE;
+    }
+	jp2->color.jp2_cdef->info = cdef_info;
+	jp2->color.jp2_cdef->n = (OPJ_UINT16) l_value;
 
-	color->jp2_cdef = (opj_jp2_cdef_t*)opj_malloc(sizeof(opj_jp2_cdef_t));
-	color->jp2_cdef->info = info;
-	color->jp2_cdef->n = n;
+	for(i = 0; i < jp2->color.jp2_cdef->n; ++i) {
+		opj_read_bytes(p_cdef_header_data, &l_value, 2);			/* Cn^i */
+		p_cdef_header_data +=2;
+		cdef_info[i].cn = (OPJ_UINT16) l_value;
 
-	for(i = 0; i < n; ++i)
-   {
-	info[i].cn = (unsigned short)cio_read(cio, 2);
-	info[i].typ = (unsigned short)cio_read(cio, 2);
-	info[i].asoc = (unsigned short)cio_read(cio, 2);
+		opj_read_bytes(p_cdef_header_data, &l_value, 2);			/* Typ^i */
+		p_cdef_header_data +=2;
+		cdef_info[i].typ = (OPJ_UINT16) l_value;
 
+		opj_read_bytes(p_cdef_header_data, &l_value, 2);			/* Asoc^i */
+		p_cdef_header_data +=2;
+		cdef_info[i].asoc = (OPJ_UINT16) l_value;
    }
+
 	return OPJ_TRUE;
-}/* jp2_read_cdef() */
+}
 
-static opj_bool jp2_read_colr(opj_jp2_t *jp2, opj_cio_t *cio,
-	opj_jp2_box_t *box, opj_jp2_color_t *color) 
+OPJ_BOOL opj_jp2_read_colr( opj_jp2_t *jp2,
+                            OPJ_BYTE * p_colr_header_data,
+                            OPJ_UINT32 p_colr_header_size,
+                            opj_event_mgr_t * p_manager
+                            )
 {
-	int skip_len;
-    opj_common_ptr cinfo;
+	OPJ_UINT32 l_value;
 
-/* Part 1, I.5.3.3 : 'A conforming JP2 reader shall ignore all Colour
- * Specification boxes after the first.' 
-*/
-	if(color->jp2_has_colr) return OPJ_FALSE;
+	/* preconditions */
+	assert(jp2 != 00);
+	assert(p_colr_header_data != 00);
+	assert(p_manager != 00);
 
-	cinfo = jp2->cinfo;
+	if (p_colr_header_size < 3) {
+		opj_event_msg(p_manager, EVT_ERROR, "Bad COLR header box (bad size)\n");
+		return OPJ_FALSE;
+	}
 
-	jp2->meth = cio_read(cio, 1);		/* METH */
-	jp2->precedence = cio_read(cio, 1);	/* PRECEDENCE */
-	jp2->approx = cio_read(cio, 1);		/* APPROX */
+	/* Part 1, I.5.3.3 : 'A conforming JP2 reader shall ignore all Colour
+	 * Specification boxes after the first.'
+	*/
+	if(jp2->color.jp2_has_colr) {
+		opj_event_msg(p_manager, EVT_INFO, "A conforming JP2 reader shall ignore all Colour Specification boxes after the first, so we ignore this one.\n");
+		p_colr_header_data += p_colr_header_size;
+		return OPJ_TRUE;
+	}
 
-	if (jp2->meth == 1) 
-   {
-	jp2->enumcs = cio_read(cio, 4);	/* EnumCS */
-   } 
-	else
-	if (jp2->meth == 2) 
-   {
-/* skip PROFILE */
-	skip_len = box->init_pos + box->length - cio_tell(cio);
-	if (skip_len < 0) 
-  {
-	opj_event_msg(cinfo, EVT_ERROR, "Error with COLR box size\n");
-	return OPJ_FALSE;
-  }
-	if(skip_len > 0)
-  {
-	unsigned char *start;
+	opj_read_bytes(p_colr_header_data,&jp2->meth ,1);			/* METH */
+	++p_colr_header_data;
 
-	start = cio_getbp(cio);
-	color->icc_profile_buf = (unsigned char*)opj_malloc(skip_len);
-	color->icc_profile_len = skip_len;
+	opj_read_bytes(p_colr_header_data,&jp2->precedence ,1);		/* PRECEDENCE */
+	++p_colr_header_data;
 
-	cio_skip(cio, box->init_pos + box->length - cio_tell(cio));
+	opj_read_bytes(p_colr_header_data,&jp2->approx ,1);			/* APPROX */
+	++p_colr_header_data;
 
-	memcpy(color->icc_profile_buf, start, skip_len);
-  }
-   }
+	if (jp2->meth == 1) {
+		if (p_colr_header_size < 7) {
+			opj_event_msg(p_manager, EVT_ERROR, "Bad COLR header box (bad size: %d)\n", p_colr_header_size);
+			return OPJ_FALSE;
+		}
+		if (p_colr_header_size > 7) {
+			/* testcase Altona_Technical_v20_x4.pdf */
+			opj_event_msg(p_manager, EVT_WARNING, "Bad COLR header box (bad size: %d)\n", p_colr_header_size);
+		}
 
-	if (cio_tell(cio) - box->init_pos != box->length) 
-   {
-	opj_event_msg(cinfo, EVT_ERROR, "Error with COLR Box\n");
-	return OPJ_FALSE;
-   }
-	color->jp2_has_colr = 1;
+		opj_read_bytes(p_colr_header_data,&jp2->enumcs ,4);			/* EnumCS */
+        
+        jp2->color.jp2_has_colr = 1;
+	}
+	else if (jp2->meth == 2) {
+		/* ICC profile */
+		OPJ_INT32 it_icc_value = 0;
+		OPJ_INT32 icc_len = (OPJ_INT32)p_colr_header_size - 3;
+
+		jp2->color.icc_profile_len = (OPJ_UINT32)icc_len;
+		jp2->color.icc_profile_buf = (OPJ_BYTE*) opj_malloc((size_t)icc_len);
+        if (!jp2->color.icc_profile_buf)
+        {
+            jp2->color.icc_profile_len = 0;
+            return OPJ_FALSE;
+        }
+		memset(jp2->color.icc_profile_buf, 0, (size_t)icc_len * sizeof(OPJ_BYTE));
 
-	return OPJ_TRUE;
-}/* jp2_read_colr() */
+		for (it_icc_value = 0; it_icc_value < icc_len; ++it_icc_value)
+		{
+			opj_read_bytes(p_colr_header_data,&l_value,1);		/* icc values */
+			++p_colr_header_data;
+			jp2->color.icc_profile_buf[it_icc_value] = (OPJ_BYTE) l_value;
+		}
+	    
+        jp2->color.jp2_has_colr = 1;
+	}
+	else if (jp2->meth > 2)
+    {
+        /*	ISO/IEC 15444-1:2004 (E), Table I.9 Legal METH values:
+        conforming JP2 reader shall ignore the entire Colour Specification box.*/
+        opj_event_msg(p_manager, EVT_INFO, "COLR BOX meth value is not a regular value (%d), " 
+            "so we will ignore the entire Colour Specification box. \n", jp2->meth);
+    }
+    return OPJ_TRUE;
+}
 
-opj_bool jp2_read_jp2h(opj_jp2_t *jp2, opj_cio_t *cio, opj_jp2_color_t *color) 
+OPJ_BOOL opj_jp2_decode(opj_jp2_t *jp2,
+                        opj_stream_private_t *p_stream,
+                        opj_image_t* p_image,
+                        opj_event_mgr_t * p_manager)
 {
-	opj_jp2_box_t box;
-	int jp2h_end;
-
-	opj_common_ptr cinfo = jp2->cinfo;
+	if (!p_image)
+		return OPJ_FALSE;
 
-  if( jp2_read_boxhdr(cinfo, cio, &box) == OPJ_FALSE ) return OPJ_FALSE;
-  do {
-    if (JP2_JP2H != box.type) 
-      {
-      if (box.type == JP2_JP2C) 
-        {
-        opj_event_msg(cinfo, EVT_ERROR, "Expected JP2H Marker\n");
-        return OPJ_FALSE;
-        }
-	  if (box.length <= 8) return OPJ_FALSE;
-      cio_skip(cio, box.length - 8);
+	/* J2K decoding */
+	if( ! opj_j2k_decode(jp2->j2k, p_stream, p_image, p_manager) ) {
+		opj_event_msg(p_manager, EVT_ERROR, "Failed to decode the codestream in the JP2 file\n");
+		return OPJ_FALSE;
+	}
 
-      if(cio->bp >= cio->end) return OPJ_FALSE;
+    if (!jp2->ignore_pclr_cmap_cdef){
+	    if (!opj_jp2_check_color(p_image, &(jp2->color), p_manager)) {
+		    return OPJ_FALSE;
+	    }
 
-      if( jp2_read_boxhdr(cinfo, cio, &box) == OPJ_FALSE ) return OPJ_FALSE;
-      }
-  } while(JP2_JP2H != box.type);
+	    /* Set Image Color Space */
+	    if (jp2->enumcs == 16)
+		    p_image->color_space = OPJ_CLRSPC_SRGB;
+	    else if (jp2->enumcs == 17)
+		    p_image->color_space = OPJ_CLRSPC_GRAY;
+	    else if (jp2->enumcs == 18)
+		    p_image->color_space = OPJ_CLRSPC_SYCC;
+            else if (jp2->enumcs == 24)
+                    p_image->color_space = OPJ_CLRSPC_EYCC;
+	    else
+		    p_image->color_space = OPJ_CLRSPC_UNKNOWN;
+
+	    /* Apply the color space if needed */
+	    if(jp2->color.jp2_cdef) {
+		    opj_jp2_apply_cdef(p_image, &(jp2->color));
+	    }
 
-	if (!jp2_read_ihdr(jp2, cio))
-		return OPJ_FALSE;
-	jp2h_end = box.init_pos + box.length;
+	    if(jp2->color.jp2_pclr) {
+		    /* Part 1, I.5.3.4: Either both or none : */
+		    if( !jp2->color.jp2_pclr->cmap)
+			    opj_jp2_free_pclr(&(jp2->color));
+		    else
+			    opj_jp2_apply_pclr(p_image, &(jp2->color));
+	    }
 
-  if (jp2->bpc == 255) 
-    {
-    if (!jp2_read_bpcc(jp2, cio))
-      return OPJ_FALSE;
+	    if(jp2->color.icc_profile_buf) {
+		    p_image->icc_profile_buf = jp2->color.icc_profile_buf;
+		    p_image->icc_profile_len = jp2->color.icc_profile_len;
+		    jp2->color.icc_profile_buf = NULL;
+	    }
     }
-  if( jp2_read_boxhdr(cinfo, cio, &box) == OPJ_FALSE ) return OPJ_FALSE;
 
-  while(cio_tell(cio) < jp2h_end)
-    {
-    if(box.type == JP2_COLR)
-      {
-      if( !jp2_read_colr(jp2, cio, &box, color))
-        {
-        if (box.length <= 8) return OPJ_FALSE;
-        cio_seek(cio, box.init_pos + 8);
-        cio_skip(cio, box.length - 8);
-        }
-      if( jp2_read_boxhdr(cinfo, cio, &box) == OPJ_FALSE ) return OPJ_FALSE;
-      continue;
-      }
-    if(box.type == JP2_CDEF && !jp2->ignore_pclr_cmap_cdef)
-      {
-      if( !jp2_read_cdef(jp2, cio, &box, color))
-        {
-        if (box.length <= 8) return OPJ_FALSE;
-        cio_seek(cio, box.init_pos + 8);
-        cio_skip(cio, box.length - 8);
-        }
-      if( jp2_read_boxhdr(cinfo, cio, &box) == OPJ_FALSE ) return OPJ_FALSE;
-      continue;
-      }
-    if(box.type == JP2_PCLR && !jp2->ignore_pclr_cmap_cdef)
-      {
-      if( !jp2_read_pclr(jp2, cio, &box, color))
-        {
-        if (box.length <= 8) return OPJ_FALSE;
-        cio_seek(cio, box.init_pos + 8);
-        cio_skip(cio, box.length - 8);
-        }
-      if( jp2_read_boxhdr(cinfo, cio, &box) == OPJ_FALSE ) return OPJ_FALSE;
-      continue;
-      }
-    if(box.type == JP2_CMAP && !jp2->ignore_pclr_cmap_cdef)
-      {
-      if( !jp2_read_cmap(jp2, cio, &box, color))
-        {
-        if (box.length <= 8) return OPJ_FALSE;
-        cio_seek(cio, box.init_pos + 8);
-        cio_skip(cio, box.length - 8);
-        }
-      if( jp2_read_boxhdr(cinfo, cio, &box) == OPJ_FALSE ) return OPJ_FALSE;
-      continue;
-      }
-    if (box.length <= 8) return OPJ_FALSE;
-    cio_seek(cio, box.init_pos + 8);
-    cio_skip(cio, box.length - 8);
-    if( jp2_read_boxhdr(cinfo, cio, &box) == OPJ_FALSE ) return OPJ_FALSE;
+	return OPJ_TRUE;
+}
 
-    }/* while(cio_tell(cio) < box_end) */
+OPJ_BOOL opj_jp2_write_jp2h(opj_jp2_t *jp2,
+                            opj_stream_private_t *stream,
+                            opj_event_mgr_t * p_manager
+                            )
+{
+	opj_jp2_img_header_writer_handler_t l_writers [3];
+	opj_jp2_img_header_writer_handler_t * l_current_writer;
 
-  cio_seek(cio, jp2h_end);
+	OPJ_INT32 i, l_nb_pass;
+	/* size of data for super box*/
+	OPJ_UINT32 l_jp2h_size = 8;
+	OPJ_BOOL l_result = OPJ_TRUE;
 
-  /* Part 1, I.5.3.3 : 'must contain at least one' */
-  return (color->jp2_has_colr == 1);
+	/* to store the data of the super box */
+	OPJ_BYTE l_jp2h_data [8];
+	
+	/* preconditions */
+	assert(stream != 00);
+	assert(jp2 != 00);
+	assert(p_manager != 00);
 
-}/* jp2_read_jp2h() */
+	memset(l_writers,0,sizeof(l_writers));
 
-static opj_bool opj_jp2_check_color(opj_image_t *image, opj_jp2_color_t *color, opj_common_ptr cinfo)
-{
-	int i;
+	if (jp2->bpc == 255) {
+		l_nb_pass = 3;
+		l_writers[0].handler = opj_jp2_write_ihdr;
+		l_writers[1].handler = opj_jp2_write_bpcc;
+		l_writers[2].handler = opj_jp2_write_colr;
+	}
+	else {
+		l_nb_pass = 2;
+		l_writers[0].handler = opj_jp2_write_ihdr;
+		l_writers[1].handler = opj_jp2_write_colr;
+	}
+	
+	/* write box header */
+	/* write JP2H type */
+	opj_write_bytes(l_jp2h_data+4,JP2_JP2H,4);
+
+	l_current_writer = l_writers;
+	for (i=0;i<l_nb_pass;++i) {
+		l_current_writer->m_data = l_current_writer->handler(jp2,&(l_current_writer->m_size));
+		if (l_current_writer->m_data == 00) {
+			opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to hold JP2 Header data\n");
+			l_result = OPJ_FALSE;
+			break;
+		}
 
-	/* testcase 4149.pdf.SIGSEGV.cf7.3501 */
-	if (color->jp2_cdef) {
-		opj_jp2_cdef_info_t *info = color->jp2_cdef->info;
-		int n = color->jp2_cdef->n;
+		l_jp2h_size += l_current_writer->m_size;
+		++l_current_writer;
+	}
 
-		for (i = 0; i < n; i++) {
-			if (info[i].cn >= image->numcomps) {
-				opj_event_msg(cinfo, EVT_ERROR, "Invalid component index %d (>= %d).\n", info[i].cn, image->numcomps);
-				return OPJ_FALSE;
-			}
-			if (info[i].asoc > 0 && (info[i].asoc - 1) >= image->numcomps) {
-				opj_event_msg(cinfo, EVT_ERROR, "Invalid component index %d (>= %d).\n", info[i].asoc - 1, image->numcomps);
-				return OPJ_FALSE;
+	if (! l_result) {
+		l_current_writer = l_writers;
+		for (i=0;i<l_nb_pass;++i) {
+			if (l_current_writer->m_data != 00) {
+				opj_free(l_current_writer->m_data );
 			}
+			++l_current_writer;
 		}
-	}
 
-	/* testcases 451.pdf.SIGSEGV.f4c.3723, 451.pdf.SIGSEGV.5b5.3723 and
-	   66ea31acbb0f23a2bbc91f64d69a03f5_signal_sigsegv_13937c0_7030_5725.pdf */
-	if (color->jp2_pclr && color->jp2_pclr->cmap) {
-		int nr_channels = color->jp2_pclr->nr_channels;
-		opj_jp2_cmap_comp_t *cmap = color->jp2_pclr->cmap;
-		opj_bool *pcol_usage, is_sane = OPJ_TRUE;
+		return OPJ_FALSE;
+	}
 
-		/* verify that all original components match an existing one */
-		for (i = 0; i < nr_channels; i++) {
-			if (cmap[i].cmp >= image->numcomps) {
-				opj_event_msg(cinfo, EVT_ERROR, "Invalid component index %d (>= %d).\n", cmap[i].cmp, image->numcomps);
-				is_sane = OPJ_FALSE;
+	/* write super box size */
+	opj_write_bytes(l_jp2h_data,l_jp2h_size,4);
+	
+	/* write super box data on stream */
+	if (opj_stream_write_data(stream,l_jp2h_data,8,p_manager) != 8) {
+		opj_event_msg(p_manager, EVT_ERROR, "Stream error while writing JP2 Header box\n");
+		l_result = OPJ_FALSE;
+	}
+	
+	if (l_result) {
+		l_current_writer = l_writers;
+		for (i=0;i<l_nb_pass;++i) {
+			if (opj_stream_write_data(stream,l_current_writer->m_data,l_current_writer->m_size,p_manager) != l_current_writer->m_size) {
+				opj_event_msg(p_manager, EVT_ERROR, "Stream error while writing JP2 Header box\n");
+				l_result = OPJ_FALSE;
+				break;
 			}
+			++l_current_writer;
 		}
+	}
 
-		pcol_usage = opj_calloc(nr_channels, sizeof(opj_bool));
-		if (!pcol_usage) {
-			opj_event_msg(cinfo, EVT_ERROR, "Unexpected OOM.\n");
-			return OPJ_FALSE;
-		}
-		/* verify that no component is targeted more than once */
-		for (i = 0; i < nr_channels; i++) {
-      int pcol = cmap[i].pcol;
-      assert(cmap[i].mtyp == 0 || cmap[i].mtyp == 1);
-			if (pcol >= nr_channels) {
-				opj_event_msg(cinfo, EVT_ERROR, "Invalid component/palette index for direct mapping %d.\n", pcol);
-				is_sane = OPJ_FALSE;
-			}
-			else if (pcol_usage[pcol] && cmap[i].mtyp == 1) {
-				opj_event_msg(cinfo, EVT_ERROR, "Component %d is mapped twice.\n", pcol);
-				is_sane = OPJ_FALSE;
-			}
-      else if (cmap[i].mtyp == 0 && cmap[i].pcol != 0) {
-        /* I.5.3.5 PCOL: If the value of the MTYP field for this channel is 0, then
-         * the value of this field shall be 0. */
-				opj_event_msg(cinfo, EVT_ERROR, "Direct use at #%d however pcol=%d.\n", i, pcol);
-				is_sane = OPJ_FALSE;
-      }
-			else
-				pcol_usage[pcol] = OPJ_TRUE;
+	l_current_writer = l_writers;
+	
+	/* cleanup */
+	for (i=0;i<l_nb_pass;++i) {
+		if (l_current_writer->m_data != 00) {
+			opj_free(l_current_writer->m_data );
 		}
-		/* verify that all components are targeted at least once */
-		for (i = 0; i < nr_channels; i++) {
-			if (!pcol_usage[i] && cmap[i].mtyp != 0) {
-				opj_event_msg(cinfo, EVT_ERROR, "Component %d doesn't have a mapping.\n", i);
-				is_sane = OPJ_FALSE;
-			}
+		++l_current_writer;
+	}
+
+	return l_result;
+}
+
+OPJ_BOOL opj_jp2_write_ftyp(opj_jp2_t *jp2,
+							opj_stream_private_t *cio,
+							opj_event_mgr_t * p_manager )
+{
+	OPJ_UINT32 i;
+	OPJ_UINT32 l_ftyp_size = 16 + 4 * jp2->numcl;
+	OPJ_BYTE * l_ftyp_data, * l_current_data_ptr;
+	OPJ_BOOL l_result;
+
+	/* preconditions */
+	assert(cio != 00);
+	assert(jp2 != 00);
+	assert(p_manager != 00);
+
+	l_ftyp_data = (OPJ_BYTE *) opj_malloc(l_ftyp_size);
+	
+	if (l_ftyp_data == 00) {
+		opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to handle ftyp data\n");
+		return OPJ_FALSE;
+	}
+
+	memset(l_ftyp_data,0,l_ftyp_size);
+
+	l_current_data_ptr = l_ftyp_data;
+
+	opj_write_bytes(l_current_data_ptr, l_ftyp_size,4); /* box size */
+	l_current_data_ptr += 4;
+
+	opj_write_bytes(l_current_data_ptr, JP2_FTYP,4); /* FTYP */
+	l_current_data_ptr += 4;
+
+	opj_write_bytes(l_current_data_ptr, jp2->brand,4); /* BR */
+	l_current_data_ptr += 4;
+
+	opj_write_bytes(l_current_data_ptr, jp2->minversion,4); /* MinV */
+	l_current_data_ptr += 4;
+
+	for (i = 0; i < jp2->numcl; i++)  {
+		opj_write_bytes(l_current_data_ptr, jp2->cl[i],4);	/* CL */
+	}
+	
+	l_result = (opj_stream_write_data(cio,l_ftyp_data,l_ftyp_size,p_manager) == l_ftyp_size);
+	if (! l_result)
+	{
+		opj_event_msg(p_manager, EVT_ERROR, "Error while writing ftyp data to stream\n");
+	}
+
+	opj_free(l_ftyp_data);
+	
+	return l_result;
+}
+
+OPJ_BOOL opj_jp2_write_jp2c(opj_jp2_t *jp2,
+							opj_stream_private_t *cio,
+							opj_event_mgr_t * p_manager )
+{
+	OPJ_OFF_T j2k_codestream_exit;
+	OPJ_BYTE l_data_header [8];
+	
+	/* preconditions */
+	assert(jp2 != 00);
+	assert(cio != 00);
+	assert(p_manager != 00);
+	assert(opj_stream_has_seek(cio));
+	
+	j2k_codestream_exit = opj_stream_tell(cio);
+	opj_write_bytes(l_data_header,
+                    (OPJ_UINT32) (j2k_codestream_exit - jp2->j2k_codestream_offset),
+                    4); /* size of codestream */
+	opj_write_bytes(l_data_header + 4,JP2_JP2C,4);									   /* JP2C */
+
+	if (! opj_stream_seek(cio,jp2->j2k_codestream_offset,p_manager)) {
+		opj_event_msg(p_manager, EVT_ERROR, "Failed to seek in the stream.\n");
+		return OPJ_FALSE;
+	}
+	
+	if (opj_stream_write_data(cio,l_data_header,8,p_manager) != 8) {
+		opj_event_msg(p_manager, EVT_ERROR, "Failed to seek in the stream.\n");
+		return OPJ_FALSE;
+	}
+
+	if (! opj_stream_seek(cio,j2k_codestream_exit,p_manager)) {
+		opj_event_msg(p_manager, EVT_ERROR, "Failed to seek in the stream.\n");
+		return OPJ_FALSE;
+	}
+
+	return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_jp2_write_jp(	opj_jp2_t *jp2,
+			    		    opj_stream_private_t *cio,
+				    		opj_event_mgr_t * p_manager )
+{
+	/* 12 bytes will be read */
+	OPJ_BYTE l_signature_data [12];
+
+	/* preconditions */
+	assert(cio != 00);
+	assert(jp2 != 00);
+	assert(p_manager != 00);
+
+	/* write box length */
+	opj_write_bytes(l_signature_data,12,4);
+	/* writes box type */
+	opj_write_bytes(l_signature_data+4,JP2_JP,4);
+	/* writes magic number*/
+	opj_write_bytes(l_signature_data+8,0x0d0a870a,4);
+	
+	if (opj_stream_write_data(cio,l_signature_data,12,p_manager) != 12) {
+		return OPJ_FALSE;
+	}
+
+	return OPJ_TRUE;
+}
+
+/* ----------------------------------------------------------------------- */
+/* JP2 decoder interface                                             */
+/* ----------------------------------------------------------------------- */
+
+void opj_jp2_setup_decoder(opj_jp2_t *jp2, opj_dparameters_t *parameters)
+{
+	/* setup the J2K codec */
+	opj_j2k_setup_decoder(jp2->j2k, parameters);
+
+	/* further JP2 initializations go here */
+	jp2->color.jp2_has_colr = 0;
+    jp2->ignore_pclr_cmap_cdef = parameters->flags & OPJ_DPARAMETERS_IGNORE_PCLR_CMAP_CDEF_FLAG;
+}
+
+/* ----------------------------------------------------------------------- */
+/* JP2 encoder interface                                             */
+/* ----------------------------------------------------------------------- */
+
+void opj_jp2_setup_encoder(	opj_jp2_t *jp2,
+                            opj_cparameters_t *parameters,
+                            opj_image_t *image,
+                            opj_event_mgr_t * p_manager)
+{
+    OPJ_UINT32 i;
+	OPJ_UINT32 depth_0;
+  OPJ_UINT32 sign;
+
+	if(!jp2 || !parameters || !image)
+		return;
+
+	/* setup the J2K codec */
+	/* ------------------- */
+
+	/* Check if number of components respects standard */
+	if (image->numcomps < 1 || image->numcomps > 16384) {
+		opj_event_msg(p_manager, EVT_ERROR, "Invalid number of components specified while setting up JP2 encoder\n");
+		return;
+	}
+
+	opj_j2k_setup_encoder(jp2->j2k, parameters, image, p_manager );
+
+	/* setup the JP2 codec */
+	/* ------------------- */
+	
+	/* Profile box */
+
+	jp2->brand = JP2_JP2;	/* BR */
+	jp2->minversion = 0;	/* MinV */
+	jp2->numcl = 1;
+	jp2->cl = (OPJ_UINT32*) opj_malloc(jp2->numcl * sizeof(OPJ_UINT32));
+    if (!jp2->cl){
+        jp2->cl = NULL;
+        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory when setup the JP2 encoder\n");
+        return;
+    }
+	jp2->cl[0] = JP2_JP2;	/* CL0 : JP2 */
+
+	/* Image Header box */
+
+	jp2->numcomps = image->numcomps;	/* NC */
+	jp2->comps = (opj_jp2_comps_t*) opj_malloc(jp2->numcomps * sizeof(opj_jp2_comps_t));
+    if (!jp2->comps) {
+        jp2->comps = NULL;
+        opj_event_msg(p_manager, EVT_ERROR, "Not enough memory when setup the JP2 encoder\n");
+        return;
+    }
+
+	jp2->h = image->y1 - image->y0;		/* HEIGHT */
+	jp2->w = image->x1 - image->x0;		/* WIDTH */
+	/* BPC */
+	depth_0 = image->comps[0].prec - 1;
+	sign = image->comps[0].sgnd;
+	jp2->bpc = depth_0 + (sign << 7);
+	for (i = 1; i < image->numcomps; i++) {
+		OPJ_UINT32 depth = image->comps[i].prec - 1;
+		sign = image->comps[i].sgnd;
+		if (depth_0 != depth)
+			jp2->bpc = 255;
+	}
+	jp2->C = 7;			/* C : Always 7 */
+	jp2->UnkC = 0;		/* UnkC, colorspace specified in colr box */
+	jp2->IPR = 0;		/* IPR, no intellectual property */
+	
+	/* BitsPerComponent box */
+	for (i = 0; i < image->numcomps; i++) {
+		jp2->comps[i].bpcc = image->comps[i].prec - 1 + (image->comps[i].sgnd << 7);
+	}
+
+	/* Colour Specification box */
+    if(image->icc_profile_len) {
+        jp2->meth = 2;
+        jp2->enumcs = 0;
+    } 
+    else {
+        jp2->meth = 1;
+        if (image->color_space == 1)
+            jp2->enumcs = 16;	/* sRGB as defined by IEC 61966-2-1 */
+        else if (image->color_space == 2)
+            jp2->enumcs = 17;	/* greyscale */
+        else if (image->color_space == 3)
+            jp2->enumcs = 18;	/* YUV */
+    }
+
+
+	jp2->precedence = 0;	/* PRECEDENCE */
+	jp2->approx = 0;		/* APPROX */
+
+	jp2->jpip_on = parameters->jpip_on;
+}
+
+OPJ_BOOL opj_jp2_encode(opj_jp2_t *jp2,
+						opj_stream_private_t *stream,
+						opj_event_mgr_t * p_manager)
+{
+	return opj_j2k_encode(jp2->j2k, stream, p_manager);
+}
+
+OPJ_BOOL opj_jp2_end_decompress(opj_jp2_t *jp2,
+                                opj_stream_private_t *cio,
+                                opj_event_mgr_t * p_manager
+                                )
+{
+	/* preconditions */
+	assert(jp2 != 00);
+	assert(cio != 00);
+	assert(p_manager != 00);
+
+	/* customization of the end encoding */
+	opj_jp2_setup_end_header_reading(jp2);
+
+	/* write header */
+	if (! opj_jp2_exec (jp2,jp2->m_procedure_list,cio,p_manager)) {
+		return OPJ_FALSE;
+	}
+
+	return opj_j2k_end_decompress(jp2->j2k, cio, p_manager);
+}
+
+OPJ_BOOL opj_jp2_end_compress(	opj_jp2_t *jp2,
+							    opj_stream_private_t *cio,
+							    opj_event_mgr_t * p_manager
+                                )
+{
+	/* preconditions */
+	assert(jp2 != 00);
+	assert(cio != 00);
+	assert(p_manager != 00);
+
+	/* customization of the end encoding */
+	opj_jp2_setup_end_header_writing(jp2);
+
+	if (! opj_j2k_end_compress(jp2->j2k,cio,p_manager)) {
+		return OPJ_FALSE;
+	}
+
+	/* write header */
+	return opj_jp2_exec(jp2,jp2->m_procedure_list,cio,p_manager);
+}
+
+void opj_jp2_setup_end_header_writing (opj_jp2_t *jp2)
+{
+	/* preconditions */
+	assert(jp2 != 00);
+
+#ifdef USE_JPIP
+  if( jp2->jpip_on )
+    opj_procedure_list_add_procedure(jp2->m_procedure_list,(opj_procedure)opj_jpip_write_iptr );
+#endif
+	opj_procedure_list_add_procedure(jp2->m_procedure_list,(opj_procedure)opj_jp2_write_jp2c );
+	/* DEVELOPER CORNER, add your custom procedures */
+#ifdef USE_JPIP
+  if( jp2->jpip_on )
+    {
+    opj_procedure_list_add_procedure(jp2->m_procedure_list,(opj_procedure)opj_jpip_write_cidx );
+    opj_procedure_list_add_procedure(jp2->m_procedure_list,(opj_procedure)opj_jpip_write_fidx );
+    }
+#endif
+}
+
+void opj_jp2_setup_end_header_reading (opj_jp2_t *jp2)
+{
+	/* preconditions */
+	assert(jp2 != 00);
+	opj_procedure_list_add_procedure(jp2->m_procedure_list,(opj_procedure)opj_jp2_read_header_procedure );
+	/* DEVELOPER CORNER, add your custom procedures */
+}
+
+OPJ_BOOL opj_jp2_default_validation (	opj_jp2_t * jp2,
+                                        opj_stream_private_t *cio,
+                                        opj_event_mgr_t * p_manager
+                                        )
+{
+	OPJ_BOOL l_is_valid = OPJ_TRUE;
+	OPJ_UINT32 i;
+
+	/* preconditions */
+	assert(jp2 != 00);
+	assert(cio != 00);
+	assert(p_manager != 00);
+
+	/* JPEG2000 codec validation */
+
+	/* STATE checking */
+	/* make sure the state is at 0 */
+	l_is_valid &= (jp2->jp2_state == JP2_STATE_NONE);
+
+	/* make sure not reading a jp2h ???? WEIRD */
+	l_is_valid &= (jp2->jp2_img_state == JP2_IMG_STATE_NONE);
+
+	/* POINTER validation */
+	/* make sure a j2k codec is present */
+	l_is_valid &= (jp2->j2k != 00);
+
+	/* make sure a procedure list is present */
+	l_is_valid &= (jp2->m_procedure_list != 00);
+
+	/* make sure a validation list is present */
+	l_is_valid &= (jp2->m_validation_list != 00);
+
+	/* PARAMETER VALIDATION */
+	/* number of components */
+	l_is_valid &= (jp2->numcl > 0);
+	/* width */
+	l_is_valid &= (jp2->h > 0);
+	/* height */
+	l_is_valid &= (jp2->w > 0);
+	/* precision */
+	for (i = 0; i < jp2->numcomps; ++i)	{
+		l_is_valid &= (jp2->comps[i].bpcc > 0);
+	}
+
+	/* METH */
+	l_is_valid &= ((jp2->meth > 0) && (jp2->meth < 3));
+
+	/* stream validation */
+	/* back and forth is needed */
+	l_is_valid &= opj_stream_has_seek(cio);
+
+	return l_is_valid;
+}
+
+OPJ_BOOL opj_jp2_read_header_procedure(  opj_jp2_t *jp2,
+                                                opj_stream_private_t *stream,
+                                                opj_event_mgr_t * p_manager
+                                                )
+{
+	opj_jp2_box_t box;
+	OPJ_UINT32 l_nb_bytes_read;
+	const opj_jp2_header_handler_t * l_current_handler;
+	OPJ_UINT32 l_last_data_size = OPJ_BOX_SIZE;
+	OPJ_UINT32 l_current_data_size;
+	OPJ_BYTE * l_current_data = 00;
+
+	/* preconditions */
+	assert(stream != 00);
+	assert(jp2 != 00);
+	assert(p_manager != 00);
+
+	l_current_data = (OPJ_BYTE*)opj_malloc(l_last_data_size);
+
+	if (l_current_data == 00) {
+		opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to handle jpeg2000 file header\n");
+		return OPJ_FALSE;
+	}
+	memset(l_current_data, 0 , l_last_data_size);
+
+	while (opj_jp2_read_boxhdr(&box,&l_nb_bytes_read,stream,p_manager)) {
+		/* is it the codestream box ? */
+		if (box.type == JP2_JP2C) {
+			if (jp2->jp2_state & JP2_STATE_HEADER) {
+				jp2->jp2_state |= JP2_STATE_CODESTREAM;
+                                opj_free(l_current_data);
+				return OPJ_TRUE;
+			}
+			else {
+				opj_event_msg(p_manager, EVT_ERROR, "bad placed jpeg codestream\n");
+				opj_free(l_current_data);
+				return OPJ_FALSE;
+			}
 		}
-		opj_free(pcol_usage);
-		if (!is_sane) {
+		else if	(box.length == 0) {
+			opj_event_msg(p_manager, EVT_ERROR, "Cannot handle box of undefined sizes\n");
+			opj_free(l_current_data);
+			return OPJ_FALSE;
+		}
+		/* testcase 1851.pdf.SIGSEGV.ce9.948 */
+		else if	(box.length < l_nb_bytes_read) {
+			opj_event_msg(p_manager, EVT_ERROR, "invalid box size %d (%x)\n", box.length, box.type);
+			opj_free(l_current_data);
 			return OPJ_FALSE;
 		}
+
+		l_current_handler = opj_jp2_find_handler(box.type);
+		l_current_data_size = box.length - l_nb_bytes_read;
+
+		if (l_current_handler != 00) {
+			if (l_current_data_size > l_last_data_size) {
+				OPJ_BYTE* new_current_data = (OPJ_BYTE*)opj_realloc(l_current_data,l_current_data_size);
+				if (!new_current_data) {
+					opj_free(l_current_data);
+                    opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to handle jpeg2000 box\n");
+					return OPJ_FALSE;
+				}
+                l_current_data = new_current_data;
+				l_last_data_size = l_current_data_size;
+			}
+
+			l_nb_bytes_read = (OPJ_UINT32)opj_stream_read_data(stream,l_current_data,l_current_data_size,p_manager);
+			if (l_nb_bytes_read != l_current_data_size) {
+				opj_event_msg(p_manager, EVT_ERROR, "Problem with reading JPEG2000 box, stream error\n");
+                opj_free(l_current_data);                
+				return OPJ_FALSE;
+			}
+
+			if (! l_current_handler->handler(jp2,l_current_data,l_current_data_size,p_manager)) {
+				opj_free(l_current_data);
+				return OPJ_FALSE;
+			}
+		}
+		else {
+			jp2->jp2_state |= JP2_STATE_UNKNOWN;
+			if (opj_stream_skip(stream,l_current_data_size,p_manager) != l_current_data_size) {
+				opj_event_msg(p_manager, EVT_ERROR, "Problem with skipping JPEG2000 box, stream error\n");
+				opj_free(l_current_data);
+				return OPJ_FALSE;
+			}
+		}
 	}
 
+	opj_free(l_current_data);
+
 	return OPJ_TRUE;
 }
 
-opj_image_t* opj_jp2_decode(opj_jp2_t *jp2, opj_cio_t *cio, 
-	opj_codestream_info_t *cstr_info) 
+/**
+ * Excutes the given procedures on the given codec.
+ *
+ * @param	p_procedure_list	the list of procedures to execute
+ * @param	jp2					the jpeg2000 file codec to execute the procedures on.
+ * @param	stream					the stream to execute the procedures on.
+ * @param	p_manager			the user manager.
+ *
+ * @return	true				if all the procedures were successfully executed.
+ */
+static OPJ_BOOL opj_jp2_exec (  opj_jp2_t * jp2,
+                                opj_procedure_list_t * p_procedure_list,
+                                opj_stream_private_t *stream,
+                                opj_event_mgr_t * p_manager
+                                )
+
 {
-	opj_common_ptr cinfo;
-	opj_image_t *image = NULL;
-	opj_jp2_color_t color;
+	OPJ_BOOL (** l_procedure) (opj_jp2_t * jp2, opj_stream_private_t *, opj_event_mgr_t *) = 00;
+	OPJ_BOOL l_result = OPJ_TRUE;
+	OPJ_UINT32 l_nb_proc, i;
+
+	/* preconditions */
+	assert(p_procedure_list != 00);
+	assert(jp2 != 00);
+	assert(stream != 00);
+	assert(p_manager != 00);
+
+	l_nb_proc = opj_procedure_list_get_nb_procedures(p_procedure_list);
+	l_procedure = (OPJ_BOOL (**) (opj_jp2_t * jp2, opj_stream_private_t *, opj_event_mgr_t *)) opj_procedure_list_get_first_procedure(p_procedure_list);
+
+	for	(i=0;i<l_nb_proc;++i) {
+		l_result = l_result && (*l_procedure) (jp2,stream,p_manager);
+		++l_procedure;
+	}
 
-	if(!jp2 || !cio) 
-   {
-	return NULL;
-   }
-	memset(&color, 0, sizeof(opj_jp2_color_t));
-	cinfo = jp2->cinfo;
-
-/* JP2 decoding */
-	if(!jp2_read_struct(jp2, cio, &color)) 
-   {
-	free_color_data(&color);
-	opj_event_msg(cinfo, EVT_ERROR, "Failed to decode jp2 structure\n");
-	return NULL;
-   }
+	/* and clear the procedure list at the end. */
+	opj_procedure_list_clear(p_procedure_list);
+	return l_result;
+}
+
+OPJ_BOOL opj_jp2_start_compress(opj_jp2_t *jp2,
+                                opj_stream_private_t *stream,
+                                opj_image_t * p_image,
+                                opj_event_mgr_t * p_manager
+                                )
+{
+	/* preconditions */
+	assert(jp2 != 00);
+	assert(stream != 00);
+	assert(p_manager != 00);
+
+	/* customization of the validation */
+	opj_jp2_setup_encoding_validation (jp2);
+
+	/* validation of the parameters codec */
+	if (! opj_jp2_exec(jp2,jp2->m_validation_list,stream,p_manager)) {
+		return OPJ_FALSE;
+	}
 
-/* J2K decoding */
-	image = j2k_decode(jp2->j2k, cio, cstr_info);
+	/* customization of the encoding */
+	opj_jp2_setup_header_writing(jp2);
 
-	if(!image) 
-   {
-	free_color_data(&color);
-	opj_event_msg(cinfo, EVT_ERROR, "Failed to decode J2K image\n");
+	/* write header */
+	if (! opj_jp2_exec (jp2,jp2->m_procedure_list,stream,p_manager)) {
+		return OPJ_FALSE;
+	}
+
+	return opj_j2k_start_compress(jp2->j2k,stream,p_image,p_manager);
+}
+
+const opj_jp2_header_handler_t * opj_jp2_find_handler (OPJ_UINT32 p_id)
+{
+	OPJ_UINT32 i, l_handler_size = sizeof(jp2_header) / sizeof(opj_jp2_header_handler_t);
+
+	for (i=0;i<l_handler_size;++i) {
+		if (jp2_header[i].id == p_id) {
+			return &jp2_header[i];
+		}
+	}
 	return NULL;
-   }
-   
-    if (!jp2->ignore_pclr_cmap_cdef){
-	    if (!opj_jp2_check_color(image, &color, cinfo)) {
-        opj_event_msg(cinfo, EVT_ERROR, "Failed to decode PCRL box\n");
-		    return NULL;
-	    }
+}
 
-    /* Set Image Color Space */
-	if (jp2->enumcs == 16)
-		image->color_space = CLRSPC_SRGB;
-	else if (jp2->enumcs == 17)
-		image->color_space = CLRSPC_GRAY;
-	else if (jp2->enumcs == 18)
-		image->color_space = CLRSPC_SYCC;
-	else
-		image->color_space = CLRSPC_UNKNOWN;
+/**
+ * Finds the image execution function related to the given box id.
+ *
+ * @param	p_id	the id of the handler to fetch.
+ *
+ * @return	the given handler or 00 if it could not be found.
+ */
+static const opj_jp2_header_handler_t * opj_jp2_img_find_handler (OPJ_UINT32 p_id)
+{
+	OPJ_UINT32 i, l_handler_size = sizeof(jp2_img_header) / sizeof(opj_jp2_header_handler_t);
+	for (i=0;i<l_handler_size;++i)
+	{
+		if (jp2_img_header[i].id == p_id) {
+			return &jp2_img_header[i];
+		}
+	}
 
-	if(color.jp2_cdef)
-   {
-	jp2_apply_cdef(image, &color);
-   }
-	if(color.jp2_pclr)
-   {
-/* Part 1, I.5.3.4: Either both or none : */
-	if( !color.jp2_pclr->cmap) 
-	 jp2_free_pclr(&color);
-	else
-	 jp2_apply_pclr(&color, image, cinfo);
-   }
-	if(color.icc_profile_buf)
-   {
-	image->icc_profile_buf = color.icc_profile_buf;
-	color.icc_profile_buf = NULL;
-	image->icc_profile_len = color.icc_profile_len;
-   }
-   }
-   
-	return image;
+	return NULL;
+}
 
-}/* opj_jp2_decode() */
+/**
+ * Reads a jpeg2000 file signature box.
+ *
+ * @param	p_header_data	the data contained in the signature box.
+ * @param	jp2				the jpeg2000 file codec.
+ * @param	p_header_size	the size of the data contained in the signature box.
+ * @param	p_manager		the user event manager.
+ *
+ * @return true if the file signature box is valid.
+ */
+static OPJ_BOOL opj_jp2_read_jp(opj_jp2_t *jp2,
+                                OPJ_BYTE * p_header_data,
+                                OPJ_UINT32 p_header_size,
+                                opj_event_mgr_t * p_manager
+                                )
 
+{
+	OPJ_UINT32 l_magic_number;
 
-void jp2_write_jp2h(opj_jp2_t *jp2, opj_cio_t *cio) {
-	opj_jp2_box_t box;
+	/* preconditions */
+	assert(p_header_data != 00);
+	assert(jp2 != 00);
+	assert(p_manager != 00);
 
-	box.init_pos = cio_tell(cio);
-	cio_skip(cio, 4);
-	cio_write(cio, JP2_JP2H, 4);	/* JP2H */
+	if (jp2->jp2_state != JP2_STATE_NONE) {
+		opj_event_msg(p_manager, EVT_ERROR, "The signature box must be the first box in the file.\n");
+		return OPJ_FALSE;
+	}
 
-	jp2_write_ihdr(jp2, cio);
+	/* assure length of data is correct (4 -> magic number) */
+	if (p_header_size != 4) {
+		opj_event_msg(p_manager, EVT_ERROR, "Error with JP signature Box size\n");
+		return OPJ_FALSE;
+	}
 
-	if (jp2->bpc == 255) {
-		jp2_write_bpcc(jp2, cio);
+	/* rearrange data */
+	opj_read_bytes(p_header_data,&l_magic_number,4);
+	if (l_magic_number != 0x0d0a870a ) {
+		opj_event_msg(p_manager, EVT_ERROR, "Error with JP Signature : bad magic number\n");
+		return OPJ_FALSE;
 	}
-	jp2_write_colr(jp2, cio);
 
-	box.length = cio_tell(cio) - box.init_pos;
-	cio_seek(cio, box.init_pos);
-	cio_write(cio, box.length, 4);	/* L */
-	cio_seek(cio, box.init_pos + box.length);
+	jp2->jp2_state |= JP2_STATE_SIGNATURE;
+
+	return OPJ_TRUE;
 }
 
-static void jp2_write_ftyp(opj_jp2_t *jp2, opj_cio_t *cio) {
-	unsigned int i;
-	opj_jp2_box_t box;
+/**
+ * Reads a a FTYP box - File type box
+ *
+ * @param	p_header_data	the data contained in the FTYP box.
+ * @param	jp2				the jpeg2000 file codec.
+ * @param	p_header_size	the size of the data contained in the FTYP box.
+ * @param	p_manager		the user event manager.
+ *
+ * @return true if the FTYP box is valid.
+ */
+static OPJ_BOOL opj_jp2_read_ftyp(	opj_jp2_t *jp2,
+									OPJ_BYTE * p_header_data,
+									OPJ_UINT32 p_header_size,
+									opj_event_mgr_t * p_manager
+                                    )
+{
+	OPJ_UINT32 i, l_remaining_bytes;
 
-	box.init_pos = cio_tell(cio);
-	cio_skip(cio, 4);
-	cio_write(cio, JP2_FTYP, 4);		/* FTYP */
+	/* preconditions */
+	assert(p_header_data != 00);
+	assert(jp2 != 00);
+	assert(p_manager != 00);
+
+	if (jp2->jp2_state != JP2_STATE_SIGNATURE) {
+		opj_event_msg(p_manager, EVT_ERROR, "The ftyp box must be the second box in the file.\n");
+		return OPJ_FALSE;
+	}
+
+	/* assure length of data is correct */
+	if (p_header_size < 8) {
+		opj_event_msg(p_manager, EVT_ERROR, "Error with FTYP signature Box size\n");
+		return OPJ_FALSE;
+	}
+
+	opj_read_bytes(p_header_data,&jp2->brand,4);		/* BR */
+	p_header_data += 4;
+
+	opj_read_bytes(p_header_data,&jp2->minversion,4);		/* MinV */
+	p_header_data += 4;
+
+	l_remaining_bytes = p_header_size - 8;
+
+	/* the number of remaining bytes should be a multiple of 4 */
+	if ((l_remaining_bytes & 0x3) != 0) {
+		opj_event_msg(p_manager, EVT_ERROR, "Error with FTYP signature Box size\n");
+		return OPJ_FALSE;
+	}
+
+	/* div by 4 */
+	jp2->numcl = l_remaining_bytes >> 2;
+	if (jp2->numcl) {
+		jp2->cl = (OPJ_UINT32 *) opj_malloc(jp2->numcl * sizeof(OPJ_UINT32));
+		if (jp2->cl == 00) {
+			opj_event_msg(p_manager, EVT_ERROR, "Not enough memory with FTYP Box\n");
+			return OPJ_FALSE;
+		}
+		memset(jp2->cl,0,jp2->numcl * sizeof(OPJ_UINT32));
+	}
+
+	for (i = 0; i < jp2->numcl; ++i)
+	{
+		opj_read_bytes(p_header_data,&jp2->cl[i],4);		/* CLi */
+		p_header_data += 4;
+	}
+
+	jp2->jp2_state |= JP2_STATE_FILE_TYPE;
+
+	return OPJ_TRUE;
+}
 
-	cio_write(cio, jp2->brand, 4);		/* BR */
-	cio_write(cio, jp2->minversion, 4);	/* MinV */
+OPJ_BOOL opj_jp2_skip_jp2c(	opj_jp2_t *jp2,
+					    	opj_stream_private_t *stream,
+					    	opj_event_mgr_t * p_manager )
+{
+	/* preconditions */
+	assert(jp2 != 00);
+	assert(stream != 00);
+	assert(p_manager != 00);
+
+	jp2->j2k_codestream_offset = opj_stream_tell(stream);
 
-	for (i = 0; i < jp2->numcl; i++) {
-		cio_write(cio, jp2->cl[i], 4);	/* CL */
+	if (opj_stream_skip(stream,8,p_manager) != 8) {
+		return OPJ_FALSE;
 	}
 
-	box.length = cio_tell(cio) - box.init_pos;
-	cio_seek(cio, box.init_pos);
-	cio_write(cio, box.length, 4);	/* L */
-	cio_seek(cio, box.init_pos + box.length);
+	return OPJ_TRUE;
 }
 
-static opj_bool jp2_read_ftyp(opj_jp2_t *jp2, opj_cio_t *cio) {
-	int i;
-	opj_jp2_box_t box;
+static OPJ_BOOL opj_jpip_skip_iptr(	opj_jp2_t *jp2,
+  opj_stream_private_t *stream,
+  opj_event_mgr_t * p_manager )
+{
+  /* preconditions */
+  assert(jp2 != 00);
+  assert(stream != 00);
+  assert(p_manager != 00);
 
-	opj_common_ptr cinfo = jp2->cinfo;
+  jp2->jpip_iptr_offset = opj_stream_tell(stream);
 
-  if( jp2_read_boxhdr(cinfo, cio, &box) == OPJ_FALSE ) {
-    opj_event_msg(cinfo, EVT_ERROR, "Failed to read boxhdr\n");
+  if (opj_stream_skip(stream,24,p_manager) != 24) {
     return OPJ_FALSE;
   }
-	if (JP2_FTYP != box.type) {
-		opj_event_msg(cinfo, EVT_ERROR, "Expected FTYP Marker\n");
-		return OPJ_FALSE;
-	}
 
-	jp2->brand = cio_read(cio, 4);		/* BR */
-	jp2->minversion = cio_read(cio, 4);	/* MinV */
-	jp2->numcl = (box.length - 16) / 4;
+  return OPJ_TRUE;
+}
+
+/**
+ * Reads the Jpeg2000 file Header box - JP2 Header box (warning, this is a super box).
+ *
+ * @param	p_header_data	the data contained in the file header box.
+ * @param	jp2				the jpeg2000 file codec.
+ * @param	p_header_size	the size of the data contained in the file header box.
+ * @param	p_manager		the user event manager.
+ *
+ * @return true if the JP2 Header box was successfully reconized.
+*/
+static OPJ_BOOL opj_jp2_read_jp2h(  opj_jp2_t *jp2,
+                                    OPJ_BYTE *p_header_data,
+                                    OPJ_UINT32 p_header_size,
+                                    opj_event_mgr_t * p_manager
+                                    )
+{
+	OPJ_UINT32 l_box_size=0, l_current_data_size = 0;
+	opj_jp2_box_t box;
+	const opj_jp2_header_handler_t * l_current_handler;
+
+	/* preconditions */
+	assert(p_header_data != 00);
+	assert(jp2 != 00);
+	assert(p_manager != 00);
 
-  /* edf_c2_1673169.jp2 */
-	if (cio_numbytesleft(cio) < ((int)jp2->numcl * 4)) {
-		opj_event_msg(cinfo, EVT_ERROR, "Not enough bytes in FTYP Box "
-				"(expected %d, but only %d left)\n",
-				((int)jp2->numcl * 4), cio_numbytesleft(cio));
+	/* make sure the box is well placed */
+	if ((jp2->jp2_state & JP2_STATE_FILE_TYPE) != JP2_STATE_FILE_TYPE ) {
+		opj_event_msg(p_manager, EVT_ERROR, "The  box must be the first box in the file.\n");
 		return OPJ_FALSE;
 	}
-	jp2->cl = (unsigned int *) opj_malloc(jp2->numcl * sizeof(unsigned int));
 
-	for (i = 0; i < (int)jp2->numcl; i++) {
-		jp2->cl[i] = cio_read(cio, 4);	/* CLi */
-	}
+	jp2->jp2_img_state = JP2_IMG_STATE_NONE;
 
-	if (cio_tell(cio) - box.init_pos != box.length) {
-		opj_event_msg(cinfo, EVT_ERROR, "Error with FTYP Box\n");
-		return OPJ_FALSE;
+	/* iterate while remaining data */
+	while (p_header_size > 0) {
+
+		if (! opj_jp2_read_boxhdr_char(&box,p_header_data,&l_box_size,p_header_size, p_manager)) {
+			opj_event_msg(p_manager, EVT_ERROR, "Stream error while reading JP2 Header box\n");
+			return OPJ_FALSE;
+		}
+
+		if (box.length > p_header_size) {
+			opj_event_msg(p_manager, EVT_ERROR, "Stream error while reading JP2 Header box: box length is inconsistent.\n");
+			return OPJ_FALSE;
+		}
+
+		l_current_handler = opj_jp2_img_find_handler(box.type);
+		l_current_data_size = box.length - l_box_size;
+		p_header_data += l_box_size;
+
+		if (l_current_handler != 00) {
+			if (! l_current_handler->handler(jp2,p_header_data,l_current_data_size,p_manager)) {
+				return OPJ_FALSE;
+			}
+		}
+		else {
+			jp2->jp2_img_state |= JP2_IMG_STATE_UNKNOWN;
+		}
+
+		p_header_data += l_current_data_size;
+		p_header_size -= box.length;
 	}
 
+	jp2->jp2_state |= JP2_STATE_HEADER;
+
 	return OPJ_TRUE;
 }
 
-static int jp2_write_jp2c(opj_jp2_t *jp2, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info) {
-	unsigned int j2k_codestream_offset, j2k_codestream_length;
-	opj_jp2_box_t box;
-
-	opj_j2k_t *j2k = jp2->j2k;
+OPJ_BOOL opj_jp2_read_boxhdr_char(   opj_jp2_box_t *box,
+                                     OPJ_BYTE * p_data,
+                                     OPJ_UINT32 * p_number_bytes_read,
+                                     OPJ_UINT32 p_box_max_size,
+                                     opj_event_mgr_t * p_manager
+                                     )
+{
+	OPJ_UINT32 l_value;
 
-	box.init_pos = cio_tell(cio);
-	cio_skip(cio, 4);
-	cio_write(cio, JP2_JP2C, 4);	/* JP2C */
+	/* preconditions */
+	assert(p_data != 00);
+	assert(box != 00);
+	assert(p_number_bytes_read != 00);
+	assert(p_manager != 00);
 
-	/* J2K encoding */
-	j2k_codestream_offset = cio_tell(cio);
-	if(!j2k_encode(j2k, cio, image, cstr_info)) {
-		opj_event_msg(j2k->cinfo, EVT_ERROR, "Failed to encode image\n");
-		return 0;
+	if (p_box_max_size < 8) {
+		opj_event_msg(p_manager, EVT_ERROR, "Cannot handle box of less than 8 bytes\n");
+		return OPJ_FALSE;
 	}
-	j2k_codestream_length = cio_tell(cio) - j2k_codestream_offset;
-
-	jp2->j2k_codestream_offset = j2k_codestream_offset;
-	jp2->j2k_codestream_length = j2k_codestream_length;
 
-	box.length = 8 + jp2->j2k_codestream_length;
-	cio_seek(cio, box.init_pos);
-	cio_write(cio, box.length, 4);	/* L */
-	cio_seek(cio, box.init_pos + box.length);
+	/* process read data */
+	opj_read_bytes(p_data, &l_value, 4);
+	p_data += 4;
+	box->length = (OPJ_UINT32)(l_value);
 
-	return box.length;
-}
+	opj_read_bytes(p_data, &l_value, 4);
+	p_data += 4;
+	box->type = (OPJ_UINT32)(l_value);
 
-static opj_bool jp2_read_jp2c(opj_jp2_t *jp2, opj_cio_t *cio, unsigned int *j2k_codestream_length, unsigned int *j2k_codestream_offset) {
-	opj_jp2_box_t box;
+	*p_number_bytes_read = 8;
 
-	opj_common_ptr cinfo = jp2->cinfo;
+	/* do we have a "special very large box ?" */
+	/* read then the XLBox */
+	if (box->length == 1) {
+		OPJ_UINT32 l_xl_part_size;
 
-  if( jp2_read_boxhdr(cinfo, cio, &box) == OPJ_FALSE ) {
-    opj_event_msg(cinfo, EVT_ERROR, "Failed to read boxhdr\n");
-    return OPJ_FALSE;
-  }
-	do {
-		if(JP2_JP2C != box.type) {
-			if (box.length <= 8) return OPJ_FALSE;
-			cio_skip(cio, box.length - 8);
-			if( jp2_read_boxhdr(cinfo, cio, &box) == OPJ_FALSE ) return OPJ_FALSE;
+		if (p_box_max_size < 16) {
+			opj_event_msg(p_manager, EVT_ERROR, "Cannot handle XL box of less than 16 bytes\n");
+			return OPJ_FALSE;
 		}
-	} while(JP2_JP2C != box.type);
 
-	*j2k_codestream_offset = cio_tell(cio);
-	if (box.length <= 8) return OPJ_FALSE;
-	*j2k_codestream_length = box.length - 8;
+		opj_read_bytes(p_data,&l_xl_part_size, 4);
+		p_data += 4;
+		*p_number_bytes_read += 4;
 
-	return OPJ_TRUE;
-}
+		if (l_xl_part_size != 0) {
+			opj_event_msg(p_manager, EVT_ERROR, "Cannot handle box sizes higher than 2^32\n");
+			return OPJ_FALSE;
+		}
 
-static void jp2_write_jp(opj_cio_t *cio) {
-	opj_jp2_box_t box;
+		opj_read_bytes(p_data, &l_value, 4);
+		*p_number_bytes_read += 4;
+		box->length = (OPJ_UINT32)(l_value);
 
-	box.init_pos = cio_tell(cio);
-	cio_skip(cio, 4);
-	cio_write(cio, JP2_JP, 4);		/* JP2 signature */
-	cio_write(cio, 0x0d0a870a, 4);
+		if (box->length == 0) {
+			opj_event_msg(p_manager, EVT_ERROR, "Cannot handle box of undefined sizes\n");
+			return OPJ_FALSE;
+		}
+	}
+	else if (box->length == 0) {
+		opj_event_msg(p_manager, EVT_ERROR, "Cannot handle box of undefined sizes\n");
+		return OPJ_FALSE;
+	}
 
-	box.length = cio_tell(cio) - box.init_pos;
-	cio_seek(cio, box.init_pos);
-	cio_write(cio, box.length, 4);	/* L */
-	cio_seek(cio, box.init_pos + box.length);
+	return OPJ_TRUE;
 }
 
-static opj_bool jp2_read_jp(opj_jp2_t *jp2, opj_cio_t *cio) {
-	opj_jp2_box_t box;
+OPJ_BOOL opj_jp2_read_header(	opj_stream_private_t *p_stream,
+                                opj_jp2_t *jp2,
+                                opj_image_t ** p_image,
+                                opj_event_mgr_t * p_manager
+                                )
+{
+	/* preconditions */
+	assert(jp2 != 00);
+	assert(p_stream != 00);
+	assert(p_manager != 00);
 
-	opj_common_ptr cinfo = jp2->cinfo;
+	/* customization of the validation */
+	opj_jp2_setup_decoding_validation (jp2);
 
-  if( jp2_read_boxhdr(cinfo, cio, &box) == OPJ_FALSE ) {
-    opj_event_msg(cinfo, EVT_ERROR, "Failed to read boxhdr\n");
-    return OPJ_FALSE;
-  }
-	if (JP2_JP != box.type) {
-		opj_event_msg(cinfo, EVT_ERROR, "Expected JP Marker\n");
-		return OPJ_FALSE;
-	}
-	if (0x0d0a870a != cio_read(cio, 4)) {
-		opj_event_msg(cinfo, EVT_ERROR, "Error with JP Marker\n");
+	/* customization of the encoding */
+	opj_jp2_setup_header_reading(jp2);
+
+	/* validation of the parameters codec */
+	if (! opj_jp2_exec(jp2,jp2->m_validation_list,p_stream,p_manager)) {
 		return OPJ_FALSE;
 	}
-	if (cio_tell(cio) - box.init_pos != box.length) {
-		opj_event_msg(cinfo, EVT_ERROR, "Error with JP Box size\n");
+
+	/* read header */
+	if (! opj_jp2_exec (jp2,jp2->m_procedure_list,p_stream,p_manager)) {
 		return OPJ_FALSE;
 	}
 
-	return OPJ_TRUE;
+	return opj_j2k_read_header(	p_stream,
+							jp2->j2k,
+							p_image,
+							p_manager);
 }
 
+void opj_jp2_setup_encoding_validation (opj_jp2_t *jp2)
+{
+	/* preconditions */
+	assert(jp2 != 00);
 
-static opj_bool jp2_read_struct(opj_jp2_t *jp2, opj_cio_t *cio,
-	opj_jp2_color_t *color) {
-	if (!jp2_read_jp(jp2, cio))
-		return OPJ_FALSE;
-	if (!jp2_read_ftyp(jp2, cio))
-		return OPJ_FALSE;
-	if (!jp2_read_jp2h(jp2, cio, color))
-		return OPJ_FALSE;
-	if (!jp2_read_jp2c(jp2, cio, &jp2->j2k_codestream_length, &jp2->j2k_codestream_offset))
-		return OPJ_FALSE;
-	
-	return OPJ_TRUE;
+	opj_procedure_list_add_procedure(jp2->m_validation_list, (opj_procedure)opj_jp2_default_validation);
+	/* DEVELOPER CORNER, add your custom validation procedure */
+}
+
+void opj_jp2_setup_decoding_validation (opj_jp2_t *jp2)
+{
+	/* preconditions */
+	assert(jp2 != 00);
+	/* DEVELOPER CORNER, add your custom validation procedure */
 }
 
+void opj_jp2_setup_header_writing (opj_jp2_t *jp2)
+{
+	/* preconditions */
+	assert(jp2 != 00);
 
-static int write_fidx( int offset_jp2c, int length_jp2c, int offset_idx, int length_idx, opj_cio_t *cio)
-{  
-  int len, lenp;
-  
-  lenp = cio_tell( cio);
-  cio_skip( cio, 4);              /* L [at the end] */
-  cio_write( cio, JPIP_FIDX, 4);  /* IPTR           */
-  
-  write_prxy( offset_jp2c, length_jp2c, offset_idx, length_idx, cio);
+	opj_procedure_list_add_procedure(jp2->m_procedure_list,(opj_procedure)opj_jp2_write_jp );
+	opj_procedure_list_add_procedure(jp2->m_procedure_list,(opj_procedure)opj_jp2_write_ftyp );
+	opj_procedure_list_add_procedure(jp2->m_procedure_list,(opj_procedure)opj_jp2_write_jp2h );
+  if( jp2->jpip_on )
+    opj_procedure_list_add_procedure(jp2->m_procedure_list,(opj_procedure)opj_jpip_skip_iptr );
+	opj_procedure_list_add_procedure(jp2->m_procedure_list,(opj_procedure)opj_jp2_skip_jp2c );
 
-  len = cio_tell( cio)-lenp;
-  cio_seek( cio, lenp);
-  cio_write( cio, len, 4);        /* L              */
-  cio_seek( cio, lenp+len);  
+	/* DEVELOPER CORNER, insert your custom procedures */
 
-  return len;
 }
 
-static void write_prxy( int offset_jp2c, int length_jp2c, int offset_idx, int length_idx, opj_cio_t *cio)
+void opj_jp2_setup_header_reading (opj_jp2_t *jp2)
 {
-  int len, lenp;
-
-  lenp = cio_tell( cio);
-  cio_skip( cio, 4);              /* L [at the end] */
-  cio_write( cio, JPIP_PRXY, 4);  /* IPTR           */
-  
-  cio_write( cio, offset_jp2c, 8); /* OOFF           */
-  cio_write( cio, length_jp2c, 4); /* OBH part 1     */
-  cio_write( cio, JP2_JP2C, 4);        /* OBH part 2     */
-  
-  cio_write( cio, 1,1);           /* NI             */
-
-  cio_write( cio, offset_idx, 8);  /* IOFF           */
-  cio_write( cio, length_idx, 4);  /* IBH part 1     */
-  cio_write( cio, JPIP_CIDX, 4);   /* IBH part 2     */
-
-  len = cio_tell( cio)-lenp;
-  cio_seek( cio, lenp);
-  cio_write( cio, len, 4);        /* L              */
-  cio_seek( cio, lenp+len);
+	/* preconditions */
+	assert(jp2 != 00);
+
+	opj_procedure_list_add_procedure(jp2->m_procedure_list,(opj_procedure)opj_jp2_read_header_procedure );
+	/* DEVELOPER CORNER, add your custom procedures */
 }
 
-static void write_iptr( int offset, int length, opj_cio_t *cio)
+OPJ_BOOL opj_jp2_read_tile_header ( opj_jp2_t * p_jp2,
+                                    OPJ_UINT32 * p_tile_index,
+                                    OPJ_UINT32 * p_data_size,
+                                    OPJ_INT32 * p_tile_x0,
+                                    OPJ_INT32 * p_tile_y0,
+                                    OPJ_INT32 * p_tile_x1,
+                                    OPJ_INT32 * p_tile_y1,
+                                    OPJ_UINT32 * p_nb_comps,
+                                    OPJ_BOOL * p_go_on,
+                                    opj_stream_private_t *p_stream,
+                                    opj_event_mgr_t * p_manager
+                                    )
 {
-  int len, lenp;
-  
-  lenp = cio_tell( cio);
-  cio_skip( cio, 4);              /* L [at the end] */
-  cio_write( cio, JPIP_IPTR, 4);  /* IPTR           */
-  
-  cio_write( cio, offset, 8);
-  cio_write( cio, length, 8);
-
-  len = cio_tell( cio)-lenp;
-  cio_seek( cio, lenp);
-  cio_write( cio, len, 4);        /* L             */
-  cio_seek( cio, lenp+len);
+	return opj_j2k_read_tile_header(p_jp2->j2k,
+								p_tile_index,
+								p_data_size,
+								p_tile_x0, p_tile_y0,
+								p_tile_x1, p_tile_y1,
+								p_nb_comps,
+								p_go_on,
+								p_stream,
+								p_manager);
 }
 
+OPJ_BOOL opj_jp2_write_tile (	opj_jp2_t *p_jp2,
+					 	 	    OPJ_UINT32 p_tile_index,
+					 	 	    OPJ_BYTE * p_data,
+					 	 	    OPJ_UINT32 p_data_size,
+					 	 	    opj_stream_private_t *p_stream,
+					 	 	    opj_event_mgr_t * p_manager
+                                )
 
-/* ----------------------------------------------------------------------- */
-/* JP2 decoder interface                                             */
-/* ----------------------------------------------------------------------- */
+{
+	return opj_j2k_write_tile (p_jp2->j2k,p_tile_index,p_data,p_data_size,p_stream,p_manager);
+}
 
-opj_jp2_t* jp2_create_decompress(opj_common_ptr cinfo) {
-	opj_jp2_t *jp2 = (opj_jp2_t*) opj_calloc(1, sizeof(opj_jp2_t));
-	if(jp2) {
-		jp2->cinfo = cinfo;
-		/* create the J2K codec */
-		jp2->j2k = j2k_create_decompress(cinfo);
-		if(jp2->j2k == NULL) {
-			jp2_destroy_decompress(jp2);
-			return NULL;
-		}
-	}
-	return jp2;
+OPJ_BOOL opj_jp2_decode_tile (  opj_jp2_t * p_jp2,
+                                OPJ_UINT32 p_tile_index,
+                                OPJ_BYTE * p_data,
+                                OPJ_UINT32 p_data_size,
+                                opj_stream_private_t *p_stream,
+                                opj_event_mgr_t * p_manager
+                                )
+{
+	return opj_j2k_decode_tile (p_jp2->j2k,p_tile_index,p_data,p_data_size,p_stream,p_manager);
 }
 
-void jp2_destroy_decompress(opj_jp2_t *jp2) {
-	if(jp2) {
+void opj_jp2_destroy(opj_jp2_t *jp2)
+{
+	if (jp2) {
 		/* destroy the J2K codec */
-		j2k_destroy_decompress(jp2->j2k);
+		opj_j2k_destroy(jp2->j2k);
+		jp2->j2k = 00;
 
-		if(jp2->comps) {
+		if (jp2->comps) {
 			opj_free(jp2->comps);
+			jp2->comps = 00;
 		}
-		if(jp2->cl) {
+
+		if (jp2->cl) {
 			opj_free(jp2->cl);
+			jp2->cl = 00;
+		}
+
+		if (jp2->color.icc_profile_buf) {
+			opj_free(jp2->color.icc_profile_buf);
+			jp2->color.icc_profile_buf = 00;
+		}
+
+		if (jp2->color.jp2_cdef) {
+			if (jp2->color.jp2_cdef->info) {
+				opj_free(jp2->color.jp2_cdef->info);
+				jp2->color.jp2_cdef->info = NULL;
+			}
+
+			opj_free(jp2->color.jp2_cdef);
+			jp2->color.jp2_cdef = 00;
+		}
+
+		if (jp2->color.jp2_pclr) {
+			if (jp2->color.jp2_pclr->cmap) {
+				opj_free(jp2->color.jp2_pclr->cmap);
+				jp2->color.jp2_pclr->cmap = NULL;
+			}
+			if (jp2->color.jp2_pclr->channel_sign) {
+				opj_free(jp2->color.jp2_pclr->channel_sign);
+				jp2->color.jp2_pclr->channel_sign = NULL;
+			}
+			if (jp2->color.jp2_pclr->channel_size) {
+				opj_free(jp2->color.jp2_pclr->channel_size);
+				jp2->color.jp2_pclr->channel_size = NULL;
+			}
+			if (jp2->color.jp2_pclr->entries) {
+				opj_free(jp2->color.jp2_pclr->entries);
+				jp2->color.jp2_pclr->entries = NULL;
+			}
+
+			opj_free(jp2->color.jp2_pclr);
+			jp2->color.jp2_pclr = 00;
+		}
+
+		if (jp2->m_validation_list) {
+			opj_procedure_list_destroy(jp2->m_validation_list);
+			jp2->m_validation_list = 00;
 		}
+
+		if (jp2->m_procedure_list) {
+			opj_procedure_list_destroy(jp2->m_procedure_list);
+			jp2->m_procedure_list = 00;
+		}
+
 		opj_free(jp2);
 	}
 }
 
-void jp2_setup_decoder(opj_jp2_t *jp2, opj_dparameters_t *parameters) {
-	/* setup the J2K codec */
-	j2k_setup_decoder(jp2->j2k, parameters);
-	/* further JP2 initializations go here */
-	jp2->ignore_pclr_cmap_cdef = parameters->flags & OPJ_DPARAMETERS_IGNORE_PCLR_CMAP_CDEF_FLAG;
+OPJ_BOOL opj_jp2_set_decode_area(	opj_jp2_t *p_jp2,
+								    opj_image_t* p_image,
+								    OPJ_INT32 p_start_x, OPJ_INT32 p_start_y,
+								    OPJ_INT32 p_end_x, OPJ_INT32 p_end_y,
+								    opj_event_mgr_t * p_manager
+                                    )
+{
+	return opj_j2k_set_decode_area(p_jp2->j2k, p_image, p_start_x, p_start_y, p_end_x, p_end_y, p_manager);
+}
+
+OPJ_BOOL opj_jp2_get_tile(	opj_jp2_t *p_jp2,
+                            opj_stream_private_t *p_stream,
+                            opj_image_t* p_image,
+                            opj_event_mgr_t * p_manager,
+                            OPJ_UINT32 tile_index
+                            )
+{
+	if (!p_image)
+		return OPJ_FALSE;
+
+	opj_event_msg(p_manager, EVT_WARNING, "JP2 box which are after the codestream will not be read by this function.\n");
+
+	if (! opj_j2k_get_tile(p_jp2->j2k, p_stream, p_image, p_manager, tile_index) ){
+		opj_event_msg(p_manager, EVT_ERROR, "Failed to decode the codestream in the JP2 file\n");
+		return OPJ_FALSE;
+	}
+
+	if (!opj_jp2_check_color(p_image, &(p_jp2->color), p_manager)) {
+		return OPJ_FALSE;
+	}
+
+	/* Set Image Color Space */
+	if (p_jp2->enumcs == 16)
+		p_image->color_space = OPJ_CLRSPC_SRGB;
+	else if (p_jp2->enumcs == 17)
+		p_image->color_space = OPJ_CLRSPC_GRAY;
+	else if (p_jp2->enumcs == 18)
+		p_image->color_space = OPJ_CLRSPC_SYCC;
+	else
+		p_image->color_space = OPJ_CLRSPC_UNKNOWN;
+
+	/* Apply the color space if needed */
+	if(p_jp2->color.jp2_cdef) {
+		opj_jp2_apply_cdef(p_image, &(p_jp2->color));
+	}
+
+	if(p_jp2->color.jp2_pclr) {
+		/* Part 1, I.5.3.4: Either both or none : */
+		if( !p_jp2->color.jp2_pclr->cmap)
+			opj_jp2_free_pclr(&(p_jp2->color));
+		else
+			opj_jp2_apply_pclr(p_image, &(p_jp2->color));
+	}
+
+	if(p_jp2->color.icc_profile_buf) {
+		p_image->icc_profile_buf = p_jp2->color.icc_profile_buf;
+		p_image->icc_profile_len = p_jp2->color.icc_profile_len;
+		p_jp2->color.icc_profile_buf = NULL;
+	}
+
+	return OPJ_TRUE;
 }
 
 /* ----------------------------------------------------------------------- */
 /* JP2 encoder interface                                             */
 /* ----------------------------------------------------------------------- */
 
-opj_jp2_t* jp2_create_compress(opj_common_ptr cinfo) {
+opj_jp2_t* opj_jp2_create(OPJ_BOOL p_is_decoder)
+{
 	opj_jp2_t *jp2 = (opj_jp2_t*)opj_malloc(sizeof(opj_jp2_t));
-	if(jp2) {
-		memset(jp2, 0, sizeof(opj_jp2_t));
-		jp2->cinfo = cinfo;
+	if (jp2) {
+		memset(jp2,0,sizeof(opj_jp2_t));
+
 		/* create the J2K codec */
-		jp2->j2k = j2k_create_compress(cinfo);
-		if(jp2->j2k == NULL) {
-			jp2_destroy_compress(jp2);
-			return NULL;
+		if (! p_is_decoder) {
+			jp2->j2k = opj_j2k_create_compress();
+		}
+		else {
+			jp2->j2k = opj_j2k_create_decompress();
 		}
-	}
-	return jp2;
-}
 
-void jp2_destroy_compress(opj_jp2_t *jp2) {
-	if(jp2) {
-		/* destroy the J2K codec */
-		j2k_destroy_compress(jp2->j2k);
+		if (jp2->j2k == 00) {
+			opj_jp2_destroy(jp2);
+			return 00;
+		}
 
-		if(jp2->comps) {
-			opj_free(jp2->comps);
+		/* Color structure */
+		jp2->color.icc_profile_buf = NULL;
+		jp2->color.icc_profile_len = 0;
+		jp2->color.jp2_cdef = NULL;
+		jp2->color.jp2_pclr = NULL;
+		jp2->color.jp2_has_colr = 0;
+
+		/* validation list creation */
+		jp2->m_validation_list = opj_procedure_list_create();
+		if (! jp2->m_validation_list) {
+			opj_jp2_destroy(jp2);
+			return 00;
 		}
-		if(jp2->cl) {
-			opj_free(jp2->cl);
+
+		/* execution list creation */
+		jp2->m_procedure_list = opj_procedure_list_create();
+		if (! jp2->m_procedure_list) {
+			opj_jp2_destroy(jp2);
+			return 00;
 		}
-		opj_free(jp2);
 	}
+
+	return jp2;
 }
 
-void jp2_setup_encoder(opj_jp2_t *jp2, opj_cparameters_t *parameters, opj_image_t *image) {
-	int i;
-	int depth_0, sign;
+void jp2_dump(opj_jp2_t* p_jp2, OPJ_INT32 flag, FILE* out_stream)
+{
+	/* preconditions */
+	assert(p_jp2 != 00);
 
-	if(!jp2 || !parameters || !image)
-		return;
+	j2k_dump(p_jp2->j2k,
+					flag,
+					out_stream);
+}
 
-	/* setup the J2K codec */
-	/* ------------------- */
+opj_codestream_index_t* jp2_get_cstr_index(opj_jp2_t* p_jp2)
+{
+	return j2k_get_cstr_index(p_jp2->j2k);
+}
 
-	/* Check if number of components respects standard */
-	if (image->numcomps < 1 || image->numcomps > 16384) {
-		opj_event_msg(jp2->cinfo, EVT_ERROR, "Invalid number of components specified while setting up JP2 encoder\n");
-		return;
-	}
+opj_codestream_info_v2_t* jp2_get_cstr_info(opj_jp2_t* p_jp2)
+{
+	return j2k_get_cstr_info(p_jp2->j2k);
+}
 
-	j2k_setup_encoder(jp2->j2k, parameters, image);
+OPJ_BOOL opj_jp2_set_decoded_resolution_factor(opj_jp2_t *p_jp2,
+                                               OPJ_UINT32 res_factor,
+                                               opj_event_mgr_t * p_manager)
+{
+	return opj_j2k_set_decoded_resolution_factor(p_jp2->j2k, res_factor, p_manager);
+}
 
-	/* setup the JP2 codec */
-	/* ------------------- */
-	
-	/* Profile box */
+/* JPIP specific */
 
-	jp2->brand = JP2_JP2;	/* BR */
-	jp2->minversion = 0;	/* MinV */
-	jp2->numcl = 1;
-	jp2->cl = (unsigned int*) opj_malloc(jp2->numcl * sizeof(unsigned int));
-	jp2->cl[0] = JP2_JP2;	/* CL0 : JP2 */
+#ifdef USE_JPIP
+static OPJ_BOOL opj_jpip_write_iptr(opj_jp2_t *jp2,
+  opj_stream_private_t *cio,
+  opj_event_mgr_t * p_manager )
+{
+  OPJ_OFF_T j2k_codestream_exit;
+  OPJ_BYTE l_data_header [24];
+
+  /* preconditions */
+  assert(jp2 != 00);
+  assert(cio != 00);
+  assert(p_manager != 00);
+  assert(opj_stream_has_seek(cio));
+
+  j2k_codestream_exit = opj_stream_tell(cio);
+  opj_write_bytes(l_data_header, 24, 4); /* size of iptr */
+  opj_write_bytes(l_data_header + 4,JPIP_IPTR,4);									   /* IPTR */
+#if 0
+  opj_write_bytes(l_data_header + 4 + 4, 0, 8); /* offset */
+  opj_write_bytes(l_data_header + 8 + 8, 0, 8); /* length */
+#else
+  opj_write_double(l_data_header + 4 + 4, 0); /* offset */
+  opj_write_double(l_data_header + 8 + 8, 0); /* length */
+#endif
 
-	/* Image Header box */
+  if (! opj_stream_seek(cio,jp2->jpip_iptr_offset,p_manager)) {
+    opj_event_msg(p_manager, EVT_ERROR, "Failed to seek in the stream.\n");
+    return OPJ_FALSE;
+  }
 
-	jp2->numcomps = image->numcomps;	/* NC */
-	jp2->comps = (opj_jp2_comps_t*) opj_malloc(jp2->numcomps * sizeof(opj_jp2_comps_t));
-	jp2->h = image->y1 - image->y0;		/* HEIGHT */
-	jp2->w = image->x1 - image->x0;		/* WIDTH */
-	/* BPC */
-	depth_0 = image->comps[0].prec - 1;
-	sign = image->comps[0].sgnd;
-	jp2->bpc = depth_0 + (sign << 7);
-	for (i = 1; i < image->numcomps; i++) {
-		int depth = image->comps[i].prec - 1;
-		sign = image->comps[i].sgnd;
-		if (depth_0 != depth)
-			jp2->bpc = 255;
-	}
-	jp2->C = 7;			/* C : Always 7 */
-	jp2->UnkC = 0;		/* UnkC, colorspace specified in colr box */
-	jp2->IPR = 0;		/* IPR, no intellectual property */
-	
-	/* BitsPerComponent box */
+  if (opj_stream_write_data(cio,l_data_header,24,p_manager) != 24) {
+    opj_event_msg(p_manager, EVT_ERROR, "Failed to seek in the stream.\n");
+    return OPJ_FALSE;
+  }
 
-	for (i = 0; i < image->numcomps; i++) {
-		jp2->comps[i].bpcc = image->comps[i].prec - 1 + (image->comps[i].sgnd << 7);
-	}
-	jp2->meth = 1;
-	if (image->color_space == 1)
-		jp2->enumcs = 16;	/* sRGB as defined by IEC 61966-2.1 */
-	else if (image->color_space == 2)
-		jp2->enumcs = 17;	/* greyscale */
-	else if (image->color_space == 3)
-		jp2->enumcs = 18;	/* YUV */
-	jp2->precedence = 0;	/* PRECEDENCE */
-	jp2->approx = 0;		/* APPROX */
-	
-	jp2->jpip_on = parameters->jpip_on;
+  if (! opj_stream_seek(cio,j2k_codestream_exit,p_manager)) {
+    opj_event_msg(p_manager, EVT_ERROR, "Failed to seek in the stream.\n");
+    return OPJ_FALSE;
+  }
+
+  return OPJ_TRUE;
+}
+
+static OPJ_BOOL opj_jpip_write_fidx(opj_jp2_t *jp2,
+  opj_stream_private_t *cio,
+  opj_event_mgr_t * p_manager )
+{
+  OPJ_OFF_T j2k_codestream_exit;
+  OPJ_BYTE l_data_header [24];
+
+  /* preconditions */
+  assert(jp2 != 00);
+  assert(cio != 00);
+  assert(p_manager != 00);
+  assert(opj_stream_has_seek(cio));
+
+  opj_write_bytes(l_data_header, 24, 4); /* size of iptr */
+  opj_write_bytes(l_data_header + 4,JPIP_FIDX,4);									   /* IPTR */
+  opj_write_double(l_data_header + 4 + 4, 0); /* offset */
+  opj_write_double(l_data_header + 8 + 8, 0); /* length */
+
+  if (opj_stream_write_data(cio,l_data_header,24,p_manager) != 24) {
+    opj_event_msg(p_manager, EVT_ERROR, "Failed to seek in the stream.\n");
+    return OPJ_FALSE;
+  }
+
+  j2k_codestream_exit = opj_stream_tell(cio);
+  if (! opj_stream_seek(cio,j2k_codestream_exit,p_manager)) {
+    opj_event_msg(p_manager, EVT_ERROR, "Failed to seek in the stream.\n");
+    return OPJ_FALSE;
+  }
+
+  return OPJ_TRUE;
 }
 
-opj_bool opj_jp2_encode(opj_jp2_t *jp2, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info) {
+static OPJ_BOOL opj_jpip_write_cidx(opj_jp2_t *jp2,
+  opj_stream_private_t *cio,
+  opj_event_mgr_t * p_manager )
+{
+  OPJ_OFF_T j2k_codestream_exit;
+  OPJ_BYTE l_data_header [24];
+
+  /* preconditions */
+  assert(jp2 != 00);
+  assert(cio != 00);
+  assert(p_manager != 00);
+  assert(opj_stream_has_seek(cio));
+
+  j2k_codestream_exit = opj_stream_tell(cio);
+  opj_write_bytes(l_data_header, 24, 4); /* size of iptr */
+  opj_write_bytes(l_data_header + 4,JPIP_CIDX,4);									   /* IPTR */
+#if 0
+  opj_write_bytes(l_data_header + 4 + 4, 0, 8); /* offset */
+  opj_write_bytes(l_data_header + 8 + 8, 0, 8); /* length */
+#else
+  opj_write_double(l_data_header + 4 + 4, 0); /* offset */
+  opj_write_double(l_data_header + 8 + 8, 0); /* length */
+#endif
 
-	int pos_iptr, pos_cidx, pos_jp2c, len_jp2c, len_cidx, end_pos, pos_fidx, len_fidx;
-	pos_jp2c = pos_iptr = -1; /* remove a warning */
+  if (! opj_stream_seek(cio,j2k_codestream_exit,p_manager)) {
+    opj_event_msg(p_manager, EVT_ERROR, "Failed to seek in the stream.\n");
+    return OPJ_FALSE;
+  }
 
-	/* JP2 encoding */
+  if (opj_stream_write_data(cio,l_data_header,24,p_manager) != 24) {
+    opj_event_msg(p_manager, EVT_ERROR, "Failed to seek in the stream.\n");
+    return OPJ_FALSE;
+  }
 
-	/* JPEG 2000 Signature box */
-	jp2_write_jp(cio);
-	/* File Type box */
-	jp2_write_ftyp(jp2, cio);
-	/* JP2 Header box */
-	jp2_write_jp2h(jp2, cio);
+  j2k_codestream_exit = opj_stream_tell(cio);
+  if (! opj_stream_seek(cio,j2k_codestream_exit,p_manager)) {
+    opj_event_msg(p_manager, EVT_ERROR, "Failed to seek in the stream.\n");
+    return OPJ_FALSE;
+  }
 
-	if( jp2->jpip_on){
-	  pos_iptr = cio_tell( cio);
-	  cio_skip( cio, 24); /* IPTR further ! */
-	  
-	  pos_jp2c = cio_tell( cio);
-	}
+  return OPJ_TRUE;
+}
 
-	/* J2K encoding */
-	if(!(len_jp2c = jp2_write_jp2c( jp2, cio, image, cstr_info))){
-	    opj_event_msg(jp2->cinfo, EVT_ERROR, "Failed to encode image\n");
-	    return OPJ_FALSE;
-	}
+#if 0
+static void write_prxy( int offset_jp2c, int length_jp2c, int offset_idx, int length_idx, opj_stream_private_t *cio,
+  opj_event_mgr_t * p_manager )
+{
+  OPJ_BYTE l_data_header [8];
+  OPJ_OFF_T len, lenp;
+
+  lenp = opj_stream_tell(cio);
+  opj_stream_skip(cio, 4, p_manager);         /* L [at the end] */
+  opj_write_bytes(l_data_header,JPIP_PRXY,4); /* IPTR           */
+  opj_stream_write_data(cio,l_data_header,4,p_manager);
+
+  opj_write_bytes( l_data_header, offset_jp2c, 8); /* OOFF           */
+  opj_stream_write_data(cio,l_data_header,8,p_manager);
+  opj_write_bytes( l_data_header, length_jp2c, 4); /* OBH part 1     */
+  opj_write_bytes( l_data_header+4, JP2_JP2C, 4);  /* OBH part 2     */
+  opj_stream_write_data(cio,l_data_header,8,p_manager);
+
+  opj_write_bytes( l_data_header, 1, 1);/* NI             */
+  opj_stream_write_data(cio,l_data_header,1,p_manager);
+
+  opj_write_bytes( l_data_header, offset_idx, 8);  /* IOFF           */
+  opj_stream_write_data(cio,l_data_header,8,p_manager);
+  opj_write_bytes( l_data_header, length_idx, 4);  /* IBH part 1     */
+  opj_write_bytes( l_data_header+4, JPIP_CIDX, 4);   /* IBH part 2     */
+  opj_stream_write_data(cio,l_data_header,8,p_manager);
+
+  len = opj_stream_tell(cio)-lenp;
+  opj_stream_skip(cio, lenp, p_manager);
+  opj_write_bytes(l_data_header,len,4);/* L              */
+  opj_stream_write_data(cio,l_data_header,4,p_manager);
+  opj_stream_seek(cio, lenp+len,p_manager);
+}
+#endif
 
-	if( jp2->jpip_on){
-	  pos_cidx = cio_tell( cio);
-	  
-	  len_cidx = write_cidx( pos_jp2c+8, cio, image, *cstr_info, len_jp2c-8);
-	  
-	  pos_fidx = cio_tell( cio);
-	  len_fidx = write_fidx( pos_jp2c, len_jp2c, pos_cidx, len_cidx, cio);
-	  
-	  end_pos = cio_tell( cio);
-	  
-	  cio_seek( cio, pos_iptr);
-	  write_iptr( pos_fidx, len_fidx, cio);
-	  
-	  cio_seek( cio, end_pos);
-	}
 
-	return OPJ_TRUE;
+#if 0
+static int write_fidx( int offset_jp2c, int length_jp2c, int offset_idx, int length_idx, opj_stream_private_t *cio,
+  opj_event_mgr_t * p_manager )
+{
+  OPJ_BYTE l_data_header [4];
+  OPJ_OFF_T len, lenp;
+
+  lenp = opj_stream_tell(cio);
+  opj_stream_skip(cio, 4, p_manager);
+  opj_write_bytes(l_data_header,JPIP_FIDX,4); /* FIDX */
+  opj_stream_write_data(cio,l_data_header,4,p_manager);
+
+  write_prxy( offset_jp2c, length_jp2c, offset_idx, length_idx, cio,p_manager);
+
+  len = opj_stream_tell(cio)-lenp;
+  opj_stream_skip(cio, lenp, p_manager);
+  opj_write_bytes(l_data_header,len,4);/* L              */
+  opj_stream_write_data(cio,l_data_header,4,p_manager);
+  opj_stream_seek(cio, lenp+len,p_manager);
+
+  return len;
 }
+#endif
+#endif /* USE_JPIP */
diff --git a/extern/libopenjpeg/jp2.h b/extern/libopenjpeg/jp2.h
index acb643c..c11d2f3 100644
--- a/extern/libopenjpeg/jp2.h
+++ b/extern/libopenjpeg/jp2.h
@@ -1,8 +1,15 @@
 /*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2002-2003, Yannick Verschueren
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR 
+ * Copyright (c) 2012, CS Systemes d'Information, France
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -37,29 +44,57 @@
 /** @defgroup JP2 JP2 - JPEG-2000 file format reader/writer */
 /*@{*/
 
-#define JPIP_JPIP 0x6a706970
-
-#define JP2_JP   0x6a502020		/**< JPEG 2000 signature box */
-#define JP2_FTYP 0x66747970		/**< File type box */
-#define JP2_JP2H 0x6a703268		/**< JP2 header box */
-#define JP2_IHDR 0x69686472		/**< Image header box */
-#define JP2_COLR 0x636f6c72		/**< Colour specification box */
-#define JP2_JP2C 0x6a703263		/**< Contiguous codestream box */
-#define JP2_URL  0x75726c20		/**< URL box */
-#define JP2_DTBL 0x6474626c		/**< Data Reference box */
-#define JP2_BPCC 0x62706363		/**< Bits per component box */
-#define JP2_JP2  0x6a703220		/**< File type fields */
-#define JP2_PCLR 0x70636c72		/**< Palette box */
-#define JP2_CMAP 0x636d6170		/**< Component Mapping box */
-#define JP2_CDEF 0x63646566		/**< Channel Definition box */
+/*#define JPIP_JPIP 0x6a706970*/
+
+#define     JP2_JP   0x6a502020    /**< JPEG 2000 signature box */
+#define     JP2_FTYP 0x66747970    /**< File type box */
+#define     JP2_JP2H 0x6a703268    /**< JP2 header box (super-box) */
+#define     JP2_IHDR 0x69686472    /**< Image header box */
+#define     JP2_COLR 0x636f6c72    /**< Colour specification box */
+#define     JP2_JP2C 0x6a703263    /**< Contiguous codestream box */
+#define     JP2_URL  0x75726c20    /**< Data entry URL box */
+#define     JP2_PCLR 0x70636c72    /**< Palette box */
+#define     JP2_CMAP 0x636d6170    /**< Component Mapping box */
+#define     JP2_CDEF 0x63646566    /**< Channel Definition box */
+#define     JP2_DTBL 0x6474626c    /**< Data Reference box */
+#define     JP2_BPCC 0x62706363    /**< Bits per component box */
+#define     JP2_JP2  0x6a703220    /**< File type fields */
+
+/* For the future */
+/* #define JP2_RES 0x72657320 */  /**< Resolution box (super-box) */
+/* #define JP2_JP2I 0x6a703269 */  /**< Intellectual property box */
+/* #define JP2_XML  0x786d6c20 */  /**< XML box */
+/* #define JP2_UUID 0x75756994 */  /**< UUID box */
+/* #define JP2_UINF 0x75696e66 */  /**< UUID info box (super-box) */
+/* #define JP2_ULST 0x756c7374 */  /**< UUID list box */
 
 /* ----------------------------------------------------------------------- */
+
+typedef enum
+{
+  JP2_STATE_NONE            = 0x0,
+  JP2_STATE_SIGNATURE       = 0x1,
+  JP2_STATE_FILE_TYPE       = 0x2,
+  JP2_STATE_HEADER          = 0x4,
+  JP2_STATE_CODESTREAM      = 0x8,
+  JP2_STATE_END_CODESTREAM  = 0x10,
+  JP2_STATE_UNKNOWN         = 0x7fffffff /* ISO C restricts enumerator values to range of 'int' */
+}
+JP2_STATE;
+
+typedef enum
+{
+  JP2_IMG_STATE_NONE        = 0x0,
+  JP2_IMG_STATE_UNKNOWN     = 0x7fffffff
+}
+JP2_IMG_STATE;
+
 /** 
 Channel description: channel index, type, assocation
 */
 typedef struct opj_jp2_cdef_info
 {
-    unsigned short cn, typ, asoc;
+    OPJ_UINT16 cn, typ, asoc;
 } opj_jp2_cdef_info_t;
 
 /** 
@@ -68,7 +103,7 @@ Channel descriptions and number of descriptions
 typedef struct opj_jp2_cdef
 {
     opj_jp2_cdef_info_t *info;
-    unsigned short n;
+    OPJ_UINT16 n;
 } opj_jp2_cdef_t;
 
 /** 
@@ -76,8 +111,8 @@ Component mappings: channel index, mapping type, palette index
 */
 typedef struct opj_jp2_cmap_comp
 {
-    unsigned short cmp;
-    unsigned char mtyp, pcol;
+    OPJ_UINT16 cmp;
+    OPJ_BYTE mtyp, pcol;
 } opj_jp2_cmap_comp_t;
 
 /** 
@@ -85,11 +120,12 @@ Palette data: table entries, palette columns
 */
 typedef struct opj_jp2_pclr
 {
-    unsigned int *entries;
-    unsigned char *channel_sign;
-    unsigned char *channel_size;
+    OPJ_UINT32 *entries;
+    OPJ_BYTE *channel_sign;
+    OPJ_BYTE *channel_size;
     opj_jp2_cmap_comp_t *cmap;
-    unsigned short nr_entries, nr_channels;
+    OPJ_UINT16 nr_entries;
+    OPJ_BYTE nr_channels;
 } opj_jp2_pclr_t;
 
 /** 
@@ -97,135 +133,360 @@ Collector for ICC profile, palette, component mapping, channel description
 */
 typedef struct opj_jp2_color
 {
-    unsigned char *icc_profile_buf;
-    int icc_profile_len;
+    OPJ_BYTE *icc_profile_buf;
+    OPJ_UINT32 icc_profile_len;
 
     opj_jp2_cdef_t *jp2_cdef;
     opj_jp2_pclr_t *jp2_pclr;
-    unsigned char jp2_has_colr;
+    OPJ_BYTE jp2_has_colr;
 } opj_jp2_color_t;
 
 /** 
 JP2 component
 */
 typedef struct opj_jp2_comps {
-  int depth;		  
-  int sgnd;		   
-  int bpcc;
+  OPJ_UINT32 depth;      
+  OPJ_UINT32 sgnd;       
+  OPJ_UINT32 bpcc;
 } opj_jp2_comps_t;
 
 /**
 JPEG-2000 file format reader/writer
 */
-typedef struct opj_jp2 {
-	/** codec context */
-	opj_common_ptr cinfo;
-	/** handle to the J2K codec  */
-	opj_j2k_t *j2k;
-	unsigned int w;
-	unsigned int h;
-	unsigned int numcomps;
-	unsigned int bpc;
-	unsigned int C;
-	unsigned int UnkC;
-	unsigned int IPR;
-	unsigned int meth;
-	unsigned int approx;
-	unsigned int enumcs;
-	unsigned int precedence;
-	unsigned int brand;
-	unsigned int minversion;
-	unsigned int numcl;
-	unsigned int *cl;
-	opj_jp2_comps_t *comps;
-	unsigned int j2k_codestream_offset;
-	unsigned int j2k_codestream_length;
-	opj_bool jpip_on;
-	opj_bool ignore_pclr_cmap_cdef;
-} opj_jp2_t;
+typedef struct opj_jp2
+{
+  /** handle to the J2K codec  */
+  opj_j2k_t *j2k;
+  /** list of validation procedures */
+  struct opj_procedure_list * m_validation_list;
+  /** list of execution procedures */
+  struct opj_procedure_list * m_procedure_list;
+
+  /* width of image */
+  OPJ_UINT32 w;
+  /* height of image */
+  OPJ_UINT32 h;
+  /* number of components in the image */
+  OPJ_UINT32 numcomps;
+  OPJ_UINT32 bpc;
+  OPJ_UINT32 C;
+  OPJ_UINT32 UnkC;
+  OPJ_UINT32 IPR;
+  OPJ_UINT32 meth;
+  OPJ_UINT32 approx;
+  OPJ_UINT32 enumcs;
+  OPJ_UINT32 precedence;
+  OPJ_UINT32 brand;
+  OPJ_UINT32 minversion;
+  OPJ_UINT32 numcl;
+  OPJ_UINT32 *cl;
+  opj_jp2_comps_t *comps;
+  /* FIXME: The following two variables are used to save offset
+    as we write out a JP2 file to disk. This mecanism is not flexible
+    as codec writers will need to extand those fields as new part
+    of the standard are implemented.
+  */
+    OPJ_OFF_T j2k_codestream_offset;
+    OPJ_OFF_T jpip_iptr_offset;
+	OPJ_BOOL jpip_on;
+  OPJ_UINT32 jp2_state;
+  OPJ_UINT32 jp2_img_state;
+
+  opj_jp2_color_t color;
+    
+    OPJ_BOOL ignore_pclr_cmap_cdef;
+}
+opj_jp2_t;
 
 /**
 JP2 Box
 */
 typedef struct opj_jp2_box {
-  int length;
-  int type;
-  int init_pos;
+    OPJ_UINT32 length;
+    OPJ_UINT32 type;
+    OPJ_INT32 init_pos;
 } opj_jp2_box_t;
 
+typedef struct opj_jp2_header_handler
+{
+  /* marker value */
+  OPJ_UINT32 id;
+  /* action linked to the marker */
+  OPJ_BOOL (*handler) (     opj_jp2_t *jp2, 
+                            OPJ_BYTE *p_header_data, 
+                            OPJ_UINT32 p_header_size, 
+                            opj_event_mgr_t * p_manager);
+}
+opj_jp2_header_handler_t;
+
+
+typedef struct opj_jp2_img_header_writer_handler 
+{
+  /* action to perform */
+  OPJ_BYTE*   (*handler) (opj_jp2_t *jp2, OPJ_UINT32 * p_data_size);
+  /* result of the action : data */
+  OPJ_BYTE*   m_data;
+  /* size of data */
+  OPJ_UINT32  m_size;
+} 
+opj_jp2_img_header_writer_handler_t;
+
 /** @name Exported functions */
 /*@{*/
 /* ----------------------------------------------------------------------- */
+
 /**
-Write the JP2H box - JP2 Header box (used in MJ2)
-@param jp2 JP2 handle
-@param cio Output buffer stream
-*/
-void jp2_write_jp2h(opj_jp2_t *jp2, opj_cio_t *cio);
-/**
-Read the JP2H box - JP2 Header box (used in MJ2)
-@param jp2 JP2 handle
-@param cio Input buffer stream
-@param ext Collector for profile, cdef and pclr data
-@return Returns true if successful, returns false otherwise
-*/
-opj_bool jp2_read_jp2h(opj_jp2_t *jp2, opj_cio_t *cio, opj_jp2_color_t *color);
-/**
-Creates a JP2 decompression structure
-@param cinfo Codec context info
-@return Returns a handle to a JP2 decompressor if successful, returns NULL otherwise
-*/
-opj_jp2_t* jp2_create_decompress(opj_common_ptr cinfo);
-/**
-Destroy a JP2 decompressor handle
-@param jp2 JP2 decompressor handle to destroy
+ * Writes the Jpeg2000 file Header box - JP2 Header box (warning, this is a super box).
+ *
+ * @param  jp2      the jpeg2000 file codec.
+ * @param  stream      the stream to write data to.
+ * @param  p_manager  user event manager.
+ *
+ * @return true if writing was successful.
 */
-void jp2_destroy_decompress(opj_jp2_t *jp2);
+OPJ_BOOL opj_jp2_write_jp2h(opj_jp2_t *jp2,
+                            opj_stream_private_t *stream,
+                            opj_event_mgr_t * p_manager );
+
 /**
 Setup the decoder decoding parameters using user parameters.
-Decoding parameters are returned in jp2->j2k->cp. 
+Decoding parameters are returned in jp2->j2k->cp.
 @param jp2 JP2 decompressor handle
 @param parameters decompression parameters
 */
-void jp2_setup_decoder(opj_jp2_t *jp2, opj_dparameters_t *parameters);
+void opj_jp2_setup_decoder(opj_jp2_t *jp2, opj_dparameters_t *parameters);
+
 /**
-Decode an image from a JPEG-2000 file stream
-@param jp2 JP2 decompressor handle
-@param cio Input buffer stream
-@param cstr_info Codestream information structure if required, NULL otherwise
-@return Returns a decoded image if successful, returns NULL otherwise
+ * Decode an image from a JPEG-2000 file stream
+ * @param jp2 JP2 decompressor handle
+ * @param p_stream  FIXME DOC
+ * @param p_image   FIXME DOC
+ * @param p_manager FIXME DOC
+ *
+ * @return Returns a decoded image if successful, returns NULL otherwise
 */
-opj_image_t* opj_jp2_decode(opj_jp2_t *jp2, opj_cio_t *cio, opj_codestream_info_t *cstr_info);
+OPJ_BOOL opj_jp2_decode(opj_jp2_t *jp2,
+                        opj_stream_private_t *p_stream,
+            opj_image_t* p_image,
+            opj_event_mgr_t * p_manager);
+
 /**
-Creates a JP2 compression structure
-@param cinfo Codec context info
-@return Returns a handle to a JP2 compressor if successful, returns NULL otherwise
+ * Setup the encoder parameters using the current image and using user parameters. 
+ * Coding parameters are returned in jp2->j2k->cp. 
+ *
+ * @param jp2 JP2 compressor handle
+ * @param parameters compression parameters
+ * @param image input filled image
+ * @param p_manager  FIXME DOC
 */
-opj_jp2_t* jp2_create_compress(opj_common_ptr cinfo);
+void opj_jp2_setup_encoder(  opj_jp2_t *jp2, 
+                            opj_cparameters_t *parameters, 
+                            opj_image_t *image, 
+                            opj_event_mgr_t * p_manager);
+
 /**
-Destroy a JP2 compressor handle
-@param jp2 JP2 compressor handle to destroy
+Encode an image into a JPEG-2000 file stream
+@param jp2      JP2 compressor handle
+@param stream    Output buffer stream
+@param p_manager  event manager
+@return Returns true if successful, returns false otherwise
 */
-void jp2_destroy_compress(opj_jp2_t *jp2);
+OPJ_BOOL opj_jp2_encode(  opj_jp2_t *jp2, 
+              opj_stream_private_t *stream, 
+              opj_event_mgr_t * p_manager);
+
+
+/**
+ * Starts a compression scheme, i.e. validates the codec parameters, writes the header.
+ *
+ * @param  jp2    the jpeg2000 file codec.
+ * @param  stream    the stream object.
+ * @param  p_image   FIXME DOC
+ * @param p_manager FIXME DOC
+ *
+ * @return true if the codec is valid.
+ */
+OPJ_BOOL opj_jp2_start_compress(opj_jp2_t *jp2,
+                                opj_stream_private_t *stream,
+                                opj_image_t * p_image,
+                                opj_event_mgr_t * p_manager);
+
+
+/**
+ * Ends the compression procedures and possibiliy add data to be read after the
+ * codestream.
+ */
+OPJ_BOOL opj_jp2_end_compress(  opj_jp2_t *jp2,
+                  opj_stream_private_t *cio,
+                  opj_event_mgr_t * p_manager);
+
+/* ----------------------------------------------------------------------- */
+
+/**
+ * Ends the decompression procedures and possibiliy add data to be read after the
+ * codestream.
+ */
+OPJ_BOOL opj_jp2_end_decompress(opj_jp2_t *jp2, 
+                                opj_stream_private_t *cio,
+                                opj_event_mgr_t * p_manager);
+
 /**
-Setup the encoder parameters using the current image and using user parameters. 
-Coding parameters are returned in jp2->j2k->cp. 
-@param jp2 JP2 compressor handle
-@param parameters compression parameters
-@param image input filled image
+ * Reads a jpeg2000 file header structure.
+ *
+ * @param p_stream the stream to read data from.
+ * @param jp2 the jpeg2000 file header structure.
+ * @param p_image   FIXME DOC
+ * @param p_manager the user event manager.
+ *
+ * @return true if the box is valid.
+ */
+OPJ_BOOL opj_jp2_read_header(  opj_stream_private_t *p_stream,
+                                opj_jp2_t *jp2,
+                                opj_image_t ** p_image,
+                                opj_event_mgr_t * p_manager );
+
+/**
+ * Reads a tile header.
+ * @param  p_jp2         the jpeg2000 codec.
+ * @param  p_tile_index  FIXME DOC
+ * @param  p_data_size   FIXME DOC
+ * @param  p_tile_x0     FIXME DOC
+ * @param  p_tile_y0     FIXME DOC
+ * @param  p_tile_x1     FIXME DOC
+ * @param  p_tile_y1     FIXME DOC
+ * @param  p_nb_comps    FIXME DOC
+ * @param  p_go_on       FIXME DOC
+ * @param  p_stream      the stream to write data to.
+ * @param  p_manager     the user event manager.
+ */
+OPJ_BOOL opj_jp2_read_tile_header ( opj_jp2_t * p_jp2,
+                                    OPJ_UINT32 * p_tile_index,
+                                    OPJ_UINT32 * p_data_size,
+                                    OPJ_INT32 * p_tile_x0,
+                                    OPJ_INT32 * p_tile_y0,
+                                    OPJ_INT32 * p_tile_x1,
+                                    OPJ_INT32 * p_tile_y1,
+                                    OPJ_UINT32 * p_nb_comps,
+                                    OPJ_BOOL * p_go_on,
+                                    opj_stream_private_t *p_stream,
+                                    opj_event_mgr_t * p_manager );
+
+/**
+ * Writes a tile.
+ *
+ * @param  p_jp2    the jpeg2000 codec.
+ * @param p_tile_index  FIXME DOC
+ * @param p_data        FIXME DOC
+ * @param p_data_size   FIXME DOC
+ * @param  p_stream      the stream to write data to.
+ * @param  p_manager  the user event manager.
+ */
+OPJ_BOOL opj_jp2_write_tile (  opj_jp2_t *p_jp2,
+                    OPJ_UINT32 p_tile_index,
+                    OPJ_BYTE * p_data,
+                    OPJ_UINT32 p_data_size,
+                    opj_stream_private_t *p_stream,
+                    opj_event_mgr_t * p_manager );
+
+/**
+ * Decode tile data.
+ * @param  p_jp2    the jpeg2000 codec.
+ * @param  p_tile_index FIXME DOC
+ * @param  p_data       FIXME DOC
+ * @param  p_data_size  FIXME DOC
+ * @param  p_stream      the stream to write data to.
+ * @param  p_manager  the user event manager.
+ *
+ * @return FIXME DOC
+ */
+OPJ_BOOL opj_jp2_decode_tile (  opj_jp2_t * p_jp2,
+                                OPJ_UINT32 p_tile_index,
+                                OPJ_BYTE * p_data,
+                                OPJ_UINT32 p_data_size,
+                                opj_stream_private_t *p_stream,
+                                opj_event_mgr_t * p_manager );
+
+/**
+ * Creates a jpeg2000 file decompressor.
+ *
+ * @return  an empty jpeg2000 file codec.
+ */
+opj_jp2_t* opj_jp2_create (OPJ_BOOL p_is_decoder);
+
+/**
+Destroy a JP2 decompressor handle
+@param jp2 JP2 decompressor handle to destroy
 */
-void jp2_setup_encoder(opj_jp2_t *jp2, opj_cparameters_t *parameters, opj_image_t *image);
+void opj_jp2_destroy(opj_jp2_t *jp2);
+
+
 /**
-Encode an image into a JPEG-2000 file stream
-@param jp2 JP2 compressor handle
-@param cio Output buffer stream
-@param image Image to encode
-@param cstr_info Codestream information structure if required, NULL otherwise
-@return Returns true if successful, returns false otherwise
+ * Sets the given area to be decoded. This function should be called right after opj_read_header and before any tile header reading.
+ *
+ * @param  p_jp2      the jpeg2000 codec.
+ * @param  p_image     FIXME DOC
+ * @param  p_start_x   the left position of the rectangle to decode (in image coordinates).
+ * @param  p_start_y    the up position of the rectangle to decode (in image coordinates).
+ * @param  p_end_x      the right position of the rectangle to decode (in image coordinates).
+ * @param  p_end_y      the bottom position of the rectangle to decode (in image coordinates).
+ * @param  p_manager    the user event manager
+ *
+ * @return  true      if the area could be set.
+ */
+OPJ_BOOL opj_jp2_set_decode_area(  opj_jp2_t *p_jp2,
+                    opj_image_t* p_image,
+                    OPJ_INT32 p_start_x, OPJ_INT32 p_start_y,
+                    OPJ_INT32 p_end_x, OPJ_INT32 p_end_y,
+                    opj_event_mgr_t * p_manager );
+
+ /**
+ * 
+ */
+OPJ_BOOL opj_jp2_get_tile(  opj_jp2_t *p_jp2,
+                            opj_stream_private_t *p_stream,
+                            opj_image_t* p_image,
+                            opj_event_mgr_t * p_manager,
+                            OPJ_UINT32 tile_index );
+
+
+/**
+ * 
+ */
+OPJ_BOOL opj_jp2_set_decoded_resolution_factor(opj_jp2_t *p_jp2, 
+                                               OPJ_UINT32 res_factor, 
+                                               opj_event_mgr_t * p_manager);
+
+
+/* TODO MSD: clean these 3 functions */
+/**
+ * Dump some elements from the JP2 decompression structure .
+ *
+ *@param p_jp2        the jp2 codec.
+ *@param flag        flag to describe what elments are dump.
+ *@param out_stream      output stream where dump the elements.
+ *
 */
-opj_bool opj_jp2_encode(opj_jp2_t *jp2, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info);
+void jp2_dump (opj_jp2_t* p_jp2, OPJ_INT32 flag, FILE* out_stream);
+
+/**
+ * Get the codestream info from a JPEG2000 codec.
+ *
+ *@param  p_jp2        jp2 codec.
+ *
+ *@return  the codestream information extract from the jpg2000 codec
+ */
+opj_codestream_info_v2_t* jp2_get_cstr_info(opj_jp2_t* p_jp2);
+
+/**
+ * Get the codestream index from a JPEG2000 codec.
+ *
+ *@param  p_jp2        jp2 codec.
+ *
+ *@return  the codestream index extract from the jpg2000 codec
+ */
+opj_codestream_index_t* jp2_get_cstr_index(opj_jp2_t* p_jp2);
+
 
-/* ----------------------------------------------------------------------- */
 /*@}*/
 
 /*@}*/
diff --git a/extern/libopenjpeg/jpt.c b/extern/libopenjpeg/jpt.c
deleted file mode 100644
index a2566ea..0000000
--- a/extern/libopenjpeg/jpt.c
+++ /dev/null
@@ -1,155 +0,0 @@
-/*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
- * Copyright (c) 2002-2003, Yannick Verschueren
- * Copyright (c) 2005, Herve Drolon, FreeImage Team
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "opj_includes.h"
-
-/*
- * Read the information contains in VBAS [JPP/JPT stream message header]
- * Store information (7 bits) in value
- *
- */
-unsigned int jpt_read_VBAS_info(opj_cio_t *cio, unsigned int value) {
-	unsigned char elmt;
-
-	elmt = cio_read(cio, 1);
-	while ((elmt >> 7) == 1) {
-		value = (value << 7);
-		value |= (elmt & 0x7f);
-		elmt = cio_read(cio, 1);
-	}
-	value = (value << 7);
-	value |= (elmt & 0x7f);
-
-	return value;
-}
-
-/*
- * Initialize the value of the message header structure 
- *
- */
-void jpt_init_msg_header(opj_jpt_msg_header_t * header) {
-	header->Id = 0;		/* In-class Identifier    */
-	header->last_byte = 0;	/* Last byte information  */
-	header->Class_Id = 0;		/* Class Identifier       */
-	header->CSn_Id = 0;		/* CSn : index identifier */
-	header->Msg_offset = 0;	/* Message offset         */
-	header->Msg_length = 0;	/* Message length         */
-	header->Layer_nb = 0;		/* Auxiliary for JPP case */
-}
-
-/*
- * Re-initialize the value of the message header structure
- *
- * Only parameters always present in message header
- *
- */
-void jpt_reinit_msg_header(opj_jpt_msg_header_t * header) {
-	header->Id = 0;		/* In-class Identifier    */
-	header->last_byte = 0;	/* Last byte information  */
-	header->Msg_offset = 0;	/* Message offset         */
-	header->Msg_length = 0;	/* Message length         */
-}
-
-/*
- * Read the message header for a JPP/JPT - stream
- *
- */
-void jpt_read_msg_header(opj_common_ptr cinfo, opj_cio_t *cio, opj_jpt_msg_header_t *header) {
-	unsigned char elmt, Class = 0, CSn = 0;
-	jpt_reinit_msg_header(header);
-
-	/* ------------- */
-	/* VBAS : Bin-ID */
-	/* ------------- */
-	elmt = cio_read(cio, 1);
-
-	/* See for Class and CSn */
-	switch ((elmt >> 5) & 0x03) {
-		case 0:
-			opj_event_msg(cinfo, EVT_ERROR, "Forbidden value encounter in message header !!\n");
-			break;
-		case 1:
-			Class = 0;
-			CSn = 0;
-			break;
-		case 2:
-			Class = 1;
-			CSn = 0;
-			break;
-		case 3:
-			Class = 1;
-			CSn = 1;
-			break;
-		default:
-			break;
-	}
-
-	/* see information on bits 'c' [p 10 : A.2.1 general, ISO/IEC FCD 15444-9] */
-	if (((elmt >> 4) & 0x01) == 1)
-		header->last_byte = 1;
-
-	/* In-class identifier */
-	header->Id |= (elmt & 0x0f);
-	if ((elmt >> 7) == 1)
-		header->Id = jpt_read_VBAS_info(cio, header->Id);
-
-	/* ------------ */
-	/* VBAS : Class */
-	/* ------------ */
-	if (Class == 1) {
-		header->Class_Id = 0;
-		header->Class_Id = jpt_read_VBAS_info(cio, header->Class_Id);
-	}
-
-	/* ---------- */
-	/* VBAS : CSn */
-	/* ---------- */
-	if (CSn == 1) {
-		header->CSn_Id = 0;
-		header->CSn_Id = jpt_read_VBAS_info(cio, header->CSn_Id);
-	}
-
-	/* ----------------- */
-	/* VBAS : Msg_offset */
-	/* ----------------- */
-	header->Msg_offset = jpt_read_VBAS_info(cio, header->Msg_offset);
-
-	/* ----------------- */
-	/* VBAS : Msg_length */
-	/* ----------------- */
-	header->Msg_length = jpt_read_VBAS_info(cio, header->Msg_length);
-
-	/* ---------- */
-	/* VBAS : Aux */
-	/* ---------- */
-	if ((header->Class_Id & 0x01) == 1) {
-		header->Layer_nb = 0;
-		header->Layer_nb = jpt_read_VBAS_info(cio, header->Layer_nb);
-	}
-}
diff --git a/extern/libopenjpeg/jpt.h b/extern/libopenjpeg/jpt.h
deleted file mode 100644
index eb01f98..0000000
--- a/extern/libopenjpeg/jpt.h
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
- * Copyright (c) 2002-2003, Yannick Verschueren
- * Copyright (c) 2005, Herve Drolon, FreeImage Team
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef __JPT_H
-#define __JPT_H
-/**
-@file jpt.h
-@brief JPT-stream reader (JPEG 2000, JPIP)
-
-JPT-stream functions are implemented in J2K.C. 
-*/
-
-/**
-Message Header JPT stream structure
-*/
-typedef struct opj_jpt_msg_header {
-	/** In-class Identifier */
-	unsigned int Id;
-	/** Last byte information */
-	unsigned int last_byte;	
-	/** Class Identifier */
-	unsigned int Class_Id;	
-	/** CSn : index identifier */
-	unsigned int CSn_Id;
-	/** Message offset */
-	unsigned int Msg_offset;
-	/** Message length */
-	unsigned int Msg_length;
-	/** Auxiliary for JPP case */
-	unsigned int Layer_nb;
-} opj_jpt_msg_header_t;
-
-/* ----------------------------------------------------------------------- */
-
-/**
-Initialize the value of the message header structure 
-@param header Message header structure
-*/
-void jpt_init_msg_header(opj_jpt_msg_header_t * header);
-
-/**
-Read the message header for a JPP/JPT - stream
-@param cinfo Codec context info
-@param cio CIO handle
-@param header Message header structure
-*/
-void jpt_read_msg_header(opj_common_ptr cinfo, opj_cio_t *cio, opj_jpt_msg_header_t *header);
-
-#endif
diff --git a/extern/libopenjpeg/license.txt b/extern/libopenjpeg/license.txt
deleted file mode 100644
index d1e5b6a..0000000
--- a/extern/libopenjpeg/license.txt
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
- * Copyright (c) 2001-2003, David Janssens
- * Copyright (c) 2002-2003, Yannick Verschueren
- * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
- * Copyright (c) 2005, Herve Drolon, FreeImage Team
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- */
\ No newline at end of file
diff --git a/extern/libopenjpeg/mct.c b/extern/libopenjpeg/mct.c
index 870993b..60ee096 100644
--- a/extern/libopenjpeg/mct.c
+++ b/extern/libopenjpeg/mct.c
@@ -1,10 +1,18 @@
 /*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2001-2003, David Janssens
  * Copyright (c) 2002-2003, Yannick Verschueren
- * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * Copyright (c) 2003-2014, Antonin Descampe
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR 
+ * Copyright (c) 2012, CS Systemes d'Information, France
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -38,30 +46,40 @@
 /* <summary> */
 /* This table contains the norms of the basis function of the reversible MCT. */
 /* </summary> */
-static const double mct_norms[3] = { 1.732, .8292, .8292 };
+static const OPJ_FLOAT64 opj_mct_norms[3] = { 1.732, .8292, .8292 };
 
 /* <summary> */
 /* This table contains the norms of the basis function of the irreversible MCT. */
 /* </summary> */
-static const double mct_norms_real[3] = { 1.732, 1.805, 1.573 };
+static const OPJ_FLOAT64 opj_mct_norms_real[3] = { 1.732, 1.805, 1.573 };
+
+const OPJ_FLOAT64 * opj_mct_get_mct_norms ()
+{
+	return opj_mct_norms;
+}
+
+const OPJ_FLOAT64 * opj_mct_get_mct_norms_real ()
+{
+	return opj_mct_norms_real;
+}
 
 /* <summary> */
 /* Foward reversible MCT. */
 /* </summary> */
-void mct_encode(
-		int* restrict c0,
-		int* restrict c1,
-		int* restrict c2,
-		int n)
+void opj_mct_encode(
+		OPJ_INT32* restrict c0,
+		OPJ_INT32* restrict c1,
+		OPJ_INT32* restrict c2,
+		OPJ_UINT32 n)
 {
-	int i;
+	OPJ_UINT32 i;
 	for(i = 0; i < n; ++i) {
-		int r = c0[i];
-		int g = c1[i];
-		int b = c2[i];
-		int y = (r + (g * 2) + b) >> 2;
-		int u = b - g;
-		int v = r - g;
+		OPJ_INT32 r = c0[i];
+		OPJ_INT32 g = c1[i];
+		OPJ_INT32 b = c2[i];
+		OPJ_INT32 y = (r + (g * 2) + b) >> 2;
+		OPJ_INT32 u = b - g;
+		OPJ_INT32 v = r - g;
 		c0[i] = y;
 		c1[i] = u;
 		c2[i] = v;
@@ -71,20 +89,20 @@ void mct_encode(
 /* <summary> */
 /* Inverse reversible MCT. */
 /* </summary> */
-void mct_decode(
-		int* restrict c0,
-		int* restrict c1, 
-		int* restrict c2, 
-		int n)
+void opj_mct_decode(
+		OPJ_INT32* restrict c0,
+		OPJ_INT32* restrict c1, 
+		OPJ_INT32* restrict c2, 
+		OPJ_UINT32 n)
 {
-	int i;
+	OPJ_UINT32 i;
 	for (i = 0; i < n; ++i) {
-		int y = c0[i];
-		int u = c1[i];
-		int v = c2[i];
-		int g = y - ((u + v) >> 2);
-		int r = v + g;
-		int b = u + g;
+		OPJ_INT32 y = c0[i];
+		OPJ_INT32 u = c1[i];
+		OPJ_INT32 v = c2[i];
+		OPJ_INT32 g = y - ((u + v) >> 2);
+		OPJ_INT32 r = v + g;
+		OPJ_INT32 b = u + g;
 		c0[i] = r;
 		c1[i] = g;
 		c2[i] = b;
@@ -94,27 +112,27 @@ void mct_decode(
 /* <summary> */
 /* Get norm of basis function of reversible MCT. */
 /* </summary> */
-double mct_getnorm(int compno) {
-	return mct_norms[compno];
+OPJ_FLOAT64 opj_mct_getnorm(OPJ_UINT32 compno) {
+	return opj_mct_norms[compno];
 }
 
 /* <summary> */
 /* Foward irreversible MCT. */
 /* </summary> */
-void mct_encode_real(
-		int* restrict c0,
-		int* restrict c1,
-		int* restrict c2,
-		int n)
+void opj_mct_encode_real(
+		OPJ_INT32* restrict c0,
+		OPJ_INT32* restrict c1,
+		OPJ_INT32* restrict c2,
+		OPJ_UINT32 n)
 {
-	int i;
+	OPJ_UINT32 i;
 	for(i = 0; i < n; ++i) {
-		int r = c0[i];
-		int g = c1[i];
-		int b = c2[i];
-		int y =  fix_mul(r, 2449) + fix_mul(g, 4809) + fix_mul(b, 934);
-		int u = -fix_mul(r, 1382) - fix_mul(g, 2714) + fix_mul(b, 4096);
-		int v =  fix_mul(r, 4096) - fix_mul(g, 3430) - fix_mul(b, 666);
+		OPJ_INT32 r = c0[i];
+		OPJ_INT32 g = c1[i];
+		OPJ_INT32 b = c2[i];
+		OPJ_INT32 y =  opj_int_fix_mul(r, 2449) + opj_int_fix_mul(g, 4809) + opj_int_fix_mul(b, 934);
+		OPJ_INT32 u = -opj_int_fix_mul(r, 1382) - opj_int_fix_mul(g, 2714) + opj_int_fix_mul(b, 4096);
+		OPJ_INT32 v =  opj_int_fix_mul(r, 4096) - opj_int_fix_mul(g, 3430) - opj_int_fix_mul(b, 666);
 		c0[i] = y;
 		c1[i] = u;
 		c2[i] = v;
@@ -124,13 +142,13 @@ void mct_encode_real(
 /* <summary> */
 /* Inverse irreversible MCT. */
 /* </summary> */
-void mct_decode_real(
-		float* restrict c0,
-		float* restrict c1,
-		float* restrict c2,
-		int n)
+void opj_mct_decode_real(
+		OPJ_FLOAT32* restrict c0,
+		OPJ_FLOAT32* restrict c1,
+		OPJ_FLOAT32* restrict c2,
+		OPJ_UINT32 n)
 {
-	int i;
+	OPJ_UINT32 i;
 #ifdef __SSE__
 	__m128 vrv, vgu, vgv, vbu;
 	vrv = _mm_set1_ps(1.402f);
@@ -170,12 +188,12 @@ void mct_decode_real(
 	n &= 7;
 #endif
 	for(i = 0; i < n; ++i) {
-		float y = c0[i];
-		float u = c1[i];
-		float v = c2[i];
-		float r = y + (v * 1.402f);
-		float g = y - (u * 0.34413f) - (v * (0.71414f));
-		float b = y + (u * 1.772f);
+		OPJ_FLOAT32 y = c0[i];
+		OPJ_FLOAT32 u = c1[i];
+		OPJ_FLOAT32 v = c2[i];
+		OPJ_FLOAT32 r = y + (v * 1.402f);
+		OPJ_FLOAT32 g = y - (u * 0.34413f) - (v * (0.71414f));
+		OPJ_FLOAT32 b = y + (u * 1.772f);
 		c0[i] = r;
 		c1[i] = g;
 		c2[i] = b;
@@ -185,6 +203,123 @@ void mct_decode_real(
 /* <summary> */
 /* Get norm of basis function of irreversible MCT. */
 /* </summary> */
-double mct_getnorm_real(int compno) {
-	return mct_norms_real[compno];
+OPJ_FLOAT64 opj_mct_getnorm_real(OPJ_UINT32 compno) {
+	return opj_mct_norms_real[compno];
+}
+
+
+OPJ_BOOL opj_mct_encode_custom(
+					   OPJ_BYTE * pCodingdata,
+					   OPJ_UINT32 n,
+					   OPJ_BYTE ** pData,
+					   OPJ_UINT32 pNbComp,
+					   OPJ_UINT32 isSigned)
+{
+	OPJ_FLOAT32 * lMct = (OPJ_FLOAT32 *) pCodingdata;
+	OPJ_UINT32 i;
+	OPJ_UINT32 j;
+	OPJ_UINT32 k;
+	OPJ_UINT32 lNbMatCoeff = pNbComp * pNbComp;
+	OPJ_INT32 * lCurrentData = 00;
+	OPJ_INT32 * lCurrentMatrix = 00;
+	OPJ_INT32 ** lData = (OPJ_INT32 **) pData;
+	OPJ_UINT32 lMultiplicator = 1 << 13;
+	OPJ_INT32 * lMctPtr;
+
+    OPJ_ARG_NOT_USED(isSigned);
+
+	lCurrentData = (OPJ_INT32 *) opj_malloc((pNbComp + lNbMatCoeff) * sizeof(OPJ_INT32));
+	if (! lCurrentData) {
+		return OPJ_FALSE;
+	}
+
+	lCurrentMatrix = lCurrentData + pNbComp;
+
+	for (i =0;i<lNbMatCoeff;++i) {
+		lCurrentMatrix[i] = (OPJ_INT32) (*(lMct++) * (OPJ_FLOAT32)lMultiplicator);
+	}
+
+	for (i = 0; i < n; ++i)  {
+		lMctPtr = lCurrentMatrix;
+		for (j=0;j<pNbComp;++j) {
+			lCurrentData[j] = (*(lData[j]));
+		}
+
+		for (j=0;j<pNbComp;++j) {
+			*(lData[j]) = 0;
+			for (k=0;k<pNbComp;++k) {
+				*(lData[j]) += opj_int_fix_mul(*lMctPtr, lCurrentData[k]);
+				++lMctPtr;
+			}
+
+			++lData[j];
+		}
+	}
+
+	opj_free(lCurrentData);
+
+	return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_mct_decode_custom(
+					   OPJ_BYTE * pDecodingData,
+					   OPJ_UINT32 n,
+					   OPJ_BYTE ** pData,
+					   OPJ_UINT32 pNbComp,
+					   OPJ_UINT32 isSigned)
+{
+	OPJ_FLOAT32 * lMct;
+	OPJ_UINT32 i;
+	OPJ_UINT32 j;
+	OPJ_UINT32 k;
+
+	OPJ_FLOAT32 * lCurrentData = 00;
+	OPJ_FLOAT32 * lCurrentResult = 00;
+	OPJ_FLOAT32 ** lData = (OPJ_FLOAT32 **) pData;
+
+    OPJ_ARG_NOT_USED(isSigned);
+
+	lCurrentData = (OPJ_FLOAT32 *) opj_malloc (2 * pNbComp * sizeof(OPJ_FLOAT32));
+	if (! lCurrentData) {
+		return OPJ_FALSE;
+	}
+	lCurrentResult = lCurrentData + pNbComp;
+
+	for (i = 0; i < n; ++i) {
+		lMct = (OPJ_FLOAT32 *) pDecodingData;
+		for (j=0;j<pNbComp;++j) {
+			lCurrentData[j] = (OPJ_FLOAT32) (*(lData[j]));
+		}
+		for (j=0;j<pNbComp;++j) {
+			lCurrentResult[j] = 0;
+			for	(k=0;k<pNbComp;++k)	{
+				lCurrentResult[j] += *(lMct++) * lCurrentData[k];
+			}
+			*(lData[j]++) = (OPJ_FLOAT32) (lCurrentResult[j]);
+		}
+	}
+	opj_free(lCurrentData);
+	return OPJ_TRUE;
+}
+
+void opj_calculate_norms(	OPJ_FLOAT64 * pNorms,
+							OPJ_UINT32 pNbComps,
+							OPJ_FLOAT32 * pMatrix)
+{
+	OPJ_UINT32 i,j,lIndex;
+	OPJ_FLOAT32 lCurrentValue;
+	OPJ_FLOAT64 * lNorms = (OPJ_FLOAT64 *) pNorms;
+	OPJ_FLOAT32 * lMatrix = (OPJ_FLOAT32 *) pMatrix;
+
+	for	(i=0;i<pNbComps;++i) {
+		lNorms[i] = 0;
+		lIndex = i;
+
+		for	(j=0;j<pNbComps;++j) {
+			lCurrentValue = lMatrix[lIndex];
+			lIndex += pNbComps;
+			lNorms[i] += lCurrentValue * lCurrentValue;
+		}
+		lNorms[i] = sqrt(lNorms[i]);
+	}
 }
diff --git a/extern/libopenjpeg/mct.h b/extern/libopenjpeg/mct.h
index 84e3f8a..1c1f4d0 100644
--- a/extern/libopenjpeg/mct.h
+++ b/extern/libopenjpeg/mct.h
@@ -1,10 +1,18 @@
 /*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2001-2003, David Janssens
  * Copyright (c) 2002-2003, Yannick Verschueren
- * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * Copyright (c) 2003-2014, Antonin Descampe
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR 
+ * Copyright (c) 2012, CS Systemes d'Information, France
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -52,7 +60,7 @@ Apply a reversible multi-component transform to an image
 @param c2 Samples blue component
 @param n Number of samples for each component
 */
-void mct_encode(int *c0, int *c1, int *c2, int n);
+void opj_mct_encode(OPJ_INT32 *c0, OPJ_INT32 *c1, OPJ_INT32 *c2, OPJ_UINT32 n);
 /**
 Apply a reversible multi-component inverse transform to an image
 @param c0 Samples for luminance component
@@ -60,13 +68,13 @@ Apply a reversible multi-component inverse transform to an image
 @param c2 Samples for blue chrominance component
 @param n Number of samples for each component
 */
-void mct_decode(int *c0, int *c1, int *c2, int n);
+void opj_mct_decode(OPJ_INT32 *c0, OPJ_INT32 *c1, OPJ_INT32 *c2, OPJ_UINT32 n);
 /**
 Get norm of the basis function used for the reversible multi-component transform
 @param compno Number of the component (0->Y, 1->U, 2->V)
 @return 
 */
-double mct_getnorm(int compno);
+OPJ_FLOAT64 opj_mct_getnorm(OPJ_UINT32 compno);
 
 /**
 Apply an irreversible multi-component transform to an image
@@ -75,7 +83,7 @@ Apply an irreversible multi-component transform to an image
 @param c2 Samples blue component
 @param n Number of samples for each component
 */
-void mct_encode_real(int *c0, int *c1, int *c2, int n);
+void opj_mct_encode_real(OPJ_INT32 *c0, OPJ_INT32 *c1, OPJ_INT32 *c2, OPJ_UINT32 n);
 /**
 Apply an irreversible multi-component inverse transform to an image
 @param c0 Samples for luminance component
@@ -83,13 +91,62 @@ Apply an irreversible multi-component inverse transform to an image
 @param c2 Samples for blue chrominance component
 @param n Number of samples for each component
 */
-void mct_decode_real(float* c0, float* c1, float* c2, int n);
+void opj_mct_decode_real(OPJ_FLOAT32* c0, OPJ_FLOAT32* c1, OPJ_FLOAT32* c2, OPJ_UINT32 n);
 /**
 Get norm of the basis function used for the irreversible multi-component transform
 @param compno Number of the component (0->Y, 1->U, 2->V)
 @return 
 */
-double mct_getnorm_real(int compno);
+OPJ_FLOAT64 opj_mct_getnorm_real(OPJ_UINT32 compno);
+
+/**
+FIXME DOC
+@param p_coding_data    MCT data
+@param n                size of components
+@param p_data           components
+@param p_nb_comp        nb of components (i.e. size of p_data)
+@param is_signed        tells if the data is signed
+@return OPJ_FALSE if function encounter a problem, OPJ_TRUE otherwise
+*/
+OPJ_BOOL opj_mct_encode_custom(
+					   OPJ_BYTE * p_coding_data,
+					   OPJ_UINT32 n,
+					   OPJ_BYTE ** p_data,
+					   OPJ_UINT32 p_nb_comp,
+					   OPJ_UINT32 is_signed);
+/**
+FIXME DOC
+@param pDecodingData    MCT data
+@param n                size of components
+@param pData            components
+@param pNbComp          nb of components (i.e. size of p_data)
+@param isSigned         tells if the data is signed
+@return OPJ_FALSE if function encounter a problem, OPJ_TRUE otherwise
+*/
+OPJ_BOOL opj_mct_decode_custom(
+					   OPJ_BYTE * pDecodingData,
+					   OPJ_UINT32 n,
+					   OPJ_BYTE ** pData,
+					   OPJ_UINT32 pNbComp,
+					   OPJ_UINT32 isSigned);
+/**
+FIXME DOC
+@param pNorms           MCT data
+@param p_nb_comps       size of components
+@param pMatrix          components
+@return 
+*/
+void opj_calculate_norms(   OPJ_FLOAT64 * pNorms,
+                            OPJ_UINT32 p_nb_comps,
+                            OPJ_FLOAT32 * pMatrix);
+/**
+FIXME DOC 
+*/
+const OPJ_FLOAT64 * opj_mct_get_mct_norms (void);
+/**
+FIXME DOC 
+*/
+const OPJ_FLOAT64 * opj_mct_get_mct_norms_real (void);
 /* ----------------------------------------------------------------------- */
 /*@}*/
 
diff --git a/extern/libopenjpeg/mqc.c b/extern/libopenjpeg/mqc.c
index 14129fb..18fcc47 100644
--- a/extern/libopenjpeg/mqc.c
+++ b/extern/libopenjpeg/mqc.c
@@ -1,10 +1,17 @@
 /*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2001-2003, David Janssens
  * Copyright (c) 2002-2003, Yannick Verschueren
- * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * Copyright (c) 2003-2014, Antonin Descampe
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * Copyright (c) 2008, Jerome Fimes, Communications & Systemes <jerome.fimes@c-s.fr>
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -42,49 +49,49 @@ Output a byte, doing bit-stuffing if necessary.
 After a 0xff byte, the next byte must be smaller than 0x90.
 @param mqc MQC handle
 */
-static void mqc_byteout(opj_mqc_t *mqc);
+static void opj_mqc_byteout(opj_mqc_t *mqc);
 /**
 Renormalize mqc->a and mqc->c while encoding, so that mqc->a stays between 0x8000 and 0x10000
 @param mqc MQC handle
 */
-static void mqc_renorme(opj_mqc_t *mqc);
+static void opj_mqc_renorme(opj_mqc_t *mqc);
 /**
 Encode the most probable symbol
 @param mqc MQC handle
 */
-static void mqc_codemps(opj_mqc_t *mqc);
+static void opj_mqc_codemps(opj_mqc_t *mqc);
 /**
 Encode the most least symbol
 @param mqc MQC handle
 */
-static void mqc_codelps(opj_mqc_t *mqc);
+static void opj_mqc_codelps(opj_mqc_t *mqc);
 /**
 Fill mqc->c with 1's for flushing
 @param mqc MQC handle
 */
-static void mqc_setbits(opj_mqc_t *mqc);
+static void opj_mqc_setbits(opj_mqc_t *mqc);
 /**
-FIXME: documentation ???
+FIXME DOC
 @param mqc MQC handle
 @return 
 */
-static INLINE int mqc_mpsexchange(opj_mqc_t *const mqc);
+static INLINE OPJ_INT32 opj_mqc_mpsexchange(opj_mqc_t *const mqc);
 /**
-FIXME: documentation ???
+FIXME DOC
 @param mqc MQC handle
 @return 
 */
-static INLINE int mqc_lpsexchange(opj_mqc_t *const mqc);
+static INLINE OPJ_INT32 opj_mqc_lpsexchange(opj_mqc_t *const mqc);
 /**
 Input a byte
 @param mqc MQC handle
 */
-static INLINE void mqc_bytein(opj_mqc_t *const mqc);
+static INLINE void opj_mqc_bytein(opj_mqc_t *const mqc);
 /**
 Renormalize mqc->a and mqc->c while decoding
 @param mqc MQC handle
 */
-static INLINE void mqc_renormd(opj_mqc_t *const mqc);
+static INLINE void opj_mqc_renormd(opj_mqc_t *const mqc);
 /*@}*/
 
 /*@}*/
@@ -195,16 +202,16 @@ static opj_mqc_state_t mqc_states[47 * 2] = {
 ==========================================================
 */
 
-static void mqc_byteout(opj_mqc_t *mqc) {
+void opj_mqc_byteout(opj_mqc_t *mqc) {
 	if (*mqc->bp == 0xff) {
 		mqc->bp++;
-		*mqc->bp = mqc->c >> 20;
+		*mqc->bp = (OPJ_BYTE)(mqc->c >> 20);
 		mqc->c &= 0xfffff;
 		mqc->ct = 7;
 	} else {
 		if ((mqc->c & 0x8000000) == 0) {	/* ((mqc->c&0x8000000)==0) CHANGE */
 			mqc->bp++;
-			*mqc->bp = mqc->c >> 19;
+			*mqc->bp = (OPJ_BYTE)(mqc->c >> 19);
 			mqc->c &= 0x7ffff;
 			mqc->ct = 8;
 		} else {
@@ -212,12 +219,12 @@ static void mqc_byteout(opj_mqc_t *mqc) {
 			if (*mqc->bp == 0xff) {
 				mqc->c &= 0x7ffffff;
 				mqc->bp++;
-				*mqc->bp = mqc->c >> 20;
+				*mqc->bp = (OPJ_BYTE)(mqc->c >> 20);
 				mqc->c &= 0xfffff;
 				mqc->ct = 7;
 			} else {
 				mqc->bp++;
-				*mqc->bp = mqc->c >> 19;
+				*mqc->bp = (OPJ_BYTE)(mqc->c >> 19);
 				mqc->c &= 0x7ffff;
 				mqc->ct = 8;
 			}
@@ -225,18 +232,18 @@ static void mqc_byteout(opj_mqc_t *mqc) {
 	}
 }
 
-static void mqc_renorme(opj_mqc_t *mqc) {
+void opj_mqc_renorme(opj_mqc_t *mqc) {
 	do {
 		mqc->a <<= 1;
 		mqc->c <<= 1;
 		mqc->ct--;
 		if (mqc->ct == 0) {
-			mqc_byteout(mqc);
+			opj_mqc_byteout(mqc);
 		}
 	} while ((mqc->a & 0x8000) == 0);
 }
 
-static void mqc_codemps(opj_mqc_t *mqc) {
+void opj_mqc_codemps(opj_mqc_t *mqc) {
 	mqc->a -= (*mqc->curctx)->qeval;
 	if ((mqc->a & 0x8000) == 0) {
 		if (mqc->a < (*mqc->curctx)->qeval) {
@@ -245,13 +252,13 @@ static void mqc_codemps(opj_mqc_t *mqc) {
 			mqc->c += (*mqc->curctx)->qeval;
 		}
 		*mqc->curctx = (*mqc->curctx)->nmps;
-		mqc_renorme(mqc);
+		opj_mqc_renorme(mqc);
 	} else {
 		mqc->c += (*mqc->curctx)->qeval;
 	}
 }
 
-static void mqc_codelps(opj_mqc_t *mqc) {
+void opj_mqc_codelps(opj_mqc_t *mqc) {
 	mqc->a -= (*mqc->curctx)->qeval;
 	if (mqc->a < (*mqc->curctx)->qeval) {
 		mqc->c += (*mqc->curctx)->qeval;
@@ -259,39 +266,39 @@ static void mqc_codelps(opj_mqc_t *mqc) {
 		mqc->a = (*mqc->curctx)->qeval;
 	}
 	*mqc->curctx = (*mqc->curctx)->nlps;
-	mqc_renorme(mqc);
+	opj_mqc_renorme(mqc);
 }
 
-static void mqc_setbits(opj_mqc_t *mqc) {
-	unsigned int tempc = mqc->c + mqc->a;
+void opj_mqc_setbits(opj_mqc_t *mqc) {
+	OPJ_UINT32 tempc = mqc->c + mqc->a;
 	mqc->c |= 0xffff;
 	if (mqc->c >= tempc) {
 		mqc->c -= 0x8000;
 	}
 }
 
-static INLINE int mqc_mpsexchange(opj_mqc_t *const mqc) {
-	int d;
+static INLINE OPJ_INT32 opj_mqc_mpsexchange(opj_mqc_t *const mqc) {
+	OPJ_INT32 d;
 	if (mqc->a < (*mqc->curctx)->qeval) {
-		d = 1 - (*mqc->curctx)->mps;
+		d = (OPJ_INT32)(1 - (*mqc->curctx)->mps);
 		*mqc->curctx = (*mqc->curctx)->nlps;
 	} else {
-		d = (*mqc->curctx)->mps;
+		d = (OPJ_INT32)(*mqc->curctx)->mps;
 		*mqc->curctx = (*mqc->curctx)->nmps;
 	}
 	
 	return d;
 }
 
-static INLINE int mqc_lpsexchange(opj_mqc_t *const mqc) {
-	int d;
+static INLINE OPJ_INT32 opj_mqc_lpsexchange(opj_mqc_t *const mqc) {
+	OPJ_INT32 d;
 	if (mqc->a < (*mqc->curctx)->qeval) {
 		mqc->a = (*mqc->curctx)->qeval;
-		d = (*mqc->curctx)->mps;
+		d = (OPJ_INT32)(*mqc->curctx)->mps;
 		*mqc->curctx = (*mqc->curctx)->nmps;
 	} else {
 		mqc->a = (*mqc->curctx)->qeval;
-		d = 1 - (*mqc->curctx)->mps;
+		d = (OPJ_INT32)(1 - (*mqc->curctx)->mps);
 		*mqc->curctx = (*mqc->curctx)->nlps;
 	}
 	
@@ -299,16 +306,16 @@ static INLINE int mqc_lpsexchange(opj_mqc_t *const mqc) {
 }
 
 #ifdef MQC_PERF_OPT
-static INLINE void mqc_bytein(opj_mqc_t *const mqc) {
+static INLINE void opj_mqc_bytein(opj_mqc_t *const mqc) {
 	unsigned int i = *((unsigned int *) mqc->bp);
 	mqc->c += i & 0xffff00;
 	mqc->ct = i & 0x0f;
 	mqc->bp += (i >> 2) & 0x04;
 }
 #else
-static void mqc_bytein(opj_mqc_t *const mqc) {
+static void opj_mqc_bytein(opj_mqc_t *const mqc) {
 	if (mqc->bp != mqc->end) {
-		unsigned int c;
+		OPJ_UINT32 c;
 		if (mqc->bp + 1 != mqc->end) {
 			c = *(mqc->bp + 1);
 		} else {
@@ -335,10 +342,10 @@ static void mqc_bytein(opj_mqc_t *const mqc) {
 }
 #endif
 
-static INLINE void mqc_renormd(opj_mqc_t *const mqc) {
+static INLINE void opj_mqc_renormd(opj_mqc_t *const mqc) {
 	do {
 		if (mqc->ct == 0) {
-			mqc_bytein(mqc);
+			opj_mqc_bytein(mqc);
 		}
 		mqc->a <<= 1;
 		mqc->c <<= 1;
@@ -352,7 +359,7 @@ static INLINE void mqc_renormd(opj_mqc_t *const mqc) {
 ==========================================================
 */
 
-opj_mqc_t* mqc_create(void) {
+opj_mqc_t* opj_mqc_create(void) {
 	opj_mqc_t *mqc = (opj_mqc_t*)opj_malloc(sizeof(opj_mqc_t));
 #ifdef MQC_PERF_OPT
 	mqc->buffer = NULL;
@@ -360,23 +367,26 @@ opj_mqc_t* mqc_create(void) {
 	return mqc;
 }
 
-void mqc_destroy(opj_mqc_t *mqc) {
+void opj_mqc_destroy(opj_mqc_t *mqc) {
 	if(mqc) {
 #ifdef MQC_PERF_OPT
-		if (mqc->buffer) {
-			opj_free(mqc->buffer);
-		}
+		opj_free(mqc->buffer);
 #endif
 		opj_free(mqc);
 	}
 }
 
-int mqc_numbytes(opj_mqc_t *mqc) {
-	return mqc->bp - mqc->start;
+OPJ_UINT32 opj_mqc_numbytes(opj_mqc_t *mqc) {
+	const ptrdiff_t diff = mqc->bp - mqc->start;
+#if 0
+  assert( diff <= 0xffffffff && diff >= 0 ); /* UINT32_MAX */
+#endif
+	return (OPJ_UINT32)diff;
 }
 
-void mqc_init_enc(opj_mqc_t *mqc, unsigned char *bp) {
-	mqc_setcurctx(mqc, 0);
+void opj_mqc_init_enc(opj_mqc_t *mqc, OPJ_BYTE *bp) {
+    /* TODO MSD: need to take a look to the v2 version */
+	opj_mqc_setcurctx(mqc, 0);
 	mqc->a = 0x8000;
 	mqc->c = 0;
 	mqc->bp = bp - 1;
@@ -387,27 +397,27 @@ void mqc_init_enc(opj_mqc_t *mqc, unsigned char *bp) {
 	mqc->start = bp;
 }
 
-void mqc_encode(opj_mqc_t *mqc, int d) {
+void opj_mqc_encode(opj_mqc_t *mqc, OPJ_UINT32 d) {
 	if ((*mqc->curctx)->mps == d) {
-		mqc_codemps(mqc);
+		opj_mqc_codemps(mqc);
 	} else {
-		mqc_codelps(mqc);
+		opj_mqc_codelps(mqc);
 	}
 }
 
-void mqc_flush(opj_mqc_t *mqc) {
-	mqc_setbits(mqc);
+void opj_mqc_flush(opj_mqc_t *mqc) {
+	opj_mqc_setbits(mqc);
 	mqc->c <<= mqc->ct;
-	mqc_byteout(mqc);
+	opj_mqc_byteout(mqc);
 	mqc->c <<= mqc->ct;
-	mqc_byteout(mqc);
+	opj_mqc_byteout(mqc);
 	
 	if (*mqc->bp != 0xff) {
 		mqc->bp++;
 	}
 }
 
-void mqc_bypass_init_enc(opj_mqc_t *mqc) {
+void opj_mqc_bypass_init_enc(opj_mqc_t *mqc) {
 	mqc->c = 0;
 	mqc->ct = 8;
 	/*if (*mqc->bp == 0xff) {
@@ -415,12 +425,12 @@ void mqc_bypass_init_enc(opj_mqc_t *mqc) {
      } */
 }
 
-void mqc_bypass_enc(opj_mqc_t *mqc, int d) {
+void opj_mqc_bypass_enc(opj_mqc_t *mqc, OPJ_UINT32 d) {
 	mqc->ct--;
 	mqc->c = mqc->c + (d << mqc->ct);
 	if (mqc->ct == 0) {
 		mqc->bp++;
-		*mqc->bp = mqc->c;
+		*mqc->bp = (OPJ_BYTE)mqc->c;
 		mqc->ct = 8;
 		if (*mqc->bp == 0xff) {
 			mqc->ct = 7;
@@ -429,19 +439,19 @@ void mqc_bypass_enc(opj_mqc_t *mqc, int d) {
 	}
 }
 
-int mqc_bypass_flush_enc(opj_mqc_t *mqc) {
-	unsigned char bit_padding;
+OPJ_UINT32 opj_mqc_bypass_flush_enc(opj_mqc_t *mqc) {
+	OPJ_BYTE bit_padding;
 	
 	bit_padding = 0;
 	
 	if (mqc->ct != 0) {
 		while (mqc->ct > 0) {
 			mqc->ct--;
-			mqc->c += bit_padding << mqc->ct;
+			mqc->c += (OPJ_UINT32)(bit_padding << mqc->ct);
 			bit_padding = (bit_padding + 1) & 0x01;
 		}
 		mqc->bp++;
-		*mqc->bp = mqc->c;
+		*mqc->bp = (OPJ_BYTE)mqc->c;
 		mqc->ct = 8;
 		mqc->c = 0;
 	}
@@ -449,32 +459,32 @@ int mqc_bypass_flush_enc(opj_mqc_t *mqc) {
 	return 1;
 }
 
-void mqc_reset_enc(opj_mqc_t *mqc) {
-	mqc_resetstates(mqc);
-	mqc_setstate(mqc, T1_CTXNO_UNI, 0, 46);
-	mqc_setstate(mqc, T1_CTXNO_AGG, 0, 3);
-	mqc_setstate(mqc, T1_CTXNO_ZC, 0, 4);
+void opj_mqc_reset_enc(opj_mqc_t *mqc) {
+	opj_mqc_resetstates(mqc);
+	opj_mqc_setstate(mqc, T1_CTXNO_UNI, 0, 46);
+	opj_mqc_setstate(mqc, T1_CTXNO_AGG, 0, 3);
+	opj_mqc_setstate(mqc, T1_CTXNO_ZC, 0, 4);
 }
 
-int mqc_restart_enc(opj_mqc_t *mqc) {
-	int correction = 1;
+OPJ_UINT32 opj_mqc_restart_enc(opj_mqc_t *mqc) {
+	OPJ_UINT32 correction = 1;
 	
 	/* <flush part> */
-	int n = 27 - 15 - mqc->ct;
+	OPJ_INT32 n = (OPJ_INT32)(27 - 15 - mqc->ct);
 	mqc->c <<= mqc->ct;
 	while (n > 0) {
-		mqc_byteout(mqc);
-		n -= mqc->ct;
+		opj_mqc_byteout(mqc);
+		n -= (OPJ_INT32)mqc->ct;
 		mqc->c <<= mqc->ct;
 	}
-	mqc_byteout(mqc);
+	opj_mqc_byteout(mqc);
 	
 	return correction;
 }
 
-void mqc_restart_init_enc(opj_mqc_t *mqc) {
+void opj_mqc_restart_init_enc(opj_mqc_t *mqc) {
 	/* <Re-init part> */
-	mqc_setcurctx(mqc, 0);
+	opj_mqc_setcurctx(mqc, 0);
 	mqc->a = 0x8000;
 	mqc->c = 0;
 	mqc->ct = 12;
@@ -484,45 +494,52 @@ void mqc_restart_init_enc(opj_mqc_t *mqc) {
 	}
 }
 
-void mqc_erterm_enc(opj_mqc_t *mqc) {
-	int k = 11 - mqc->ct + 1;
+void opj_mqc_erterm_enc(opj_mqc_t *mqc) {
+	OPJ_INT32 k = (OPJ_INT32)(11 - mqc->ct + 1);
 	
 	while (k > 0) {
 		mqc->c <<= mqc->ct;
 		mqc->ct = 0;
-		mqc_byteout(mqc);
-		k -= mqc->ct;
+		opj_mqc_byteout(mqc);
+		k -= (OPJ_INT32)mqc->ct;
 	}
 	
 	if (*mqc->bp != 0xff) {
-		mqc_byteout(mqc);
+		opj_mqc_byteout(mqc);
 	}
 }
 
-void mqc_segmark_enc(opj_mqc_t *mqc) {
-	int i;
-	mqc_setcurctx(mqc, 18);
+void opj_mqc_segmark_enc(opj_mqc_t *mqc) {
+	OPJ_UINT32 i;
+	opj_mqc_setcurctx(mqc, 18);
 	
 	for (i = 1; i < 5; i++) {
-		mqc_encode(mqc, i % 2);
+		opj_mqc_encode(mqc, i % 2);
 	}
 }
 
-void mqc_init_dec(opj_mqc_t *mqc, unsigned char *bp, int len) {
-	mqc_setcurctx(mqc, 0);
+OPJ_BOOL opj_mqc_init_dec(opj_mqc_t *mqc, OPJ_BYTE *bp, OPJ_UINT32 len) {
+	opj_mqc_setcurctx(mqc, 0);
 	mqc->start = bp;
 	mqc->end = bp + len;
 	mqc->bp = bp;
 	if (len==0) mqc->c = 0xff << 16;
-	else mqc->c = *mqc->bp << 16;
+	else mqc->c = (OPJ_UINT32)(*mqc->bp << 16);
 
-#ifdef MQC_PERF_OPT
+#ifdef MQC_PERF_OPT /* TODO_MSD: check this option and put in experimental */
 	{
-		unsigned int c;
-		unsigned int *ip;
-		unsigned char *end = mqc->end - 1;
-		mqc->buffer = opj_realloc(mqc->buffer, (len + 1) * sizeof(unsigned int));
-		ip = (unsigned int *) mqc->buffer;
+        OPJ_UINT32 c;
+		OPJ_UINT32 *ip;
+		OPJ_BYTE *end = mqc->end - 1;
+        void* new_buffer = opj_realloc(mqc->buffer, (len + 1) * sizeof(OPJ_UINT32));
+        if (! new_buffer) {
+            opj_free(mqc->buffer);
+            mqc->buffer = NULL;
+            return OPJ_FALSE;
+        }
+        mqc->buffer = new_buffer;
+		
+        ip = (OPJ_UINT32 *) mqc->buffer;
 
 		while (bp < end) {
 			c = *(bp + 1);
@@ -553,40 +570,41 @@ void mqc_init_dec(opj_mqc_t *mqc, unsigned char *bp, int len) {
 		mqc->bp = mqc->buffer;
 	}
 #endif
-	mqc_bytein(mqc);
+	opj_mqc_bytein(mqc);
 	mqc->c <<= 7;
 	mqc->ct -= 7;
 	mqc->a = 0x8000;
+        return OPJ_TRUE;
 }
 
-int mqc_decode(opj_mqc_t *const mqc) {
-	int d;
+OPJ_INT32 opj_mqc_decode(opj_mqc_t *const mqc) {
+	OPJ_INT32 d;
 	mqc->a -= (*mqc->curctx)->qeval;
 	if ((mqc->c >> 16) < (*mqc->curctx)->qeval) {
-		d = mqc_lpsexchange(mqc);
-		mqc_renormd(mqc);
+		d = opj_mqc_lpsexchange(mqc);
+		opj_mqc_renormd(mqc);
 	} else {
 		mqc->c -= (*mqc->curctx)->qeval << 16;
 		if ((mqc->a & 0x8000) == 0) {
-			d = mqc_mpsexchange(mqc);
-			mqc_renormd(mqc);
+			d = opj_mqc_mpsexchange(mqc);
+			opj_mqc_renormd(mqc);
 		} else {
-			d = (*mqc->curctx)->mps;
+			d = (OPJ_INT32)(*mqc->curctx)->mps;
 		}
 	}
 
 	return d;
 }
 
-void mqc_resetstates(opj_mqc_t *mqc) {
-	int i;
+void opj_mqc_resetstates(opj_mqc_t *mqc) {
+	OPJ_UINT32 i;
 	for (i = 0; i < MQC_NUMCTXS; i++) {
 		mqc->ctxs[i] = mqc_states;
 	}
 }
 
-void mqc_setstate(opj_mqc_t *mqc, int ctxno, int msb, int prob) {
-	mqc->ctxs[ctxno] = &mqc_states[msb + (prob << 1)];
+void opj_mqc_setstate(opj_mqc_t *mqc, OPJ_UINT32 ctxno, OPJ_UINT32 msb, OPJ_INT32 prob) {
+	mqc->ctxs[ctxno] = &mqc_states[msb + (OPJ_UINT32)(prob << 1)];
 }
 
 
diff --git a/extern/libopenjpeg/mqc.h b/extern/libopenjpeg/mqc.h
index d00cd10..69a2d46 100644
--- a/extern/libopenjpeg/mqc.h
+++ b/extern/libopenjpeg/mqc.h
@@ -1,10 +1,17 @@
 /*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2001-2003, David Janssens
  * Copyright (c) 2002-2003, Yannick Verschueren
- * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * Copyright (c) 2003-2014, Antonin Descampe
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * Copyright (c) 2008, Jerome Fimes, Communications & Systemes <jerome.fimes@c-s.fr>
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -47,9 +54,9 @@ This struct defines the state of a context.
 */
 typedef struct opj_mqc_state {
 	/** the probability of the Least Probable Symbol (0.75->0x8000, 1.5->0xffff) */
-	unsigned int qeval;
+	OPJ_UINT32 qeval;
 	/** the Most Probable Symbol (0 or 1) */
-	int mps;
+	OPJ_UINT32 mps;
 	/** next state if the next encoded symbol is the MPS */
 	struct opj_mqc_state *nmps;
 	/** next state if the next encoded symbol is the LPS */
@@ -62,12 +69,12 @@ typedef struct opj_mqc_state {
 MQ coder
 */
 typedef struct opj_mqc {
-	unsigned int c;
-	unsigned int a;
-	unsigned int ct;
-	unsigned char *bp;
-	unsigned char *start;
-	unsigned char *end;
+	OPJ_UINT32 c;
+	OPJ_UINT32 a;
+	OPJ_UINT32 ct;
+	OPJ_BYTE *bp;
+	OPJ_BYTE *start;
+	OPJ_BYTE *end;
 	opj_mqc_state_t *ctxs[MQC_NUMCTXS];
 	opj_mqc_state_t **curctx;
 #ifdef MQC_PERF_OPT
@@ -82,24 +89,24 @@ typedef struct opj_mqc {
 Create a new MQC handle 
 @return Returns a new MQC handle if successful, returns NULL otherwise
 */
-opj_mqc_t* mqc_create(void);
+opj_mqc_t* opj_mqc_create(void);
 /**
 Destroy a previously created MQC handle
 @param mqc MQC handle to destroy
 */
-void mqc_destroy(opj_mqc_t *mqc);
+void opj_mqc_destroy(opj_mqc_t *mqc);
 /**
 Return the number of bytes written/read since initialisation
 @param mqc MQC handle
 @return Returns the number of bytes already encoded
 */
-int mqc_numbytes(opj_mqc_t *mqc);
+OPJ_UINT32 opj_mqc_numbytes(opj_mqc_t *mqc);
 /**
 Reset the states of all the context of the coder/decoder 
 (each context is set to a state where 0 and 1 are more or less equiprobable)
 @param mqc MQC handle
 */
-void mqc_resetstates(opj_mqc_t *mqc);
+void opj_mqc_resetstates(opj_mqc_t *mqc);
 /**
 Set the state of a particular context
 @param mqc MQC handle
@@ -107,37 +114,37 @@ Set the state of a particular context
 @param msb The MSB of the new state of the context
 @param prob Number that identifies the probability of the symbols for the new state of the context
 */
-void mqc_setstate(opj_mqc_t *mqc, int ctxno, int msb, int prob);
+void opj_mqc_setstate(opj_mqc_t *mqc, OPJ_UINT32 ctxno, OPJ_UINT32 msb, OPJ_INT32 prob);
 /**
 Initialize the encoder
 @param mqc MQC handle
 @param bp Pointer to the start of the buffer where the bytes will be written
 */
-void mqc_init_enc(opj_mqc_t *mqc, unsigned char *bp);
+void opj_mqc_init_enc(opj_mqc_t *mqc, OPJ_BYTE *bp);
 /**
 Set the current context used for coding/decoding
 @param mqc MQC handle
 @param ctxno Number that identifies the context
 */
-#define mqc_setcurctx(mqc, ctxno)	(mqc)->curctx = &(mqc)->ctxs[(int)(ctxno)]
+#define opj_mqc_setcurctx(mqc, ctxno)	(mqc)->curctx = &(mqc)->ctxs[(OPJ_UINT32)(ctxno)]
 /**
 Encode a symbol using the MQ-coder
 @param mqc MQC handle
 @param d The symbol to be encoded (0 or 1)
 */
-void mqc_encode(opj_mqc_t *mqc, int d);
+void opj_mqc_encode(opj_mqc_t *mqc, OPJ_UINT32 d);
 /**
 Flush the encoder, so that all remaining data is written
 @param mqc MQC handle
 */
-void mqc_flush(opj_mqc_t *mqc);
+void opj_mqc_flush(opj_mqc_t *mqc);
 /**
 BYPASS mode switch, initialization operation. 
 JPEG 2000 p 505. 
 <h2>Not fully implemented and tested !!</h2>
 @param mqc MQC handle
 */
-void mqc_bypass_init_enc(opj_mqc_t *mqc);
+void opj_mqc_bypass_init_enc(opj_mqc_t *mqc);
 /**
 BYPASS mode switch, coding operation. 
 JPEG 2000 p 505. 
@@ -145,53 +152,53 @@ JPEG 2000 p 505.
 @param mqc MQC handle
 @param d The symbol to be encoded (0 or 1)
 */
-void mqc_bypass_enc(opj_mqc_t *mqc, int d);
+void opj_mqc_bypass_enc(opj_mqc_t *mqc, OPJ_UINT32 d);
 /**
 BYPASS mode switch, flush operation
 <h2>Not fully implemented and tested !!</h2>
 @param mqc MQC handle
 @return Returns 1 (always)
 */
-int mqc_bypass_flush_enc(opj_mqc_t *mqc);
+OPJ_UINT32 opj_mqc_bypass_flush_enc(opj_mqc_t *mqc);
 /**
 RESET mode switch
 @param mqc MQC handle
 */
-void mqc_reset_enc(opj_mqc_t *mqc);
+void opj_mqc_reset_enc(opj_mqc_t *mqc);
 /**
 RESTART mode switch (TERMALL)
 @param mqc MQC handle
 @return Returns 1 (always)
 */
-int mqc_restart_enc(opj_mqc_t *mqc);
+OPJ_UINT32 opj_mqc_restart_enc(opj_mqc_t *mqc);
 /**
 RESTART mode switch (TERMALL) reinitialisation
 @param mqc MQC handle
 */
-void mqc_restart_init_enc(opj_mqc_t *mqc);
+void opj_mqc_restart_init_enc(opj_mqc_t *mqc);
 /**
 ERTERM mode switch (PTERM)
 @param mqc MQC handle
 */
-void mqc_erterm_enc(opj_mqc_t *mqc);
+void opj_mqc_erterm_enc(opj_mqc_t *mqc);
 /**
 SEGMARK mode switch (SEGSYM)
 @param mqc MQC handle
 */
-void mqc_segmark_enc(opj_mqc_t *mqc);
+void opj_mqc_segmark_enc(opj_mqc_t *mqc);
 /**
 Initialize the decoder
 @param mqc MQC handle
 @param bp Pointer to the start of the buffer from which the bytes will be read
 @param len Length of the input buffer
 */
-void mqc_init_dec(opj_mqc_t *mqc, unsigned char *bp, int len);
+OPJ_BOOL opj_mqc_init_dec(opj_mqc_t *mqc, OPJ_BYTE *bp, OPJ_UINT32 len);
 /**
 Decode a symbol
 @param mqc MQC handle
 @return Returns the decoded symbol (0 or 1)
 */
-int mqc_decode(opj_mqc_t *const mqc);
+OPJ_INT32 opj_mqc_decode(opj_mqc_t * const mqc);
 /* ----------------------------------------------------------------------- */
 /*@}*/
 
diff --git a/extern/libopenjpeg/openjpeg.c b/extern/libopenjpeg/openjpeg.c
index 180cc84..4665d90 100644
--- a/extern/libopenjpeg/openjpeg.c
+++ b/extern/libopenjpeg/openjpeg.c
@@ -1,5 +1,12 @@
 /*
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR 
+ * Copyright (c) 2012, CS Systemes d'Information, France
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -28,9 +35,99 @@
 #include <windows.h>
 #endif /* _WIN32 */
 
-#include "opj_config.h"
 #include "opj_includes.h"
 
+
+/* ---------------------------------------------------------------------- */
+/* Functions to set the message handlers */
+
+OPJ_BOOL OPJ_CALLCONV opj_set_info_handler(	opj_codec_t * p_codec, 
+											opj_msg_callback p_callback,
+											void * p_user_data)
+{
+	opj_codec_private_t * l_codec = (opj_codec_private_t *) p_codec;
+	if(! l_codec){
+		return OPJ_FALSE;
+	}
+	
+	l_codec->m_event_mgr.info_handler = p_callback;
+	l_codec->m_event_mgr.m_info_data = p_user_data;
+	
+	return OPJ_TRUE;
+}
+
+OPJ_BOOL OPJ_CALLCONV opj_set_warning_handler(	opj_codec_t * p_codec, 
+												opj_msg_callback p_callback,
+												void * p_user_data)
+{
+	opj_codec_private_t * l_codec = (opj_codec_private_t *) p_codec;
+	if (! l_codec) {
+		return OPJ_FALSE;
+	}
+	
+	l_codec->m_event_mgr.warning_handler = p_callback;
+	l_codec->m_event_mgr.m_warning_data = p_user_data;
+	
+	return OPJ_TRUE;
+}
+
+OPJ_BOOL OPJ_CALLCONV opj_set_error_handler(opj_codec_t * p_codec, 
+											opj_msg_callback p_callback,
+											void * p_user_data)
+{
+	opj_codec_private_t * l_codec = (opj_codec_private_t *) p_codec;
+	if (! l_codec) {
+		return OPJ_FALSE;
+	}
+	
+	l_codec->m_event_mgr.error_handler = p_callback;
+	l_codec->m_event_mgr.m_error_data = p_user_data;
+	
+	return OPJ_TRUE;
+}
+
+/* ---------------------------------------------------------------------- */
+
+static OPJ_SIZE_T opj_read_from_file (void * p_buffer, OPJ_SIZE_T p_nb_bytes, FILE * p_file)
+{
+	OPJ_SIZE_T l_nb_read = fread(p_buffer,1,p_nb_bytes,p_file);
+	return l_nb_read ? l_nb_read : (OPJ_SIZE_T)-1;
+}
+
+static OPJ_UINT64 opj_get_data_length_from_file (FILE * p_file)
+{
+	OPJ_OFF_T file_length = 0;
+
+	OPJ_FSEEK(p_file, 0, SEEK_END);
+	file_length = (OPJ_OFF_T)OPJ_FTELL(p_file);
+	OPJ_FSEEK(p_file, 0, SEEK_SET);
+
+	return (OPJ_UINT64)file_length;
+}
+
+static OPJ_SIZE_T opj_write_from_file (void * p_buffer, OPJ_SIZE_T p_nb_bytes, FILE * p_file)
+{
+	return fwrite(p_buffer,1,p_nb_bytes,p_file);
+}
+
+static OPJ_OFF_T opj_skip_from_file (OPJ_OFF_T p_nb_bytes, FILE * p_user_data)
+{
+	if (OPJ_FSEEK(p_user_data,p_nb_bytes,SEEK_CUR)) {
+		return -1;
+	}
+
+	return p_nb_bytes;
+}
+
+static OPJ_BOOL opj_seek_from_file (OPJ_OFF_T p_nb_bytes, FILE * p_user_data)
+{
+	if (OPJ_FSEEK(p_user_data,p_nb_bytes,SEEK_SET)) {
+		return OPJ_FALSE;
+	}
+
+	return OPJ_TRUE;
+}
+
 /* ---------------------------------------------------------------------- */
 #ifdef _WIN32
 #ifndef OPJ_STATIC
@@ -57,62 +154,185 @@ DllMain(HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
 
 /* ---------------------------------------------------------------------- */
 
-
 const char* OPJ_CALLCONV opj_version(void) {
-    return PACKAGE_VERSION;
-}
-
-opj_dinfo_t* OPJ_CALLCONV opj_create_decompress(OPJ_CODEC_FORMAT format) {
-	opj_dinfo_t *dinfo = (opj_dinfo_t*)opj_calloc(1, sizeof(opj_dinfo_t));
-	if(!dinfo) return NULL;
-	dinfo->is_decompressor = OPJ_TRUE;
-	switch(format) {
-		case CODEC_J2K:
-		case CODEC_JPT:
-			/* get a J2K decoder handle */
-			dinfo->j2k_handle = (void*)j2k_create_decompress((opj_common_ptr)dinfo);
-			if(!dinfo->j2k_handle) {
-				opj_free(dinfo);
+    return OPJ_PACKAGE_VERSION;
+}
+
+/* ---------------------------------------------------------------------- */
+/* DECOMPRESSION FUNCTIONS*/
+
+opj_codec_t* OPJ_CALLCONV opj_create_decompress(OPJ_CODEC_FORMAT p_format)
+{
+	opj_codec_private_t *l_codec = 00;
+
+	l_codec = (opj_codec_private_t*) opj_calloc(1, sizeof(opj_codec_private_t));
+	if (!l_codec){
+		return 00;
+	}
+	memset(l_codec, 0, sizeof(opj_codec_private_t));
+
+	l_codec->is_decompressor = 1;
+
+	switch (p_format) {
+		case OPJ_CODEC_J2K:
+			l_codec->opj_dump_codec = (void (*) (void*, OPJ_INT32, FILE*)) j2k_dump;
+
+			l_codec->opj_get_codec_info = (opj_codestream_info_v2_t* (*) (void*) ) j2k_get_cstr_info;
+
+			l_codec->opj_get_codec_index = (opj_codestream_index_t* (*) (void*) ) j2k_get_cstr_index;
+
+			l_codec->m_codec_data.m_decompression.opj_decode =
+					(OPJ_BOOL (*) (	void *,
+									struct opj_stream_private *,
+									opj_image_t*, struct opj_event_mgr * )) opj_j2k_decode;
+
+			l_codec->m_codec_data.m_decompression.opj_end_decompress =
+					(OPJ_BOOL (*) (	void *,
+									struct opj_stream_private *,
+									struct opj_event_mgr *)) opj_j2k_end_decompress;
+
+			l_codec->m_codec_data.m_decompression.opj_read_header =
+					(OPJ_BOOL (*) (	struct opj_stream_private *,
+									void *,
+									opj_image_t **,
+									struct opj_event_mgr * )) opj_j2k_read_header;
+
+			l_codec->m_codec_data.m_decompression.opj_destroy =
+					(void (*) (void *))opj_j2k_destroy;
+
+			l_codec->m_codec_data.m_decompression.opj_setup_decoder =
+					(void (*) (void * , opj_dparameters_t * )) opj_j2k_setup_decoder;
+
+			l_codec->m_codec_data.m_decompression.opj_read_tile_header =
+					(OPJ_BOOL (*) (	void *,
+									OPJ_UINT32*,
+									OPJ_UINT32*,
+									OPJ_INT32*, OPJ_INT32*,
+									OPJ_INT32*, OPJ_INT32*,
+									OPJ_UINT32*,
+									OPJ_BOOL*,
+									struct opj_stream_private *,
+									struct opj_event_mgr * )) opj_j2k_read_tile_header;
+
+			l_codec->m_codec_data.m_decompression.opj_decode_tile_data =
+					(OPJ_BOOL (*) ( void *, 
+                                    OPJ_UINT32, 
+                                    OPJ_BYTE*, 
+                                    OPJ_UINT32, 
+                                    struct opj_stream_private *,
+                                    struct opj_event_mgr *)) opj_j2k_decode_tile;
+
+			l_codec->m_codec_data.m_decompression.opj_set_decode_area =
+					(OPJ_BOOL (*) ( void *, 
+                                    opj_image_t*, 
+                                    OPJ_INT32, OPJ_INT32, OPJ_INT32, OPJ_INT32, 
+                                    struct opj_event_mgr *)) opj_j2k_set_decode_area;
+
+			l_codec->m_codec_data.m_decompression.opj_get_decoded_tile = 
+                    (OPJ_BOOL (*) ( void *p_codec,
+								    opj_stream_private_t *p_cio,
+								    opj_image_t *p_image,
+								    struct opj_event_mgr * p_manager,
+								    OPJ_UINT32 tile_index)) opj_j2k_get_tile;
+
+			l_codec->m_codec_data.m_decompression.opj_set_decoded_resolution_factor = 
+                    (OPJ_BOOL (*) ( void * p_codec,
+									OPJ_UINT32 res_factor,
+									struct opj_event_mgr * p_manager)) opj_j2k_set_decoded_resolution_factor;
+
+			l_codec->m_codec = opj_j2k_create_decompress();
+
+			if (! l_codec->m_codec) {
+				opj_free(l_codec);
 				return NULL;
 			}
+
 			break;
-		case CODEC_JP2:
+
+		case OPJ_CODEC_JP2:
 			/* get a JP2 decoder handle */
-			dinfo->jp2_handle = (void*)jp2_create_decompress((opj_common_ptr)dinfo);
-			if(!dinfo->jp2_handle) {
-				opj_free(dinfo);
-				return NULL;
+			l_codec->opj_dump_codec = (void (*) (void*, OPJ_INT32, FILE*)) jp2_dump;
+
+			l_codec->opj_get_codec_info = (opj_codestream_info_v2_t* (*) (void*) ) jp2_get_cstr_info;
+
+			l_codec->opj_get_codec_index = (opj_codestream_index_t* (*) (void*) ) jp2_get_cstr_index;
+
+			l_codec->m_codec_data.m_decompression.opj_decode =
+					(OPJ_BOOL (*) (	void *,
+									struct opj_stream_private *,
+									opj_image_t*,
+									struct opj_event_mgr * )) opj_jp2_decode;
+
+			l_codec->m_codec_data.m_decompression.opj_end_decompress =  
+                    (OPJ_BOOL (*) ( void *,
+                                    struct opj_stream_private *,
+                                    struct opj_event_mgr *)) opj_jp2_end_decompress;
+
+			l_codec->m_codec_data.m_decompression.opj_read_header =  
+                    (OPJ_BOOL (*) ( struct opj_stream_private *,
+					                void *,
+					                opj_image_t **,
+					                struct opj_event_mgr * )) opj_jp2_read_header;
+
+			l_codec->m_codec_data.m_decompression.opj_read_tile_header = 
+                    (OPJ_BOOL (*) ( void *,
+					                OPJ_UINT32*,
+					                OPJ_UINT32*,
+					                OPJ_INT32*,
+					                OPJ_INT32*,
+					                OPJ_INT32 * ,
+					                OPJ_INT32 * ,
+					                OPJ_UINT32 * ,
+					                OPJ_BOOL *,
+					                struct opj_stream_private *,
+					                struct opj_event_mgr * )) opj_jp2_read_tile_header;
+
+			l_codec->m_codec_data.m_decompression.opj_decode_tile_data = 
+                    (OPJ_BOOL (*) ( void *,
+                                    OPJ_UINT32,OPJ_BYTE*,OPJ_UINT32,
+                                    struct opj_stream_private *,
+                                    struct opj_event_mgr * )) opj_jp2_decode_tile;
+
+			l_codec->m_codec_data.m_decompression.opj_destroy = (void (*) (void *))opj_jp2_destroy;
+
+			l_codec->m_codec_data.m_decompression.opj_setup_decoder = 
+                    (void (*) (void * ,opj_dparameters_t * )) opj_jp2_setup_decoder;
+
+			l_codec->m_codec_data.m_decompression.opj_set_decode_area = 
+                    (OPJ_BOOL (*) ( void *,
+                                    opj_image_t*, 
+                                    OPJ_INT32,OPJ_INT32,OPJ_INT32,OPJ_INT32,
+                                    struct opj_event_mgr * )) opj_jp2_set_decode_area;
+
+			l_codec->m_codec_data.m_decompression.opj_get_decoded_tile = 
+                    (OPJ_BOOL (*) ( void *p_codec,
+									opj_stream_private_t *p_cio,
+									opj_image_t *p_image,
+									struct opj_event_mgr * p_manager,
+									OPJ_UINT32 tile_index)) opj_jp2_get_tile;
+
+			l_codec->m_codec_data.m_decompression.opj_set_decoded_resolution_factor = 
+                    (OPJ_BOOL (*) ( void * p_codec,
+						    		OPJ_UINT32 res_factor,
+							    	opj_event_mgr_t * p_manager)) opj_jp2_set_decoded_resolution_factor;
+
+			l_codec->m_codec = opj_jp2_create(OPJ_TRUE);
+
+			if (! l_codec->m_codec) {
+				opj_free(l_codec);
+				return 00;
 			}
+
 			break;
-		case CODEC_UNKNOWN:
+		case OPJ_CODEC_UNKNOWN:
+		case OPJ_CODEC_JPT:
 		default:
-			opj_free(dinfo);
-			return NULL;
+			opj_free(l_codec);
+			return 00;
 	}
 
-	dinfo->codec_format = format;
-
-	return dinfo;
-}
-
-void OPJ_CALLCONV opj_destroy_decompress(opj_dinfo_t *dinfo) {
-	if(dinfo) {
-		/* destroy the codec */
-		switch(dinfo->codec_format) {
-			case CODEC_J2K:
-			case CODEC_JPT:
-				j2k_destroy_decompress((opj_j2k_t*)dinfo->j2k_handle);
-				break;
-			case CODEC_JP2:
-				jp2_destroy_decompress((opj_jp2_t*)dinfo->jp2_handle);
-				break;
-			case CODEC_UNKNOWN:
-			default:
-				break;
-		}
-		/* destroy the decompressor */
-		opj_free(dinfo);
-	}
+	opj_set_default_event_handler(&(l_codec->m_event_mgr));
+	return (opj_codec_t*) l_codec;
 }
 
 void OPJ_CALLCONV opj_set_default_decoder_parameters(opj_dparameters_t *parameters) {
@@ -121,7 +341,6 @@ void OPJ_CALLCONV opj_set_default_decoder_parameters(opj_dparameters_t *paramete
 		/* default decoding parameters */
 		parameters->cp_layer = 0;
 		parameters->cp_reduce = 0;
-		parameters->cp_limit_decoding = NO_LIMITATION;
 
 		parameters->decod_format = -1;
 		parameters->cod_format = -1;
@@ -136,108 +355,298 @@ void OPJ_CALLCONV opj_set_default_decoder_parameters(opj_dparameters_t *paramete
 	}
 }
 
-void OPJ_CALLCONV opj_setup_decoder(opj_dinfo_t *dinfo, opj_dparameters_t *parameters) {
-	if(dinfo && parameters) {
-		switch(dinfo->codec_format) {
-			case CODEC_J2K:
-			case CODEC_JPT:
-				j2k_setup_decoder((opj_j2k_t*)dinfo->j2k_handle, parameters);
-				break;
-			case CODEC_JP2:
-				jp2_setup_decoder((opj_jp2_t*)dinfo->jp2_handle, parameters);
-				break;
-			case CODEC_UNKNOWN:
-			default:
-				break;
+OPJ_BOOL OPJ_CALLCONV opj_setup_decoder(opj_codec_t *p_codec,
+                                        opj_dparameters_t *parameters 
+										)
+{
+	if (p_codec && parameters) { 
+		opj_codec_private_t * l_codec = (opj_codec_private_t *) p_codec;
+
+		if (! l_codec->is_decompressor) {
+			opj_event_msg(&(l_codec->m_event_mgr), EVT_ERROR, 
+                "Codec provided to the opj_setup_decoder function is not a decompressor handler.\n");
+			return OPJ_FALSE;
 		}
+
+		l_codec->m_codec_data.m_decompression.opj_setup_decoder(l_codec->m_codec,
+																parameters);
+		return OPJ_TRUE;
 	}
+	return OPJ_FALSE;
 }
 
-opj_image_t* OPJ_CALLCONV opj_decode(opj_dinfo_t *dinfo, opj_cio_t *cio) {
-	return opj_decode_with_info(dinfo, cio, NULL);
+OPJ_BOOL OPJ_CALLCONV opj_read_header (	opj_stream_t *p_stream,
+										opj_codec_t *p_codec,
+										opj_image_t **p_image )
+{
+	if (p_codec && p_stream) {
+		opj_codec_private_t* l_codec = (opj_codec_private_t*) p_codec;
+		opj_stream_private_t* l_stream = (opj_stream_private_t*) p_stream;
+
+		if(! l_codec->is_decompressor) {
+			opj_event_msg(&(l_codec->m_event_mgr), EVT_ERROR, 
+                "Codec provided to the opj_read_header function is not a decompressor handler.\n");
+			return OPJ_FALSE;
+		}
+
+		return l_codec->m_codec_data.m_decompression.opj_read_header(	l_stream,
+																		l_codec->m_codec,
+																		p_image,
+																		&(l_codec->m_event_mgr) );
+	}
+
+	return OPJ_FALSE;
 }
 
-opj_image_t* OPJ_CALLCONV opj_decode_with_info(opj_dinfo_t *dinfo, opj_cio_t *cio, opj_codestream_info_t *cstr_info) {
-	if(dinfo && cio) {
-		switch(dinfo->codec_format) {
-			case CODEC_J2K:
-				return j2k_decode((opj_j2k_t*)dinfo->j2k_handle, cio, cstr_info);
-			case CODEC_JPT:
-				return j2k_decode_jpt_stream((opj_j2k_t*)dinfo->j2k_handle, cio, cstr_info);
-			case CODEC_JP2:
-				return opj_jp2_decode((opj_jp2_t*)dinfo->jp2_handle, cio, cstr_info);
-			case CODEC_UNKNOWN:
-			default:
-				break;
+OPJ_BOOL OPJ_CALLCONV opj_decode(   opj_codec_t *p_codec,
+                                    opj_stream_t *p_stream,
+                                    opj_image_t* p_image)
+{
+	if (p_codec && p_stream) {
+		opj_codec_private_t * l_codec = (opj_codec_private_t *) p_codec;
+		opj_stream_private_t * l_stream = (opj_stream_private_t *) p_stream;
+
+		if (! l_codec->is_decompressor) {
+			return OPJ_FALSE;
 		}
+
+		return l_codec->m_codec_data.m_decompression.opj_decode(l_codec->m_codec,
+																l_stream,
+																p_image,
+																&(l_codec->m_event_mgr) );
 	}
-	return NULL;
+
+	return OPJ_FALSE;
 }
 
-opj_cinfo_t* OPJ_CALLCONV opj_create_compress(OPJ_CODEC_FORMAT format) {
-	opj_cinfo_t *cinfo = (opj_cinfo_t*)opj_calloc(1, sizeof(opj_cinfo_t));
-	if(!cinfo) return NULL;
-	cinfo->is_decompressor = OPJ_FALSE;
-	switch(format) {
-		case CODEC_J2K:
-			/* get a J2K coder handle */
-			cinfo->j2k_handle = (void*)j2k_create_compress((opj_common_ptr)cinfo);
-			if(!cinfo->j2k_handle) {
-				opj_free(cinfo);
-				return NULL;
-			}
-			break;
-		case CODEC_JP2:
-			/* get a JP2 coder handle */
-			cinfo->jp2_handle = (void*)jp2_create_compress((opj_common_ptr)cinfo);
-			if(!cinfo->jp2_handle) {
-				opj_free(cinfo);
-				return NULL;
-			}
-			break;
-		case CODEC_JPT:
-		case CODEC_UNKNOWN:
-		default:
-			opj_free(cinfo);
-			return NULL;
+OPJ_BOOL OPJ_CALLCONV opj_set_decode_area(	opj_codec_t *p_codec,
+											opj_image_t* p_image,
+											OPJ_INT32 p_start_x, OPJ_INT32 p_start_y,
+											OPJ_INT32 p_end_x, OPJ_INT32 p_end_y
+											)
+{
+	if (p_codec) {
+		opj_codec_private_t * l_codec = (opj_codec_private_t *) p_codec;
+		
+		if (! l_codec->is_decompressor) {
+			return OPJ_FALSE;
+		}
+
+		return  l_codec->m_codec_data.m_decompression.opj_set_decode_area(	l_codec->m_codec,
+																			p_image,
+																			p_start_x, p_start_y,
+																			p_end_x, p_end_y,
+																			&(l_codec->m_event_mgr) );
+	}
+	return OPJ_FALSE;
+}
+
+OPJ_BOOL OPJ_CALLCONV opj_read_tile_header(	opj_codec_t *p_codec,
+											opj_stream_t * p_stream,
+											OPJ_UINT32 * p_tile_index,
+											OPJ_UINT32 * p_data_size,
+											OPJ_INT32 * p_tile_x0, OPJ_INT32 * p_tile_y0,
+											OPJ_INT32 * p_tile_x1, OPJ_INT32 * p_tile_y1,
+											OPJ_UINT32 * p_nb_comps,
+											OPJ_BOOL * p_should_go_on)
+{
+	if (p_codec && p_stream && p_data_size && p_tile_index) {
+		opj_codec_private_t * l_codec = (opj_codec_private_t *) p_codec;
+		opj_stream_private_t * l_stream = (opj_stream_private_t *) p_stream;
+
+		if (! l_codec->is_decompressor) {
+			return OPJ_FALSE;
+		}
+
+		return l_codec->m_codec_data.m_decompression.opj_read_tile_header(	l_codec->m_codec,
+																			p_tile_index,
+																			p_data_size,
+																			p_tile_x0, p_tile_y0,
+																			p_tile_x1, p_tile_y1,
+																			p_nb_comps,
+																			p_should_go_on,
+																			l_stream,
+																			&(l_codec->m_event_mgr));
 	}
+	return OPJ_FALSE;
+}
+
+OPJ_BOOL OPJ_CALLCONV opj_decode_tile_data(	opj_codec_t *p_codec,
+											OPJ_UINT32 p_tile_index,
+											OPJ_BYTE * p_data,
+											OPJ_UINT32 p_data_size,
+											opj_stream_t *p_stream
+											)
+{
+	if (p_codec && p_data && p_stream) {
+		opj_codec_private_t * l_codec = (opj_codec_private_t *) p_codec;
+		opj_stream_private_t * l_stream = (opj_stream_private_t *) p_stream;
 
-	cinfo->codec_format = format;
+		if (! l_codec->is_decompressor) {
+			return OPJ_FALSE;
+		}
 
-	return cinfo;
+		return l_codec->m_codec_data.m_decompression.opj_decode_tile_data(	l_codec->m_codec,
+																			p_tile_index,
+																			p_data,
+																			p_data_size,
+																			l_stream,
+																			&(l_codec->m_event_mgr) );
+	}
+	return OPJ_FALSE;
 }
 
-void OPJ_CALLCONV opj_destroy_compress(opj_cinfo_t *cinfo) {
-	if(cinfo) {
-		/* destroy the codec */
-		switch(cinfo->codec_format) {
-			case CODEC_J2K:
-				j2k_destroy_compress((opj_j2k_t*)cinfo->j2k_handle);
-				break;
-			case CODEC_JP2:
-				jp2_destroy_compress((opj_jp2_t*)cinfo->jp2_handle);
-				break;
-			case CODEC_JPT:
-			case CODEC_UNKNOWN:
-			default:
-				break;
+OPJ_BOOL OPJ_CALLCONV opj_get_decoded_tile(	opj_codec_t *p_codec,
+											opj_stream_t *p_stream,
+											opj_image_t *p_image,
+											OPJ_UINT32 tile_index)
+{
+	if (p_codec && p_stream) {
+		opj_codec_private_t * l_codec = (opj_codec_private_t *) p_codec;
+		opj_stream_private_t * l_stream = (opj_stream_private_t *) p_stream;
+
+		if (! l_codec->is_decompressor) {
+			return OPJ_FALSE;
 		}
-		/* destroy the decompressor */
-		opj_free(cinfo);
+		
+		return l_codec->m_codec_data.m_decompression.opj_get_decoded_tile(	l_codec->m_codec,
+																			l_stream,
+																			p_image,
+																			&(l_codec->m_event_mgr),
+																			tile_index);
 	}
+
+	return OPJ_FALSE;
+}
+
+OPJ_BOOL OPJ_CALLCONV opj_set_decoded_resolution_factor(opj_codec_t *p_codec, 
+														OPJ_UINT32 res_factor )
+{
+	opj_codec_private_t * l_codec = (opj_codec_private_t *) p_codec;
+
+	if ( !l_codec ){
+		fprintf(stderr, "[ERROR] Input parameters of the setup_decoder function are incorrect.\n");
+		return OPJ_FALSE;
+	}
+
+	l_codec->m_codec_data.m_decompression.opj_set_decoded_resolution_factor(l_codec->m_codec, 
+																			res_factor,
+																			&(l_codec->m_event_mgr) );
+	return OPJ_TRUE;
+}
+
+/* ---------------------------------------------------------------------- */
+/* COMPRESSION FUNCTIONS*/
+
+opj_codec_t* OPJ_CALLCONV opj_create_compress(OPJ_CODEC_FORMAT p_format)
+{
+	opj_codec_private_t *l_codec = 00;
+
+	l_codec = (opj_codec_private_t*)opj_calloc(1, sizeof(opj_codec_private_t));
+	if (!l_codec) {
+		return 00;
+	}
+	memset(l_codec, 0, sizeof(opj_codec_private_t));
+	
+	l_codec->is_decompressor = 0;
+
+	switch(p_format) {
+		case OPJ_CODEC_J2K:
+			l_codec->m_codec_data.m_compression.opj_encode = (OPJ_BOOL (*) (void *,
+																			struct opj_stream_private *,
+																			struct opj_event_mgr * )) opj_j2k_encode;
+
+			l_codec->m_codec_data.m_compression.opj_end_compress = (OPJ_BOOL (*) (	void *,
+																					struct opj_stream_private *,
+																					struct opj_event_mgr *)) opj_j2k_end_compress;
+
+			l_codec->m_codec_data.m_compression.opj_start_compress = (OPJ_BOOL (*) (void *,
+																					struct opj_stream_private *,
+																					struct opj_image * ,
+																					struct opj_event_mgr *)) opj_j2k_start_compress;
+
+			l_codec->m_codec_data.m_compression.opj_write_tile = (OPJ_BOOL (*) (void *,
+																				OPJ_UINT32,
+																				OPJ_BYTE*,
+																				OPJ_UINT32,
+																				struct opj_stream_private *,
+																				struct opj_event_mgr *) ) opj_j2k_write_tile;
+
+			l_codec->m_codec_data.m_compression.opj_destroy = (void (*) (void *)) opj_j2k_destroy;
+
+			l_codec->m_codec_data.m_compression.opj_setup_encoder = (void (*) (	void *,
+																				opj_cparameters_t *,
+																				struct opj_image *,
+																				struct opj_event_mgr * )) opj_j2k_setup_encoder;
+
+			l_codec->m_codec = opj_j2k_create_compress();
+			if (! l_codec->m_codec) {
+				opj_free(l_codec);
+				return 00;
+			}
+
+			break;
+
+		case OPJ_CODEC_JP2:
+			/* get a JP2 decoder handle */
+			l_codec->m_codec_data.m_compression.opj_encode = (OPJ_BOOL (*) (void *,
+																			struct opj_stream_private *,
+																			struct opj_event_mgr * )) opj_jp2_encode;
+
+			l_codec->m_codec_data.m_compression.opj_end_compress = (OPJ_BOOL (*) (	void *,
+																					struct opj_stream_private *,
+																					struct opj_event_mgr *)) opj_jp2_end_compress;
+
+			l_codec->m_codec_data.m_compression.opj_start_compress = (OPJ_BOOL (*) (void *,
+																					struct opj_stream_private *,
+																					struct opj_image * ,
+																					struct opj_event_mgr *))  opj_jp2_start_compress;
+
+			l_codec->m_codec_data.m_compression.opj_write_tile = (OPJ_BOOL (*) (void *,
+																				OPJ_UINT32,
+																				OPJ_BYTE*,
+																				OPJ_UINT32,
+																				struct opj_stream_private *,
+																				struct opj_event_mgr *)) opj_jp2_write_tile;
+
+			l_codec->m_codec_data.m_compression.opj_destroy = (void (*) (void *)) opj_jp2_destroy;
+
+			l_codec->m_codec_data.m_compression.opj_setup_encoder = (void (*) (	void *,
+																				opj_cparameters_t *,
+																				struct opj_image *,
+																				struct opj_event_mgr * )) opj_jp2_setup_encoder;
+
+			l_codec->m_codec = opj_jp2_create(OPJ_FALSE);
+			if (! l_codec->m_codec) {
+				opj_free(l_codec);
+				return 00;
+			}
+
+			break;
+
+		case OPJ_CODEC_UNKNOWN:
+		case OPJ_CODEC_JPT:
+		default:
+			opj_free(l_codec);
+			return 00;
+	}
+
+	opj_set_default_event_handler(&(l_codec->m_event_mgr));
+	return (opj_codec_t*) l_codec;
 }
 
 void OPJ_CALLCONV opj_set_default_encoder_parameters(opj_cparameters_t *parameters) {
 	if(parameters) {
 		memset(parameters, 0, sizeof(opj_cparameters_t));
 		/* default coding parameters */
-		parameters->cp_cinema = OFF; 
+        parameters->cp_cinema = OPJ_OFF; /* DEPRECATED */
+        parameters->rsiz = OPJ_PROFILE_NONE;
 		parameters->max_comp_size = 0;
 		parameters->numresolution = 6;
-		parameters->cp_rsiz = STD_RSIZ;
+        parameters->cp_rsiz = OPJ_STD_RSIZ; /* DEPRECATED */
 		parameters->cblockw_init = 64;
 		parameters->cblockh_init = 64;
-		parameters->prog_order = LRCP;
+		parameters->prog_order = OPJ_LRCP;
 		parameters->roi_compno = -1;		/* no ROI */
 		parameters->subsampling_dx = 1;
 		parameters->subsampling_dy = 1;
@@ -246,7 +655,7 @@ void OPJ_CALLCONV opj_set_default_encoder_parameters(opj_cparameters_t *paramete
 		parameters->cod_format = -1;
 		parameters->tcp_rates[0] = 0;   
 		parameters->tcp_numlayers = 0;
-    parameters->cp_disto_alloc = 0;
+		parameters->cp_disto_alloc = 0;
 		parameters->cp_fixed_alloc = 0;
 		parameters->cp_fixed_quality = 0;
 		parameters->jpip_on = OPJ_FALSE;
@@ -285,59 +694,271 @@ void OPJ_CALLCONV opj_set_default_encoder_parameters(opj_cparameters_t *paramete
 	}
 }
 
-void OPJ_CALLCONV opj_setup_encoder(opj_cinfo_t *cinfo, opj_cparameters_t *parameters, opj_image_t *image) {
-	if(cinfo && parameters && image) {
-		switch(cinfo->codec_format) {
-			case CODEC_J2K:
-				j2k_setup_encoder((opj_j2k_t*)cinfo->j2k_handle, parameters, image);
-				break;
-			case CODEC_JP2:
-				jp2_setup_encoder((opj_jp2_t*)cinfo->jp2_handle, parameters, image);
-				break;
-			case CODEC_JPT:
-			case CODEC_UNKNOWN:
-			default:
-				break;
+OPJ_BOOL OPJ_CALLCONV opj_setup_encoder(opj_codec_t *p_codec, 
+										opj_cparameters_t *parameters, 
+										opj_image_t *p_image)
+{
+	if (p_codec && parameters && p_image) {
+		opj_codec_private_t * l_codec = (opj_codec_private_t *) p_codec;
+
+		if (! l_codec->is_decompressor) {
+			l_codec->m_codec_data.m_compression.opj_setup_encoder(	l_codec->m_codec,
+																	parameters,
+																	p_image,
+																	&(l_codec->m_event_mgr) );
+			return OPJ_TRUE;
+		}
+	}
+
+	return OPJ_FALSE;
+}
+
+OPJ_BOOL OPJ_CALLCONV opj_start_compress (	opj_codec_t *p_codec,
+											opj_image_t * p_image,
+											opj_stream_t *p_stream)
+{
+	if (p_codec && p_stream) {
+		opj_codec_private_t * l_codec = (opj_codec_private_t *) p_codec;
+		opj_stream_private_t * l_stream = (opj_stream_private_t *) p_stream;
+
+		if (! l_codec->is_decompressor) {
+			return l_codec->m_codec_data.m_compression.opj_start_compress(	l_codec->m_codec,
+																			l_stream,
+																			p_image,
+																			&(l_codec->m_event_mgr));
+		}
+	}
+
+	return OPJ_FALSE;
+}
+
+OPJ_BOOL OPJ_CALLCONV opj_encode(opj_codec_t *p_info, opj_stream_t *p_stream)
+{
+	if (p_info && p_stream) {
+		opj_codec_private_t * l_codec = (opj_codec_private_t *) p_info;
+		opj_stream_private_t * l_stream = (opj_stream_private_t *) p_stream;
+
+		if (! l_codec->is_decompressor) {
+			return l_codec->m_codec_data.m_compression.opj_encode(	l_codec->m_codec,
+															l_stream,
+															&(l_codec->m_event_mgr));
+		}
+	}
+
+	return OPJ_FALSE;
+
+}
+
+OPJ_BOOL OPJ_CALLCONV opj_end_compress (opj_codec_t *p_codec,
+										opj_stream_t *p_stream)
+{
+	if (p_codec && p_stream) {
+		opj_codec_private_t * l_codec = (opj_codec_private_t *) p_codec;
+		opj_stream_private_t * l_stream = (opj_stream_private_t *) p_stream;
+
+		if (! l_codec->is_decompressor) {
+			return l_codec->m_codec_data.m_compression.opj_end_compress(l_codec->m_codec,
+																		l_stream,
+																		&(l_codec->m_event_mgr));
+		}
+	}
+	return OPJ_FALSE;
+
+}
+
+OPJ_BOOL OPJ_CALLCONV opj_end_decompress (	opj_codec_t *p_codec,
+											opj_stream_t *p_stream)
+{
+	if (p_codec && p_stream) {
+		opj_codec_private_t * l_codec = (opj_codec_private_t *) p_codec;
+		opj_stream_private_t * l_stream = (opj_stream_private_t *) p_stream;
+
+		if (! l_codec->is_decompressor) {
+			return OPJ_FALSE;
 		}
+		
+		return l_codec->m_codec_data.m_decompression.opj_end_decompress(l_codec->m_codec,
+																		l_stream,
+																		&(l_codec->m_event_mgr) );
 	}
+
+	return OPJ_FALSE;
 }
 
-opj_bool OPJ_CALLCONV opj_encode(opj_cinfo_t *cinfo, opj_cio_t *cio, opj_image_t *image, char *index) {
-	if (index != NULL)
-		opj_event_msg((opj_common_ptr)cinfo, EVT_WARNING, "Set index to NULL when calling the opj_encode function.\n"
-		"To extract the index, use the opj_encode_with_info() function.\n"
-		"No index will be generated during this encoding\n");
-	return opj_encode_with_info(cinfo, cio, image, NULL);
+OPJ_BOOL OPJ_CALLCONV opj_set_MCT(opj_cparameters_t *parameters,
+                                  OPJ_FLOAT32 * pEncodingMatrix,
+                                  OPJ_INT32 * p_dc_shift,OPJ_UINT32 pNbComp)
+{
+	OPJ_UINT32 l_matrix_size = pNbComp * pNbComp * (OPJ_UINT32)sizeof(OPJ_FLOAT32);
+	OPJ_UINT32 l_dc_shift_size = pNbComp * (OPJ_UINT32)sizeof(OPJ_INT32);
+	OPJ_UINT32 l_mct_total_size = l_matrix_size + l_dc_shift_size;
+
+	/* add MCT capability */
+    if (OPJ_IS_PART2(parameters->rsiz)) {
+        parameters->rsiz |= OPJ_EXTENSION_MCT;
+    } else {
+        parameters->rsiz = ((OPJ_PROFILE_PART2) | (OPJ_EXTENSION_MCT));
+    }
+	parameters->irreversible = 1;
+
+	/* use array based MCT */
+	parameters->tcp_mct = 2;
+	parameters->mct_data = opj_malloc(l_mct_total_size);
+	if (! parameters->mct_data) {
+		return OPJ_FALSE;
+	}
+
+	memcpy(parameters->mct_data,pEncodingMatrix,l_matrix_size);
+	memcpy(((OPJ_BYTE *) parameters->mct_data) +  l_matrix_size,p_dc_shift,l_dc_shift_size);
+
+	return OPJ_TRUE;
 }
 
-opj_bool OPJ_CALLCONV opj_encode_with_info(opj_cinfo_t *cinfo, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info) {
-	if(cinfo && cio && image) {
-		switch(cinfo->codec_format) {
-			case CODEC_J2K:
-				return j2k_encode((opj_j2k_t*)cinfo->j2k_handle, cio, image, cstr_info);
-			case CODEC_JP2:
-				return opj_jp2_encode((opj_jp2_t*)cinfo->jp2_handle, cio, image, cstr_info);	    
-			case CODEC_JPT:
-			case CODEC_UNKNOWN:
-			default:
-				break;
+OPJ_BOOL OPJ_CALLCONV opj_write_tile (	opj_codec_t *p_codec,
+										OPJ_UINT32 p_tile_index,
+										OPJ_BYTE * p_data,
+										OPJ_UINT32 p_data_size,
+										opj_stream_t *p_stream )
+{
+	if (p_codec && p_stream && p_data) {
+		opj_codec_private_t * l_codec = (opj_codec_private_t *) p_codec;
+		opj_stream_private_t * l_stream = (opj_stream_private_t *) p_stream;
+
+		if (l_codec->is_decompressor) {
+			return OPJ_FALSE;
 		}
+
+		return l_codec->m_codec_data.m_compression.opj_write_tile(	l_codec->m_codec,
+																	p_tile_index,
+																	p_data,
+																	p_data_size,
+																	l_stream,
+																	&(l_codec->m_event_mgr) );
 	}
+
 	return OPJ_FALSE;
 }
 
-void OPJ_CALLCONV opj_destroy_cstr_info(opj_codestream_info_t *cstr_info) {
+/* ---------------------------------------------------------------------- */
+
+void OPJ_CALLCONV opj_destroy_codec(opj_codec_t *p_codec)
+{
+	if (p_codec) {
+		opj_codec_private_t * l_codec = (opj_codec_private_t *) p_codec;
+
+		if (l_codec->is_decompressor) {
+			l_codec->m_codec_data.m_decompression.opj_destroy(l_codec->m_codec);
+		}
+		else {
+			l_codec->m_codec_data.m_compression.opj_destroy(l_codec->m_codec);
+		}
+
+		l_codec->m_codec = 00;
+		opj_free(l_codec);
+	}
+}
+
+/* ---------------------------------------------------------------------- */
+
+void OPJ_CALLCONV opj_dump_codec(	opj_codec_t *p_codec,
+									OPJ_INT32 info_flag,
+									FILE* output_stream)
+{
+	if (p_codec) {
+		opj_codec_private_t* l_codec = (opj_codec_private_t*) p_codec;
+
+		l_codec->opj_dump_codec(l_codec->m_codec, info_flag, output_stream);
+		return;
+	}
+
+	fprintf(stderr, "[ERROR] Input parameter of the dump_codec function are incorrect.\n");
+	return;
+}
+
+opj_codestream_info_v2_t* OPJ_CALLCONV opj_get_cstr_info(opj_codec_t *p_codec)
+{
+	if (p_codec) {
+		opj_codec_private_t* l_codec = (opj_codec_private_t*) p_codec;
+
+		return l_codec->opj_get_codec_info(l_codec->m_codec);
+	}
+
+	return NULL;
+}
+
+void OPJ_CALLCONV opj_destroy_cstr_info(opj_codestream_info_v2_t **cstr_info) {
 	if (cstr_info) {
-		int tileno;
-		for (tileno = 0; tileno < cstr_info->tw * cstr_info->th; tileno++) {
-			opj_tile_info_t *tile_info = &cstr_info->tile[tileno];
-			opj_free(tile_info->thresh);
-			opj_free(tile_info->packet);
-			opj_free(tile_info->tp);
-			opj_free(tile_info->marker);
+
+		if ((*cstr_info)->m_default_tile_info.tccp_info){
+			opj_free((*cstr_info)->m_default_tile_info.tccp_info);
+		}
+
+		if ((*cstr_info)->tile_info){
+			/* FIXME not used for the moment*/
 		}
-		opj_free(cstr_info->tile);
-		opj_free(cstr_info->marker);
-		opj_free(cstr_info->numdecompos);
+
+		opj_free((*cstr_info));
+		(*cstr_info) = NULL;
+	}
+}
+
+opj_codestream_index_t * OPJ_CALLCONV opj_get_cstr_index(opj_codec_t *p_codec)
+{
+	if (p_codec) {
+		opj_codec_private_t* l_codec = (opj_codec_private_t*) p_codec;
+
+		return l_codec->opj_get_codec_index(l_codec->m_codec);
+	}
+
+	return NULL;
+}
+
+void OPJ_CALLCONV opj_destroy_cstr_index(opj_codestream_index_t **p_cstr_index)
+{
+	if (*p_cstr_index){
+		j2k_destroy_cstr_index(*p_cstr_index);
+		(*p_cstr_index) = NULL;
 	}
 }
+
+opj_stream_t* OPJ_CALLCONV opj_stream_create_default_file_stream (const char *fname, OPJ_BOOL p_is_read_stream)
+{
+    return opj_stream_create_file_stream(fname, OPJ_J2K_STREAM_CHUNK_SIZE, p_is_read_stream);
+}
+
+opj_stream_t* OPJ_CALLCONV opj_stream_create_file_stream (
+        const char *fname, 
+		OPJ_SIZE_T p_size, 
+        OPJ_BOOL p_is_read_stream)
+{
+    opj_stream_t* l_stream = 00;
+    FILE *p_file;
+    const char *mode;
+
+    if (! fname) {
+        return NULL;
+    }
+    
+    if(p_is_read_stream) mode = "rb"; else mode = "wb";
+
+    p_file = fopen(fname, mode);
+
+    if (! p_file) {
+	    return NULL;
+    }
+
+    l_stream = opj_stream_create(p_size,p_is_read_stream);
+    if (! l_stream) {
+        fclose(p_file);
+        return NULL;
+    }
+
+    opj_stream_set_user_data(l_stream, p_file, (opj_stream_free_user_data_fn) fclose);
+    opj_stream_set_user_data_length(l_stream, opj_get_data_length_from_file(p_file));
+    opj_stream_set_read_function(l_stream, (opj_stream_read_fn) opj_read_from_file);
+    opj_stream_set_write_function(l_stream, (opj_stream_write_fn) opj_write_from_file);
+    opj_stream_set_skip_function(l_stream, (opj_stream_skip_fn) opj_skip_from_file);
+    opj_stream_set_seek_function(l_stream, (opj_stream_seek_fn) opj_seek_from_file);
+
+    return l_stream;
+}
diff --git a/extern/libopenjpeg/openjpeg.h b/extern/libopenjpeg/openjpeg.h
index 59147c8..988db72 100644
--- a/extern/libopenjpeg/openjpeg.h
+++ b/extern/libopenjpeg/openjpeg.h
@@ -1,12 +1,21 @@
  /*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2001-2003, David Janssens
  * Copyright (c) 2002-2003, Yannick Verschueren
- * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * Copyright (c) 2003-2014, Antonin Descampe
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
  * Copyright (c) 2006-2007, Parvatha Elangovan
+ * Copyright (c) 2008, Jerome Fimes, Communications & Systemes <jerome.fimes@c-s.fr>
  * Copyright (c) 2010-2011, Kaori Hagihara
+ * Copyright (c) 2011-2012, Centre National d'Etudes Spatiales (CNES), France 
+ * Copyright (c) 2012, CS Systemes d'Information, France
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -40,8 +49,42 @@
 ==========================================================
 */
 
+/*
+The inline keyword is supported by C99 but not by C90. 
+Most compilers implement their own version of this keyword ... 
+*/
+#ifndef INLINE
+	#if defined(_MSC_VER)
+		#define INLINE __forceinline
+	#elif defined(__GNUC__)
+		#define INLINE __inline__
+	#elif defined(__MWERKS__)
+		#define INLINE inline
+	#else 
+		/* add other compilers here ... */
+		#define INLINE 
+	#endif /* defined(<Compiler>) */
+#endif /* INLINE */
+
+/* deprecated attribute */
+#ifdef __GNUC__
+	#define OPJ_DEPRECATED(func) func __attribute__ ((deprecated))
+#elif defined(_MSC_VER)
+	#define OPJ_DEPRECATED(func) __declspec(deprecated) func
+#else
+	#pragma message("WARNING: You need to implement DEPRECATED for this compiler")
+	#define OPJ_DEPRECATED(func) func
+#endif
+
 #if defined(OPJ_STATIC) || !defined(_WIN32)
+/* http://gcc.gnu.org/wiki/Visibility */
+#if __GNUC__ >= 4
+#define OPJ_API    __attribute__ ((visibility ("default")))
+#define OPJ_LOCAL  __attribute__ ((visibility ("hidden")))
+#else
 #define OPJ_API
+#define OPJ_LOCAL
+#endif
 #define OPJ_CALLCONV
 #else
 #define OPJ_CALLCONV __stdcall
@@ -60,12 +103,34 @@ defined with this macro as being exported.
 #endif /* OPJ_EXPORTS */
 #endif /* !OPJ_STATIC || !_WIN32 */
 
-typedef int opj_bool;
+typedef int OPJ_BOOL;
 #define OPJ_TRUE 1
 #define OPJ_FALSE 0
 
+typedef char          OPJ_CHAR;
+typedef float         OPJ_FLOAT32;
+typedef double        OPJ_FLOAT64;
+typedef unsigned char OPJ_BYTE;
+
+#include "opj_stdint.h"
+
+typedef int8_t   OPJ_INT8;
+typedef uint8_t  OPJ_UINT8;
+typedef int16_t  OPJ_INT16;
+typedef uint16_t OPJ_UINT16;
+typedef int32_t  OPJ_INT32;
+typedef uint32_t OPJ_UINT32;
+typedef int64_t  OPJ_INT64;
+typedef uint64_t OPJ_UINT64;
+
+typedef int64_t  OPJ_OFF_T; /* 64-bit file offset type */
+
+#include <stdio.h>
+typedef size_t   OPJ_SIZE_T;
+
 /* Avoid compile-time warning because parameter is not used */
 #define OPJ_ARG_NOT_USED(x) (void)(x)
+
 /* 
 ==========================================================
    Useful constant definitions
@@ -74,10 +139,16 @@ typedef int opj_bool;
 
 #define OPJ_PATH_LEN 4096 /**< Maximum allowed size for filenames */
 
-#define J2K_MAXRLVLS 33					/**< Number of maximum resolution level authorized */
-#define J2K_MAXBANDS (3*J2K_MAXRLVLS-2)	/**< Number of maximum sub-band linked to number of resolution level */
+#define OPJ_J2K_MAXRLVLS 33					/**< Number of maximum resolution level authorized */
+#define OPJ_J2K_MAXBANDS (3*OPJ_J2K_MAXRLVLS-2)	/**< Number of maximum sub-band linked to number of resolution level */
 
-/* UniPG>> */
+#define OPJ_J2K_DEFAULT_NB_SEGS				10
+#define OPJ_J2K_STREAM_CHUNK_SIZE			0x100000 /** 1 mega by default */
+#define OPJ_J2K_DEFAULT_HEADER_SIZE			1000
+#define OPJ_J2K_MCC_DEFAULT_NB_RECORDS		10
+#define OPJ_J2K_MCT_DEFAULT_NB_RECORDS		10
+
+/* UniPG>> */ /* NOT YET USED IN THE V2 VERSION OF OPENJPEG */
 #define JPWL_MAX_NO_TILESPECS	16 /**< Maximum number of tile parts expected by JPWL: increase at your will */
 #define JPWL_MAX_NO_PACKSPECS	16 /**< Maximum number of packet parts expected by JPWL: increase at your will */
 #define JPWL_MAX_NO_MARKERS	512 /**< Maximum number of JPWL markers: increase at your will */
@@ -88,75 +159,141 @@ typedef int opj_bool;
 #define JPWL_MAXIMUM_EPB_ROOM 65450 /**< Expect this maximum number of bytes for composition of EPBs */
 /* <<UniPG */
 
+/**
+ * EXPERIMENTAL FOR THE MOMENT
+ * Supported options about file information used only in j2k_dump
+*/
+#define OPJ_IMG_INFO		1	/**< Basic image information provided to the user */
+#define OPJ_J2K_MH_INFO		2	/**< Codestream information based only on the main header */
+#define OPJ_J2K_TH_INFO		4	/**< Tile information based on the current tile header */
+#define OPJ_J2K_TCH_INFO	8	/**< Tile/Component information of all tiles */
+#define OPJ_J2K_MH_IND		16	/**< Codestream index based only on the main header */
+#define OPJ_J2K_TH_IND		32	/**< Tile index based on the current tile */
+/*FIXME #define OPJ_J2K_CSTR_IND	48*/	/**<  */
+#define OPJ_JP2_INFO		128	/**< JP2 file information */
+#define OPJ_JP2_IND			256	/**< JP2 file index */
+
+/**
+ * JPEG 2000 Profiles, see Table A.10 from 15444-1 (updated in various AMD)
+ * These values help chosing the RSIZ value for the J2K codestream.
+ * The RSIZ value triggers various encoding options, as detailed in Table A.10.
+ * If OPJ_PROFILE_PART2 is chosen, it has to be combined with one or more extensions
+ * described hereunder.
+ *   Example: rsiz = OPJ_PROFILE_PART2 | OPJ_EXTENSION_MCT;
+ * For broadcast profiles, the OPJ_PROFILE value has to be combined with the targeted
+ * mainlevel (3-0 LSB, value between 0 and 11):
+ *   Example: rsiz = OPJ_PROFILE_BC_MULTI | 0x0005; (here mainlevel 5)
+ * For IMF profiles, the OPJ_PROFILE value has to be combined with the targeted mainlevel
+ * (3-0 LSB, value between 0 and 11) and sublevel (7-4 LSB, value between 0 and 9):
+ *   Example: rsiz = OPJ_PROFILE_IMF_2K | 0x0040 | 0x0005; (here main 5 and sublevel 4)
+ * */
+#define OPJ_PROFILE_NONE        0x0000 /** no profile, conform to 15444-1 */
+#define OPJ_PROFILE_0           0x0001 /** Profile 0 as described in 15444-1,Table A.45 */
+#define OPJ_PROFILE_1           0x0002 /** Profile 1 as described in 15444-1,Table A.45 */
+#define OPJ_PROFILE_PART2       0x8000 /** At least 1 extension defined in 15444-2 (Part-2) */
+#define OPJ_PROFILE_CINEMA_2K   0x0003 /** 2K cinema profile defined in 15444-1 AMD1 */
+#define OPJ_PROFILE_CINEMA_4K   0x0004 /** 4K cinema profile defined in 15444-1 AMD1 */
+#define OPJ_PROFILE_CINEMA_S2K  0x0005 /** Scalable 2K cinema profile defined in 15444-1 AMD2 */
+#define OPJ_PROFILE_CINEMA_S4K  0x0006 /** Scalable 4K cinema profile defined in 15444-1 AMD2 */
+#define OPJ_PROFILE_CINEMA_LTS  0x0007 /** Long term storage cinema profile defined in 15444-1 AMD2 */
+#define OPJ_PROFILE_BC_SINGLE   0x0100 /** Single Tile Broadcast profile defined in 15444-1 AMD3 */
+#define OPJ_PROFILE_BC_MULTI    0x0200 /** Multi Tile Broadcast profile defined in 15444-1 AMD3 */
+#define OPJ_PROFILE_BC_MULTI_R  0x0300 /** Multi Tile Reversible Broadcast profile defined in 15444-1 AMD3 */
+#define OPJ_PROFILE_IMF_2K      0x0400 /** 2K Single Tile Lossy IMF profile defined in 15444-1 AMD 8 */
+#define OPJ_PROFILE_IMF_4K      0x0401 /** 4K Single Tile Lossy IMF profile defined in 15444-1 AMD 8 */
+#define OPJ_PROFILE_IMF_8K      0x0402 /** 8K Single Tile Lossy IMF profile defined in 15444-1 AMD 8 */
+#define OPJ_PROFILE_IMF_2K_R    0x0403 /** 2K Single/Multi Tile Reversible IMF profile defined in 15444-1 AMD 8 */
+#define OPJ_PROFILE_IMF_4K_R    0x0800 /** 4K Single/Multi Tile Reversible IMF profile defined in 15444-1 AMD 8 */
+#define OPJ_PROFILE_IMF_8K_R    0x0801  /** 8K Single/Multi Tile Reversible IMF profile defined in 15444-1 AMD 8 */
+
+/**
+ * JPEG 2000 Part-2 extensions
+ * */
+#define OPJ_EXTENSION_NONE      0x0000 /** No Part-2 extension */
+#define OPJ_EXTENSION_MCT       0x0100  /** Custom MCT support */
+
+/**
+ * JPEG 2000 profile macros
+ * */
+#define OPJ_IS_CINEMA(v)     (((v) >= OPJ_PROFILE_CINEMA_2K)&&((v) <= OPJ_PROFILE_CINEMA_S4K))
+#define OPJ_IS_STORAGE(v)    ((v) == OPJ_PROFILE_CINEMA_LTS)
+#define OPJ_IS_BROADCAST(v)  (((v) >= OPJ_PROFILE_BC_SINGLE)&&((v) <= ((OPJ_PROFILE_BC_MULTI_R) | (0x000b))))
+#define OPJ_IS_IMF(v)        (((v) >= OPJ_PROFILE_IMF_2K)&&((v) <= ((OPJ_PROFILE_IMF_8K_R) | (0x009b))))
+#define OPJ_IS_PART2(v)      ((v) & OPJ_PROFILE_PART2)
+
+/**
+ * JPEG 2000 codestream and component size limits in cinema profiles
+ * */
+#define OPJ_CINEMA_24_CS     1302083   	/** Maximum codestream length for 24fps */
+#define OPJ_CINEMA_48_CS     651041     /** Maximum codestream length for 48fps */
+#define OPJ_CINEMA_24_COMP   1041666    /** Maximum size per color component for 2K & 4K @ 24fps */
+#define OPJ_CINEMA_48_COMP   520833		/** Maximum size per color component for 2K @ 48fps */
+
 /* 
 ==========================================================
    enum definitions
 ==========================================================
 */
-/** 
-Rsiz Capabilities
-*/
+
+/**
+ * DEPRECATED: use RSIZ, OPJ_PROFILE_* and OPJ_EXTENSION_* instead
+ * Rsiz Capabilities
+ * */
 typedef enum RSIZ_CAPABILITIES {
-	STD_RSIZ = 0,		/** Standard JPEG2000 profile*/
-	CINEMA2K = 3,		/** Profile name for a 2K image*/
-	CINEMA4K = 4		/** Profile name for a 4K image*/
+    OPJ_STD_RSIZ = 0,		/** Standard JPEG2000 profile*/
+    OPJ_CINEMA2K = 3,		/** Profile name for a 2K image*/
+    OPJ_CINEMA4K = 4,		/** Profile name for a 4K image*/
+    OPJ_MCT = 0x8100
 } OPJ_RSIZ_CAPABILITIES;
 
-/** 
-Digital cinema operation mode 
-*/
+/**
+ * DEPRECATED: use RSIZ, OPJ_PROFILE_* and OPJ_EXTENSION_* instead
+ * Digital cinema operation mode
+ * */
 typedef enum CINEMA_MODE {
-	OFF = 0,					/** Not Digital Cinema*/
-	CINEMA2K_24 = 1,	/** 2K Digital Cinema at 24 fps*/
-	CINEMA2K_48 = 2,	/** 2K Digital Cinema at 48 fps*/
-	CINEMA4K_24 = 3		/** 4K Digital Cinema at 24 fps*/
+    OPJ_OFF = 0,			/** Not Digital Cinema*/
+    OPJ_CINEMA2K_24 = 1,	/** 2K Digital Cinema at 24 fps*/
+    OPJ_CINEMA2K_48 = 2,	/** 2K Digital Cinema at 48 fps*/
+    OPJ_CINEMA4K_24 = 3		/** 4K Digital Cinema at 24 fps*/
 }OPJ_CINEMA_MODE;
 
 /** 
-Progression order 
-*/
+ * Progression order
+ * */
 typedef enum PROG_ORDER {
-	PROG_UNKNOWN = -1,	/**< place-holder */
-	LRCP = 0,		/**< layer-resolution-component-precinct order */
-	RLCP = 1,		/**< resolution-layer-component-precinct order */
-	RPCL = 2,		/**< resolution-precinct-component-layer order */
-	PCRL = 3,		/**< precinct-component-resolution-layer order */
-	CPRL = 4		/**< component-precinct-resolution-layer order */
+	OPJ_PROG_UNKNOWN = -1,	/**< place-holder */
+	OPJ_LRCP = 0,			/**< layer-resolution-component-precinct order */
+	OPJ_RLCP = 1,			/**< resolution-layer-component-precinct order */
+	OPJ_RPCL = 2,			/**< resolution-precinct-component-layer order */
+	OPJ_PCRL = 3,			/**< precinct-component-resolution-layer order */
+	OPJ_CPRL = 4			/**< component-precinct-resolution-layer order */
 } OPJ_PROG_ORDER;
 
 /**
-Supported image color spaces
+ * Supported image color spaces
 */
 typedef enum COLOR_SPACE {
-	CLRSPC_UNKNOWN = -1,	/**< not supported by the library */
-	CLRSPC_UNSPECIFIED = 0, /**< not specified in the codestream */ 
-	CLRSPC_SRGB = 1,		/**< sRGB */
-	CLRSPC_GRAY = 2,		/**< grayscale */
-	CLRSPC_SYCC = 3			/**< YUV */
+    OPJ_CLRSPC_UNKNOWN = -1,	/**< not supported by the library */
+    OPJ_CLRSPC_UNSPECIFIED = 0,	/**< not specified in the codestream */
+    OPJ_CLRSPC_SRGB = 1,		/**< sRGB */
+    OPJ_CLRSPC_GRAY = 2,		/**< grayscale */
+    OPJ_CLRSPC_SYCC = 3,		/**< YUV */
+    OPJ_CLRSPC_EYCC = 4,        /**< e-YCC */
+    OPJ_CLRSPC_CMYK = 5         /**< CMYK */
 } OPJ_COLOR_SPACE;
 
-#define ENUMCS_SRGB 16
-#define ENUMCS_GRAY 17
-#define ENUMCS_SYCC 18
-
 /**
-Supported codec
+ * Supported codec
 */
 typedef enum CODEC_FORMAT {
-	CODEC_UNKNOWN = -1,	/**< place-holder */
-	CODEC_J2K  = 0,		/**< JPEG-2000 codestream : read/write */
-	CODEC_JPT  = 1,		/**< JPT-stream (JPEG 2000, JPIP) : read only */
-	CODEC_JP2  = 2 		/**< JPEG-2000 file format : read/write */
+	OPJ_CODEC_UNKNOWN = -1,	/**< place-holder */
+	OPJ_CODEC_J2K  = 0,		/**< JPEG-2000 codestream : read/write */
+	OPJ_CODEC_JPT  = 1,		/**< JPT-stream (JPEG 2000, JPIP) : read only */
+    OPJ_CODEC_JP2  = 2,		/**< JP2 file format : read/write */
+    OPJ_CODEC_JPP  = 3,		/**< JPP-stream (JPEG 2000, JPIP) : to be coded */
+    OPJ_CODEC_JPX  = 4		/**< JPX file format (JPEG 2000 Part-2) : to be coded */
 } OPJ_CODEC_FORMAT;
 
-/** 
-Limit decoding to certain portions of the codestream. 
-*/
-typedef enum LIMIT_DECODING {
-	NO_LIMITATION = 0,				  /**< No limitation for the decoding. The entire codestream will de decoded */
-	LIMIT_TO_MAIN_HEADER = 1,		/**< The decoding is limited to the Main Header */
-	DECODE_ALL_BUT_PACKETS = 2	/**< Decode everything except the JPEG 2000 packets */
-} OPJ_LIMIT_DECODING;
 
 /* 
 ==========================================================
@@ -165,31 +302,12 @@ typedef enum LIMIT_DECODING {
 */
 
 /**
-Callback function prototype for events
-@param msg Event message
-@param client_data 
-*/
+ * Callback function prototype for events
+ * @param msg               Event message
+ * @param client_data       Client object where will be return the event message 
+ * */
 typedef void (*opj_msg_callback) (const char *msg, void *client_data);
 
-/**
-Message handler object
-used for 
-<ul>
-<li>Error messages
-<li>Warning messages
-<li>Debugging messages
-</ul>
-*/
-typedef struct opj_event_mgr {
-	/** Error message callback if available, NULL otherwise */
-	opj_msg_callback error_handler;
-	/** Warning message callback if available, NULL otherwise */
-	opj_msg_callback warning_handler;
-	/** Debug message callback if available, NULL otherwise */
-	opj_msg_callback info_handler;
-} opj_event_mgr_t;
-
-
 /* 
 ==========================================================
    codec typedef definitions
@@ -197,39 +315,40 @@ typedef struct opj_event_mgr {
 */
 
 /**
-Progression order changes
-*/
+ * Progression order changes
+ * 
+ */
 typedef struct opj_poc {
 	/** Resolution num start, Component num start, given by POC */
-	int resno0, compno0;
+	OPJ_UINT32 resno0, compno0;
 	/** Layer num end,Resolution num end, Component num end, given by POC */
-	int layno1, resno1, compno1;
+	OPJ_UINT32 layno1, resno1, compno1;
 	/** Layer num start,Precinct num start, Precinct num end */
-	int layno0, precno0, precno1;
+	OPJ_UINT32 layno0, precno0, precno1;
 	/** Progression order enum*/
 	OPJ_PROG_ORDER prg1,prg;
 	/** Progression order string*/
-	char progorder[5];
+	OPJ_CHAR progorder[5];
 	/** Tile number */
-	int tile;
+	OPJ_UINT32 tile;
 	/** Start and end values for Tile width and height*/
-	int tx0,tx1,ty0,ty1;
+	OPJ_INT32 tx0,tx1,ty0,ty1;
 	/** Start value, initialised in pi_initialise_encode*/
-	int layS, resS, compS, prcS;
+	OPJ_UINT32 layS, resS, compS, prcS;
 	/** End value, initialised in pi_initialise_encode */
-	int layE, resE, compE, prcE;
+	OPJ_UINT32 layE, resE, compE, prcE;
 	/** Start and end values of Tile width and height, initialised in pi_initialise_encode*/
-	int txS,txE,tyS,tyE,dx,dy;
+	OPJ_UINT32 txS,txE,tyS,tyE,dx,dy;
 	/** Temporary values for Tile parts, initialised in pi_create_encode */
-	int lay_t, res_t, comp_t, prc_t,tx0_t,ty0_t;
+	OPJ_UINT32 lay_t, res_t, comp_t, prc_t,tx0_t,ty0_t;
 } opj_poc_t;
 
 /**
-Compression parameters
-*/
+ * Compression parameters
+ * */
 typedef struct opj_cparameters {
 	/** size of tile: tile_size_on = false (not in argument) or = true (in argument) */
-	opj_bool tile_size_on;
+	OPJ_BOOL tile_size_on;
 	/** XTOsiz */
 	int cp_tx0;
 	/** YTOsiz */
@@ -250,15 +369,15 @@ typedef struct opj_cparameters {
 	char *cp_comment;
 	/** csty : coding style */
 	int csty;
-	/** progression order (default LRCP) */
+	/** progression order (default OPJ_LRCP) */
 	OPJ_PROG_ORDER prog_order;
 	/** progression order changes */
 	opj_poc_t POC[32];
 	/** number of progression order changes (POC), default to 0 */
-	int numpocs;
+	OPJ_UINT32 numpocs;
 	/** number of layers */
 	int tcp_numlayers;
-	/** rates of layers */
+    /** rates of layers - might be subsequently limited by the max_cs_size field */
 	float tcp_rates[100];
 	/** different psnr for successive layers */
 	float tcp_distoratio[100];
@@ -279,9 +398,9 @@ typedef struct opj_cparameters {
 	/* number of precinct size specifications */
 	int res_spec;
 	/** initial precinct width */
-	int prcw_init[J2K_MAXRLVLS];
+	int prcw_init[OPJ_J2K_MAXRLVLS];
 	/** initial precinct height */
-	int prch_init[J2K_MAXRLVLS];
+	int prch_init[OPJ_J2K_MAXRLVLS];
 
 	/**@name command line encoder parameters (not used inside the library) */
 	/*@{*/
@@ -307,11 +426,11 @@ typedef struct opj_cparameters {
 	int cod_format;
 	/*@}*/
 
-/* UniPG>> */
+/* UniPG>> */ /* NOT YET USED IN THE V2 VERSION OF OPENJPEG */
 	/**@name JPWL encoding parameters */
 	/*@{*/
 	/** enables writing of EPC in MH, thus activating JPWL */
-	opj_bool jpwl_epc_on;
+	OPJ_BOOL jpwl_epc_on;
 	/** error protection method for MH (0,1,16,32,37-128) */
 	int jpwl_hprot_MH;
 	/** tile number of header protection specification (>=0) */
@@ -339,12 +458,21 @@ typedef struct opj_cparameters {
 	/*@}*/
 /* <<UniPG */
 
-	/** Digital Cinema compliance 0-not compliant, 1-compliant*/
-	OPJ_CINEMA_MODE cp_cinema;
-	/** Maximum rate for each component. If == 0, component size limitation is not considered */
+    /**
+     * DEPRECATED: use RSIZ, OPJ_PROFILE_* and MAX_COMP_SIZE instead
+     * Digital Cinema compliance 0-not compliant, 1-compliant
+     * */
+    OPJ_CINEMA_MODE cp_cinema;
+    /**
+     * Maximum size (in bytes) for each component.
+     * If == 0, component size limitation is not considered
+     * */
 	int max_comp_size;
-	/** Profile name*/
-	OPJ_RSIZ_CAPABILITIES cp_rsiz;
+    /**
+     * DEPRECATED: use RSIZ, OPJ_PROFILE_* and OPJ_EXTENSION_* instead
+     * Profile name
+     * */
+    OPJ_RSIZ_CAPABILITIES cp_rsiz;
 	/** Tile part generation*/
 	char tp_on;
 	/** Flag for Tile part generation*/
@@ -352,14 +480,27 @@ typedef struct opj_cparameters {
 	/** MCT (multiple component transform) */
 	char tcp_mct;
 	/** Enable JPIP indexing*/
-	opj_bool jpip_on;
-} opj_cparameters_t;
+	OPJ_BOOL jpip_on;
+	/** Naive implementation of MCT restricted to a single reversible array based 
+        encoding without offset concerning all the components. */
+	void * mct_data;
+    /**
+     * Maximum size (in bytes) for the whole codestream.
+     * If == 0, codestream size limitation is not considered
+     * If it does not comply with tcp_rates, max_cs_size prevails
+     * and a warning is issued.
+     * */
+    int max_cs_size;
+    /** RSIZ value
+        To be used to combine OPJ_PROFILE_*, OPJ_EXTENSION_* and (sub)levels values. */
+    OPJ_UINT16 rsiz;
+} opj_cparameters_t;  
 
 #define OPJ_DPARAMETERS_IGNORE_PCLR_CMAP_CDEF_FLAG	0x0001
 
 /**
-Decompression parameters
-*/
+ * Decompression parameters
+ * */
 typedef struct opj_dparameters {
 	/** 
 	Set the number of highest resolution levels to be discarded. 
@@ -368,16 +509,16 @@ typedef struct opj_dparameters {
 	if != 0, then original dimension divided by 2^(reduce); 
 	if == 0 or not used, image is decoded to the full resolution 
 	*/
-	int cp_reduce;
+	OPJ_UINT32 cp_reduce;
 	/** 
 	Set the maximum number of quality layers to decode. 
 	If there are less quality layers than the specified number, all the quality layers are decoded.
 	if != 0, then only the first "layer" layers are decoded; 
 	if == 0 or not used, all the quality layers are decoded 
 	*/
-	int cp_layer;
+	OPJ_UINT32 cp_layer;
 
-	/**@name command line encoder parameters (not used inside the library) */
+	/**@name command line decoder parameters (not used inside the library) */
 	/*@{*/
 	/** input file name */
 	char infile[OPJ_PATH_LEN];
@@ -387,13 +528,30 @@ typedef struct opj_dparameters {
 	int decod_format;
 	/** output file format 0: PGX, 1: PxM, 2: BMP */
 	int cod_format;
+
+	/** Decoding area left boundary */
+	OPJ_UINT32 DA_x0;
+	/** Decoding area right boundary */
+	OPJ_UINT32 DA_x1;
+	/** Decoding area up boundary */
+	OPJ_UINT32 DA_y0;
+	/** Decoding area bottom boundary */
+	OPJ_UINT32 DA_y1;
+	/** Verbose mode */
+	OPJ_BOOL m_verbose;
+
+	/** tile number ot the decoded tile*/
+	OPJ_UINT32 tile_index;
+	/** Nb of tile to decode */
+	OPJ_UINT32 nb_tile_to_decode;
+
 	/*@}*/
 
-/* UniPG>> */
+/* UniPG>> */ /* NOT YET USED IN THE V2 VERSION OF OPENJPEG */
 	/**@name JPWL decoding parameters */
 	/*@{*/
 	/** activates the JPWL correction capabilities */
-	opj_bool jpwl_correct;
+	OPJ_BOOL jpwl_correct;
 	/** expected number of components */
 	int jpwl_exp_comps;
 	/** maximum number of tiles */
@@ -401,59 +559,15 @@ typedef struct opj_dparameters {
 	/*@}*/
 /* <<UniPG */
 
-	/** 
-	Specify whether the decoding should be done on the entire codestream, or be limited to the main header
-	Limiting the decoding to the main header makes it possible to extract the characteristics of the codestream
-	if == NO_LIMITATION, the entire codestream is decoded; 
-	if == LIMIT_TO_MAIN_HEADER, only the main header is decoded; 
-	*/
-	OPJ_LIMIT_DECODING cp_limit_decoding;
-
 	unsigned int flags;
-} opj_dparameters_t;
 
-/** Common fields between JPEG-2000 compression and decompression master structs. */
-
-#define opj_common_fields \
-	opj_event_mgr_t *event_mgr;	/**< pointer to the event manager */\
-	void * client_data;			/**< Available for use by application */\
-	opj_bool is_decompressor;	/**< So common code can tell which is which */\
-	OPJ_CODEC_FORMAT codec_format;	/**< selected codec */\
-	void *j2k_handle;			/**< pointer to the J2K codec */\
-	void *jp2_handle;			/**< pointer to the JP2 codec */\
-	void *mj2_handle			/**< pointer to the MJ2 codec */
-	
-/* Routines that are to be used by both halves of the library are declared
- * to receive a pointer to this structure.  There are no actual instances of
- * opj_common_struct_t, only of opj_cinfo_t and opj_dinfo_t.
- */
-typedef struct opj_common_struct {
-  opj_common_fields;		/* Fields common to both master struct types */
-  /* Additional fields follow in an actual opj_cinfo_t or
-   * opj_dinfo_t.  All three structs must agree on these
-   * initial fields!  (This would be a lot cleaner in C++.)
-   */
-} opj_common_struct_t;
+} opj_dparameters_t;
 
-typedef opj_common_struct_t * opj_common_ptr;
 
 /**
-Compression context info
-*/
-typedef struct opj_cinfo {
-	/** Fields shared with opj_dinfo_t */
-	opj_common_fields;	
-	/* other specific fields go here */
-} opj_cinfo_t;
-
-/**
-Decompression context info
-*/
-typedef struct opj_dinfo {
-	/** Fields shared with opj_cinfo_t */
-	opj_common_fields;	
-	/* other specific fields go here */
-} opj_dinfo_t;
+ * JPEG2000 codec V2.
+ * */
+typedef void * opj_codec_t;
 
 /* 
 ==========================================================
@@ -461,35 +575,43 @@ typedef struct opj_dinfo {
 ==========================================================
 */
 
-/*
+/**
  * Stream open flags.
- */
+ * */
 /** The stream was opened for reading. */
-#define OPJ_STREAM_READ	0x0001
+#define OPJ_STREAM_READ	OPJ_TRUE
 /** The stream was opened for writing. */
-#define OPJ_STREAM_WRITE 0x0002
+#define OPJ_STREAM_WRITE OPJ_FALSE
 
-/**
-Byte input-output stream (CIO)
-*/
-typedef struct opj_cio {
-	/** codec context */
-	opj_common_ptr cinfo;
+/*
+ * Callback function prototype for read function
+ */
+typedef OPJ_SIZE_T (* opj_stream_read_fn) (void * p_buffer, OPJ_SIZE_T p_nb_bytes, void * p_user_data) ;
+
+/*
+ * Callback function prototype for write function
+ */
+typedef OPJ_SIZE_T (* opj_stream_write_fn) (void * p_buffer, OPJ_SIZE_T p_nb_bytes, void * p_user_data) ;
+
+/*
+ * Callback function prototype for skip function
+ */
+typedef OPJ_OFF_T (* opj_stream_skip_fn) (OPJ_OFF_T p_nb_bytes, void * p_user_data) ;
 
-	/** open mode (read/write) either OPJ_STREAM_READ or OPJ_STREAM_WRITE */
-	int openmode;
-	/** pointer to the start of the buffer */
-	unsigned char *buffer;
-	/** buffer size in bytes */
-	int length;
+/*
+ * Callback function prototype for seek function
+ */
+typedef OPJ_BOOL (* opj_stream_seek_fn) (OPJ_OFF_T p_nb_bytes, void * p_user_data) ;
+
+/*
+ * Callback function prototype for free user data function
+ */
+typedef void (* opj_stream_free_user_data_fn) (void * p_user_data) ;
 
-	/** pointer to the start of the stream */
-	unsigned char *start;
-	/** pointer to the end of the stream */
-	unsigned char *end;
-	/** pointer to the current position */
-	unsigned char *bp;
-} opj_cio_t;
+/*
+ * JPEG2000 Stream.
+ */
+typedef void * opj_stream_t;
 
 /* 
 ==========================================================
@@ -498,99 +620,104 @@ typedef struct opj_cio {
 */
 
 /**
-Defines a single image component
-*/
+ * Defines a single image component
+ * */
 typedef struct opj_image_comp {
 	/** XRsiz: horizontal separation of a sample of ith component with respect to the reference grid */
-	int dx;
+	OPJ_UINT32 dx;
 	/** YRsiz: vertical separation of a sample of ith component with respect to the reference grid */
-	int dy;
+	OPJ_UINT32 dy;
 	/** data width */
-	int w;
+	OPJ_UINT32 w;
 	/** data height */
-	int h;
+	OPJ_UINT32 h;
 	/** x component offset compared to the whole image */
-	int x0;
+	OPJ_UINT32 x0;
 	/** y component offset compared to the whole image */
-	int y0;
+	OPJ_UINT32 y0;
 	/** precision */
-	int prec;
+	OPJ_UINT32 prec;
 	/** image depth in bits */
-	int bpp;
+	OPJ_UINT32 bpp;
 	/** signed (1) / unsigned (0) */
-	int sgnd;
+	OPJ_UINT32 sgnd;
 	/** number of decoded resolution */
-	int resno_decoded;
+	OPJ_UINT32 resno_decoded;
 	/** number of division by 2 of the out image compared to the original size of image */
-	int factor;
+	OPJ_UINT32 factor;
 	/** image component data */
-	int *data;
+	OPJ_INT32 *data;
+  /** alpha channel */
+  OPJ_UINT16 alpha;
 } opj_image_comp_t;
 
 /** 
-Defines image data and characteristics
-*/
+ * Defines image data and characteristics
+ * */
 typedef struct opj_image {
 	/** XOsiz: horizontal offset from the origin of the reference grid to the left side of the image area */
-	int x0;
+	OPJ_UINT32 x0;
 	/** YOsiz: vertical offset from the origin of the reference grid to the top side of the image area */
-	int y0;
+	OPJ_UINT32 y0;
 	/** Xsiz: width of the reference grid */
-	int x1;
+	OPJ_UINT32 x1;
 	/** Ysiz: height of the reference grid */
-	int y1;
+	OPJ_UINT32 y1;
 	/** number of components in the image */
-	int numcomps;
+	OPJ_UINT32 numcomps;
 	/** color space: sRGB, Greyscale or YUV */
 	OPJ_COLOR_SPACE color_space;
 	/** image components */
 	opj_image_comp_t *comps;
 	/** 'restricted' ICC profile */
-	unsigned char *icc_profile_buf;
+	OPJ_BYTE *icc_profile_buf;
 	/** size of ICC profile */
-	int icc_profile_len;
+	OPJ_UINT32 icc_profile_len;
 } opj_image_t;
 
+
 /**
-Component parameters structure used by the opj_image_create function
-*/
+ * Component parameters structure used by the opj_image_create function
+ * */
 typedef struct opj_image_comptparm {
 	/** XRsiz: horizontal separation of a sample of ith component with respect to the reference grid */
-	int dx;
+	OPJ_UINT32 dx;
 	/** YRsiz: vertical separation of a sample of ith component with respect to the reference grid */
-	int dy;
+	OPJ_UINT32 dy;
 	/** data width */
-	int w;
+	OPJ_UINT32 w;
 	/** data height */
-	int h;
+	OPJ_UINT32 h;
 	/** x component offset compared to the whole image */
-	int x0;
+	OPJ_UINT32 x0;
 	/** y component offset compared to the whole image */
-	int y0;
+	OPJ_UINT32 y0;
 	/** precision */
-	int prec;
+	OPJ_UINT32 prec;
 	/** image depth in bits */
-	int bpp;
+	OPJ_UINT32 bpp;
 	/** signed (1) / unsigned (0) */
-	int sgnd;
+	OPJ_UINT32 sgnd;
 } opj_image_cmptparm_t;
 
+
 /* 
 ==========================================================
    Information on the JPEG 2000 codestream
 ==========================================================
 */
+/* QUITE EXPERIMENTAL FOR THE MOMENT */
 
 /**
-Index structure : Information concerning a packet inside tile
-*/
+ * Index structure : Information concerning a packet inside tile
+ * */
 typedef struct opj_packet_info {
 	/** packet start position (including SOP marker if it exists) */
-	int start_pos;
+	OPJ_OFF_T start_pos;
 	/** end of packet header position (including EPH marker if it exists)*/
-	int end_ph_pos;
+	OPJ_OFF_T end_ph_pos;
 	/** packet end position */
-	int end_pos;
+	OPJ_OFF_T end_pos;
 	/** packet distorsion */
 	double disto;
 } opj_packet_info_t;
@@ -598,20 +725,20 @@ typedef struct opj_packet_info {
 
 /* UniPG>> */
 /**
-Marker structure
-*/
-typedef struct opj_marker_info_t {
+ * Marker structure
+ * */
+typedef struct opj_marker_info {
 	/** marker type */
 	unsigned short int type;
 	/** position in codestream */
-	int pos;
+	OPJ_OFF_T pos;
 	/** length, marker val included */
 	int len;
 } opj_marker_info_t;
 /* <<UniPG */
 
 /**
-Index structure : Information concerning tile-parts
+ * Index structure : Information concerning tile-parts
 */
 typedef struct opj_tp_info {
 	/** start position of tile part */
@@ -627,7 +754,7 @@ typedef struct opj_tp_info {
 } opj_tp_info_t;
 
 /**
-Index structure : information regarding tiles 
+ * Index structure : information regarding tiles
 */
 typedef struct opj_tile_info {
 	/** value of thresh for each layer by tile cfr. Marcela   */
@@ -667,7 +794,7 @@ typedef struct opj_tile_info {
 } opj_tile_info_t;
 
 /**
-Index structure of the codestream
+ * Index structure of the codestream
 */
 typedef struct opj_codestream_info {
 	/** maximum distortion reduction on the whole image (add for Marcela) */
@@ -718,6 +845,197 @@ typedef struct opj_codestream_info {
 	opj_tile_info_t *tile;
 } opj_codestream_info_t;
 
+/* <----------------------------------------------------------- */
+/* new output managment of the codestream information and index */
+
+/**
+ * Tile-component coding parameters information
+ */
+typedef struct opj_tccp_info
+{
+	/** component index */
+	OPJ_UINT32 compno;
+	/** coding style */
+	OPJ_UINT32 csty;
+	/** number of resolutions */
+	OPJ_UINT32 numresolutions;
+	/** code-blocks width */
+	OPJ_UINT32 cblkw;
+	/** code-blocks height */
+	OPJ_UINT32 cblkh;
+	/** code-block coding style */
+	OPJ_UINT32 cblksty;
+	/** discrete wavelet transform identifier */
+	OPJ_UINT32 qmfbid;
+	/** quantisation style */
+	OPJ_UINT32 qntsty;
+	/** stepsizes used for quantization */
+	OPJ_UINT32 stepsizes_mant[OPJ_J2K_MAXBANDS];
+	/** stepsizes used for quantization */
+	OPJ_UINT32 stepsizes_expn[OPJ_J2K_MAXBANDS];
+	/** number of guard bits */
+	OPJ_UINT32 numgbits;
+	/** Region Of Interest shift */
+	OPJ_INT32 roishift;
+	/** precinct width */
+	OPJ_UINT32 prcw[OPJ_J2K_MAXRLVLS];
+	/** precinct height */
+	OPJ_UINT32 prch[OPJ_J2K_MAXRLVLS];
+}
+opj_tccp_info_t;
+
+/**
+ * Tile coding parameters information
+ */
+typedef struct opj_tile_v2_info {
+
+	/** number (index) of tile */
+	int tileno;
+	/** coding style */
+	OPJ_UINT32 csty;
+	/** progression order */
+	OPJ_PROG_ORDER prg;
+	/** number of layers */
+	OPJ_UINT32 numlayers;
+	/** multi-component transform identifier */
+	OPJ_UINT32 mct;
+
+	/** information concerning tile component parameters*/
+	opj_tccp_info_t *tccp_info;
+
+} opj_tile_info_v2_t;
+
+/**
+ * Information structure about the codestream (FIXME should be expand and enhance)
+ */
+typedef struct opj_codestream_info_v2 {
+	/* Tile info */
+	/** tile origin in x = XTOsiz */
+	OPJ_UINT32 tx0;
+	/** tile origin in y = YTOsiz */
+	OPJ_UINT32 ty0;
+	/** tile size in x = XTsiz */
+	OPJ_UINT32 tdx;
+	/** tile size in y = YTsiz */
+	OPJ_UINT32 tdy;
+	/** number of tiles in X */
+	OPJ_UINT32 tw;
+	/** number of tiles in Y */
+	OPJ_UINT32 th;
+
+	/** number of components*/
+	OPJ_UINT32 nbcomps;
+
+	/** Default information regarding tiles inside image */
+	opj_tile_info_v2_t m_default_tile_info;
+
+	/** information regarding tiles inside image */
+	opj_tile_info_v2_t *tile_info; /* FIXME not used for the moment */
+
+} opj_codestream_info_v2_t;
+
+
+/**
+ * Index structure about a tile part
+ */
+typedef struct opj_tp_index {
+	/** start position */
+	OPJ_OFF_T start_pos;
+	/** end position of the header */
+	OPJ_OFF_T end_header;
+	/** end position */
+	OPJ_OFF_T end_pos;
+
+} opj_tp_index_t;
+
+/**
+ * Index structure about a tile
+ */
+typedef struct opj_tile_index {
+	/** tile index */
+	OPJ_UINT32 tileno;
+
+	/** number of tile parts */
+	OPJ_UINT32 nb_tps;
+	/** current nb of tile part (allocated)*/
+	OPJ_UINT32 current_nb_tps;
+	/** current tile-part index */
+	OPJ_UINT32 current_tpsno;
+	/** information concerning tile parts */
+	opj_tp_index_t *tp_index;
+
+	/* UniPG>> */ /* NOT USED FOR THE MOMENT IN THE V2 VERSION */
+		/** number of markers */
+		OPJ_UINT32 marknum;
+		/** list of markers */
+		opj_marker_info_t *marker;
+		/** actual size of markers array */
+		OPJ_UINT32 maxmarknum;
+	/* <<UniPG */
+
+	/** packet number */
+	OPJ_UINT32 nb_packet;
+	/** information concerning packets inside tile */
+	opj_packet_info_t *packet_index;
+
+} opj_tile_index_t;
+
+/**
+ * Index structure of the codestream (FIXME should be expand and enhance)
+ */
+typedef struct opj_codestream_index {
+	/** main header start position (SOC position) */
+	OPJ_OFF_T main_head_start;
+	/** main header end position (first SOT position) */
+	OPJ_OFF_T main_head_end;
+
+	/** codestream's size */
+	OPJ_UINT64 codestream_size;
+
+/* UniPG>> */ /* NOT USED FOR THE MOMENT IN THE V2 VERSION */
+	/** number of markers */
+	OPJ_UINT32 marknum;
+	/** list of markers */
+	opj_marker_info_t *marker;
+	/** actual size of markers array */
+	OPJ_UINT32 maxmarknum;
+/* <<UniPG */
+
+	/** */
+	OPJ_UINT32 nb_of_tiles;
+	/** */
+	opj_tile_index_t *tile_index; /* FIXME not used for the moment */
+
+}opj_codestream_index_t;
+/* -----------------------------------------------------------> */
+
+/*
+==========================================================
+   Metadata from the JP2file
+==========================================================
+*/
+
+/**
+ * Info structure of the JP2 file
+ * EXPERIMENTAL FOR THE MOMENT
+ */
+typedef struct opj_jp2_metadata {
+	/** */
+	OPJ_INT32	not_used;
+
+} opj_jp2_metadata_t;
+
+/**
+ * Index structure of the JP2 file
+ * EXPERIMENTAL FOR THE MOMENT
+ */
+typedef struct opj_jp2_index {
+	/** */
+	OPJ_INT32	not_used;
+
+} opj_jp2_index_t;
+
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -729,6 +1047,7 @@ extern "C" {
 ==========================================================
 */
 
+/* Get the version of the openjpeg library*/
 OPJ_API const char * OPJ_CALLCONV opj_version(void);
 
 /* 
@@ -738,20 +1057,33 @@ OPJ_API const char * OPJ_CALLCONV opj_version(void);
 */
 
 /**
-Create an image
-@param numcmpts number of components
-@param cmptparms components parameters
-@param clrspc image color space
-@return returns a new image structure if successful, returns NULL otherwise
-*/
-OPJ_API opj_image_t* OPJ_CALLCONV opj_image_create(int numcmpts, opj_image_cmptparm_t *cmptparms, OPJ_COLOR_SPACE clrspc);
+ * Create an image
+ *
+ * @param numcmpts      number of components
+ * @param cmptparms     components parameters
+ * @param clrspc        image color space
+ * @return returns      a new image structure if successful, returns NULL otherwise
+ * */
+OPJ_API opj_image_t* OPJ_CALLCONV opj_image_create(OPJ_UINT32 numcmpts, opj_image_cmptparm_t *cmptparms, OPJ_COLOR_SPACE clrspc);
 
 /**
-Deallocate any resources associated with an image
-@param image image to be destroyed
-*/
+ * Deallocate any resources associated with an image
+ *
+ * @param image         image to be destroyed
+ */
 OPJ_API void OPJ_CALLCONV opj_image_destroy(opj_image_t *image);
 
+/**
+ * Creates an image without allocating memory for the image (used in the new version of the library).
+ *
+ * @param	numcmpts    the number of components
+ * @param	cmptparms   the components parameters
+ * @param	clrspc      the image color space
+ *
+ * @return	a new image structure if successful, NULL otherwise.
+*/
+OPJ_API opj_image_t* OPJ_CALLCONV opj_image_tile_create(OPJ_UINT32 numcmpts, opj_image_cmptparm_t *cmptparms, OPJ_COLOR_SPACE clrspc);
+
 /* 
 ==========================================================
    stream functions definitions
@@ -759,100 +1091,314 @@ OPJ_API void OPJ_CALLCONV opj_image_destroy(opj_image_t *image);
 */
 
 /**
-Open and allocate a memory stream for read / write. 
-On reading, the user must provide a buffer containing encoded data. The buffer will be 
-wrapped by the returned CIO handle. 
-On writing, buffer parameters must be set to 0: a buffer will be allocated by the library 
-to contain encoded data. 
-@param cinfo Codec context info
-@param buffer Reading: buffer address. Writing: NULL
-@param length Reading: buffer length. Writing: 0
-@return Returns a CIO handle if successful, returns NULL otherwise
+ * Creates an abstract stream. This function does nothing except allocating memory and initializing the abstract stream.
+ *
+ * @param	p_is_input		if set to true then the stream will be an input stream, an output stream else.
+ *
+ * @return	a stream object.
+*/
+OPJ_API opj_stream_t* OPJ_CALLCONV opj_stream_default_create(OPJ_BOOL p_is_input);
+
+/**
+ * Creates an abstract stream. This function does nothing except allocating memory and initializing the abstract stream.
+ *
+ * @param	p_buffer_size  FIXME DOC
+ * @param	p_is_input		if set to true then the stream will be an input stream, an output stream else.
+ *
+ * @return	a stream object.
+*/
+OPJ_API opj_stream_t* OPJ_CALLCONV opj_stream_create(OPJ_SIZE_T p_buffer_size, OPJ_BOOL p_is_input);
+
+/**
+ * Destroys a stream created by opj_create_stream. This function does NOT close the abstract stream. If needed the user must
+ * close its own implementation of the stream.
+ *
+ * @param	p_stream	the stream to destroy.
+ */
+OPJ_API void OPJ_CALLCONV opj_stream_destroy(opj_stream_t* p_stream);
+ 
+/**
+ * Sets the given function to be used as a read function.
+ * @param		p_stream	the stream to modify
+ * @param		p_function	the function to use a read function.
 */
-OPJ_API opj_cio_t* OPJ_CALLCONV opj_cio_open(opj_common_ptr cinfo, unsigned char *buffer, int length);
+OPJ_API void OPJ_CALLCONV opj_stream_set_read_function(opj_stream_t* p_stream, opj_stream_read_fn p_function);
 
 /**
-Close and free a CIO handle
-@param cio CIO handle to free
+ * Sets the given function to be used as a write function.
+ * @param		p_stream	the stream to modify
+ * @param		p_function	the function to use a write function.
 */
-OPJ_API void OPJ_CALLCONV opj_cio_close(opj_cio_t *cio);
+OPJ_API void OPJ_CALLCONV opj_stream_set_write_function(opj_stream_t* p_stream, opj_stream_write_fn p_function);
 
 /**
-Get position in byte stream
-@param cio CIO handle
-@return Returns the position in bytes
+ * Sets the given function to be used as a skip function.
+ * @param		p_stream	the stream to modify
+ * @param		p_function	the function to use a skip function.
 */
-OPJ_API int OPJ_CALLCONV cio_tell(opj_cio_t *cio);
+OPJ_API void OPJ_CALLCONV opj_stream_set_skip_function(opj_stream_t* p_stream, opj_stream_skip_fn p_function);
+
 /**
-Set position in byte stream
-@param cio CIO handle
-@param pos Position, in number of bytes, from the beginning of the stream
+ * Sets the given function to be used as a seek function, the stream is then seekable.
+ * @param		p_stream	the stream to modify
+ * @param		p_function	the function to use a skip function.
 */
-OPJ_API void OPJ_CALLCONV cio_seek(opj_cio_t *cio, int pos);
+OPJ_API void OPJ_CALLCONV opj_stream_set_seek_function(opj_stream_t* p_stream, opj_stream_seek_fn p_function);
 
+/**
+ * Sets the given data to be used as a user data for the stream.
+ * @param		p_stream	the stream to modify
+ * @param		p_data		the data to set.
+ * @param		p_function	the function to free p_data when opj_stream_destroy() is called.
+*/
+OPJ_API void OPJ_CALLCONV opj_stream_set_user_data (opj_stream_t* p_stream, void * p_data, opj_stream_free_user_data_fn p_function);
+
+/**
+ * Sets the length of the user data for the stream.
+ *
+ * @param p_stream    the stream to modify
+ * @param data_length length of the user_data.
+*/
+OPJ_API void OPJ_CALLCONV opj_stream_set_user_data_length(opj_stream_t* p_stream, OPJ_UINT64 data_length);
+
+/**
+ * Create a stream from a file identified with its filename with default parameters (helper function)
+ * @param fname             the filename of the file to stream
+ * @param p_is_read_stream  whether the stream is a read stream (true) or not (false)
+*/
+OPJ_API opj_stream_t* OPJ_CALLCONV opj_stream_create_default_file_stream (const char *fname, OPJ_BOOL p_is_read_stream);
+ 
+/** Create a stream from a file identified with its filename with a specific buffer size
+ * @param fname             the filename of the file to stream
+ * @param p_buffer_size     size of the chunk used to stream
+ * @param p_is_read_stream  whether the stream is a read stream (true) or not (false)
+*/
+OPJ_API opj_stream_t* OPJ_CALLCONV opj_stream_create_file_stream (const char *fname,
+                                                                     OPJ_SIZE_T p_buffer_size,
+                                                                     OPJ_BOOL p_is_read_stream);
+ 
 /* 
 ==========================================================
    event manager functions definitions
 ==========================================================
 */
-
-OPJ_API opj_event_mgr_t* OPJ_CALLCONV opj_set_event_mgr(opj_common_ptr cinfo, opj_event_mgr_t *event_mgr, void *context);
+/**
+ * Set the info handler use by openjpeg.
+ * @param p_codec       the codec previously initialise
+ * @param p_callback    the callback function which will be used
+ * @param p_user_data   client object where will be returned the message
+*/
+OPJ_API OPJ_BOOL OPJ_CALLCONV opj_set_info_handler(opj_codec_t * p_codec, 
+                                                   opj_msg_callback p_callback,
+                                                   void * p_user_data);
+/**
+ * Set the warning handler use by openjpeg.
+ * @param p_codec       the codec previously initialise
+ * @param p_callback    the callback function which will be used
+ * @param p_user_data   client object where will be returned the message
+*/
+OPJ_API OPJ_BOOL OPJ_CALLCONV opj_set_warning_handler(opj_codec_t * p_codec,
+                                                      opj_msg_callback p_callback,
+                                                      void * p_user_data);
+/**
+ * Set the error handler use by openjpeg.
+ * @param p_codec       the codec previously initialise
+ * @param p_callback    the callback function which will be used
+ * @param p_user_data   client object where will be returned the message
+*/
+OPJ_API OPJ_BOOL OPJ_CALLCONV opj_set_error_handler(opj_codec_t * p_codec, 
+                                                    opj_msg_callback p_callback,
+                                                    void * p_user_data);
 
 /* 
 ==========================================================
    codec functions definitions
 ==========================================================
 */
+
 /**
-Creates a J2K/JPT/JP2 decompression structure
-@param format Decoder to select
-@return Returns a handle to a decompressor if successful, returns NULL otherwise
-*/
-OPJ_API opj_dinfo_t* OPJ_CALLCONV opj_create_decompress(OPJ_CODEC_FORMAT format);
+ * Creates a J2K/JP2 decompression structure
+ * @param format 		Decoder to select
+ *
+ * @return Returns a handle to a decompressor if successful, returns NULL otherwise
+ * */
+OPJ_API opj_codec_t* OPJ_CALLCONV opj_create_decompress(OPJ_CODEC_FORMAT format);
+
 /**
-Destroy a decompressor handle
-@param dinfo decompressor handle to destroy
-*/
-OPJ_API void OPJ_CALLCONV opj_destroy_decompress(opj_dinfo_t *dinfo);
+ * Destroy a decompressor handle
+ *
+ * @param	p_codec			decompressor handle to destroy
+ */
+OPJ_API void OPJ_CALLCONV opj_destroy_codec(opj_codec_t * p_codec);
+
 /**
-Set decoding parameters to default values
-@param parameters Decompression parameters
-*/
+ * Read after the codestream if necessary
+ * @param	p_codec			the JPEG2000 codec to read.
+ * @param	p_stream		the JPEG2000 stream.
+ */
+OPJ_API OPJ_BOOL OPJ_CALLCONV opj_end_decompress (	opj_codec_t *p_codec,
+													opj_stream_t *p_stream);
+
+
+/**
+ * Set decoding parameters to default values
+ * @param parameters Decompression parameters
+ */
 OPJ_API void OPJ_CALLCONV opj_set_default_decoder_parameters(opj_dparameters_t *parameters);
+
 /**
-Setup the decoder decoding parameters using user parameters.
-Decoding parameters are returned in j2k->cp. 
-@param dinfo decompressor handle
-@param parameters decompression parameters
-*/
-OPJ_API void OPJ_CALLCONV opj_setup_decoder(opj_dinfo_t *dinfo, opj_dparameters_t *parameters);
+ * Setup the decoder with decompression parameters provided by the user and with the message handler
+ * provided by the user.
+ *
+ * @param p_codec 		decompressor handler
+ * @param parameters 	decompression parameters
+ *
+ * @return true			if the decoder is correctly set
+ */
+OPJ_API OPJ_BOOL OPJ_CALLCONV opj_setup_decoder(opj_codec_t *p_codec,
+												opj_dparameters_t *parameters );
+
 /**
-Decode an image from a JPEG-2000 codestream 
-@param dinfo decompressor handle
-@param cio Input buffer stream
-@return Returns a decoded image if successful, returns NULL otherwise
-*/
-OPJ_API opj_image_t* OPJ_CALLCONV opj_decode(opj_dinfo_t *dinfo, opj_cio_t *cio);
+ * Decodes an image header.
+ *
+ * @param	p_stream		the jpeg2000 stream.
+ * @param	p_codec			the jpeg2000 codec to read.
+ * @param	p_image			the image structure initialized with the characteristics of encoded image.
+ *
+ * @return true				if the main header of the codestream and the JP2 header is correctly read.
+ */
+OPJ_API OPJ_BOOL OPJ_CALLCONV opj_read_header (	opj_stream_t *p_stream,
+												opj_codec_t *p_codec,
+												opj_image_t **p_image);
 
 /**
-Decode an image from a JPEG-2000 codestream and extract the codestream information
-@param dinfo decompressor handle
-@param cio Input buffer stream
-@param cstr_info Codestream information structure if needed afterwards, NULL otherwise
-@return Returns a decoded image if successful, returns NULL otherwise
-*/
-OPJ_API opj_image_t* OPJ_CALLCONV opj_decode_with_info(opj_dinfo_t *dinfo, opj_cio_t *cio, opj_codestream_info_t *cstr_info);
+ * Sets the given area to be decoded. This function should be called right after opj_read_header and before any tile header reading.
+ *
+ * @param	p_codec			the jpeg2000 codec.
+ * @param	p_image         the decoded image previously setted by opj_read_header
+ * @param	p_start_x		the left position of the rectangle to decode (in image coordinates).
+ * @param	p_end_x			the right position of the rectangle to decode (in image coordinates).
+ * @param	p_start_y		the up position of the rectangle to decode (in image coordinates).
+ * @param	p_end_y			the bottom position of the rectangle to decode (in image coordinates).
+ *
+ * @return	true			if the area could be set.
+ */
+OPJ_API OPJ_BOOL OPJ_CALLCONV opj_set_decode_area(	opj_codec_t *p_codec,
+													opj_image_t* p_image,
+													OPJ_INT32 p_start_x, OPJ_INT32 p_start_y,
+													OPJ_INT32 p_end_x, OPJ_INT32 p_end_y );
+
 /**
-Creates a J2K/JP2 compression structure
-@param format Coder to select
-@return Returns a handle to a compressor if successful, returns NULL otherwise
-*/
-OPJ_API opj_cinfo_t* OPJ_CALLCONV opj_create_compress(OPJ_CODEC_FORMAT format);
+ * Decode an image from a JPEG-2000 codestream
+ *
+ * @param p_decompressor 	decompressor handle
+ * @param p_stream			Input buffer stream
+ * @param p_image 			the decoded image
+ * @return 					true if success, otherwise false
+ * */
+OPJ_API OPJ_BOOL OPJ_CALLCONV opj_decode(   opj_codec_t *p_decompressor,
+                                            opj_stream_t *p_stream,
+                                            opj_image_t *p_image);
+
 /**
-Destroy a compressor handle
-@param cinfo compressor handle to destroy
-*/
-OPJ_API void OPJ_CALLCONV opj_destroy_compress(opj_cinfo_t *cinfo);
+ * Get the decoded tile from the codec
+ *
+ * @param	p_codec			the jpeg2000 codec.
+ * @param	p_stream		input streamm
+ * @param	p_image			output image
+ * @param	tile_index		index of the tile which will be decode
+ *
+ * @return					true if success, otherwise false
+ */
+OPJ_API OPJ_BOOL OPJ_CALLCONV opj_get_decoded_tile(	opj_codec_t *p_codec,
+													opj_stream_t *p_stream,
+													opj_image_t *p_image,
+													OPJ_UINT32 tile_index);
+
+/**
+ * Set the resolution factor of the decoded image
+ * @param	p_codec			the jpeg2000 codec.
+ * @param	res_factor		resolution factor to set
+ *
+ * @return					true if success, otherwise false
+ */
+OPJ_API OPJ_BOOL OPJ_CALLCONV opj_set_decoded_resolution_factor(opj_codec_t *p_codec, OPJ_UINT32 res_factor);
+
+/**
+ * Writes a tile with the given data.
+ *
+ * @param	p_codec		        the jpeg2000 codec.
+ * @param	p_tile_index		the index of the tile to write. At the moment, the tiles must be written from 0 to n-1 in sequence.
+ * @param	p_data				pointer to the data to write. Data is arranged in sequence, data_comp0, then data_comp1, then ... NO INTERLEAVING should be set.
+ * @param	p_data_size			this value os used to make sure the data being written is correct. The size must be equal to the sum for each component of 
+ *                              tile_width * tile_height * component_size. component_size can be 1,2 or 4 bytes, depending on the precision of the given component.
+ * @param	p_stream			the stream to write data to.
+ *
+ * @return	true if the data could be written.
+ */
+OPJ_API OPJ_BOOL OPJ_CALLCONV opj_write_tile (	opj_codec_t *p_codec,
+												OPJ_UINT32 p_tile_index,
+												OPJ_BYTE * p_data,
+												OPJ_UINT32 p_data_size,
+												opj_stream_t *p_stream );
+
+/**
+ * Reads a tile header. This function is compulsory and allows one to know the size of the tile thta will be decoded.
+ * The user may need to refer to the image got by opj_read_header to understand the size being taken by the tile.
+ *
+ * @param	p_codec			the jpeg2000 codec.
+ * @param	p_tile_index	pointer to a value that will hold the index of the tile being decoded, in case of success.
+ * @param	p_data_size		pointer to a value that will hold the maximum size of the decoded data, in case of success. In case
+ *							of truncated codestreams, the actual number of bytes decoded may be lower. The computation of the size is the same
+ *							as depicted in opj_write_tile.
+ * @param	p_tile_x0		pointer to a value that will hold the x0 pos of the tile (in the image).
+ * @param	p_tile_y0		pointer to a value that will hold the y0 pos of the tile (in the image).
+ * @param	p_tile_x1		pointer to a value that will hold the x1 pos of the tile (in the image).
+ * @param	p_tile_y1		pointer to a value that will hold the y1 pos of the tile (in the image).
+ * @param	p_nb_comps		pointer to a value that will hold the number of components in the tile.
+ * @param	p_should_go_on	pointer to a boolean that will hold the fact that the decoding should go on. In case the
+ *							codestream is over at the time of the call, the value will be set to false. The user should then stop
+ *							the decoding.
+ * @param	p_stream		the stream to decode.
+ * @return	true			if the tile header could be decoded. In case the decoding should end, the returned value is still true.
+ *							returning false may be the result of a shortage of memory or an internal error.
+ */
+OPJ_API OPJ_BOOL OPJ_CALLCONV opj_read_tile_header(	opj_codec_t *p_codec,
+												opj_stream_t * p_stream,
+												OPJ_UINT32 * p_tile_index,
+												OPJ_UINT32 * p_data_size,
+												OPJ_INT32 * p_tile_x0, OPJ_INT32 * p_tile_y0,
+												OPJ_INT32 * p_tile_x1, OPJ_INT32 * p_tile_y1,
+												OPJ_UINT32 * p_nb_comps,
+												OPJ_BOOL * p_should_go_on );
+
+/**
+ * Reads a tile data. This function is compulsory and allows one to decode tile data. opj_read_tile_header should be called before.
+ * The user may need to refer to the image got by opj_read_header to understand the size being taken by the tile.
+ *
+ * @param	p_codec			the jpeg2000 codec.
+ * @param	p_tile_index	the index of the tile being decoded, this should be the value set by opj_read_tile_header.
+ * @param	p_data			pointer to a memory block that will hold the decoded data.
+ * @param	p_data_size		size of p_data. p_data_size should be bigger or equal to the value set by opj_read_tile_header.
+ * @param	p_stream		the stream to decode.
+ *
+ * @return	true			if the data could be decoded.
+ */
+OPJ_API OPJ_BOOL OPJ_CALLCONV opj_decode_tile_data(	opj_codec_t *p_codec,
+													OPJ_UINT32 p_tile_index,
+													OPJ_BYTE * p_data,
+													OPJ_UINT32 p_data_size,
+													opj_stream_t *p_stream );
+
+/* COMPRESSION FUNCTIONS*/
+
+/**
+ * Creates a J2K/JP2 compression structure
+ * @param 	format 		Coder to select
+ * @return 				Returns a handle to a compressor if successful, returns NULL otherwise
+ */
+OPJ_API opj_codec_t* OPJ_CALLCONV opj_create_compress(OPJ_CODEC_FORMAT format);
+
 /**
 Set encoding parameters to default values, that means : 
 <ul>
@@ -875,36 +1421,135 @@ Set encoding parameters to default values, that means :
 @param parameters Compression parameters
 */
 OPJ_API void OPJ_CALLCONV opj_set_default_encoder_parameters(opj_cparameters_t *parameters);
+
 /**
-Setup the encoder parameters using the current image and using user parameters. 
-@param cinfo Compressor handle
-@param parameters Compression parameters
-@param image Input filled image
-*/
-OPJ_API void OPJ_CALLCONV opj_setup_encoder(opj_cinfo_t *cinfo, opj_cparameters_t *parameters, opj_image_t *image);
+ * Setup the encoder parameters using the current image and using user parameters.
+ * @param p_codec 		Compressor handle
+ * @param parameters 	Compression parameters
+ * @param image 		Input filled image
+ */
+OPJ_API OPJ_BOOL OPJ_CALLCONV opj_setup_encoder(opj_codec_t *p_codec, 
+												opj_cparameters_t *parameters, 
+												opj_image_t *image);
+
 /**
-Encode an image into a JPEG-2000 codestream
-3@param cinfo compressor handle
-@param cio Output buffer stream
-@param image Image to encode
-@param index Depreacted -> Set to NULL. To extract index, used opj_encode_wci()
-@return Returns true if successful, returns false otherwise
-*/
-OPJ_API opj_bool OPJ_CALLCONV opj_encode(opj_cinfo_t *cinfo, opj_cio_t *cio, opj_image_t *image, char *index);
+ * Start to compress the current image.
+ * @param p_codec 		Compressor handle
+ * @param image 	    Input filled image
+ * @param p_stream 		Input stgream
+ */
+OPJ_API OPJ_BOOL OPJ_CALLCONV opj_start_compress (	opj_codec_t *p_codec,
+													opj_image_t * p_image,
+													opj_stream_t *p_stream);
+
+/**
+ * End to compress the current image.
+ * @param p_codec 		Compressor handle
+ * @param p_stream 		Input stgream
+ */
+OPJ_API OPJ_BOOL OPJ_CALLCONV opj_end_compress (opj_codec_t *p_codec,
+												opj_stream_t *p_stream);
+
 /**
-Encode an image into a JPEG-2000 codestream and extract the codestream information
-@param cinfo compressor handle
-@param cio Output buffer stream
-@param image Image to encode
-@param cstr_info Codestream information structure if needed afterwards, NULL otherwise
-@return Returns true if successful, returns false otherwise
+ * Encode an image into a JPEG-2000 codestream
+ * @param p_codec 		compressor handle
+ * @param p_stream 		Output buffer stream
+ *
+ * @return 				Returns true if successful, returns false otherwise
+ */
+OPJ_API OPJ_BOOL OPJ_CALLCONV opj_encode(opj_codec_t *p_codec,
+                                         opj_stream_t *p_stream);
+/*
+==========================================================
+   codec output functions definitions
+==========================================================
 */
-OPJ_API opj_bool OPJ_CALLCONV opj_encode_with_info(opj_cinfo_t *cinfo, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info);
+/* EXPERIMENTAL FUNCTIONS FOR NOW, USED ONLY IN J2K_DUMP*/
+
 /**
 Destroy Codestream information after compression or decompression
 @param cstr_info Codestream information structure
 */
-OPJ_API void OPJ_CALLCONV opj_destroy_cstr_info(opj_codestream_info_t *cstr_info);
+OPJ_API void OPJ_CALLCONV opj_destroy_cstr_info(opj_codestream_info_v2_t **cstr_info);
+
+
+/**
+ * Dump the codec information into the output stream
+ *
+ * @param	p_codec			the jpeg2000 codec.
+ * @param	info_flag		type of information dump.
+ * @param	output_stream	output stream where dump the informations get from the codec.
+ *
+ */
+OPJ_API void OPJ_CALLCONV opj_dump_codec(	opj_codec_t *p_codec,
+											OPJ_INT32 info_flag,
+											FILE* output_stream);
+
+/**
+ * Get the codestream information from the codec
+ *
+ * @param	p_codec			the jpeg2000 codec.
+ *
+ * @return					a pointer to a codestream information structure.
+ *
+ */
+OPJ_API opj_codestream_info_v2_t* OPJ_CALLCONV opj_get_cstr_info(opj_codec_t *p_codec);
+
+/**
+ * Get the codestream index from the codec
+ *
+ * @param	p_codec			the jpeg2000 codec.
+ *
+ * @return					a pointer to a codestream index structure.
+ *
+ */
+OPJ_API opj_codestream_index_t * OPJ_CALLCONV opj_get_cstr_index(opj_codec_t *p_codec);
+
+OPJ_API void OPJ_CALLCONV opj_destroy_cstr_index(opj_codestream_index_t **p_cstr_index);
+
+
+/**
+ * Get the JP2 file information from the codec FIXME
+ *
+ * @param	p_codec			the jpeg2000 codec.
+ *
+ * @return					a pointer to a JP2 metadata structure.
+ *
+ */
+OPJ_API opj_jp2_metadata_t* OPJ_CALLCONV opj_get_jp2_metadata(opj_codec_t *p_codec);
+
+/**
+ * Get the JP2 file index from the codec FIXME
+ *
+ * @param	p_codec			the jpeg2000 codec.
+ *
+ * @return					a pointer to a JP2 index structure.
+ *
+ */
+OPJ_API opj_jp2_index_t* OPJ_CALLCONV opj_get_jp2_index(opj_codec_t *p_codec);
+
+
+/*
+==========================================================
+   MCT functions
+==========================================================
+*/
+
+/**
+ * Sets the MCT matrix to use.
+ *
+ * @param	parameters		the parameters to change.
+ * @param	pEncodingMatrix	the encoding matrix.
+ * @param	p_dc_shift		the dc shift coefficients to use.
+ * @param	pNbComp			the number of components of the image.
+ *
+ * @return	true if the parameters could be set.
+ */
+OPJ_API OPJ_BOOL OPJ_CALLCONV opj_set_MCT( opj_cparameters_t *parameters,
+		                               	   OPJ_FLOAT32 * pEncodingMatrix,
+		                               	   OPJ_INT32 * p_dc_shift,
+		                               	   OPJ_UINT32 pNbComp);
+
 
 
 #ifdef __cplusplus
diff --git a/extern/libopenjpeg/opj_clock.c b/extern/libopenjpeg/opj_clock.c
new file mode 100644
index 0000000..0df99ef
--- /dev/null
+++ b/extern/libopenjpeg/opj_clock.c
@@ -0,0 +1,64 @@
+/*
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifdef _WIN32
+#include <windows.h>
+#else
+#include <sys/time.h>
+#include <sys/resource.h>
+#include <sys/times.h>
+#endif /* _WIN32 */
+#include "opj_includes.h"
+
+OPJ_FLOAT64 opj_clock(void) {
+#ifdef _WIN32
+	/* _WIN32: use QueryPerformance (very accurate) */
+    LARGE_INTEGER freq , t ;
+    /* freq is the clock speed of the CPU */
+    QueryPerformanceFrequency(&freq) ;
+	/* cout << "freq = " << ((double) freq.QuadPart) << endl; */
+    /* t is the high resolution performance counter (see MSDN) */
+    QueryPerformanceCounter ( & t ) ;
+    return ( t.QuadPart /(OPJ_FLOAT64) freq.QuadPart ) ;
+#else
+	/* Unix or Linux: use resource usage */
+    struct rusage t;
+    OPJ_FLOAT64 procTime;
+    /* (1) Get the rusage data structure at this moment (man getrusage) */
+    getrusage(0,&t);
+    /* (2) What is the elapsed time ? - CPU time = User time + System time */
+	/* (2a) Get the seconds */
+    procTime = (OPJ_FLOAT64)(t.ru_utime.tv_sec + t.ru_stime.tv_sec);
+    /* (2b) More precisely! Get the microseconds part ! */
+    return ( procTime + (OPJ_FLOAT64)(t.ru_utime.tv_usec + t.ru_stime.tv_usec) * 1e-6 ) ;
+#endif
+}
+
diff --git a/extern/libopenjpeg/opj_clock.h b/extern/libopenjpeg/opj_clock.h
new file mode 100644
index 0000000..6f5168b
--- /dev/null
+++ b/extern/libopenjpeg/opj_clock.h
@@ -0,0 +1,59 @@
+/*
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __OPJ_CLOCK_H
+#define __OPJ_CLOCK_H
+/**
+@file opj_clock.h
+@brief Internal function for timing
+
+The functions in OPJ_CLOCK.C are internal utilities mainly used for timing.
+*/
+
+/** @defgroup MISC MISC - Miscellaneous internal functions */
+/*@{*/
+
+/** @name Exported functions */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+
+/**
+Difference in successive opj_clock() calls tells you the elapsed time
+@return Returns time in seconds
+*/
+OPJ_FLOAT64 opj_clock(void);
+
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __OPJ_CLOCK_H */
+
diff --git a/extern/libopenjpeg/opj_codec.h b/extern/libopenjpeg/opj_codec.h
new file mode 100644
index 0000000..4fdfa7d
--- /dev/null
+++ b/extern/libopenjpeg/opj_codec.h
@@ -0,0 +1,165 @@
+/*
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __OPJ_CODEC_H
+#define __OPJ_CODEC_H
+/**
+@file opj_codec.h
+*/
+
+
+/**
+ * Main codec handler used for compression or decompression.
+ */
+typedef struct opj_codec_private
+{
+    /** FIXME DOC */
+    union
+    {
+        /**
+         * Decompression handler.
+         */
+        struct opj_decompression
+        {
+            /** Main header reading function handler */
+            OPJ_BOOL (*opj_read_header) ( struct opj_stream_private * cio,
+                                          void * p_codec,
+                                          opj_image_t **p_image,
+                                          struct opj_event_mgr * p_manager);
+
+            /** Decoding function */
+            OPJ_BOOL (*opj_decode) ( void * p_codec,
+                                     struct opj_stream_private * p_cio,
+                                     opj_image_t * p_image,
+                                     struct opj_event_mgr * p_manager);
+
+            /** FIXME DOC */
+            OPJ_BOOL (*opj_read_tile_header)( void * p_codec,
+                                              OPJ_UINT32 * p_tile_index,
+                                              OPJ_UINT32 * p_data_size,
+                                              OPJ_INT32 * p_tile_x0,
+                                              OPJ_INT32 * p_tile_y0,
+                                              OPJ_INT32 * p_tile_x1,
+                                              OPJ_INT32 * p_tile_y1,
+                                              OPJ_UINT32 * p_nb_comps,
+                                              OPJ_BOOL * p_should_go_on,
+                                              struct opj_stream_private * p_cio,
+                                              struct opj_event_mgr * p_manager);
+
+            /** FIXME DOC */
+            OPJ_BOOL (*opj_decode_tile_data)( void * p_codec,
+                                              OPJ_UINT32 p_tile_index,
+                                              OPJ_BYTE * p_data,
+                                              OPJ_UINT32 p_data_size,
+                                              struct opj_stream_private * p_cio,
+                                              struct opj_event_mgr * p_manager);
+
+            /** Reading function used after codestream if necessary */
+            OPJ_BOOL (* opj_end_decompress) ( void *p_codec,
+                                              struct opj_stream_private * cio,
+                                              struct opj_event_mgr * p_manager);
+
+            /** Codec destroy function handler */
+            void (*opj_destroy) (void * p_codec);
+
+            /** Setup decoder function handler */
+            void (*opj_setup_decoder) ( void * p_codec, opj_dparameters_t * p_param);
+
+            /** Set decode area function handler */
+            OPJ_BOOL (*opj_set_decode_area) ( void * p_codec,
+                                              opj_image_t * p_image,
+                                              OPJ_INT32 p_start_x,
+                                              OPJ_INT32 p_end_x,
+                                              OPJ_INT32 p_start_y,
+                                              OPJ_INT32 p_end_y,
+                                              struct opj_event_mgr * p_manager);
+
+            /** Get tile function */
+            OPJ_BOOL (*opj_get_decoded_tile) ( void *p_codec,
+                                               opj_stream_private_t * p_cio,
+                                               opj_image_t *p_image,
+                                               struct opj_event_mgr * p_manager,
+                                               OPJ_UINT32 tile_index);
+
+            /** Set the decoded resolution factor */
+            OPJ_BOOL (*opj_set_decoded_resolution_factor) ( void * p_codec,
+                                                            OPJ_UINT32 res_factor,
+                                                            opj_event_mgr_t * p_manager);
+        } m_decompression;
+
+        /**
+         * Compression handler. FIXME DOC
+         */
+        struct opj_compression
+        {
+            OPJ_BOOL (* opj_start_compress) ( void *p_codec,
+                                              struct opj_stream_private * cio,
+                                              struct opj_image * p_image,
+                                              struct opj_event_mgr * p_manager);
+
+            OPJ_BOOL (* opj_encode) ( void * p_codec,
+                                      struct opj_stream_private *p_cio,
+                                      struct opj_event_mgr * p_manager);
+
+            OPJ_BOOL (* opj_write_tile) ( void * p_codec,
+                                          OPJ_UINT32 p_tile_index,
+                                          OPJ_BYTE * p_data,
+                                          OPJ_UINT32 p_data_size,
+                                          struct opj_stream_private * p_cio,
+                                          struct opj_event_mgr * p_manager);
+
+            OPJ_BOOL (* opj_end_compress) (	void * p_codec,
+                                            struct opj_stream_private * p_cio,
+                                            struct opj_event_mgr * p_manager);
+
+            void (* opj_destroy) (void * p_codec);
+
+            void (* opj_setup_encoder) ( void * p_codec,
+                                         opj_cparameters_t * p_param,
+                                         struct opj_image * p_image,
+                                         struct opj_event_mgr * p_manager);
+        } m_compression;
+    } m_codec_data;
+    /** FIXME DOC*/
+    void * m_codec;
+    /** Event handler */
+    opj_event_mgr_t m_event_mgr;
+    /** Flag to indicate if the codec is used to decode or encode*/
+    OPJ_BOOL is_decompressor;
+    void (*opj_dump_codec) (void * p_codec, OPJ_INT32 info_flag, FILE* output_stream);
+    opj_codestream_info_v2_t* (*opj_get_codec_info)(void* p_codec);
+    opj_codestream_index_t* (*opj_get_codec_index)(void* p_codec);
+}
+opj_codec_private_t;
+
+
+#endif /* __OPJ_CODEC_H */
+
diff --git a/extern/libopenjpeg/opj_config.h b/extern/libopenjpeg/opj_config.h
index 5d0a877..815ed3d 100644
--- a/extern/libopenjpeg/opj_config.h
+++ b/extern/libopenjpeg/opj_config.h
@@ -1,39 +1,5 @@
-/* for BLENDER - we hand-maintain this,
- * for the original OpenJpeg package it is generated,
- * the endian check is a blender define */
+#define OPJ_HAVE_STDINT_H 		1
 
-/* create config.h for CMake */
-#define PACKAGE_VERSION "1.5.2"
-
-#define HAVE_INTTYPES_H
-#define HAVE_MEMORY_H
-#define HAVE_STDINT_H
-#define HAVE_STDLIB_H
-#define HAVE_STRINGS_H
-#define HAVE_STRING_H
-#define HAVE_SYS_STAT_H
-#define HAVE_SYS_TYPES_H
-#define HAVE_UNISTD_H
-/* #define HAVE_LIBPNG */
-/* #define HAVE_PNG_H */
-/* #define HAVE_LIBTIFF */
-/* #define HAVE_TIFF_H */
-
-/* #undef HAVE_LIBLCMS1 */
-/* #undef HAVE_LIBLCMS2 */
-/* #undef HAVE_LCMS1_H */
-/* #undef HAVE_LCMS2_H */
-/* #undef USE_SYSTEM_GETOPT */
-
-/* Byte order.  */
-/* All compilers that support Mac OS X define either __BIG_ENDIAN__ or
-__LITTLE_ENDIAN__ to match the endianness of the architecture being
-compiled for. This is not necessarily the same as the architecture of the
-machine doing the building. In order to support Universal Binaries on
-Mac OS X, we prefer those defines to decide the endianness.
-On other platforms we use the result of the TRY_RUN. */
-#if defined(__BIG_ENDIAN__)
-#  define OPJ_BIG_ENDIAN
-#else
-#  undef OPJ_BIG_ENDIAN
-#endif
+#define OPJ_VERSION_MAJOR 2
+#define OPJ_VERSION_MINOR 1
+#define OPJ_VERSION_BUILD 0
diff --git a/extern/libopenjpeg/opj_config_private.h b/extern/libopenjpeg/opj_config_private.h
new file mode 100644
index 0000000..61f82ec
--- /dev/null
+++ b/extern/libopenjpeg/opj_config_private.h
@@ -0,0 +1,6 @@
+/* create opj_config_private.h for CMake */
+#define OPJ_HAVE_INTTYPES_H 	1
+
+#define OPJ_PACKAGE_VERSION "2.1.0"
+
+// #define OPJ_HAVE_FSEEKO ON
diff --git a/extern/libopenjpeg/opj_includes.h b/extern/libopenjpeg/opj_includes.h
index e9194fd..d9238b1 100644
--- a/extern/libopenjpeg/opj_includes.h
+++ b/extern/libopenjpeg/opj_includes.h
@@ -1,5 +1,12 @@
 /*
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR 
+ * Copyright (c) 2012, CS Systemes d'Information, France
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -26,6 +33,12 @@
 #ifndef OPJ_INCLUDES_H
 #define OPJ_INCLUDES_H
 
+/*
+ * This must be included before any system headers,
+ * since they can react to macro defined there
+ */
+#include "opj_config_private.h"
+
 /*
  ==========================================================
    Standard includes used by the library
@@ -40,6 +53,41 @@
 #include <stdio.h>
 #include <stdarg.h>
 #include <ctype.h>
+#include <assert.h>
+
+/*
+  Use fseeko() and ftello() if they are available since they use
+  'off_t' rather than 'long'.  It is wrong to use fseeko() and
+  ftello() only on systems with special LFS support since some systems
+  (e.g. FreeBSD) support a 64-bit off_t by default.
+*/
+#if defined(OPJ_HAVE_FSEEKO) && !defined(fseek)
+#  define fseek  fseeko
+#  define ftell  ftello
+#endif
+
+
+#if defined(WIN32) && !defined(Windows95) && !defined(__BORLANDC__) && \
+  !(defined(_MSC_VER) && _MSC_VER < 1400) && \
+  !(defined(__MINGW32__) && __MSVCRT_VERSION__ < 0x800)
+  /*
+    Windows '95 and Borland C do not support _lseeki64
+    Visual Studio does not support _fseeki64 and _ftelli64 until the 2005 release.
+    Without these interfaces, files over 2GB in size are not supported for Windows.
+  */
+#  define OPJ_FSEEK(stream,offset,whence) _fseeki64(stream,/* __int64 */ offset,whence)
+#  define OPJ_FSTAT(fildes,stat_buff) _fstati64(fildes,/* struct _stati64 */ stat_buff)
+#  define OPJ_FTELL(stream) /* __int64 */ _ftelli64(stream)
+#  define OPJ_STAT_STRUCT_T struct _stati64
+#  define OPJ_STAT(path,stat_buff) _stati64(path,/* struct _stati64 */ stat_buff)
+#else
+#  define OPJ_FSEEK(stream,offset,whence) fseek(stream,offset,whence)
+#  define OPJ_FSTAT(fildes,stat_buff) fstat(fildes,stat_buff)
+#  define OPJ_FTELL(stream) ftell(stream)
+#  define OPJ_STAT_STRUCT_T struct stat
+#  define OPJ_STAT(path,stat_buff) stat(path,stat_buff)
+#endif
+
 
 /*
  ==========================================================
@@ -59,22 +107,6 @@
 	#define __attribute__(x) /* __attribute__(x) */
 #endif
 
-/*
-The inline keyword is supported by C99 but not by C90. 
-Most compilers implement their own version of this keyword ... 
-*/
-#ifndef INLINE
-	#if defined(_MSC_VER)
-		#define INLINE __forceinline
-	#elif defined(__GNUC__)
-		#define INLINE __inline__
-	#elif defined(__MWERKS__)
-		#define INLINE inline
-	#else 
-		/* add other compilers here ... */
-		#define INLINE 
-	#endif /* defined(<Compiler>) */
-#endif /* INLINE */
 
 /* Are restricted pointers available? (C99) */
 #if (__STDC_VERSION__ != 199901L)
@@ -86,54 +118,63 @@ Most compilers implement their own version of this keyword ...
 	#endif
 #endif
 
-/* MSVC and Borland C do not have lrintf */
-#if defined(_MSC_VER) || defined(__BORLANDC__)
+/* MSVC before 2013 and Borland C do not have lrintf */
+#if defined(_MSC_VER) && (_MSC_VER < 1800) || defined(__BORLANDC__)
 static INLINE long lrintf(float f){
-#ifdef _M_IX86
-    long int i;
+#ifdef _M_X64
+    return (long)((f>0.0f) ? (f + 0.5f):(f -0.5f));
+#else
+    int i;
  
     _asm{
         fld f
         fistp i
     };
+ 
     return i;
-#else
-    return (long)((f>0.0f) ? (f + 0.5f):(f -0.5f));
-#endif /* _M_IX86 */
+#endif
 }
 #endif
 
-#include "j2k_lib.h"
+#include "opj_inttypes.h"
+#include "opj_clock.h"
 #include "opj_malloc.h"
+#include "function_list.h"
 #include "event.h"
 #include "bio.h"
 #include "cio.h"
 
 #include "image.h"
+#include "invert.h"
 #include "j2k.h"
 #include "jp2.h"
-#include "jpt.h"
 
 #include "mqc.h"
 #include "raw.h"
 #include "bio.h"
-#include "tgt.h"
+
 #include "pi.h"
+#include "tgt.h"
 #include "tcd.h"
 #include "t1.h"
 #include "dwt.h"
 #include "t2.h"
 #include "mct.h"
-#include "int.h"
-#include "fix.h"
+#include "opj_intmath.h"
 
+#ifdef USE_JPIP
 #include "cidx_manager.h"
 #include "indexbox_manager.h"
+#endif
 
 /* JPWL>> */
 #ifdef USE_JPWL
-#include "./jpwl/jpwl.h"
+#include "openjpwl/jpwl.h"
 #endif /* USE_JPWL */
 /* <<JPWL */
 
+/* V2 */
+#include "opj_codec.h"
+
+
 #endif /* OPJ_INCLUDES_H */
diff --git a/extern/libopenjpeg/opj_intmath.h b/extern/libopenjpeg/opj_intmath.h
new file mode 100644
index 0000000..dc89895
--- /dev/null
+++ b/extern/libopenjpeg/opj_intmath.h
@@ -0,0 +1,178 @@
+/*
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * Copyright (c) 2003-2014, Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __INT_H
+#define __INT_H
+/**
+@file opj_intmath.h
+@brief Implementation of operations on integers (INT)
+
+The functions in OPJ_INTMATH.H have for goal to realize operations on integers.
+*/
+
+/** @defgroup OPJ_INTMATH OPJ_INTMATH - Implementation of operations on integers */
+/*@{*/
+
+/** @name Exported functions (see also openjpeg.h) */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+/**
+Get the minimum of two integers
+@return Returns a if a < b else b
+*/
+static INLINE OPJ_INT32 opj_int_min(OPJ_INT32 a, OPJ_INT32 b) {
+	return a < b ? a : b;
+}
+
+/**
+Get the minimum of two integers
+@return Returns a if a < b else b
+*/
+static INLINE OPJ_UINT32 opj_uint_min(OPJ_UINT32 a, OPJ_UINT32 b) {
+	return a < b ? a : b;
+}
+
+/**
+Get the maximum of two integers
+@return Returns a if a > b else b
+*/
+static INLINE OPJ_INT32 opj_int_max(OPJ_INT32 a, OPJ_INT32 b) {
+	return (a > b) ? a : b;
+}
+
+/**
+Get the maximum of two integers
+@return Returns a if a > b else b
+*/
+static INLINE OPJ_UINT32 opj_uint_max(OPJ_UINT32  a, OPJ_UINT32  b) {
+	return (a > b) ? a : b;
+}
+
+/**
+Clamp an integer inside an interval
+@return
+<ul>
+<li>Returns a if (min < a < max)
+<li>Returns max if (a > max)
+<li>Returns min if (a < min) 
+</ul>
+*/
+static INLINE OPJ_INT32 opj_int_clamp(OPJ_INT32 a, OPJ_INT32 min, OPJ_INT32 max) {
+	if (a < min)
+		return min;
+	if (a > max)
+		return max;
+	return a;
+}
+/**
+@return Get absolute value of integer
+*/
+static INLINE OPJ_INT32 opj_int_abs(OPJ_INT32 a) {
+	return a < 0 ? -a : a;
+}
+/**
+Divide an integer and round upwards
+@return Returns a divided by b
+*/
+static INLINE OPJ_INT32 opj_int_ceildiv(OPJ_INT32 a, OPJ_INT32 b) {
+  assert(b);
+	return (a + b - 1) / b;
+}
+
+/**
+Divide an integer and round upwards
+@return Returns a divided by b
+*/
+static INLINE OPJ_UINT32  opj_uint_ceildiv(OPJ_UINT32  a, OPJ_UINT32  b) {
+	return (a + b - 1) / b;
+}
+
+/**
+Divide an integer by a power of 2 and round upwards
+@return Returns a divided by 2^b
+*/
+static INLINE OPJ_INT32 opj_int_ceildivpow2(OPJ_INT32 a, OPJ_INT32 b) {
+	return (OPJ_INT32)((a + (OPJ_INT64)(1 << b) - 1) >> b);
+}
+/**
+Divide an integer by a power of 2 and round downwards
+@return Returns a divided by 2^b
+*/
+static INLINE OPJ_INT32 opj_int_floordivpow2(OPJ_INT32 a, OPJ_INT32 b) {
+	return a >> b;
+}
+/**
+Get logarithm of an integer and round downwards
+@return Returns log2(a)
+*/
+static INLINE OPJ_INT32 opj_int_floorlog2(OPJ_INT32 a) {
+	OPJ_INT32 l;
+	for (l = 0; a > 1; l++) {
+		a >>= 1;
+	}
+	return l;
+}
+/**
+Get logarithm of an integer and round downwards
+@return Returns log2(a)
+*/
+static INLINE OPJ_UINT32  opj_uint_floorlog2(OPJ_UINT32  a) {
+	OPJ_UINT32  l;
+	for (l = 0; a > 1; ++l)
+	{
+		a >>= 1;
+	}
+	return l;
+}
+
+/**
+Multiply two fixed-precision rational numbers.
+@param a
+@param b
+@return Returns a * b
+*/
+static INLINE OPJ_INT32 opj_int_fix_mul(OPJ_INT32 a, OPJ_INT32 b) {
+    OPJ_INT64 temp = (OPJ_INT64) a * (OPJ_INT64) b ;
+    temp += temp & 4096;
+    return (OPJ_INT32) (temp >> 13) ;
+}
+
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif
diff --git a/extern/libopenjpeg/opj_inttypes.h b/extern/libopenjpeg/opj_inttypes.h
new file mode 100644
index 0000000..e74aed6
--- /dev/null
+++ b/extern/libopenjpeg/opj_inttypes.h
@@ -0,0 +1,48 @@
+/*
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2012, Mathieu Malaterre <mathieu.malaterre@gmail.com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef OPJ_INTTYPES_H
+#define OPJ_INTTYPES_H
+
+#include "opj_config_private.h"
+#ifdef OPJ_HAVE_INTTYPES_H
+#include <inttypes.h>
+#else
+#if defined(_WIN32)
+#define PRId64 "I64d"
+#define PRIi64 "I64i"
+#define PRIu64 "I64u"
+#define PRIx64 "I64x"
+#else
+#error unsupported platform
+#endif
+#endif
+
+#endif /* OPJ_INTTYPES_H */
diff --git a/extern/libopenjpeg/opj_malloc.h b/extern/libopenjpeg/opj_malloc.h
index aef2ee3..5007b0c 100644
--- a/extern/libopenjpeg/opj_malloc.h
+++ b/extern/libopenjpeg/opj_malloc.h
@@ -1,4 +1,9 @@
 /*
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
  * Copyright (c) 2007, Callum Lerwick <seg@haxxed.com>
  * All rights reserved.
@@ -48,8 +53,13 @@ Allocate an uninitialized memory block
 #ifdef ALLOC_PERF_OPT
 void * OPJ_CALLCONV opj_malloc(size_t size);
 #else
+/* prevent assertion on overflow for MSVC */
+#ifdef _MSC_VER
+#define opj_malloc(size) ((size_t)(size) >= (size_t)-0x100 ? NULL : malloc(size))
+#else
 #define opj_malloc(size) malloc(size)
 #endif
+#endif
 
 /**
 Allocate a memory block with elements initialized to 0
@@ -60,8 +70,13 @@ Allocate a memory block with elements initialized to 0
 #ifdef ALLOC_PERF_OPT
 void * OPJ_CALLCONV opj_calloc(size_t _NumOfElements, size_t _SizeOfElements);
 #else
+/* prevent assertion on overflow for MSVC */
+#ifdef _MSC_VER
+#define opj_calloc(num, size) ((size_t)(num) != 0 && (size_t)(num) >= (size_t)-0x100 / (size_t)(size) ? NULL : calloc(num, size))
+#else
 #define opj_calloc(num, size) calloc(num, size)
 #endif
+#endif
 
 /**
 Allocate memory aligned to a 16 byte boundry
@@ -139,8 +154,13 @@ Reallocate memory blocks.
 #ifdef ALLOC_PERF_OPT
 void * OPJ_CALLCONV opj_realloc(void * m, size_t s);
 #else
+/* prevent assertion on overflow for MSVC */
+#ifdef _MSC_VER
+#define opj_realloc(m, s) ((size_t)(s) >= (size_t)-0x100 ? NULL : realloc(m, s))
+#else
 #define opj_realloc(m, s) realloc(m, s)
 #endif
+#endif
 
 /**
 Deallocates or frees a memory block.
diff --git a/extern/libopenjpeg/opj_stdint.h b/extern/libopenjpeg/opj_stdint.h
new file mode 100644
index 0000000..b8556a1
--- /dev/null
+++ b/extern/libopenjpeg/opj_stdint.h
@@ -0,0 +1,52 @@
+/*
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2012, Mathieu Malaterre <mathieu.malaterre@gmail.com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef OPJ_STDINT_H
+#define OPJ_STDINT_H
+
+#include "opj_config.h"
+#ifdef OPJ_HAVE_STDINT_H
+#include <stdint.h>
+#else
+#if defined(_WIN32)
+typedef   signed __int8   int8_t;
+typedef unsigned __int8   uint8_t;
+typedef   signed __int16  int16_t;
+typedef unsigned __int16  uint16_t;
+typedef   signed __int32  int32_t;
+typedef unsigned __int32  uint32_t;
+typedef   signed __int64  int64_t;
+typedef unsigned __int64  uint64_t;
+#else
+#error unsupported platform
+#endif
+#endif
+
+#endif /* OPJ_STDINT_H */
diff --git a/extern/libopenjpeg/phix_manager.c b/extern/libopenjpeg/phix_manager.c
index 60a0281..5a3e883 100644
--- a/extern/libopenjpeg/phix_manager.c
+++ b/extern/libopenjpeg/phix_manager.c
@@ -1,8 +1,8 @@
 /*
  * $Id: phix_manager.c 897 2011-08-28 21:43:57Z Kaori.Hagihara@gmail.com $
  *
- * Copyright (c) 2002-2011, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2011, Professor Benoit Macq
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2003-2004, Yannick Verschueren
  * Copyright (c) 2010-2011, Kaori Hagihara
  * All rights reserved.
@@ -33,10 +33,9 @@
  *  \brief Modification of jpip.c from 2KAN indexer
  */
 
-#include <stdlib.h>
-#include <math.h>
 #include "opj_includes.h"
 
+
 /* 
  * Write faix box of phix
  *
@@ -48,50 +47,63 @@
  * @param[in] cio       file output handle
  * @return              length of faix box
  */
-int write_phixfaix( int coff, int compno, opj_codestream_info_t cstr_info, opj_bool EPHused, int j2klen, opj_cio_t *cio);
 
-int write_phix( int coff, opj_codestream_info_t cstr_info, opj_bool EPHused, int j2klen, opj_cio_t *cio)
+int opj_write_phix( int coff, opj_codestream_info_t cstr_info, OPJ_BOOL EPHused, int j2klen, opj_stream_private_t *cio,
+              opj_event_mgr_t * p_manager )
 {
-  int len, lenp=0, compno, i;
+  OPJ_BYTE l_data_header [8];
+  OPJ_UINT32 len, compno, i;
   opj_jp2_box_t *box;
+  OPJ_OFF_T lenp = 0;
 
-  box = (opj_jp2_box_t *)opj_calloc( cstr_info.numcomps, sizeof(opj_jp2_box_t));
+  box = (opj_jp2_box_t *)opj_calloc( (size_t)cstr_info.numcomps, sizeof(opj_jp2_box_t));
   
   for( i=0;i<2;i++){
-    if (i) cio_seek( cio, lenp);
+    if (i)
+      opj_stream_seek( cio, lenp, p_manager);
       
-    lenp = cio_tell( cio);
-    cio_skip( cio, 4);              /* L [at the end] */
-    cio_write( cio, JPIP_PHIX, 4);  /* PHIX           */
+    lenp = opj_stream_tell(cio);
+    opj_stream_skip(cio, 4, p_manager);         /* L [at the end]      */
+    opj_write_bytes(l_data_header,JPIP_PHIX,4); /* PHIX */
+    opj_stream_write_data(cio,l_data_header,4,p_manager);
       
-    write_manf( i, cstr_info.numcomps, box, cio);
+    opj_write_manf( (int)i, cstr_info.numcomps, box, cio, p_manager );
 
-    for( compno=0; compno<cstr_info.numcomps; compno++){       
-      box[compno].length = write_phixfaix( coff, compno, cstr_info, EPHused, j2klen, cio);
+    for( compno=0; compno<(OPJ_UINT32)cstr_info.numcomps; compno++){       
+      box[compno].length = (OPJ_UINT32)opj_write_phixfaix( coff, (int)compno, cstr_info, EPHused, j2klen, cio,p_manager);
       box[compno].type = JPIP_FAIX;
     }
 
-    len = cio_tell( cio)-lenp;
-    cio_seek( cio, lenp);
-    cio_write( cio, len, 4);        /* L              */
-    cio_seek( cio, lenp+len);
+    len = (OPJ_UINT32)(opj_stream_tell(cio)-lenp);
+    opj_stream_seek(cio, 4, p_manager);
+    opj_write_bytes(l_data_header,len,4);/* L              */
+    opj_stream_write_data(cio,l_data_header,4,p_manager);
+    opj_stream_seek( cio, lenp+len,p_manager);
   }
 
   opj_free(box);
 
-  return len;
+  return (int)len;
 }
 
-int write_phixfaix( int coff, int compno, opj_codestream_info_t cstr_info, opj_bool EPHused, int j2klen, opj_cio_t *cio)
+
+int opj_write_phixfaix( int coff, int compno, opj_codestream_info_t cstr_info, OPJ_BOOL EPHused, int j2klen, opj_stream_private_t *cio,
+              opj_event_mgr_t * p_manager )
 {
-  int len, lenp, tileno, version, i, nmax, size_of_coding; /* 4 or 8 */
+  OPJ_UINT32 tileno, version, i, nmax, size_of_coding; /* 4 or 8 */
   opj_tile_info_t *tile_Idx;
   opj_packet_info_t packet;
-  int resno, precno, layno, num_packet;
+  int resno, precno, layno;
+  OPJ_UINT32 num_packet;
   int numOfres, numOfprec, numOflayers;
+  OPJ_BYTE l_data_header [8];
+  OPJ_OFF_T lenp;
+  OPJ_UINT32 len;
+
   packet.end_ph_pos = packet.start_pos = -1;
   (void)EPHused; /* unused ? */
 
+
   if( j2klen > pow( 2, 32)){
     size_of_coding =  8;
     version = 1;
@@ -101,19 +113,23 @@ int write_phixfaix( int coff, int compno, opj_codestream_info_t cstr_info, opj_b
     version = 0;
   }
 
-  lenp = cio_tell( cio);
-  cio_skip( cio, 4);              /* L [at the end]      */
-  cio_write( cio, JPIP_FAIX, 4);  /* FAIX                */ 
-  cio_write( cio, version,1);     /* Version 0 = 4 bytes */
+  lenp = opj_stream_tell(cio);
+  opj_stream_skip(cio, 4, p_manager);         /* L [at the end]      */
+  opj_write_bytes(l_data_header,JPIP_FAIX,4); /* FAIX */
+  opj_stream_write_data(cio,l_data_header,4,p_manager);
+  opj_write_bytes(l_data_header,version,1);   /* Version 0 = 4 bytes */
+  opj_stream_write_data(cio,l_data_header,1,p_manager);
 
   nmax = 0;
-  for( i=0; i<=cstr_info.numdecompos[compno]; i++)
-    nmax += cstr_info.tile[0].ph[i] * cstr_info.tile[0].pw[i] * cstr_info.numlayers;
+  for( i=0; i<=(OPJ_UINT32)cstr_info.numdecompos[compno]; i++)
+    nmax += (OPJ_UINT32)(cstr_info.tile[0].ph[i] * cstr_info.tile[0].pw[i] * cstr_info.numlayers);
   
-  cio_write( cio, nmax, size_of_coding); /* NMAX */
-  cio_write( cio, cstr_info.tw*cstr_info.th, size_of_coding);      /* M    */
+  opj_write_bytes(l_data_header,nmax,size_of_coding);         /* NMAX           */
+  opj_stream_write_data(cio,l_data_header,size_of_coding,p_manager);
+  opj_write_bytes(l_data_header,(OPJ_UINT32)(cstr_info.tw*cstr_info.th),size_of_coding);  /* M              */
+  opj_stream_write_data(cio,l_data_header,size_of_coding,p_manager);
   
-  for( tileno=0; tileno<cstr_info.tw*cstr_info.th; tileno++){
+  for( tileno=0; tileno<(OPJ_UINT32)(cstr_info.tw*cstr_info.th); tileno++){
     tile_Idx = &cstr_info.tile[ tileno];
     
     num_packet = 0;
@@ -126,27 +142,29 @@ int write_phixfaix( int coff, int compno, opj_codestream_info_t cstr_info, opj_b
 	for( layno=0; layno<numOflayers; layno++){
 	  
 	  switch ( cstr_info.prog){
-	  case LRCP:
+	  case OPJ_LRCP:
 	    packet = tile_Idx->packet[ ((layno*numOfres+resno)*cstr_info.numcomps+compno)*numOfprec+precno];
 	    break;
-	  case RLCP:
+	  case OPJ_RLCP:
 	    packet = tile_Idx->packet[ ((resno*numOflayers+layno)*cstr_info.numcomps+compno)*numOfprec+precno];
 	    break;
-	  case RPCL:
+	  case OPJ_RPCL:
 	    packet = tile_Idx->packet[ ((resno*numOfprec+precno)*cstr_info.numcomps+compno)*numOflayers+layno];
 	    break;
-	  case PCRL:
+	  case OPJ_PCRL:
 	    packet = tile_Idx->packet[ ((precno*cstr_info.numcomps+compno)*numOfres+resno)*numOflayers + layno];
 	    break;
-	  case CPRL:
+	  case OPJ_CPRL:
 	    packet = tile_Idx->packet[ ((compno*numOfprec+precno)*numOfres+resno)*numOflayers + layno];
 	    break;
 	  default:
 	    fprintf( stderr, "failed to ppix indexing\n");
 	  }
 
-	  cio_write( cio, packet.start_pos-coff, size_of_coding);                /* start position */
-	  cio_write( cio, packet.end_ph_pos-packet.start_pos+1, size_of_coding); /* length         */
+    opj_write_bytes(l_data_header,(OPJ_UINT32)(packet.start_pos-coff),size_of_coding);            /* start position */
+    opj_stream_write_data(cio,l_data_header,size_of_coding,p_manager);
+    opj_write_bytes(l_data_header,(OPJ_UINT32)(packet.end_ph_pos-packet.start_pos+1),size_of_coding); /* length         */
+    opj_stream_write_data(cio,l_data_header,size_of_coding,p_manager);
 	  
 	  num_packet++;
 	}
@@ -155,16 +173,19 @@ int write_phixfaix( int coff, int compno, opj_codestream_info_t cstr_info, opj_b
 
     /* PADDING */
     while( num_packet < nmax){
-      cio_write( cio, 0, size_of_coding); /* start position            */
-      cio_write( cio, 0, size_of_coding); /* length                    */
+      opj_write_bytes(l_data_header,0,size_of_coding);/* start position            */
+      opj_stream_write_data(cio,l_data_header,size_of_coding,p_manager);
+      opj_write_bytes(l_data_header,0,size_of_coding);/* length                    */
+      opj_stream_write_data(cio,l_data_header,size_of_coding,p_manager);
       num_packet++;
     }
   }
 
-  len = cio_tell( cio)-lenp;
-  cio_seek( cio, lenp);
-  cio_write( cio, len, 4);        /* L  */
-  cio_seek( cio, lenp+len);
+  len = (OPJ_UINT32)(opj_stream_tell(cio)-lenp);
+  opj_stream_seek(cio, lenp,p_manager);
+  opj_write_bytes(l_data_header,len,4);/* L  */
+  opj_stream_write_data(cio,l_data_header,4,p_manager);
+  opj_stream_seek(cio, lenp+len,p_manager);
 
-  return len;
+  return (int)len;
 }
diff --git a/extern/libopenjpeg/pi.c b/extern/libopenjpeg/pi.c
index e8e33bf..1d8db41 100644
--- a/extern/libopenjpeg/pi.c
+++ b/extern/libopenjpeg/pi.c
@@ -1,9 +1,15 @@
 /*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2001-2003, David Janssens
  * Copyright (c) 2002-2003, Yannick Verschueren
- * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * Copyright (c) 2003-2014, Antonin Descampe
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
  * Copyright (c) 2006-2007, Parvatha Elangovan
  * All rights reserved.
@@ -41,48 +47,193 @@
 /**
 Get next packet in layer-resolution-component-precinct order.
 @param pi packet iterator to modify
-@return returns false if pi pointed to the last packet or else returns true 
+@return returns false if pi pointed to the last packet or else returns true
 */
-static opj_bool pi_next_lrcp(opj_pi_iterator_t * pi);
+static OPJ_BOOL opj_pi_next_lrcp(opj_pi_iterator_t * pi);
 /**
 Get next packet in resolution-layer-component-precinct order.
 @param pi packet iterator to modify
-@return returns false if pi pointed to the last packet or else returns true 
+@return returns false if pi pointed to the last packet or else returns true
 */
-static opj_bool pi_next_rlcp(opj_pi_iterator_t * pi);
+static OPJ_BOOL opj_pi_next_rlcp(opj_pi_iterator_t * pi);
 /**
 Get next packet in resolution-precinct-component-layer order.
 @param pi packet iterator to modify
-@return returns false if pi pointed to the last packet or else returns true 
+@return returns false if pi pointed to the last packet or else returns true
 */
-static opj_bool pi_next_rpcl(opj_pi_iterator_t * pi);
+static OPJ_BOOL opj_pi_next_rpcl(opj_pi_iterator_t * pi);
 /**
 Get next packet in precinct-component-resolution-layer order.
 @param pi packet iterator to modify
-@return returns false if pi pointed to the last packet or else returns true 
+@return returns false if pi pointed to the last packet or else returns true
 */
-static opj_bool pi_next_pcrl(opj_pi_iterator_t * pi);
+static OPJ_BOOL opj_pi_next_pcrl(opj_pi_iterator_t * pi);
 /**
 Get next packet in component-precinct-resolution-layer order.
 @param pi packet iterator to modify
-@return returns false if pi pointed to the last packet or else returns true 
+@return returns false if pi pointed to the last packet or else returns true
 */
-static opj_bool pi_next_cprl(opj_pi_iterator_t * pi);
+static OPJ_BOOL opj_pi_next_cprl(opj_pi_iterator_t * pi);
+
+/**
+ * Updates the coding parameters if the encoding is used with Progression order changes and final (or cinema parameters are used).
+ *
+ * @param	p_cp		the coding parameters to modify
+ * @param	p_tileno	the tile index being concerned.
+ * @param	p_tx0		X0 parameter for the tile
+ * @param	p_tx1		X1 parameter for the tile
+ * @param	p_ty0		Y0 parameter for the tile
+ * @param	p_ty1		Y1 parameter for the tile
+ * @param	p_max_prec	the maximum precision for all the bands of the tile
+ * @param	p_max_res	the maximum number of resolutions for all the poc inside the tile.
+ * @param	p_dx_min		the minimum dx of all the components of all the resolutions for the tile.
+ * @param	p_dy_min		the minimum dy of all the components of all the resolutions for the tile.
+ */
+static void opj_pi_update_encode_poc_and_final ( opj_cp_t *p_cp,
+                                                 OPJ_UINT32 p_tileno,
+                                                 OPJ_INT32 p_tx0,
+                                                 OPJ_INT32 p_tx1,
+                                                 OPJ_INT32 p_ty0,
+                                                 OPJ_INT32 p_ty1,
+                                                 OPJ_UINT32 p_max_prec,
+                                                 OPJ_UINT32 p_max_res,
+                                                 OPJ_UINT32 p_dx_min,
+                                                 OPJ_UINT32 p_dy_min);
+
+/**
+ * Updates the coding parameters if the encoding is not used with Progression order changes and final (and cinema parameters are used).
+ *
+ * @param	p_cp		the coding parameters to modify
+ * @param	p_num_comps		the number of components
+ * @param	p_tileno	the tile index being concerned.
+ * @param	p_tx0		X0 parameter for the tile
+ * @param	p_tx1		X1 parameter for the tile
+ * @param	p_ty0		Y0 parameter for the tile
+ * @param	p_ty1		Y1 parameter for the tile
+ * @param	p_max_prec	the maximum precision for all the bands of the tile
+ * @param	p_max_res	the maximum number of resolutions for all the poc inside the tile.
+ * @param	p_dx_min		the minimum dx of all the components of all the resolutions for the tile.
+ * @param	p_dy_min		the minimum dy of all the components of all the resolutions for the tile.
+ */
+static void opj_pi_update_encode_not_poc (  opj_cp_t *p_cp,
+                                            OPJ_UINT32 p_num_comps,
+                                            OPJ_UINT32 p_tileno,
+                                            OPJ_INT32 p_tx0,
+                                            OPJ_INT32 p_tx1,
+                                            OPJ_INT32 p_ty0,
+                                            OPJ_INT32 p_ty1,
+                                            OPJ_UINT32 p_max_prec,
+                                            OPJ_UINT32 p_max_res,
+                                            OPJ_UINT32 p_dx_min,
+                                            OPJ_UINT32 p_dy_min);
+/**
+ * Gets the encoding parameters needed to update the coding parameters and all the pocs.
+ * 
+ * @param	p_image			the image being encoded.
+ * @param	p_cp			the coding parameters.
+ * @param	tileno			the tile index of the tile being encoded.
+ * @param	p_tx0			pointer that will hold the X0 parameter for the tile
+ * @param	p_tx1			pointer that will hold the X1 parameter for the tile
+ * @param	p_ty0			pointer that will hold the Y0 parameter for the tile
+ * @param	p_ty1			pointer that will hold the Y1 parameter for the tile
+ * @param	p_max_prec		pointer that will hold the the maximum precision for all the bands of the tile
+ * @param	p_max_res		pointer that will hold the the maximum number of resolutions for all the poc inside the tile.
+ * @param	p_dx_min			pointer that will hold the the minimum dx of all the components of all the resolutions for the tile.
+ * @param	p_dy_min			pointer that will hold the the minimum dy of all the components of all the resolutions for the tile.
+ */
+static void opj_get_encoding_parameters(const opj_image_t *p_image,
+                                        const opj_cp_t *p_cp,
+                                        OPJ_UINT32  tileno,
+                                        OPJ_INT32  * p_tx0,
+                                        OPJ_INT32 * p_tx1,
+                                        OPJ_INT32 * p_ty0,
+                                        OPJ_INT32 * p_ty1,
+                                        OPJ_UINT32 * p_dx_min,
+                                        OPJ_UINT32 * p_dy_min,
+                                        OPJ_UINT32 * p_max_prec,
+                                        OPJ_UINT32 * p_max_res );
+
+/**
+ * Gets the encoding parameters needed to update the coding parameters and all the pocs.
+ * The precinct widths, heights, dx and dy for each component at each resolution will be stored as well.
+ * the last parameter of the function should be an array of pointers of size nb components, each pointer leading
+ * to an area of size 4 * max_res. The data is stored inside this area with the following pattern :
+ * dx_compi_res0 , dy_compi_res0 , w_compi_res0, h_compi_res0 , dx_compi_res1 , dy_compi_res1 , w_compi_res1, h_compi_res1 , ...
+ *
+ * @param	p_image			the image being encoded.
+ * @param	p_cp			the coding parameters.
+ * @param	tileno			the tile index of the tile being encoded.
+ * @param	p_tx0			pointer that will hold the X0 parameter for the tile
+ * @param	p_tx1			pointer that will hold the X1 parameter for the tile
+ * @param	p_ty0			pointer that will hold the Y0 parameter for the tile
+ * @param	p_ty1			pointer that will hold the Y1 parameter for the tile
+ * @param	p_max_prec		pointer that will hold the the maximum precision for all the bands of the tile
+ * @param	p_max_res		pointer that will hold the the maximum number of resolutions for all the poc inside the tile.
+ * @param	p_dx_min		pointer that will hold the the minimum dx of all the components of all the resolutions for the tile.
+ * @param	p_dy_min		pointer that will hold the the minimum dy of all the components of all the resolutions for the tile.
+ * @param	p_resolutions	pointer to an area corresponding to the one described above.
+ */
+static void opj_get_all_encoding_parameters(const opj_image_t *p_image,
+                                            const opj_cp_t *p_cp,
+                                            OPJ_UINT32 tileno,
+                                            OPJ_INT32 * p_tx0,
+                                            OPJ_INT32 * p_tx1,
+                                            OPJ_INT32 * p_ty0,
+                                            OPJ_INT32 * p_ty1,
+                                            OPJ_UINT32 * p_dx_min,
+                                            OPJ_UINT32 * p_dy_min,
+                                            OPJ_UINT32 * p_max_prec,
+                                            OPJ_UINT32 * p_max_res,
+                                            OPJ_UINT32 ** p_resolutions );
+/**
+ * Allocates memory for a packet iterator. Data and data sizes are set by this operation.
+ * No other data is set. The include section of the packet  iterator is not allocated.
+ * 
+ * @param	p_image		the image used to initialize the packet iterator (in fact only the number of components is relevant.
+ * @param	p_cp		the coding parameters.
+ * @param	tileno	the index of the tile from which creating the packet iterator.
+ */
+static opj_pi_iterator_t * opj_pi_create(	const opj_image_t *p_image,
+                                            const opj_cp_t *p_cp,
+                                            OPJ_UINT32 tileno );
+/**
+ * FIXME DOC
+ */
+static void opj_pi_update_decode_not_poc (opj_pi_iterator_t * p_pi,
+                                          opj_tcp_t * p_tcp,
+                                          OPJ_UINT32 p_max_precision,
+                                          OPJ_UINT32 p_max_res);
+/**
+ * FIXME DOC
+ */
+static void opj_pi_update_decode_poc (  opj_pi_iterator_t * p_pi,
+                                        opj_tcp_t * p_tcp,
+                                        OPJ_UINT32 p_max_precision,
+                                        OPJ_UINT32 p_max_res);
+
+/**
+ * FIXME DOC
+ */
+OPJ_BOOL opj_pi_check_next_level(	OPJ_INT32 pos,
+								opj_cp_t *cp,
+								OPJ_UINT32 tileno,
+								OPJ_UINT32 pino,
+								const OPJ_CHAR *prog);
 
 /*@}*/
 
 /*@}*/
 
-/* 
+/*
 ==========================================================
    local functions
 ==========================================================
 */
 
-static opj_bool pi_next_lrcp(opj_pi_iterator_t * pi) {
+OPJ_BOOL opj_pi_next_lrcp(opj_pi_iterator_t * pi) {
 	opj_pi_comp_t *comp = NULL;
 	opj_pi_resolution_t *res = NULL;
-	long index = 0;
+	OPJ_UINT32 index = 0;
 	
 	if (!pi->first) {
 		comp = &pi->comps[pi->compno];
@@ -119,10 +270,10 @@ LABEL_SKIP:;
 	return OPJ_FALSE;
 }
 
-static opj_bool pi_next_rlcp(opj_pi_iterator_t * pi) {
+OPJ_BOOL opj_pi_next_rlcp(opj_pi_iterator_t * pi) {
 	opj_pi_comp_t *comp = NULL;
 	opj_pi_resolution_t *res = NULL;
-	long index = 0;
+	OPJ_UINT32 index = 0;
 
 	if (!pi->first) {
 		comp = &pi->comps[pi->compno];
@@ -158,27 +309,27 @@ LABEL_SKIP:;
 	return OPJ_FALSE;
 }
 
-static opj_bool pi_next_rpcl(opj_pi_iterator_t * pi) {
+OPJ_BOOL opj_pi_next_rpcl(opj_pi_iterator_t * pi) {
 	opj_pi_comp_t *comp = NULL;
 	opj_pi_resolution_t *res = NULL;
-	long index = 0;
+	OPJ_UINT32 index = 0;
 
 	if (!pi->first) {
 		goto LABEL_SKIP;
 	} else {
-		int compno, resno;
+		OPJ_UINT32 compno, resno;
 		pi->first = 0;
 		pi->dx = 0;
 		pi->dy = 0;
 		for (compno = 0; compno < pi->numcomps; compno++) {
 			comp = &pi->comps[compno];
 			for (resno = 0; resno < comp->numresolutions; resno++) {
-				int dx, dy;
+				OPJ_UINT32 dx, dy;
 				res = &comp->resolutions[resno];
-				dx = comp->dx * (1 << (res->pdx + comp->numresolutions - 1 - resno));
-				dy = comp->dy * (1 << (res->pdy + comp->numresolutions - 1 - resno));
-				pi->dx = !pi->dx ? dx : int_min(pi->dx, dx);
-				pi->dy = !pi->dy ? dy : int_min(pi->dy, dy);
+				dx = comp->dx * (1u << (res->pdx + comp->numresolutions - 1 - resno));
+				dy = comp->dy * (1u << (res->pdy + comp->numresolutions - 1 - resno));
+				pi->dx = !pi->dx ? dx : opj_uint_min(pi->dx, dx);
+				pi->dy = !pi->dy ? dy : opj_uint_min(pi->dy, dy);
 			}
 		}
 	}
@@ -189,42 +340,42 @@ if (!pi->tp_on){
 			pi->poc.tx1 = pi->tx1;
 		}
 	for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {
-		for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1; pi->y += pi->dy - (pi->y % pi->dy)) {
-			for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1; pi->x += pi->dx - (pi->x % pi->dx)) {
+		for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1; pi->y += (OPJ_INT32)(pi->dy - (OPJ_UINT32)(pi->y % (OPJ_INT32)pi->dy))) {
+			for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1; pi->x += (OPJ_INT32)(pi->dx - (OPJ_UINT32)(pi->x % (OPJ_INT32)pi->dx))) {
 				for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {
-					int levelno;
-					int trx0, try0;
-					int trx1, try1;
-					int rpx, rpy;
-					int prci, prcj;
+					OPJ_UINT32 levelno;
+					OPJ_INT32 trx0, try0;
+					OPJ_INT32  trx1, try1;
+					OPJ_UINT32  rpx, rpy;
+					OPJ_INT32  prci, prcj;
 					comp = &pi->comps[pi->compno];
 					if (pi->resno >= comp->numresolutions) {
 						continue;
 					}
 					res = &comp->resolutions[pi->resno];
 					levelno = comp->numresolutions - 1 - pi->resno;
-					trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);
-					try0 = int_ceildiv(pi->ty0, comp->dy << levelno);
-					trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);
-					try1 = int_ceildiv(pi->ty1, comp->dy << levelno);
+					trx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32)(comp->dx << levelno));
+					try0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32)(comp->dy << levelno));
+					trx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32)(comp->dx << levelno));
+					try1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32)(comp->dy << levelno));
 					rpx = res->pdx + levelno;
 					rpy = res->pdy + levelno;
-					if (!((pi->y % (comp->dy << rpy) == 0) || ((pi->y == pi->ty0) && ((try0 << levelno) % (1 << rpy))))){
+					if (!((pi->y % (OPJ_INT32)(comp->dy << rpy) == 0) || ((pi->y == pi->ty0) && ((try0 << levelno) % (1 << rpy))))){
 						continue;	
 					}
-					if (!((pi->x % (comp->dx << rpx) == 0) || ((pi->x == pi->tx0) && ((trx0 << levelno) % (1 << rpx))))){
-						continue; 
+					if (!((pi->x % (OPJ_INT32)(comp->dx << rpx) == 0) || ((pi->x == pi->tx0) && ((trx0 << levelno) % (1 << rpx))))){
+						continue;
 					}
 					
 					if ((res->pw==0)||(res->ph==0)) continue;
 					
 					if ((trx0==trx1)||(try0==try1)) continue;
 					
-					prci = int_floordivpow2(int_ceildiv(pi->x, comp->dx << levelno), res->pdx) 
-						 - int_floordivpow2(trx0, res->pdx);
-					prcj = int_floordivpow2(int_ceildiv(pi->y, comp->dy << levelno), res->pdy) 
-						 - int_floordivpow2(try0, res->pdy);
-					pi->precno = prci + prcj * res->pw;
+					prci = opj_int_floordivpow2(opj_int_ceildiv(pi->x, (OPJ_INT32)(comp->dx << levelno)), (OPJ_INT32)res->pdx)
+						 - opj_int_floordivpow2(trx0, (OPJ_INT32)res->pdx);
+					prcj = opj_int_floordivpow2(opj_int_ceildiv(pi->y, (OPJ_INT32)(comp->dy << levelno)), (OPJ_INT32)res->pdy)
+						 - opj_int_floordivpow2(try0, (OPJ_INT32)res->pdy);
+					pi->precno = (OPJ_UINT32)(prci + prcj * (OPJ_INT32)res->pw);
 					for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {
 						index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;
 						if (!pi->include[index]) {
@@ -241,28 +392,28 @@ LABEL_SKIP:;
 	return OPJ_FALSE;
 }
 
-static opj_bool pi_next_pcrl(opj_pi_iterator_t * pi) {
+OPJ_BOOL opj_pi_next_pcrl(opj_pi_iterator_t * pi) {
 	opj_pi_comp_t *comp = NULL;
 	opj_pi_resolution_t *res = NULL;
-	long index = 0;
+	OPJ_UINT32 index = 0;
 
 	if (!pi->first) {
 		comp = &pi->comps[pi->compno];
 		goto LABEL_SKIP;
 	} else {
-		int compno, resno;
+		OPJ_UINT32 compno, resno;
 		pi->first = 0;
 		pi->dx = 0;
 		pi->dy = 0;
 		for (compno = 0; compno < pi->numcomps; compno++) {
 			comp = &pi->comps[compno];
 			for (resno = 0; resno < comp->numresolutions; resno++) {
-				int dx, dy;
+				OPJ_UINT32 dx, dy;
 				res = &comp->resolutions[resno];
-				dx = comp->dx * (1 << (res->pdx + comp->numresolutions - 1 - resno));
-				dy = comp->dy * (1 << (res->pdy + comp->numresolutions - 1 - resno));
-				pi->dx = !pi->dx ? dx : int_min(pi->dx, dx);
-				pi->dy = !pi->dy ? dy : int_min(pi->dy, dy);
+				dx = comp->dx * (1u << (res->pdx + comp->numresolutions - 1 - resno));
+				dy = comp->dy * (1u << (res->pdy + comp->numresolutions - 1 - resno));
+				pi->dx = !pi->dx ? dx : opj_uint_min(pi->dx, dx);
+				pi->dy = !pi->dy ? dy : opj_uint_min(pi->dy, dy);
 			}
 		}
 	}
@@ -272,40 +423,40 @@ static opj_bool pi_next_pcrl(opj_pi_iterator_t * pi) {
 			pi->poc.ty1 = pi->ty1;
 			pi->poc.tx1 = pi->tx1;
 		}
-	for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1; pi->y += pi->dy - (pi->y % pi->dy)) {
-		for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1; pi->x += pi->dx - (pi->x % pi->dx)) {
+	for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1; pi->y += (OPJ_INT32)(pi->dy - (OPJ_UINT32)(pi->y % (OPJ_INT32)pi->dy))) {
+		for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1; pi->x += (OPJ_INT32)(pi->dx - (OPJ_UINT32)(pi->x % (OPJ_INT32)pi->dx))) {
 			for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {
 				comp = &pi->comps[pi->compno];
-				for (pi->resno = pi->poc.resno0; pi->resno < int_min(pi->poc.resno1, comp->numresolutions); pi->resno++) {
-					int levelno;
-					int trx0, try0;
-					int trx1, try1;
-					int rpx, rpy;
-					int prci, prcj;
+				for (pi->resno = pi->poc.resno0; pi->resno < opj_uint_min(pi->poc.resno1, comp->numresolutions); pi->resno++) {
+					OPJ_UINT32 levelno;
+					OPJ_INT32 trx0, try0;
+					OPJ_INT32 trx1, try1;
+					OPJ_UINT32 rpx, rpy;
+					OPJ_INT32 prci, prcj;
 					res = &comp->resolutions[pi->resno];
 					levelno = comp->numresolutions - 1 - pi->resno;
-					trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);
-					try0 = int_ceildiv(pi->ty0, comp->dy << levelno);
-					trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);
-					try1 = int_ceildiv(pi->ty1, comp->dy << levelno);
+					trx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32)(comp->dx << levelno));
+					try0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32)(comp->dy << levelno));
+					trx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32)(comp->dx << levelno));
+					try1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32)(comp->dy << levelno));
 					rpx = res->pdx + levelno;
 					rpy = res->pdy + levelno;
-					if (!((pi->y % (comp->dy << rpy) == 0) || ((pi->y == pi->ty0) && ((try0 << levelno) % (1 << rpy))))){
+					if (!((pi->y % (OPJ_INT32)(comp->dy << rpy) == 0) || ((pi->y == pi->ty0) && ((try0 << levelno) % (1 << rpy))))){
 						continue;	
 					}
-					if (!((pi->x % (comp->dx << rpx) == 0) || ((pi->x == pi->tx0) && ((trx0 << levelno) % (1 << rpx))))){
-						continue; 
+					if (!((pi->x % (OPJ_INT32)(comp->dx << rpx) == 0) || ((pi->x == pi->tx0) && ((trx0 << levelno) % (1 << rpx))))){
+						continue;
 					}
 					
 					if ((res->pw==0)||(res->ph==0)) continue;
 					
 					if ((trx0==trx1)||(try0==try1)) continue;
 					
-					prci = int_floordivpow2(int_ceildiv(pi->x, comp->dx << levelno), res->pdx) 
-						 - int_floordivpow2(trx0, res->pdx);
-					prcj = int_floordivpow2(int_ceildiv(pi->y, comp->dy << levelno), res->pdy) 
-						 - int_floordivpow2(try0, res->pdy);
-					pi->precno = prci + prcj * res->pw;
+					prci = opj_int_floordivpow2(opj_int_ceildiv(pi->x, (OPJ_INT32)(comp->dx << levelno)), (OPJ_INT32)res->pdx)
+						 - opj_int_floordivpow2(trx0, (OPJ_INT32)res->pdx);
+					prcj = opj_int_floordivpow2(opj_int_ceildiv(pi->y, (OPJ_INT32)(comp->dy << levelno)), (OPJ_INT32)res->pdy)
+						 - opj_int_floordivpow2(try0, (OPJ_INT32)res->pdy);
+					pi->precno = (OPJ_UINT32)(prci + prcj * (OPJ_INT32)res->pw);
 					for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {
 						index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;
 						if (!pi->include[index]) {
@@ -322,10 +473,10 @@ LABEL_SKIP:;
 	return OPJ_FALSE;
 }
 
-static opj_bool pi_next_cprl(opj_pi_iterator_t * pi) {
+OPJ_BOOL opj_pi_next_cprl(opj_pi_iterator_t * pi) {
 	opj_pi_comp_t *comp = NULL;
 	opj_pi_resolution_t *res = NULL;
-	long index = 0;
+	OPJ_UINT32 index = 0;
 
 	if (!pi->first) {
 		comp = &pi->comps[pi->compno];
@@ -335,17 +486,17 @@ static opj_bool pi_next_cprl(opj_pi_iterator_t * pi) {
 	}
 
 	for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {
-		int resno;
+		OPJ_UINT32 resno;
 		comp = &pi->comps[pi->compno];
 		pi->dx = 0;
 		pi->dy = 0;
 		for (resno = 0; resno < comp->numresolutions; resno++) {
-			int dx, dy;
+			OPJ_UINT32 dx, dy;
 			res = &comp->resolutions[resno];
-			dx = comp->dx * (1 << (res->pdx + comp->numresolutions - 1 - resno));
-			dy = comp->dy * (1 << (res->pdy + comp->numresolutions - 1 - resno));
-			pi->dx = !pi->dx ? dx : int_min(pi->dx, dx);
-			pi->dy = !pi->dy ? dy : int_min(pi->dy, dy);
+			dx = comp->dx * (1u << (res->pdx + comp->numresolutions - 1 - resno));
+			dy = comp->dy * (1u << (res->pdy + comp->numresolutions - 1 - resno));
+			pi->dx = !pi->dx ? dx : opj_uint_min(pi->dx, dx);
+			pi->dy = !pi->dy ? dy : opj_uint_min(pi->dy, dy);
 		}
 		if (!pi->tp_on){
 			pi->poc.ty0 = pi->ty0;
@@ -353,38 +504,38 @@ static opj_bool pi_next_cprl(opj_pi_iterator_t * pi) {
 			pi->poc.ty1 = pi->ty1;
 			pi->poc.tx1 = pi->tx1;
 		}
-		for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1; pi->y += pi->dy - (pi->y % pi->dy)) {
-			for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1; pi->x += pi->dx - (pi->x % pi->dx)) {
-				for (pi->resno = pi->poc.resno0; pi->resno < int_min(pi->poc.resno1, comp->numresolutions); pi->resno++) {
-					int levelno;
-					int trx0, try0;
-					int trx1, try1;
-					int rpx, rpy;
-					int prci, prcj;
+		for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1; pi->y += (OPJ_INT32)(pi->dy - (OPJ_UINT32)(pi->y % (OPJ_INT32)pi->dy))) {
+			for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1; pi->x += (OPJ_INT32)(pi->dx - (OPJ_UINT32)(pi->x % (OPJ_INT32)pi->dx))) {
+				for (pi->resno = pi->poc.resno0; pi->resno < opj_uint_min(pi->poc.resno1, comp->numresolutions); pi->resno++) {
+					OPJ_UINT32 levelno;
+					OPJ_INT32 trx0, try0;
+					OPJ_INT32 trx1, try1;
+					OPJ_UINT32 rpx, rpy;
+					OPJ_INT32 prci, prcj;
 					res = &comp->resolutions[pi->resno];
 					levelno = comp->numresolutions - 1 - pi->resno;
-					trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);
-					try0 = int_ceildiv(pi->ty0, comp->dy << levelno);
-					trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);
-					try1 = int_ceildiv(pi->ty1, comp->dy << levelno);
+					trx0 = opj_int_ceildiv(pi->tx0, (OPJ_INT32)(comp->dx << levelno));
+					try0 = opj_int_ceildiv(pi->ty0, (OPJ_INT32)(comp->dy << levelno));
+					trx1 = opj_int_ceildiv(pi->tx1, (OPJ_INT32)(comp->dx << levelno));
+					try1 = opj_int_ceildiv(pi->ty1, (OPJ_INT32)(comp->dy << levelno));
 					rpx = res->pdx + levelno;
 					rpy = res->pdy + levelno;
-					if (!((pi->y % (comp->dy << rpy) == 0) || ((pi->y == pi->ty0) && ((try0 << levelno) % (1 << rpy))))){
+					if (!((pi->y % (OPJ_INT32)(comp->dy << rpy) == 0) || ((pi->y == pi->ty0) && ((try0 << levelno) % (1 << rpy))))){
 						continue;	
 					}
-					if (!((pi->x % (comp->dx << rpx) == 0) || ((pi->x == pi->tx0) && ((trx0 << levelno) % (1 << rpx))))){
-						continue; 
+					if (!((pi->x % (OPJ_INT32)(comp->dx << rpx) == 0) || ((pi->x == pi->tx0) && ((trx0 << levelno) % (1 << rpx))))){
+						continue;
 					}
 					
 					if ((res->pw==0)||(res->ph==0)) continue;
 					
 					if ((trx0==trx1)||(try0==try1)) continue;
 					
-					prci = int_floordivpow2(int_ceildiv(pi->x, comp->dx << levelno), res->pdx) 
-						 - int_floordivpow2(trx0, res->pdx);
-					prcj = int_floordivpow2(int_ceildiv(pi->y, comp->dy << levelno), res->pdy) 
-						 - int_floordivpow2(try0, res->pdy);
-					pi->precno = prci + prcj * res->pw;
+					prci = opj_int_floordivpow2(opj_int_ceildiv(pi->x, (OPJ_INT32)(comp->dx << levelno)), (OPJ_INT32)res->pdx)
+						 - opj_int_floordivpow2(trx0, (OPJ_INT32)res->pdx);
+					prcj = opj_int_floordivpow2(opj_int_ceildiv(pi->y, (OPJ_INT32)(comp->dy << levelno)), (OPJ_INT32)res->pdy)
+						 - opj_int_floordivpow2(try0, (OPJ_INT32)res->pdy);
+					pi->precno = (OPJ_UINT32)(prci + prcj * (OPJ_INT32)res->pw);
 					for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {
 						index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;
 						if (!pi->include[index]) {
@@ -401,357 +552,1009 @@ LABEL_SKIP:;
 	return OPJ_FALSE;
 }
 
-/* 
-==========================================================
-   Packet iterator interface
-==========================================================
-*/
+void opj_get_encoding_parameters(	const opj_image_t *p_image,
+                                    const opj_cp_t *p_cp,
+                                    OPJ_UINT32 p_tileno,
+                                    OPJ_INT32 * p_tx0,
+                                    OPJ_INT32  * p_tx1,
+                                    OPJ_INT32  * p_ty0,
+                                    OPJ_INT32  * p_ty1,
+                                    OPJ_UINT32 * p_dx_min,
+                                    OPJ_UINT32 * p_dy_min,
+                                    OPJ_UINT32 * p_max_prec,
+                                    OPJ_UINT32 * p_max_res )
+{
+	/* loop */
+	OPJ_UINT32  compno, resno;
+	/* pointers */
+	const opj_tcp_t *l_tcp = 00;
+	const opj_tccp_t * l_tccp = 00;
+	const opj_image_comp_t * l_img_comp = 00;
 
-opj_pi_iterator_t *pi_create_decode(opj_image_t *image, opj_cp_t *cp, int tileno) {
-	int p, q;
-	int compno, resno, pino;
-	opj_pi_iterator_t *pi = NULL;
-	opj_tcp_t *tcp = NULL;
-	opj_tccp_t *tccp = NULL;
+	/* position in x and y of tile */
+	OPJ_UINT32 p, q;
 
-	tcp = &cp->tcps[tileno];
+	/* preconditions */
+	assert(p_cp != 00);
+	assert(p_image != 00);
+	assert(p_tileno < p_cp->tw * p_cp->th);
 
-	pi = (opj_pi_iterator_t*) opj_calloc((tcp->numpocs + 1), sizeof(opj_pi_iterator_t));
-	if(!pi) {
-		/* TODO: throw an error */
-		return NULL;
-	}
+	/* initializations */
+	l_tcp = &p_cp->tcps [p_tileno];
+	l_img_comp = p_image->comps;
+	l_tccp = l_tcp->tccps;
 
-	for (pino = 0; pino < tcp->numpocs + 1; pino++) {	/* change */
-		int maxres = 0;
-		int maxprec = 0;
-		p = tileno % cp->tw;
-		q = tileno / cp->tw;
+	/* here calculation of tx0, tx1, ty0, ty1, maxprec, dx and dy */
+	p = p_tileno % p_cp->tw;
+	q = p_tileno / p_cp->tw;
 
-		pi[pino].tx0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
-		pi[pino].ty0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
-		pi[pino].tx1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
-		pi[pino].ty1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
-		pi[pino].numcomps = image->numcomps;
+	/* find extent of tile */
+	*p_tx0 = opj_int_max((OPJ_INT32)(p_cp->tx0 + p * p_cp->tdx), (OPJ_INT32)p_image->x0);
+	*p_tx1 = opj_int_min((OPJ_INT32)(p_cp->tx0 + (p + 1) * p_cp->tdx), (OPJ_INT32)p_image->x1);
+	*p_ty0 = opj_int_max((OPJ_INT32)(p_cp->ty0 + q * p_cp->tdy), (OPJ_INT32)p_image->y0);
+	*p_ty1 = opj_int_min((OPJ_INT32)(p_cp->ty0 + (q + 1) * p_cp->tdy), (OPJ_INT32)p_image->y1);
 
-		pi[pino].comps = (opj_pi_comp_t*) opj_calloc(image->numcomps, sizeof(opj_pi_comp_t));
-		if(!pi[pino].comps) {
-			/* TODO: throw an error */
-			pi_destroy(pi, cp, tileno);
-			return NULL;
-		}
-		
-		for (compno = 0; compno < pi->numcomps; compno++) {
-			int tcx0, tcy0, tcx1, tcy1;
-			opj_pi_comp_t *comp = &pi[pino].comps[compno];
-			tccp = &tcp->tccps[compno];
-			comp->dx = image->comps[compno].dx;
-			comp->dy = image->comps[compno].dy;
-			comp->numresolutions = tccp->numresolutions;
+	/* max precision is 0 (can only grow) */
+	*p_max_prec = 0;
+	*p_max_res = 0;
 
-			comp->resolutions = (opj_pi_resolution_t*) opj_calloc(comp->numresolutions, sizeof(opj_pi_resolution_t));
-			if(!comp->resolutions) {
-				/* TODO: throw an error */
-				pi_destroy(pi, cp, tileno);
-				return NULL;
-			}
+	/* take the largest value for dx_min and dy_min */
+	*p_dx_min = 0x7fffffff;
+	*p_dy_min  = 0x7fffffff;
 
-			tcx0 = int_ceildiv(pi->tx0, comp->dx);
-			tcy0 = int_ceildiv(pi->ty0, comp->dy);
-			tcx1 = int_ceildiv(pi->tx1, comp->dx);
-			tcy1 = int_ceildiv(pi->ty1, comp->dy);
-			if (comp->numresolutions > maxres) {
-				maxres = comp->numresolutions;
-			}
+	for (compno = 0; compno < p_image->numcomps; ++compno) {
+		/* arithmetic variables to calculate */
+		OPJ_UINT32 l_level_no;
+		OPJ_INT32 l_rx0, l_ry0, l_rx1, l_ry1;
+		OPJ_INT32 l_px0, l_py0, l_px1, py1;
+		OPJ_UINT32 l_pdx, l_pdy;
+		OPJ_UINT32 l_pw, l_ph;
+		OPJ_UINT32 l_product;
+		OPJ_INT32 l_tcx0, l_tcy0, l_tcx1, l_tcy1;
 
-			for (resno = 0; resno < comp->numresolutions; resno++) {
-				int levelno;
-				int rx0, ry0, rx1, ry1;
-				int px0, py0, px1, py1;
-				opj_pi_resolution_t *res = &comp->resolutions[resno];
-				if (tccp->csty & J2K_CCP_CSTY_PRT) {
-					res->pdx = tccp->prcw[resno];
-					res->pdy = tccp->prch[resno];
-				} else {
-					res->pdx = 15;
-					res->pdy = 15;
-				}
-				levelno = comp->numresolutions - 1 - resno;
-				rx0 = int_ceildivpow2(tcx0, levelno);
-				ry0 = int_ceildivpow2(tcy0, levelno);
-				rx1 = int_ceildivpow2(tcx1, levelno);
-				ry1 = int_ceildivpow2(tcy1, levelno);
-				px0 = int_floordivpow2(rx0, res->pdx) << res->pdx;
-				py0 = int_floordivpow2(ry0, res->pdy) << res->pdy;
-				px1 = int_ceildivpow2(rx1, res->pdx) << res->pdx;
-				py1 = int_ceildivpow2(ry1, res->pdy) << res->pdy;
-				res->pw = (rx0==rx1)?0:((px1 - px0) >> res->pdx);
-				res->ph = (ry0==ry1)?0:((py1 - py0) >> res->pdy);
-				
-				if (res->pw*res->ph > maxprec) {
-					maxprec = res->pw*res->ph;
-				}
-				
-			}
+		l_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32)l_img_comp->dx);
+		l_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32)l_img_comp->dy);
+		l_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32)l_img_comp->dx);
+		l_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32)l_img_comp->dy);
+
+		if (l_tccp->numresolutions > *p_max_res) {
+			*p_max_res = l_tccp->numresolutions;
 		}
-		
-		tccp = &tcp->tccps[0];
-		pi[pino].step_p = 1;
-		pi[pino].step_c = maxprec * pi[pino].step_p;
-		pi[pino].step_r = image->numcomps * pi[pino].step_c;
-		pi[pino].step_l = maxres * pi[pino].step_r;
-		
-		if (pino == 0) {
-			pi[pino].include = (short int*) opj_calloc(image->numcomps * maxres * tcp->numlayers * maxprec, sizeof(short int));
-			if(!pi[pino].include) {
-				/* TODO: throw an error */
-				pi_destroy(pi, cp, tileno);
-				return NULL;
+
+		/* use custom size for precincts */
+		for (resno = 0; resno < l_tccp->numresolutions; ++resno) {
+			OPJ_UINT32 l_dx, l_dy;
+
+			/* precinct width and height */
+			l_pdx = l_tccp->prcw[resno];
+			l_pdy = l_tccp->prch[resno];
+
+			l_dx = l_img_comp->dx * (1u << (l_pdx + l_tccp->numresolutions - 1 - resno));
+			l_dy = l_img_comp->dy * (1u << (l_pdy + l_tccp->numresolutions - 1 - resno));
+
+			/* take the minimum size for dx for each comp and resolution */
+			*p_dx_min = opj_uint_min(*p_dx_min, l_dx);
+			*p_dy_min = opj_uint_min(*p_dy_min, l_dy);
+
+			/* various calculations of extents */
+			l_level_no = l_tccp->numresolutions - 1 - resno;
+
+			l_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32)l_level_no);
+			l_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32)l_level_no);
+			l_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32)l_level_no);
+			l_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32)l_level_no);
+
+			l_px0 = opj_int_floordivpow2(l_rx0, (OPJ_INT32)l_pdx) << l_pdx;
+			l_py0 = opj_int_floordivpow2(l_ry0, (OPJ_INT32)l_pdy) << l_pdy;
+			l_px1 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32)l_pdx) << l_pdx;
+
+			py1 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32)l_pdy) << l_pdy;
+
+			l_pw = (l_rx0==l_rx1)?0:(OPJ_UINT32)((l_px1 - l_px0) >> l_pdx);
+			l_ph = (l_ry0==l_ry1)?0:(OPJ_UINT32)((py1 - l_py0) >> l_pdy);
+
+			l_product = l_pw * l_ph;
+
+			/* update precision */
+			if (l_product > *p_max_prec) {
+				*p_max_prec = l_product;
 			}
 		}
-		else {
-			pi[pino].include = pi[pino - 1].include;
-		}
-		
-		if (tcp->POC == 0) {
-			pi[pino].first = 1;
-			pi[pino].poc.resno0 = 0;
-			pi[pino].poc.compno0 = 0;
-			pi[pino].poc.layno1 = tcp->numlayers;
-			pi[pino].poc.resno1 = maxres;
-			pi[pino].poc.compno1 = image->numcomps;
-			pi[pino].poc.prg = tcp->prg;
-		} else {
-			pi[pino].first = 1;
-			pi[pino].poc.resno0 = tcp->pocs[pino].resno0;
-			pi[pino].poc.compno0 = tcp->pocs[pino].compno0;
-			pi[pino].poc.layno1 = tcp->pocs[pino].layno1;
-			pi[pino].poc.resno1 = tcp->pocs[pino].resno1;
-			pi[pino].poc.compno1 = tcp->pocs[pino].compno1;
-			pi[pino].poc.prg = tcp->pocs[pino].prg;
+		++l_img_comp;
+		++l_tccp;
+	}
+}
+
+
+void opj_get_all_encoding_parameters(   const opj_image_t *p_image,
+                                        const opj_cp_t *p_cp,
+                                        OPJ_UINT32 tileno,
+                                        OPJ_INT32 * p_tx0,
+                                        OPJ_INT32 * p_tx1,
+                                        OPJ_INT32 * p_ty0,
+                                        OPJ_INT32 * p_ty1,
+                                        OPJ_UINT32 * p_dx_min,
+                                        OPJ_UINT32 * p_dy_min,
+                                        OPJ_UINT32 * p_max_prec,
+                                        OPJ_UINT32 * p_max_res,
+                                        OPJ_UINT32 ** p_resolutions )
+{
+	/* loop*/
+	OPJ_UINT32 compno, resno;
+
+	/* pointers*/
+	const opj_tcp_t *tcp = 00;
+	const opj_tccp_t * l_tccp = 00;
+	const opj_image_comp_t * l_img_comp = 00;
+
+	/* to store l_dx, l_dy, w and h for each resolution and component.*/
+	OPJ_UINT32 * lResolutionPtr;
+
+	/* position in x and y of tile*/
+	OPJ_UINT32 p, q;
+
+	/* preconditions in debug*/
+	assert(p_cp != 00);
+	assert(p_image != 00);
+	assert(tileno < p_cp->tw * p_cp->th);
+
+	/* initializations*/
+	tcp = &p_cp->tcps [tileno];
+	l_tccp = tcp->tccps;
+	l_img_comp = p_image->comps;
+
+	/* position in x and y of tile*/
+	p = tileno % p_cp->tw;
+	q = tileno / p_cp->tw;
+
+	/* here calculation of tx0, tx1, ty0, ty1, maxprec, l_dx and l_dy */
+	*p_tx0 = opj_int_max((OPJ_INT32)(p_cp->tx0 + p * p_cp->tdx), (OPJ_INT32)p_image->x0);
+	*p_tx1 = opj_int_min((OPJ_INT32)(p_cp->tx0 + (p + 1) * p_cp->tdx), (OPJ_INT32)p_image->x1);
+	*p_ty0 = opj_int_max((OPJ_INT32)(p_cp->ty0 + q * p_cp->tdy), (OPJ_INT32)p_image->y0);
+	*p_ty1 = opj_int_min((OPJ_INT32)(p_cp->ty0 + (q + 1) * p_cp->tdy), (OPJ_INT32)p_image->y1);
+
+	/* max precision and resolution is 0 (can only grow)*/
+	*p_max_prec = 0;
+	*p_max_res = 0;
+
+	/* take the largest value for dx_min and dy_min*/
+	*p_dx_min = 0x7fffffff;
+	*p_dy_min = 0x7fffffff;
+
+	for (compno = 0; compno < p_image->numcomps; ++compno) {
+		/* aritmetic variables to calculate*/
+		OPJ_UINT32 l_level_no;
+		OPJ_INT32 l_rx0, l_ry0, l_rx1, l_ry1;
+		OPJ_INT32 l_px0, l_py0, l_px1, py1;
+		OPJ_UINT32 l_product;
+		OPJ_INT32 l_tcx0, l_tcy0, l_tcx1, l_tcy1;
+		OPJ_UINT32 l_pdx, l_pdy , l_pw , l_ph;
+
+		lResolutionPtr = p_resolutions[compno];
+
+		l_tcx0 = opj_int_ceildiv(*p_tx0, (OPJ_INT32)l_img_comp->dx);
+		l_tcy0 = opj_int_ceildiv(*p_ty0, (OPJ_INT32)l_img_comp->dy);
+		l_tcx1 = opj_int_ceildiv(*p_tx1, (OPJ_INT32)l_img_comp->dx);
+		l_tcy1 = opj_int_ceildiv(*p_ty1, (OPJ_INT32)l_img_comp->dy);
+
+		if (l_tccp->numresolutions > *p_max_res) {
+			*p_max_res = l_tccp->numresolutions;
 		}
-		pi[pino].poc.layno0  = 0;
-		pi[pino].poc.precno0 = 0; 
-		pi[pino].poc.precno1 = maxprec;
+
+		/* use custom size for precincts*/
+		l_level_no = l_tccp->numresolutions - 1;
+		for (resno = 0; resno < l_tccp->numresolutions; ++resno) {
+			OPJ_UINT32 l_dx, l_dy;
+
+			/* precinct width and height*/
+			l_pdx = l_tccp->prcw[resno];
+			l_pdy = l_tccp->prch[resno];
+			*lResolutionPtr++ = l_pdx;
+			*lResolutionPtr++ = l_pdy;
+			l_dx = l_img_comp->dx * (1u << (l_pdx + l_level_no));
+			l_dy = l_img_comp->dy * (1u << (l_pdy + l_level_no));
+			/* take the minimum size for l_dx for each comp and resolution*/
+			*p_dx_min = (OPJ_UINT32)opj_int_min((OPJ_INT32)*p_dx_min, (OPJ_INT32)l_dx);
+			*p_dy_min = (OPJ_UINT32)opj_int_min((OPJ_INT32)*p_dy_min, (OPJ_INT32)l_dy);
+
+			/* various calculations of extents*/
+			l_rx0 = opj_int_ceildivpow2(l_tcx0, (OPJ_INT32)l_level_no);
+			l_ry0 = opj_int_ceildivpow2(l_tcy0, (OPJ_INT32)l_level_no);
+			l_rx1 = opj_int_ceildivpow2(l_tcx1, (OPJ_INT32)l_level_no);
+			l_ry1 = opj_int_ceildivpow2(l_tcy1, (OPJ_INT32)l_level_no);
+			l_px0 = opj_int_floordivpow2(l_rx0, (OPJ_INT32)l_pdx) << l_pdx;
+			l_py0 = opj_int_floordivpow2(l_ry0, (OPJ_INT32)l_pdy) << l_pdy;
+			l_px1 = opj_int_ceildivpow2(l_rx1, (OPJ_INT32)l_pdx) << l_pdx;
+			py1 = opj_int_ceildivpow2(l_ry1, (OPJ_INT32)l_pdy) << l_pdy;
+			l_pw = (l_rx0==l_rx1)?0:(OPJ_UINT32)((l_px1 - l_px0) >> l_pdx);
+			l_ph = (l_ry0==l_ry1)?0:(OPJ_UINT32)((py1 - l_py0) >> l_pdy);
+			*lResolutionPtr++ = l_pw;
+			*lResolutionPtr++ = l_ph;
+			l_product = l_pw * l_ph;
 			
+            /* update precision*/
+			if (l_product > *p_max_prec) {
+				*p_max_prec = l_product;
+			}
+
+			--l_level_no;
+		}
+		++l_tccp;
+		++l_img_comp;
 	}
-	
-	return pi;
 }
 
+opj_pi_iterator_t * opj_pi_create(	const opj_image_t *image,
+                                    const opj_cp_t *cp,
+                                    OPJ_UINT32 tileno )
+{
+	/* loop*/
+	OPJ_UINT32 pino, compno;
+	/* number of poc in the p_pi*/
+	OPJ_UINT32 l_poc_bound;
 
-opj_pi_iterator_t *pi_initialise_encode(opj_image_t *image, opj_cp_t *cp, int tileno, J2K_T2_MODE t2_mode){ 
-	int p, q, pino;
-	int compno, resno;
-	int maxres = 0;
-	int maxprec = 0;
-	opj_pi_iterator_t *pi = NULL;
-	opj_tcp_t *tcp = NULL;
-	opj_tccp_t *tccp = NULL;
-	
+	/* pointers to tile coding parameters and components.*/
+	opj_pi_iterator_t *l_pi = 00;
+	opj_tcp_t *tcp = 00;
+	const opj_tccp_t *tccp = 00;
+
+	/* current packet iterator being allocated*/
+	opj_pi_iterator_t *l_current_pi = 00;
+
+	/* preconditions in debug*/
+	assert(cp != 00);
+	assert(image != 00);
+	assert(tileno < cp->tw * cp->th);
+
+	/* initializations*/
 	tcp = &cp->tcps[tileno];
+	l_poc_bound = tcp->numpocs+1;
 
-	pi = (opj_pi_iterator_t*) opj_calloc((tcp->numpocs + 1), sizeof(opj_pi_iterator_t));
-	if(!pi) {	return NULL;}
-	pi->tp_on = cp->tp_on;
-
-	for(pino = 0;pino < tcp->numpocs+1 ; pino ++){
-		p = tileno % cp->tw;
-		q = tileno / cp->tw;
-
-		pi[pino].tx0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
-		pi[pino].ty0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
-		pi[pino].tx1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
-		pi[pino].ty1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
-		pi[pino].numcomps = image->numcomps;
-		
-		pi[pino].comps = (opj_pi_comp_t*) opj_calloc(image->numcomps, sizeof(opj_pi_comp_t));
-		if(!pi[pino].comps) {
-			pi_destroy(pi, cp, tileno);
+	/* memory allocations*/
+	l_pi = (opj_pi_iterator_t*) opj_calloc((l_poc_bound), sizeof(opj_pi_iterator_t));
+	if (!l_pi) {
+		return NULL;
+	}
+	memset(l_pi,0,l_poc_bound * sizeof(opj_pi_iterator_t));
+
+	l_current_pi = l_pi;
+	for (pino = 0; pino < l_poc_bound ; ++pino) {
+
+		l_current_pi->comps = (opj_pi_comp_t*) opj_calloc(image->numcomps, sizeof(opj_pi_comp_t));
+		if (! l_current_pi->comps) {
+			opj_pi_destroy(l_pi, l_poc_bound);
 			return NULL;
 		}
-		
-		for (compno = 0; compno < pi[pino].numcomps; compno++) {
-			int tcx0, tcy0, tcx1, tcy1;
-			opj_pi_comp_t *comp = &pi[pino].comps[compno];
-			tccp = &tcp->tccps[compno];
-			comp->dx = image->comps[compno].dx;
-			comp->dy = image->comps[compno].dy;
-			comp->numresolutions = tccp->numresolutions;
 
-			comp->resolutions = (opj_pi_resolution_t*) opj_malloc(comp->numresolutions * sizeof(opj_pi_resolution_t));
-			if(!comp->resolutions) {
-				pi_destroy(pi, cp, tileno);
-				return NULL;
-			}
+		l_current_pi->numcomps = image->numcomps;
+		memset(l_current_pi->comps,0,image->numcomps * sizeof(opj_pi_comp_t));
 
-			tcx0 = int_ceildiv(pi[pino].tx0, comp->dx);
-			tcy0 = int_ceildiv(pi[pino].ty0, comp->dy);
-			tcx1 = int_ceildiv(pi[pino].tx1, comp->dx);
-			tcy1 = int_ceildiv(pi[pino].ty1, comp->dy);
-			if (comp->numresolutions > maxres) {
-				maxres = comp->numresolutions;
-			}
+		for (compno = 0; compno < image->numcomps; ++compno) {
+			opj_pi_comp_t *comp = &l_current_pi->comps[compno];
 
-			for (resno = 0; resno < comp->numresolutions; resno++) {
-				int levelno;
-				int rx0, ry0, rx1, ry1;
-				int px0, py0, px1, py1;
-				opj_pi_resolution_t *res = &comp->resolutions[resno];
-				if (tccp->csty & J2K_CCP_CSTY_PRT) {
-					res->pdx = tccp->prcw[resno];
-					res->pdy = tccp->prch[resno];
-				} else {
-					res->pdx = 15;
-					res->pdy = 15;
-				}
-				levelno = comp->numresolutions - 1 - resno;
-				rx0 = int_ceildivpow2(tcx0, levelno);
-				ry0 = int_ceildivpow2(tcy0, levelno);
-				rx1 = int_ceildivpow2(tcx1, levelno);
-				ry1 = int_ceildivpow2(tcy1, levelno);
-				px0 = int_floordivpow2(rx0, res->pdx) << res->pdx;
-				py0 = int_floordivpow2(ry0, res->pdy) << res->pdy;
-				px1 = int_ceildivpow2(rx1, res->pdx) << res->pdx;
-				py1 = int_ceildivpow2(ry1, res->pdy) << res->pdy;
-				res->pw = (rx0==rx1)?0:((px1 - px0) >> res->pdx);
-				res->ph = (ry0==ry1)?0:((py1 - py0) >> res->pdy);
-
-				if (res->pw*res->ph > maxprec) {
-					maxprec = res->pw * res->ph;
-				}
+			tccp = &tcp->tccps[compno];
+
+			comp->resolutions = (opj_pi_resolution_t*) opj_malloc(tccp->numresolutions * sizeof(opj_pi_resolution_t));
+			if (!comp->resolutions) {
+				opj_pi_destroy(l_pi, l_poc_bound);
+				return 00;
 			}
+
+			comp->numresolutions = tccp->numresolutions;
+			memset(comp->resolutions,0,tccp->numresolutions * sizeof(opj_pi_resolution_t));
 		}
-		
-		tccp = &tcp->tccps[0];
-		pi[pino].step_p = 1;
-		pi[pino].step_c = maxprec * pi[pino].step_p;
-		pi[pino].step_r = image->numcomps * pi[pino].step_c;
-		pi[pino].step_l = maxres * pi[pino].step_r;
-		
-		for (compno = 0; compno < pi->numcomps; compno++) {
-			opj_pi_comp_t *comp = &pi->comps[compno];
-			for (resno = 0; resno < comp->numresolutions; resno++) {
-				int dx, dy;
-				opj_pi_resolution_t *res = &comp->resolutions[resno];
-				dx = comp->dx * (1 << (res->pdx + comp->numresolutions - 1 - resno));
-				dy = comp->dy * (1 << (res->pdy + comp->numresolutions - 1 - resno));
-				pi[pino].dx = !pi->dx ? dx : int_min(pi->dx, dx);
-				pi[pino].dy = !pi->dy ? dy : int_min(pi->dy, dy);
-			}
+		++l_current_pi;
+	}
+	return l_pi;
+}
+
+void opj_pi_update_encode_poc_and_final (   opj_cp_t *p_cp,
+                                            OPJ_UINT32 p_tileno,
+                                            OPJ_INT32 p_tx0,
+                                            OPJ_INT32 p_tx1,
+                                            OPJ_INT32 p_ty0,
+                                            OPJ_INT32 p_ty1,
+                                            OPJ_UINT32 p_max_prec,
+                                            OPJ_UINT32 p_max_res,
+                                            OPJ_UINT32 p_dx_min,
+                                            OPJ_UINT32 p_dy_min)
+{
+	/* loop*/
+	OPJ_UINT32 pino;
+	/* tile coding parameter*/
+	opj_tcp_t *l_tcp = 00;
+	/* current poc being updated*/
+	opj_poc_t * l_current_poc = 00;
+
+	/* number of pocs*/
+	OPJ_UINT32 l_poc_bound;
+
+    OPJ_ARG_NOT_USED(p_max_res);
+
+	/* preconditions in debug*/
+	assert(p_cp != 00);
+	assert(p_tileno < p_cp->tw * p_cp->th);
+
+	/* initializations*/
+	l_tcp = &p_cp->tcps [p_tileno];
+	/* number of iterations in the loop */
+	l_poc_bound = l_tcp->numpocs+1;
+
+	/* start at first element, and to make sure the compiler will not make a calculation each time in the loop
+	   store a pointer to the current element to modify rather than l_tcp->pocs[i]*/
+	l_current_poc = l_tcp->pocs;
+
+	l_current_poc->compS = l_current_poc->compno0;
+	l_current_poc->compE = l_current_poc->compno1;
+	l_current_poc->resS = l_current_poc->resno0;
+	l_current_poc->resE = l_current_poc->resno1;
+	l_current_poc->layE = l_current_poc->layno1;
+
+	/* special treatment for the first element*/
+	l_current_poc->layS = 0;
+	l_current_poc->prg  = l_current_poc->prg1;
+	l_current_poc->prcS = 0;
+
+	l_current_poc->prcE = p_max_prec;
+	l_current_poc->txS = (OPJ_UINT32)p_tx0;
+	l_current_poc->txE = (OPJ_UINT32)p_tx1;
+	l_current_poc->tyS = (OPJ_UINT32)p_ty0;
+	l_current_poc->tyE = (OPJ_UINT32)p_ty1;
+	l_current_poc->dx = p_dx_min;
+	l_current_poc->dy = p_dy_min;
+
+	++ l_current_poc;
+	for (pino = 1;pino < l_poc_bound ; ++pino) {
+		l_current_poc->compS = l_current_poc->compno0;
+		l_current_poc->compE= l_current_poc->compno1;
+		l_current_poc->resS = l_current_poc->resno0;
+		l_current_poc->resE = l_current_poc->resno1;
+		l_current_poc->layE = l_current_poc->layno1;
+		l_current_poc->prg  = l_current_poc->prg1;
+		l_current_poc->prcS = 0;
+		/* special treatment here different from the first element*/
+		l_current_poc->layS = (l_current_poc->layE > (l_current_poc-1)->layE) ? l_current_poc->layE : 0;
+
+		l_current_poc->prcE = p_max_prec;
+		l_current_poc->txS = (OPJ_UINT32)p_tx0;
+		l_current_poc->txE = (OPJ_UINT32)p_tx1;
+		l_current_poc->tyS = (OPJ_UINT32)p_ty0;
+		l_current_poc->tyE = (OPJ_UINT32)p_ty1;
+		l_current_poc->dx = p_dx_min;
+		l_current_poc->dy = p_dy_min;
+		++ l_current_poc;
+	}
+}
+
+void opj_pi_update_encode_not_poc (	opj_cp_t *p_cp,
+                                    OPJ_UINT32 p_num_comps,
+                                    OPJ_UINT32 p_tileno,
+                                    OPJ_INT32 p_tx0,
+                                    OPJ_INT32 p_tx1,
+                                    OPJ_INT32 p_ty0,
+                                    OPJ_INT32 p_ty1,
+                                    OPJ_UINT32 p_max_prec,
+                                    OPJ_UINT32 p_max_res,
+                                    OPJ_UINT32 p_dx_min,
+                                    OPJ_UINT32 p_dy_min)
+{
+	/* loop*/
+	OPJ_UINT32 pino;
+	/* tile coding parameter*/
+	opj_tcp_t *l_tcp = 00;
+	/* current poc being updated*/
+	opj_poc_t * l_current_poc = 00;
+	/* number of pocs*/
+	OPJ_UINT32 l_poc_bound;
+
+	/* preconditions in debug*/
+	assert(p_cp != 00);
+	assert(p_tileno < p_cp->tw * p_cp->th);
+
+	/* initializations*/
+	l_tcp = &p_cp->tcps [p_tileno];
+
+	/* number of iterations in the loop */
+	l_poc_bound = l_tcp->numpocs+1;
+
+	/* start at first element, and to make sure the compiler will not make a calculation each time in the loop
+	   store a pointer to the current element to modify rather than l_tcp->pocs[i]*/
+	l_current_poc = l_tcp->pocs;
+
+	for (pino = 0; pino < l_poc_bound ; ++pino) {
+		l_current_poc->compS = 0;
+		l_current_poc->compE = p_num_comps;/*p_image->numcomps;*/
+		l_current_poc->resS = 0;
+		l_current_poc->resE = p_max_res;
+		l_current_poc->layS = 0;
+		l_current_poc->layE = l_tcp->numlayers;
+		l_current_poc->prg  = l_tcp->prg;
+		l_current_poc->prcS = 0;
+		l_current_poc->prcE = p_max_prec;
+		l_current_poc->txS = (OPJ_UINT32)p_tx0;
+		l_current_poc->txE = (OPJ_UINT32)p_tx1;
+		l_current_poc->tyS = (OPJ_UINT32)p_ty0;
+		l_current_poc->tyE = (OPJ_UINT32)p_ty1;
+		l_current_poc->dx = p_dx_min;
+		l_current_poc->dy = p_dy_min;
+		++ l_current_poc;
+	}
+}
+
+void opj_pi_update_decode_poc (opj_pi_iterator_t * p_pi,
+                               opj_tcp_t * p_tcp,
+                               OPJ_UINT32 p_max_precision,
+                               OPJ_UINT32 p_max_res)
+{
+	/* loop*/
+	OPJ_UINT32 pino;
+
+	/* encoding prameters to set*/
+	OPJ_UINT32 l_bound;
+
+	opj_pi_iterator_t * l_current_pi = 00;
+	opj_poc_t* l_current_poc = 0;
+
+    OPJ_ARG_NOT_USED(p_max_res);
+
+	/* preconditions in debug*/
+	assert(p_pi != 00);
+	assert(p_tcp != 00);
+
+	/* initializations*/
+	l_bound = p_tcp->numpocs+1;
+	l_current_pi = p_pi;
+	l_current_poc = p_tcp->pocs;
+
+	for	(pino = 0;pino<l_bound;++pino) {
+		l_current_pi->poc.prg = l_current_poc->prg; /* Progression Order #0 */
+		l_current_pi->first = 1;
+
+		l_current_pi->poc.resno0 = l_current_poc->resno0; /* Resolution Level Index #0 (Start) */
+		l_current_pi->poc.compno0 = l_current_poc->compno0; /* Component Index #0 (Start) */
+		l_current_pi->poc.layno0 = 0;
+		l_current_pi->poc.precno0 = 0;
+		l_current_pi->poc.resno1 = l_current_poc->resno1; /* Resolution Level Index #0 (End) */
+		l_current_pi->poc.compno1 = l_current_poc->compno1; /* Component Index #0 (End) */
+		l_current_pi->poc.layno1 = l_current_poc->layno1; /* Layer Index #0 (End) */
+		l_current_pi->poc.precno1 = p_max_precision;
+		++l_current_pi;
+		++l_current_poc;
+	}
+}
+
+void opj_pi_update_decode_not_poc (opj_pi_iterator_t * p_pi,
+                                   opj_tcp_t * p_tcp,
+                                   OPJ_UINT32 p_max_precision,
+                                   OPJ_UINT32 p_max_res)
+{
+	/* loop*/
+	OPJ_UINT32 pino;
+
+	/* encoding prameters to set*/
+	OPJ_UINT32 l_bound;
+
+	opj_pi_iterator_t * l_current_pi = 00;
+	/* preconditions in debug*/
+	assert(p_tcp != 00);
+	assert(p_pi != 00);
+
+	/* initializations*/
+	l_bound = p_tcp->numpocs+1;
+	l_current_pi = p_pi;
+
+	for (pino = 0;pino<l_bound;++pino) {
+		l_current_pi->poc.prg = p_tcp->prg;
+		l_current_pi->first = 1;
+		l_current_pi->poc.resno0 = 0;
+		l_current_pi->poc.compno0 = 0;
+		l_current_pi->poc.layno0 = 0;
+		l_current_pi->poc.precno0 = 0;
+		l_current_pi->poc.resno1 = p_max_res;
+		l_current_pi->poc.compno1 = l_current_pi->numcomps;
+		l_current_pi->poc.layno1 = p_tcp->numlayers;
+		l_current_pi->poc.precno1 = p_max_precision;
+		++l_current_pi;
+	}
+}
+
+
+
+OPJ_BOOL opj_pi_check_next_level(	OPJ_INT32 pos,
+								opj_cp_t *cp,
+								OPJ_UINT32 tileno,
+								OPJ_UINT32 pino,
+								const OPJ_CHAR *prog)
+{
+	OPJ_INT32 i;
+	opj_tcp_t *tcps =&cp->tcps[tileno];
+	opj_poc_t *tcp = &tcps->pocs[pino];
+
+	if(pos>=0){
+		for(i=pos;pos>=0;i--){
+			switch(prog[i]){
+		    case 'R':
+			    if(tcp->res_t==tcp->resE){
+				    if(opj_pi_check_next_level(pos-1,cp,tileno,pino,prog)){
+					    return OPJ_TRUE;
+				    }else{
+					    return OPJ_FALSE;
+				    }
+			    }else{
+				    return OPJ_TRUE;
+			    }
+			    break;
+		    case 'C':
+			    if(tcp->comp_t==tcp->compE){
+				    if(opj_pi_check_next_level(pos-1,cp,tileno,pino,prog)){
+					    return OPJ_TRUE;
+				    }else{
+					    return OPJ_FALSE;
+				    }
+			    }else{
+				    return OPJ_TRUE;
+			    }
+			    break;
+		    case 'L':
+			    if(tcp->lay_t==tcp->layE){
+				    if(opj_pi_check_next_level(pos-1,cp,tileno,pino,prog)){
+					    return OPJ_TRUE;
+				    }else{
+					    return OPJ_FALSE;
+				    }
+			    }else{
+				    return OPJ_TRUE;
+			    }
+			    break;
+		    case 'P':
+			    switch(tcp->prg){
+				    case OPJ_LRCP||OPJ_RLCP:
+					    if(tcp->prc_t == tcp->prcE){
+						    if(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){
+							    return OPJ_TRUE;
+						    }else{
+							    return OPJ_FALSE;
+						    }
+					    }else{
+						    return OPJ_TRUE;
+					    }
+					    break;
+			    default:
+				    if(tcp->tx0_t == tcp->txE){
+					    /*TY*/
+					    if(tcp->ty0_t == tcp->tyE){
+						    if(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){
+							    return OPJ_TRUE;
+						    }else{
+							    return OPJ_FALSE;
+						    }
+					    }else{
+						    return OPJ_TRUE;
+					    }/*TY*/
+				    }else{
+					    return OPJ_TRUE;
+				    }
+				    break;
+			    }/*end case P*/
+		    }/*end switch*/
+		}/*end for*/
+	}/*end if*/
+	return OPJ_FALSE;
+}
+
+
+/*
+==========================================================
+   Packet iterator interface
+==========================================================
+*/
+opj_pi_iterator_t *opj_pi_create_decode(opj_image_t *p_image,
+										opj_cp_t *p_cp,
+										OPJ_UINT32 p_tile_no)
+{
+	/* loop */
+	OPJ_UINT32 pino;
+	OPJ_UINT32 compno, resno;
+
+	/* to store w, h, dx and dy fro all components and resolutions */
+	OPJ_UINT32 * l_tmp_data;
+	OPJ_UINT32 ** l_tmp_ptr;
+
+	/* encoding prameters to set */
+	OPJ_UINT32 l_max_res;
+	OPJ_UINT32 l_max_prec;
+	OPJ_INT32 l_tx0,l_tx1,l_ty0,l_ty1;
+	OPJ_UINT32 l_dx_min,l_dy_min;
+	OPJ_UINT32 l_bound;
+	OPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ;
+	OPJ_UINT32 l_data_stride;
+
+	/* pointers */
+	opj_pi_iterator_t *l_pi = 00;
+	opj_tcp_t *l_tcp = 00;
+	const opj_tccp_t *l_tccp = 00;
+	opj_pi_comp_t *l_current_comp = 00;
+	opj_image_comp_t * l_img_comp = 00;
+	opj_pi_iterator_t * l_current_pi = 00;
+	OPJ_UINT32 * l_encoding_value_ptr = 00;
+
+	/* preconditions in debug */
+	assert(p_cp != 00);
+	assert(p_image != 00);
+	assert(p_tile_no < p_cp->tw * p_cp->th);
+
+	/* initializations */
+	l_tcp = &p_cp->tcps[p_tile_no];
+	l_bound = l_tcp->numpocs+1;
+
+	l_data_stride = 4 * OPJ_J2K_MAXRLVLS;
+	l_tmp_data = (OPJ_UINT32*)opj_malloc(
+		l_data_stride * p_image->numcomps * sizeof(OPJ_UINT32));
+	if
+		(! l_tmp_data)
+	{
+		return 00;
+	}
+	l_tmp_ptr = (OPJ_UINT32**)opj_malloc(
+		p_image->numcomps * sizeof(OPJ_UINT32 *));
+	if
+		(! l_tmp_ptr)
+	{
+		opj_free(l_tmp_data);
+		return 00;
+	}
+
+	/* memory allocation for pi */
+	l_pi = opj_pi_create(p_image, p_cp, p_tile_no);
+	if (!l_pi) {
+		opj_free(l_tmp_data);
+		opj_free(l_tmp_ptr);
+		return 00;
+	}
+
+	l_encoding_value_ptr = l_tmp_data;
+	/* update pointer array */
+	for
+		(compno = 0; compno < p_image->numcomps; ++compno)
+	{
+		l_tmp_ptr[compno] = l_encoding_value_ptr;
+		l_encoding_value_ptr += l_data_stride;
+	}
+	/* get encoding parameters */
+	opj_get_all_encoding_parameters(p_image,p_cp,p_tile_no,&l_tx0,&l_tx1,&l_ty0,&l_ty1,&l_dx_min,&l_dy_min,&l_max_prec,&l_max_res,l_tmp_ptr);
+
+	/* step calculations */
+	l_step_p = 1;
+	l_step_c = l_max_prec * l_step_p;
+	l_step_r = p_image->numcomps * l_step_c;
+	l_step_l = l_max_res * l_step_r;
+
+	/* set values for first packet iterator */
+	l_current_pi = l_pi;
+
+	/* memory allocation for include */
+	l_current_pi->include = (OPJ_INT16*) opj_calloc((l_tcp->numlayers +1) * l_step_l, sizeof(OPJ_INT16));
+	if
+		(!l_current_pi->include)
+	{
+		opj_free(l_tmp_data);
+		opj_free(l_tmp_ptr);
+		opj_pi_destroy(l_pi, l_bound);
+		return 00;
+	}
+	memset(l_current_pi->include,0, (l_tcp->numlayers + 1) * l_step_l* sizeof(OPJ_INT16));
+
+	/* special treatment for the first packet iterator */
+	l_current_comp = l_current_pi->comps;
+	l_img_comp = p_image->comps;
+	l_tccp = l_tcp->tccps;
+
+	l_current_pi->tx0 = l_tx0;
+	l_current_pi->ty0 = l_ty0;
+	l_current_pi->tx1 = l_tx1;
+	l_current_pi->ty1 = l_ty1;
+
+	/*l_current_pi->dx = l_img_comp->dx;*/
+	/*l_current_pi->dy = l_img_comp->dy;*/
+
+	l_current_pi->step_p = l_step_p;
+	l_current_pi->step_c = l_step_c;
+	l_current_pi->step_r = l_step_r;
+	l_current_pi->step_l = l_step_l;
+
+	/* allocation for components and number of components has already been calculated by opj_pi_create */
+	for
+		(compno = 0; compno < l_current_pi->numcomps; ++compno)
+	{
+		opj_pi_resolution_t *l_res = l_current_comp->resolutions;
+		l_encoding_value_ptr = l_tmp_ptr[compno];
+
+		l_current_comp->dx = l_img_comp->dx;
+		l_current_comp->dy = l_img_comp->dy;
+		/* resolutions have already been initialized */
+		for
+			(resno = 0; resno < l_current_comp->numresolutions; resno++)
+		{
+			l_res->pdx = *(l_encoding_value_ptr++);
+			l_res->pdy = *(l_encoding_value_ptr++);
+			l_res->pw =  *(l_encoding_value_ptr++);
+			l_res->ph =  *(l_encoding_value_ptr++);
+			++l_res;
 		}
+		++l_current_comp;
+		++l_img_comp;
+		++l_tccp;
+	}
+	++l_current_pi;
+
+	for (pino = 1 ; pino<l_bound ; ++pino )
+	{
+		l_current_comp = l_current_pi->comps;
+		l_img_comp = p_image->comps;
+		l_tccp = l_tcp->tccps;
 
-		if (pino == 0) {
-			pi[pino].include = (short int*) opj_calloc(tcp->numlayers * pi[pino].step_l, sizeof(short int));
-			if(!pi[pino].include) {
-				pi_destroy(pi, cp, tileno);
-				return NULL;
+		l_current_pi->tx0 = l_tx0;
+		l_current_pi->ty0 = l_ty0;
+		l_current_pi->tx1 = l_tx1;
+		l_current_pi->ty1 = l_ty1;
+		/*l_current_pi->dx = l_dx_min;*/
+		/*l_current_pi->dy = l_dy_min;*/
+		l_current_pi->step_p = l_step_p;
+		l_current_pi->step_c = l_step_c;
+		l_current_pi->step_r = l_step_r;
+		l_current_pi->step_l = l_step_l;
+
+		/* allocation for components and number of components has already been calculated by opj_pi_create */
+		for
+			(compno = 0; compno < l_current_pi->numcomps; ++compno)
+		{
+			opj_pi_resolution_t *l_res = l_current_comp->resolutions;
+			l_encoding_value_ptr = l_tmp_ptr[compno];
+
+			l_current_comp->dx = l_img_comp->dx;
+			l_current_comp->dy = l_img_comp->dy;
+			/* resolutions have already been initialized */
+			for
+				(resno = 0; resno < l_current_comp->numresolutions; resno++)
+			{
+				l_res->pdx = *(l_encoding_value_ptr++);
+				l_res->pdy = *(l_encoding_value_ptr++);
+				l_res->pw =  *(l_encoding_value_ptr++);
+				l_res->ph =  *(l_encoding_value_ptr++);
+				++l_res;
 			}
+			++l_current_comp;
+			++l_img_comp;
+			++l_tccp;
 		}
-		else {
-			pi[pino].include = pi[pino - 1].include;
-		}
-		
-		/* Generation of boundaries for each prog flag*/
-			if(tcp->POC && ( cp->cinema || ((!cp->cinema) && (t2_mode == FINAL_PASS)))){
-				tcp->pocs[pino].compS= tcp->pocs[pino].compno0;
-				tcp->pocs[pino].compE= tcp->pocs[pino].compno1;
-				tcp->pocs[pino].resS = tcp->pocs[pino].resno0;
-				tcp->pocs[pino].resE = tcp->pocs[pino].resno1;
-				tcp->pocs[pino].layE = tcp->pocs[pino].layno1;
-				tcp->pocs[pino].prg  = tcp->pocs[pino].prg1;
-				if (pino > 0)
-					tcp->pocs[pino].layS = (tcp->pocs[pino].layE > tcp->pocs[pino - 1].layE) ? tcp->pocs[pino - 1].layE : 0;
-			}else {
-				tcp->pocs[pino].compS= 0;
-				tcp->pocs[pino].compE= image->numcomps;
-				tcp->pocs[pino].resS = 0;
-				tcp->pocs[pino].resE = maxres;
-				tcp->pocs[pino].layS = 0;
-				tcp->pocs[pino].layE = tcp->numlayers;
-				tcp->pocs[pino].prg  = tcp->prg;
-			}
-			tcp->pocs[pino].prcS = 0;
-			tcp->pocs[pino].prcE = maxprec;;
-			tcp->pocs[pino].txS = pi[pino].tx0;
-			tcp->pocs[pino].txE = pi[pino].tx1;
-			tcp->pocs[pino].tyS = pi[pino].ty0;
-			tcp->pocs[pino].tyE = pi[pino].ty1;
-			tcp->pocs[pino].dx = pi[pino].dx;
-			tcp->pocs[pino].dy = pi[pino].dy;
+		/* special treatment*/
+		l_current_pi->include = (l_current_pi-1)->include;
+		++l_current_pi;
+	}
+	opj_free(l_tmp_data);
+	l_tmp_data = 00;
+	opj_free(l_tmp_ptr);
+	l_tmp_ptr = 00;
+	if
+		(l_tcp->POC)
+	{
+		opj_pi_update_decode_poc (l_pi,l_tcp,l_max_prec,l_max_res);
+	}
+	else
+	{
+		opj_pi_update_decode_not_poc(l_pi,l_tcp,l_max_prec,l_max_res);
+	}
+	return l_pi;
+}
+
+
+
+opj_pi_iterator_t *opj_pi_initialise_encode(const opj_image_t *p_image,
+                                            opj_cp_t *p_cp,
+                                            OPJ_UINT32 p_tile_no,
+                                            J2K_T2_MODE p_t2_mode )
+{
+	/* loop*/
+	OPJ_UINT32 pino;
+	OPJ_UINT32 compno, resno;
+
+	/* to store w, h, dx and dy fro all components and resolutions*/
+	OPJ_UINT32 * l_tmp_data;
+	OPJ_UINT32 ** l_tmp_ptr;
+
+	/* encoding prameters to set*/
+	OPJ_UINT32 l_max_res;
+	OPJ_UINT32 l_max_prec;
+	OPJ_INT32 l_tx0,l_tx1,l_ty0,l_ty1;
+	OPJ_UINT32 l_dx_min,l_dy_min;
+	OPJ_UINT32 l_bound;
+	OPJ_UINT32 l_step_p , l_step_c , l_step_r , l_step_l ;
+	OPJ_UINT32 l_data_stride;
+
+	/* pointers*/
+	opj_pi_iterator_t *l_pi = 00;
+	opj_tcp_t *l_tcp = 00;
+	const opj_tccp_t *l_tccp = 00;
+	opj_pi_comp_t *l_current_comp = 00;
+	opj_image_comp_t * l_img_comp = 00;
+	opj_pi_iterator_t * l_current_pi = 00;
+	OPJ_UINT32 * l_encoding_value_ptr = 00;
+
+	/* preconditions in debug*/
+	assert(p_cp != 00);
+	assert(p_image != 00);
+	assert(p_tile_no < p_cp->tw * p_cp->th);
+
+	/* initializations*/
+	l_tcp = &p_cp->tcps[p_tile_no];
+	l_bound = l_tcp->numpocs+1;
+
+	l_data_stride = 4 * OPJ_J2K_MAXRLVLS;
+	l_tmp_data = (OPJ_UINT32*)opj_malloc(
+		l_data_stride * p_image->numcomps * sizeof(OPJ_UINT32));
+	if (! l_tmp_data) {
+		return 00;
+	}
+
+	l_tmp_ptr = (OPJ_UINT32**)opj_malloc(
+		p_image->numcomps * sizeof(OPJ_UINT32 *));
+	if (! l_tmp_ptr) {
+		opj_free(l_tmp_data);
+		return 00;
+	}
+
+	/* memory allocation for pi*/
+	l_pi = opj_pi_create(p_image,p_cp,p_tile_no);
+	if (!l_pi) {
+		opj_free(l_tmp_data);
+		opj_free(l_tmp_ptr);
+		return 00;
+	}
+
+	l_encoding_value_ptr = l_tmp_data;
+	/* update pointer array*/
+	for (compno = 0; compno < p_image->numcomps; ++compno) {
+		l_tmp_ptr[compno] = l_encoding_value_ptr;
+		l_encoding_value_ptr += l_data_stride;
+	}
+
+	/* get encoding parameters*/
+	opj_get_all_encoding_parameters(p_image,p_cp,p_tile_no,&l_tx0,&l_tx1,&l_ty0,&l_ty1,&l_dx_min,&l_dy_min,&l_max_prec,&l_max_res,l_tmp_ptr);
+
+	/* step calculations*/
+	l_step_p = 1;
+	l_step_c = l_max_prec * l_step_p;
+	l_step_r = p_image->numcomps * l_step_c;
+	l_step_l = l_max_res * l_step_r;
+
+	/* set values for first packet iterator*/
+	l_pi->tp_on = p_cp->m_specific_param.m_enc.m_tp_on;
+	l_current_pi = l_pi;
+
+	/* memory allocation for include*/
+	l_current_pi->include = (OPJ_INT16*) opj_calloc(l_tcp->numlayers * l_step_l, sizeof(OPJ_INT16));
+	if (!l_current_pi->include) {
+		opj_free(l_tmp_data);
+		opj_free(l_tmp_ptr);
+		opj_pi_destroy(l_pi, l_bound);
+		return 00;
+	}
+	memset(l_current_pi->include,0,l_tcp->numlayers * l_step_l* sizeof(OPJ_INT16));
+
+	/* special treatment for the first packet iterator*/
+	l_current_comp = l_current_pi->comps;
+	l_img_comp = p_image->comps;
+	l_tccp = l_tcp->tccps;
+	l_current_pi->tx0 = l_tx0;
+	l_current_pi->ty0 = l_ty0;
+	l_current_pi->tx1 = l_tx1;
+	l_current_pi->ty1 = l_ty1;
+	l_current_pi->dx = l_dx_min;
+	l_current_pi->dy = l_dy_min;
+	l_current_pi->step_p = l_step_p;
+	l_current_pi->step_c = l_step_c;
+	l_current_pi->step_r = l_step_r;
+	l_current_pi->step_l = l_step_l;
+
+	/* allocation for components and number of components has already been calculated by opj_pi_create */
+	for (compno = 0; compno < l_current_pi->numcomps; ++compno) {
+		opj_pi_resolution_t *l_res = l_current_comp->resolutions;
+		l_encoding_value_ptr = l_tmp_ptr[compno];
+
+		l_current_comp->dx = l_img_comp->dx;
+		l_current_comp->dy = l_img_comp->dy;
+
+		/* resolutions have already been initialized */
+		for (resno = 0; resno < l_current_comp->numresolutions; resno++) {
+			l_res->pdx = *(l_encoding_value_ptr++);
+			l_res->pdy = *(l_encoding_value_ptr++);
+			l_res->pw =  *(l_encoding_value_ptr++);
+			l_res->ph =  *(l_encoding_value_ptr++);
+			++l_res;
 		}
-			return pi;
+
+		++l_current_comp;
+		++l_img_comp;
+		++l_tccp;
 	}
+	++l_current_pi;
 
+	for (pino = 1 ; pino<l_bound ; ++pino ) {
+		l_current_comp = l_current_pi->comps;
+		l_img_comp = p_image->comps;
+		l_tccp = l_tcp->tccps;
 
+		l_current_pi->tx0 = l_tx0;
+		l_current_pi->ty0 = l_ty0;
+		l_current_pi->tx1 = l_tx1;
+		l_current_pi->ty1 = l_ty1;
+		l_current_pi->dx = l_dx_min;
+		l_current_pi->dy = l_dy_min;
+		l_current_pi->step_p = l_step_p;
+		l_current_pi->step_c = l_step_c;
+		l_current_pi->step_r = l_step_r;
+		l_current_pi->step_l = l_step_l;
 
-void pi_destroy(opj_pi_iterator_t *pi, opj_cp_t *cp, int tileno) {
-	int compno, pino;
-	opj_tcp_t *tcp = &cp->tcps[tileno];
-	if(pi) {
-		for (pino = 0; pino < tcp->numpocs + 1; pino++) {	
-			if(pi[pino].comps) {
-				for (compno = 0; compno < pi->numcomps; compno++) {
-					opj_pi_comp_t *comp = &pi[pino].comps[compno];
-					if(comp->resolutions) {
-						opj_free(comp->resolutions);
-					}
-				}
-				opj_free(pi[pino].comps);
+		/* allocation for components and number of components has already been calculated by opj_pi_create */
+		for (compno = 0; compno < l_current_pi->numcomps; ++compno) {
+			opj_pi_resolution_t *l_res = l_current_comp->resolutions;
+			l_encoding_value_ptr = l_tmp_ptr[compno];
+
+			l_current_comp->dx = l_img_comp->dx;
+			l_current_comp->dy = l_img_comp->dy;
+			/* resolutions have already been initialized */
+			for (resno = 0; resno < l_current_comp->numresolutions; resno++) {
+				l_res->pdx = *(l_encoding_value_ptr++);
+				l_res->pdy = *(l_encoding_value_ptr++);
+				l_res->pw =  *(l_encoding_value_ptr++);
+				l_res->ph =  *(l_encoding_value_ptr++);
+				++l_res;
 			}
+			++l_current_comp;
+			++l_img_comp;
+			++l_tccp;
 		}
-		if(pi->include) {
-			opj_free(pi->include);
-		}
-		opj_free(pi);
+
+		/* special treatment*/
+		l_current_pi->include = (l_current_pi-1)->include;
+		++l_current_pi;
 	}
-}
 
-opj_bool pi_next(opj_pi_iterator_t * pi) {
-	switch (pi->poc.prg) {
-		case LRCP:
-			return pi_next_lrcp(pi);
-		case RLCP:
-			return pi_next_rlcp(pi);
-		case RPCL:
-			return pi_next_rpcl(pi);
-		case PCRL:
-			return pi_next_pcrl(pi);
-		case CPRL:
-			return pi_next_cprl(pi);
-		case PROG_UNKNOWN:
-			return OPJ_FALSE;
+	opj_free(l_tmp_data);
+	l_tmp_data = 00;
+	opj_free(l_tmp_ptr);
+	l_tmp_ptr = 00;
+
+    if (l_tcp->POC && (OPJ_IS_CINEMA(p_cp->rsiz) || p_t2_mode == FINAL_PASS)) {
+		opj_pi_update_encode_poc_and_final(p_cp,p_tile_no,l_tx0,l_tx1,l_ty0,l_ty1,l_max_prec,l_max_res,l_dx_min,l_dy_min);
 	}
-	
-	return OPJ_FALSE;
+	else {
+		opj_pi_update_encode_not_poc(p_cp,p_image->numcomps,p_tile_no,l_tx0,l_tx1,l_ty0,l_ty1,l_max_prec,l_max_res,l_dx_min,l_dy_min);
+	}
+
+	return l_pi;
 }
 
-opj_bool pi_create_encode( opj_pi_iterator_t *pi, opj_cp_t *cp,int tileno, int pino,int tpnum, int tppos, J2K_T2_MODE t2_mode,int cur_totnum_tp){
-	char prog[4];
-	int i;
-	int incr_top=1,resetX=0;
+void opj_pi_create_encode( 	opj_pi_iterator_t *pi,
+							opj_cp_t *cp,
+							OPJ_UINT32 tileno,
+							OPJ_UINT32 pino,
+							OPJ_UINT32 tpnum,
+							OPJ_INT32 tppos,
+							J2K_T2_MODE t2_mode)
+{
+	const OPJ_CHAR *prog;
+	OPJ_INT32 i;
+	OPJ_UINT32 incr_top=1,resetX=0;
 	opj_tcp_t *tcps =&cp->tcps[tileno];
 	opj_poc_t *tcp= &tcps->pocs[pino];
 
+	prog = opj_j2k_convert_progression_order(tcp->prg);
+
 	pi[pino].first = 1;
 	pi[pino].poc.prg = tcp->prg;
 
-	switch(tcp->prg){
-		case CPRL: strncpy(prog, "CPRL",4);
-			break;
-		case LRCP: strncpy(prog, "LRCP",4);
-			break;
-		case PCRL: strncpy(prog, "PCRL",4);
-			break;
-		case RLCP: strncpy(prog, "RLCP",4);
-			break;
-		case RPCL: strncpy(prog, "RPCL",4);
-			break;
-		case PROG_UNKNOWN: 
-			return OPJ_TRUE;
-	}
-
-	if(!(cp->tp_on && ((!cp->cinema && (t2_mode == FINAL_PASS)) || cp->cinema))){
+    if(!(cp->m_specific_param.m_enc.m_tp_on && ((!OPJ_IS_CINEMA(cp->rsiz) && (t2_mode == FINAL_PASS)) || OPJ_IS_CINEMA(cp->rsiz)))){
 		pi[pino].poc.resno0 = tcp->resS;
 		pi[pino].poc.resno1 = tcp->resE;
 		pi[pino].poc.compno0 = tcp->compS;
@@ -760,204 +1563,314 @@ opj_bool pi_create_encode( opj_pi_iterator_t *pi, opj_cp_t *cp,int tileno, int p
 		pi[pino].poc.layno1 = tcp->layE;
 		pi[pino].poc.precno0 = tcp->prcS;
 		pi[pino].poc.precno1 = tcp->prcE;
-		pi[pino].poc.tx0 = tcp->txS;
-		pi[pino].poc.ty0 = tcp->tyS;
-		pi[pino].poc.tx1 = tcp->txE;
-		pi[pino].poc.ty1 = tcp->tyE;
+		pi[pino].poc.tx0 = (OPJ_INT32)tcp->txS;
+		pi[pino].poc.ty0 = (OPJ_INT32)tcp->tyS;
+		pi[pino].poc.tx1 = (OPJ_INT32)tcp->txE;
+		pi[pino].poc.ty1 = (OPJ_INT32)tcp->tyE;
 	}else {
-		if( tpnum < cur_totnum_tp){
-			for(i=3;i>=0;i--){
+		for(i=tppos+1;i<4;i++){
+			switch(prog[i]){
+			case 'R':
+				pi[pino].poc.resno0 = tcp->resS;
+				pi[pino].poc.resno1 = tcp->resE;
+				break;
+			case 'C':
+				pi[pino].poc.compno0 = tcp->compS;
+				pi[pino].poc.compno1 = tcp->compE;
+				break;
+			case 'L':
+				pi[pino].poc.layno0 = tcp->layS;
+				pi[pino].poc.layno1 = tcp->layE;
+				break;
+			case 'P':
+				switch(tcp->prg){
+				case OPJ_LRCP:
+				case OPJ_RLCP:
+					pi[pino].poc.precno0 = tcp->prcS;
+					pi[pino].poc.precno1 = tcp->prcE;
+					break;
+				default:
+					pi[pino].poc.tx0 = (OPJ_INT32)tcp->txS;
+					pi[pino].poc.ty0 = (OPJ_INT32)tcp->tyS;
+					pi[pino].poc.tx1 = (OPJ_INT32)tcp->txE;
+					pi[pino].poc.ty1 = (OPJ_INT32)tcp->tyE;
+					break;
+				}
+				break;
+			}
+		}
+
+		if(tpnum==0){
+			for(i=tppos;i>=0;i--){
 				switch(prog[i]){
 				case 'C':
-					if (i > tppos){
-						pi[pino].poc.compno0 = tcp->compS;
-						pi[pino].poc.compno1 = tcp->compE;
-					}else{
-						if (tpnum == 0){
-							tcp->comp_t = tcp->compS;
-							pi[pino].poc.compno0 = tcp->comp_t;
-							pi[pino].poc.compno1 = tcp->comp_t+1;
-							tcp->comp_t+=1;
-						}else{
-							if (incr_top == 1){
-								if(tcp->comp_t ==tcp->compE){
-									tcp->comp_t = tcp->compS;
-									pi[pino].poc.compno0 = tcp->comp_t;
-									pi[pino].poc.compno1 = tcp->comp_t+1;
-									tcp->comp_t+=1;
-									incr_top=1;
-								}else{
-									pi[pino].poc.compno0 = tcp->comp_t;
-									pi[pino].poc.compno1 = tcp->comp_t+1;
-									tcp->comp_t+=1;
-									incr_top=0;
-								}
-							}else{
-								pi[pino].poc.compno0 = tcp->comp_t-1;
-								pi[pino].poc.compno1 = tcp->comp_t;
-							}
-						}
+					tcp->comp_t = tcp->compS;
+					pi[pino].poc.compno0 = tcp->comp_t;
+					pi[pino].poc.compno1 = tcp->comp_t+1;
+					tcp->comp_t+=1;
+					break;
+				case 'R':
+					tcp->res_t = tcp->resS;
+					pi[pino].poc.resno0 = tcp->res_t;
+					pi[pino].poc.resno1 = tcp->res_t+1;
+					tcp->res_t+=1;
+					break;
+				case 'L':
+					tcp->lay_t = tcp->layS;
+					pi[pino].poc.layno0 = tcp->lay_t;
+					pi[pino].poc.layno1 = tcp->lay_t+1;
+					tcp->lay_t+=1;
+					break;
+				case 'P':
+					switch(tcp->prg){
+					case OPJ_LRCP:
+					case OPJ_RLCP:
+						tcp->prc_t = tcp->prcS;
+						pi[pino].poc.precno0 = tcp->prc_t;
+						pi[pino].poc.precno1 = tcp->prc_t+1;
+						tcp->prc_t+=1;
+						break;
+					default:
+						tcp->tx0_t = tcp->txS;
+						tcp->ty0_t = tcp->tyS;
+						pi[pino].poc.tx0 = (OPJ_INT32)tcp->tx0_t;
+						pi[pino].poc.tx1 = (OPJ_INT32)(tcp->tx0_t + tcp->dx - (tcp->tx0_t % tcp->dx));
+						pi[pino].poc.ty0 = (OPJ_INT32)tcp->ty0_t;
+						pi[pino].poc.ty1 = (OPJ_INT32)(tcp->ty0_t + tcp->dy - (tcp->ty0_t % tcp->dy));
+						tcp->tx0_t = (OPJ_UINT32)pi[pino].poc.tx1;
+						tcp->ty0_t = (OPJ_UINT32)pi[pino].poc.ty1;
+						break;
 					}
 					break;
-
+				}
+			}
+			incr_top=1;
+		}else{
+			for(i=tppos;i>=0;i--){
+				switch(prog[i]){
+				case 'C':
+					pi[pino].poc.compno0 = tcp->comp_t-1;
+					pi[pino].poc.compno1 = tcp->comp_t;
+					break;
 				case 'R':
-					if (i > tppos){
-						pi[pino].poc.resno0 = tcp->resS;
-						pi[pino].poc.resno1 = tcp->resE;
-					}else{
-						if (tpnum == 0){
-							tcp->res_t = tcp->resS;
+					pi[pino].poc.resno0 = tcp->res_t-1;
+					pi[pino].poc.resno1 = tcp->res_t;
+					break;
+				case 'L':
+					pi[pino].poc.layno0 = tcp->lay_t-1;
+					pi[pino].poc.layno1 = tcp->lay_t;
+					break;
+				case 'P':
+					switch(tcp->prg){
+					case OPJ_LRCP:
+					case OPJ_RLCP:
+						pi[pino].poc.precno0 = tcp->prc_t-1;
+						pi[pino].poc.precno1 = tcp->prc_t;
+						break;
+					default:
+						pi[pino].poc.tx0 = (OPJ_INT32)(tcp->tx0_t - tcp->dx - (tcp->tx0_t % tcp->dx));
+						pi[pino].poc.tx1 = (OPJ_INT32)tcp->tx0_t ;
+						pi[pino].poc.ty0 = (OPJ_INT32)(tcp->ty0_t - tcp->dy - (tcp->ty0_t % tcp->dy));
+						pi[pino].poc.ty1 = (OPJ_INT32)tcp->ty0_t ;
+						break;
+					}
+					break;
+				}
+				if(incr_top==1){
+					switch(prog[i]){
+					case 'R':
+						if(tcp->res_t==tcp->resE){
+							if(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){
+								tcp->res_t = tcp->resS;
+								pi[pino].poc.resno0 = tcp->res_t;
+								pi[pino].poc.resno1 = tcp->res_t+1;
+								tcp->res_t+=1;
+								incr_top=1;
+							}else{
+								incr_top=0;
+							}
+						}else{
 							pi[pino].poc.resno0 = tcp->res_t;
 							pi[pino].poc.resno1 = tcp->res_t+1;
 							tcp->res_t+=1;
-						}else{
-							if (incr_top == 1){
-								if(tcp->res_t==tcp->resE){
-									tcp->res_t = tcp->resS;
-									pi[pino].poc.resno0 = tcp->res_t;
-									pi[pino].poc.resno1 = tcp->res_t+1;
-									tcp->res_t+=1;
-									incr_top=1;
-								}else{
-									pi[pino].poc.resno0 = tcp->res_t;
-									pi[pino].poc.resno1 = tcp->res_t+1;
-									tcp->res_t+=1;
-									incr_top=0;
-								}
+							incr_top=0;
+						}
+						break;
+					case 'C':
+						if(tcp->comp_t ==tcp->compE){
+							if(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){
+								tcp->comp_t = tcp->compS;
+								pi[pino].poc.compno0 = tcp->comp_t;
+								pi[pino].poc.compno1 = tcp->comp_t+1;
+								tcp->comp_t+=1;
+								incr_top=1;
 							}else{
-								pi[pino].poc.resno0 = tcp->res_t - 1;
-								pi[pino].poc.resno1 = tcp->res_t;
+								incr_top=0;
 							}
+						}else{
+							pi[pino].poc.compno0 = tcp->comp_t;
+							pi[pino].poc.compno1 = tcp->comp_t+1;
+							tcp->comp_t+=1;
+							incr_top=0;
 						}
-					}
-					break;
-
-				case 'L':
-					if (i > tppos){
-						pi[pino].poc.layno0 = tcp->layS;
-						pi[pino].poc.layno1 = tcp->layE;
-					}else{
-						if (tpnum == 0){
-							tcp->lay_t = tcp->layS;
+						break;
+					case 'L':
+						if(tcp->lay_t == tcp->layE){
+							if(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){
+								tcp->lay_t = tcp->layS;
+								pi[pino].poc.layno0 = tcp->lay_t;
+								pi[pino].poc.layno1 = tcp->lay_t+1;
+								tcp->lay_t+=1;
+								incr_top=1;
+							}else{
+								incr_top=0;
+							}
+						}else{
 							pi[pino].poc.layno0 = tcp->lay_t;
 							pi[pino].poc.layno1 = tcp->lay_t+1;
 							tcp->lay_t+=1;
-						}else{
-							if (incr_top == 1){
-								if(tcp->lay_t == tcp->layE){
-									tcp->lay_t = tcp->layS;
-									pi[pino].poc.layno0 = tcp->lay_t;
-									pi[pino].poc.layno1 = tcp->lay_t+1;
-									tcp->lay_t+=1;
-									incr_top=1;
-								}else{
-									pi[pino].poc.layno0 = tcp->lay_t;
-									pi[pino].poc.layno1 = tcp->lay_t+1;
-									tcp->lay_t+=1;
-									incr_top=0;
-								}
-							}else{
-								pi[pino].poc.layno0 = tcp->lay_t - 1;
-								pi[pino].poc.layno1 = tcp->lay_t;
-							}
+							incr_top=0;
 						}
-					}
-					break;
-
-				case 'P':
-					switch(tcp->prg){
-						case LRCP:
-						case RLCP:
-							if (i > tppos){
-								pi[pino].poc.precno0 = tcp->prcS;
-								pi[pino].poc.precno1 = tcp->prcE;
-							}else{
-								if (tpnum == 0){
+						break;
+					case 'P':
+						switch(tcp->prg){
+						case OPJ_LRCP:
+						case OPJ_RLCP:
+							if(tcp->prc_t == tcp->prcE){
+								if(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){
 									tcp->prc_t = tcp->prcS;
 									pi[pino].poc.precno0 = tcp->prc_t;
 									pi[pino].poc.precno1 = tcp->prc_t+1;
-									tcp->prc_t+=1; 
+									tcp->prc_t+=1;
+									incr_top=1;
 								}else{
-									if (incr_top == 1){
-										if(tcp->prc_t == tcp->prcE){
-											tcp->prc_t = tcp->prcS;
-											pi[pino].poc.precno0 = tcp->prc_t;
-											pi[pino].poc.precno1 = tcp->prc_t+1;
-											tcp->prc_t+=1;
-											incr_top=1;
-										}else{
-											pi[pino].poc.precno0 = tcp->prc_t;
-											pi[pino].poc.precno1 = tcp->prc_t+1;
-											tcp->prc_t+=1;
-											incr_top=0;
-										}
-									}else{
-										pi[pino].poc.precno0 = tcp->prc_t - 1;
-										pi[pino].poc.precno1 = tcp->prc_t;
-									}
+									incr_top=0;
 								}
+							}else{
+								pi[pino].poc.precno0 = tcp->prc_t;
+								pi[pino].poc.precno1 = tcp->prc_t+1;
+								tcp->prc_t+=1;
+								incr_top=0;
 							}
-						break;
+							break;
 						default:
-							if (i > tppos){
-								pi[pino].poc.tx0 = tcp->txS;
-								pi[pino].poc.ty0 = tcp->tyS;
-								pi[pino].poc.tx1 = tcp->txE;
-								pi[pino].poc.ty1 = tcp->tyE;
-							}else{
-								if (tpnum == 0){
-									tcp->tx0_t = tcp->txS;
-									tcp->ty0_t = tcp->tyS;
-									pi[pino].poc.tx0 = tcp->tx0_t;
-									pi[pino].poc.tx1 = tcp->tx0_t + tcp->dx - (tcp->tx0_t % tcp->dx);
-									pi[pino].poc.ty0 = tcp->ty0_t;
-									pi[pino].poc.ty1 = tcp->ty0_t + tcp->dy - (tcp->ty0_t % tcp->dy);
-									tcp->tx0_t = pi[pino].poc.tx1;
-									tcp->ty0_t = pi[pino].poc.ty1;
-								}else{
-									if (incr_top == 1){
-										if(tcp->tx0_t >= tcp->txE){
-											if(tcp->ty0_t >= tcp->tyE){
-												tcp->ty0_t = tcp->tyS;
-												pi[pino].poc.ty0 = tcp->ty0_t;
-												pi[pino].poc.ty1 = tcp->ty0_t + tcp->dy - (tcp->ty0_t % tcp->dy);
-												tcp->ty0_t = pi[pino].poc.ty1;
-												incr_top=1;resetX=1;
-											}else{
-												pi[pino].poc.ty0 = tcp->ty0_t;
-												pi[pino].poc.ty1 = tcp->ty0_t + tcp->dy - (tcp->ty0_t % tcp->dy);
-												tcp->ty0_t = pi[pino].poc.ty1;
-												incr_top=0;resetX=1;
-											}
-											if(resetX==1){
-												tcp->tx0_t = tcp->txS;
-												pi[pino].poc.tx0 = tcp->tx0_t;
-												pi[pino].poc.tx1 = tcp->tx0_t + tcp->dx- (tcp->tx0_t % tcp->dx);
-												tcp->tx0_t = pi[pino].poc.tx1;
-											}
-										}else{
-											pi[pino].poc.tx0 = tcp->tx0_t;
-											pi[pino].poc.tx1 = tcp->tx0_t + tcp->dx- (tcp->tx0_t % tcp->dx);
-											tcp->tx0_t = pi[pino].poc.tx1;
-											pi[pino].poc.ty0 = tcp->ty0_t - tcp->dy - (tcp->ty0_t % tcp->dy);
-											pi[pino].poc.ty1 = tcp->ty0_t ;
-											incr_top=0;
-										}
+							if(tcp->tx0_t >= tcp->txE){
+								if(tcp->ty0_t >= tcp->tyE){
+									if(opj_pi_check_next_level(i-1,cp,tileno,pino,prog)){
+										tcp->ty0_t = tcp->tyS;
+										pi[pino].poc.ty0 = (OPJ_INT32)tcp->ty0_t;
+										pi[pino].poc.ty1 = (OPJ_INT32)(tcp->ty0_t + tcp->dy - (tcp->ty0_t % tcp->dy));
+										tcp->ty0_t = (OPJ_UINT32)pi[pino].poc.ty1;
+										incr_top=1;resetX=1;
 									}else{
-										pi[pino].poc.tx0 = tcp->tx0_t - tcp->dx - (tcp->tx0_t % tcp->dx);
-										pi[pino].poc.tx1 = tcp->tx0_t ;
-										pi[pino].poc.ty0 = tcp->ty0_t - tcp->dy - (tcp->ty0_t % tcp->dy);
-										pi[pino].poc.ty1 = tcp->ty0_t ;
+										incr_top=0;resetX=0;
 									}
+								}else{
+									pi[pino].poc.ty0 = (OPJ_INT32)tcp->ty0_t;
+									pi[pino].poc.ty1 = (OPJ_INT32)(tcp->ty0_t + tcp->dy - (tcp->ty0_t % tcp->dy));
+									tcp->ty0_t = (OPJ_UINT32)pi[pino].poc.ty1;
+									incr_top=0;resetX=1;
+								}
+								if(resetX==1){
+									tcp->tx0_t = tcp->txS;
+									pi[pino].poc.tx0 = (OPJ_INT32)tcp->tx0_t;
+									pi[pino].poc.tx1 = (OPJ_INT32)(tcp->tx0_t + tcp->dx- (tcp->tx0_t % tcp->dx));
+									tcp->tx0_t = (OPJ_UINT32)pi[pino].poc.tx1;
 								}
+							}else{
+								pi[pino].poc.tx0 = (OPJ_INT32)tcp->tx0_t;
+								pi[pino].poc.tx1 = (OPJ_INT32)(tcp->tx0_t + tcp->dx- (tcp->tx0_t % tcp->dx));
+								tcp->tx0_t = (OPJ_UINT32)pi[pino].poc.tx1;
+								incr_top=0;
 							}
-						break;
+							break;
 						}
 						break;
-				}		
-			} 
+					}
+				}
+			}
 		}
-	}	
-	return OPJ_FALSE;
+	}
+}
+
+void opj_pi_destroy(opj_pi_iterator_t *p_pi,
+                    OPJ_UINT32 p_nb_elements)
+{
+	OPJ_UINT32 compno, pino;
+	opj_pi_iterator_t *l_current_pi = p_pi;
+    if (p_pi) {
+		if (p_pi->include) {
+			opj_free(p_pi->include);
+			p_pi->include = 00;
+		}
+		for (pino = 0; pino < p_nb_elements; ++pino){
+			if(l_current_pi->comps) {
+				opj_pi_comp_t *l_current_component = l_current_pi->comps;
+                for (compno = 0; compno < l_current_pi->numcomps; compno++){
+                    if(l_current_component->resolutions) {
+						opj_free(l_current_component->resolutions);
+						l_current_component->resolutions = 00;
+					}
+
+					++l_current_component;
+				}
+				opj_free(l_current_pi->comps);
+				l_current_pi->comps = 0;
+			}
+			++l_current_pi;
+		}
+		opj_free(p_pi);
+	}
+}
+
+
+
+void opj_pi_update_encoding_parameters(	const opj_image_t *p_image,
+                                        opj_cp_t *p_cp,
+                                        OPJ_UINT32 p_tile_no )
+{
+	/* encoding parameters to set */
+	OPJ_UINT32 l_max_res;
+	OPJ_UINT32 l_max_prec;
+	OPJ_INT32 l_tx0,l_tx1,l_ty0,l_ty1;
+	OPJ_UINT32 l_dx_min,l_dy_min;
+
+	/* pointers */
+	opj_tcp_t *l_tcp = 00;
+
+	/* preconditions */
+	assert(p_cp != 00);
+	assert(p_image != 00);
+	assert(p_tile_no < p_cp->tw * p_cp->th);
+
+	l_tcp = &(p_cp->tcps[p_tile_no]);
+
+	/* get encoding parameters */
+	opj_get_encoding_parameters(p_image,p_cp,p_tile_no,&l_tx0,&l_tx1,&l_ty0,&l_ty1,&l_dx_min,&l_dy_min,&l_max_prec,&l_max_res);
+
+	if (l_tcp->POC) {
+		opj_pi_update_encode_poc_and_final(p_cp,p_tile_no,l_tx0,l_tx1,l_ty0,l_ty1,l_max_prec,l_max_res,l_dx_min,l_dy_min);
+	}
+	else {
+		opj_pi_update_encode_not_poc(p_cp,p_image->numcomps,p_tile_no,l_tx0,l_tx1,l_ty0,l_ty1,l_max_prec,l_max_res,l_dx_min,l_dy_min);
+	}
 }
 
+OPJ_BOOL opj_pi_next(opj_pi_iterator_t * pi) {
+	switch (pi->poc.prg) {
+		case OPJ_LRCP:
+			return opj_pi_next_lrcp(pi);
+		case OPJ_RLCP:
+			return opj_pi_next_rlcp(pi);
+		case OPJ_RPCL:
+			return opj_pi_next_rpcl(pi);
+		case OPJ_PCRL:
+			return opj_pi_next_pcrl(pi);
+		case OPJ_CPRL:
+			return opj_pi_next_cprl(pi);
+		case OPJ_PROG_UNKNOWN:
+			return OPJ_FALSE;
+	}
+	
+	return OPJ_FALSE;
+}
diff --git a/extern/libopenjpeg/pi.h b/extern/libopenjpeg/pi.h
index cf9135f..f239679 100644
--- a/extern/libopenjpeg/pi.h
+++ b/extern/libopenjpeg/pi.h
@@ -1,9 +1,15 @@
 /*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2001-2003, David Janssens
  * Copyright (c) 2002-2003, Yannick Verschueren
- * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * Copyright (c) 2003-2014, Antonin Descampe
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
  * All rights reserved.
  *
@@ -44,110 +50,136 @@ by some function in T2.C.
 /*@{*/
 
 /**
-FIXME: documentation
+FIXME DOC
 */
 typedef struct opj_pi_resolution {
-  int pdx, pdy;
-  int pw, ph;
+  OPJ_UINT32 pdx, pdy;
+  OPJ_UINT32 pw, ph;
 } opj_pi_resolution_t;
 
 /**
-FIXME: documentation
+FIXME DOC
 */
 typedef struct opj_pi_comp {
-  int dx, dy;
+  OPJ_UINT32 dx, dy;
   /** number of resolution levels */
-  int numresolutions;
+  OPJ_UINT32 numresolutions;
   opj_pi_resolution_t *resolutions;
 } opj_pi_comp_t;
 
-/** 
-Packet iterator 
+/**
+Packet iterator
 */
 typedef struct opj_pi_iterator {
-	/** Enabling Tile part generation*/
-	char tp_on;
-	/** precise if the packet has been already used (usefull for progression order change) */
-	short int *include;
-	/** layer step used to localize the packet in the include vector */
-	int step_l;
-	/** resolution step used to localize the packet in the include vector */
-	int step_r;	
-	/** component step used to localize the packet in the include vector */
-	int step_c;	
-	/** precinct step used to localize the packet in the include vector */
-	int step_p;	
-	/** component that identify the packet */
-	int compno;
-	/** resolution that identify the packet */
-	int resno;
-	/** precinct that identify the packet */
-	int precno;
-	/** layer that identify the packet */
-	int layno;   
-	/** 0 if the first packet */
-	int first;
-	/** progression order change information */
-	opj_poc_t poc;
-	/** number of components in the image */
-	int numcomps;
-	/** Components*/
-	opj_pi_comp_t *comps;
-	int tx0, ty0, tx1, ty1;
-	int x, y, dx, dy;
+  /** Enabling Tile part generation*/
+  OPJ_BYTE tp_on;
+  /** precise if the packet has been already used (usefull for progression order change) */
+  OPJ_INT16 *include;
+  /** layer step used to localize the packet in the include vector */
+  OPJ_UINT32 step_l;
+  /** resolution step used to localize the packet in the include vector */
+  OPJ_UINT32 step_r;
+  /** component step used to localize the packet in the include vector */
+  OPJ_UINT32 step_c;
+  /** precinct step used to localize the packet in the include vector */
+  OPJ_UINT32 step_p;
+  /** component that identify the packet */
+  OPJ_UINT32 compno;
+  /** resolution that identify the packet */
+  OPJ_UINT32 resno;
+  /** precinct that identify the packet */
+  OPJ_UINT32 precno;
+  /** layer that identify the packet */
+  OPJ_UINT32 layno;
+  /** 0 if the first packet */
+  OPJ_BOOL first;
+  /** progression order change information */
+  opj_poc_t poc;
+  /** number of components in the image */
+  OPJ_UINT32 numcomps;
+  /** Components*/
+  opj_pi_comp_t *comps;
+  /** FIXME DOC*/
+  OPJ_INT32 tx0, ty0, tx1, ty1;
+  /** FIXME DOC*/
+  OPJ_INT32 x, y;
+  /** FIXME DOC*/
+  OPJ_UINT32 dx, dy;
 } opj_pi_iterator_t;
 
 /** @name Exported functions */
 /*@{*/
 /* ----------------------------------------------------------------------- */
 /**
-Create a packet iterator for Encoder
-@param image Raw image for which the packets will be listed
-@param cp Coding parameters
-@param tileno Number that identifies the tile for which to list the packets
-@param t2_mode If == 0 In Threshold calculation ,If == 1 Final pass
-@return Returns a packet iterator that points to the first packet of the tile
-@see pi_destroy
+ * Creates a packet iterator for encoding.
+ *
+ * @param	image		the image being encoded.
+ * @param	cp		the coding parameters.
+ * @param	tileno	index of the tile being encoded.
+ * @param	t2_mode	the type of pass for generating the packet iterator
+ *
+ * @return	a list of packet iterator that points to the first packet of the tile (not true).
 */
-opj_pi_iterator_t *pi_initialise_encode(opj_image_t *image, opj_cp_t *cp, int tileno,J2K_T2_MODE t2_mode);
+opj_pi_iterator_t *opj_pi_initialise_encode(const opj_image_t *image,
+                                            opj_cp_t *cp,
+                                            OPJ_UINT32 tileno,
+                                            J2K_T2_MODE t2_mode);
+
+/**
+ * Updates the encoding parameters of the codec.
+ *
+ * @param	p_image		the image being encoded.
+ * @param	p_cp		the coding parameters.
+ * @param	p_tile_no	index of the tile being encoded.
+*/
+void opj_pi_update_encoding_parameters(	const opj_image_t *p_image,
+                                        opj_cp_t *p_cp,
+                                        OPJ_UINT32 p_tile_no );
+
 /**
 Modify the packet iterator for enabling tile part generation
-@param pi Handle to the packet iterator generated in pi_initialise_encode  
+@param pi Handle to the packet iterator generated in pi_initialise_encode
 @param cp Coding parameters
 @param tileno Number that identifies the tile for which to list the packets
-@param pino Iterator index for pi
+@param pino   FIXME DOC
 @param tpnum Tile part number of the current tile
 @param tppos The position of the tile part flag in the progression order
-@param t2_mode If == 0 In Threshold calculation ,If == 1 Final pass
-@param cur_totnum_tp The total number of tile parts in the current tile
-@return Returns true if an error is detected 
+@param t2_mode FIXME DOC
 */
-opj_bool pi_create_encode(opj_pi_iterator_t *pi, opj_cp_t *cp,int tileno, int pino,int tpnum, int tppos, J2K_T2_MODE t2_mode,int cur_totnum_tp);
+void opj_pi_create_encode(  opj_pi_iterator_t *pi, 
+                            opj_cp_t *cp,
+                            OPJ_UINT32 tileno, 
+                            OPJ_UINT32 pino,
+                            OPJ_UINT32 tpnum, 
+                            OPJ_INT32 tppos, 
+                            J2K_T2_MODE t2_mode);
+
 /**
 Create a packet iterator for Decoder
 @param image Raw image for which the packets will be listed
 @param cp Coding parameters
 @param tileno Number that identifies the tile for which to list the packets
 @return Returns a packet iterator that points to the first packet of the tile
-@see pi_destroy
+@see opj_pi_destroy
 */
-opj_pi_iterator_t *pi_create_decode(opj_image_t * image, opj_cp_t * cp, int tileno);
-
+opj_pi_iterator_t *opj_pi_create_decode(opj_image_t * image, 
+                                        opj_cp_t * cp,
+                                        OPJ_UINT32 tileno);
 /**
-Destroy a packet iterator
-@param pi Previously created packet iterator
-@param cp Coding parameters
-@param tileno Number that identifies the tile for which the packets were listed
-@see pi_create
-*/
-void pi_destroy(opj_pi_iterator_t *pi, opj_cp_t *cp, int tileno);
+ * Destroys a packet iterator array.
+ *
+ * @param	p_pi			the packet iterator array to destroy.
+ * @param	p_nb_elements	the number of elements in the array.
+ */
+void opj_pi_destroy(opj_pi_iterator_t *p_pi,
+                    OPJ_UINT32 p_nb_elements);
 
 /**
 Modify the packet iterator to point to the next packet
 @param pi Packet iterator to modify
-@return Returns false if pi pointed to the last packet or else returns true 
+@return Returns false if pi pointed to the last packet or else returns true
 */
-opj_bool pi_next(opj_pi_iterator_t * pi);
+OPJ_BOOL opj_pi_next(opj_pi_iterator_t * pi);
 /* ----------------------------------------------------------------------- */
 /*@}*/
 
diff --git a/extern/libopenjpeg/ppix_manager.c b/extern/libopenjpeg/ppix_manager.c
index 58d324c..fce5148 100644
--- a/extern/libopenjpeg/ppix_manager.c
+++ b/extern/libopenjpeg/ppix_manager.c
@@ -1,8 +1,8 @@
 /*
  * $Id: ppix_manager.c 897 2011-08-28 21:43:57Z Kaori.Hagihara@gmail.com $
  *
- * Copyright (c) 2002-2011, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2011, Professor Benoit Macq
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2003-2004, Yannick Verschueren
  * Copyright (c) 2010-2011, Kaori Hagihara
  * All rights reserved.
@@ -33,9 +33,6 @@
  *  \brief Modification of jpip.c from 2KAN indexer
  */
 
-#include <stdio.h>
-#include <stdlib.h>
-#include <math.h>
 #include "opj_includes.h"
 
 /* 
@@ -49,49 +46,65 @@
  * @param[in] cio       file output handle
  * @return              length of faix box
  */
-int write_ppixfaix( int coff, int compno, opj_codestream_info_t cstr_info, opj_bool EPHused, int j2klen, opj_cio_t *cio);
 
-int write_ppix( int coff, opj_codestream_info_t cstr_info, opj_bool EPHused, int j2klen, opj_cio_t *cio)
+
+int opj_write_ppix( int coff, opj_codestream_info_t cstr_info, OPJ_BOOL EPHused, int j2klen, opj_stream_private_t *cio,
+              opj_event_mgr_t * p_manager )
 {
-  int len, lenp, compno, i;
+  OPJ_BYTE l_data_header [4];
+  int compno, i;
   opj_jp2_box_t *box;
+  OPJ_OFF_T lenp;
+  OPJ_UINT32 len;
 
   /*  printf("cstr_info.packno %d\n", cstr_info.packno); //NMAX? */
 
   lenp = -1;
-  box = (opj_jp2_box_t *)opj_calloc( cstr_info.numcomps, sizeof(opj_jp2_box_t));
+  box = (opj_jp2_box_t *)opj_calloc( (size_t)cstr_info.numcomps, sizeof(opj_jp2_box_t));
   
   for (i=0;i<2;i++){
-    if (i) cio_seek( cio, lenp);
+    if (i)
+
+      opj_stream_seek( cio, lenp, p_manager);
     
-    lenp = cio_tell( cio);
-    cio_skip( cio, 4);              /* L [at the end] */
-    cio_write( cio, JPIP_PPIX, 4);  /* PPIX           */
+    lenp = (OPJ_UINT32)(opj_stream_tell(cio));
+    opj_stream_skip( cio, 4, p_manager);       /* L [at the end] */
+    opj_write_bytes(l_data_header,JPIP_PPIX,4);/* PPIX           */
+    opj_stream_write_data(cio,l_data_header,4,p_manager);
 
-    write_manf( i, cstr_info.numcomps, box, cio);
+    opj_write_manf( i, cstr_info.numcomps, box, cio, p_manager);
     
     for (compno=0; compno<cstr_info.numcomps; compno++){
-      box[compno].length = write_ppixfaix( coff, compno, cstr_info, EPHused, j2klen, cio);
+      box[compno].length = (OPJ_UINT32)opj_write_ppixfaix( coff, compno, cstr_info, EPHused, j2klen, cio,p_manager);
       box[compno].type = JPIP_FAIX;
     }
    
-    len = cio_tell( cio)-lenp;
-    cio_seek( cio, lenp);
-    cio_write( cio, len, 4);        /* L              */
-    cio_seek( cio, lenp+len);
+
+  len = (OPJ_UINT32)(opj_stream_tell(cio)-lenp);
+  opj_stream_seek(cio, lenp,p_manager);
+  opj_write_bytes(l_data_header,len,4);/* L              */
+  opj_stream_write_data(cio,l_data_header,4,p_manager);
+  opj_stream_seek(cio, lenp+len,p_manager);
   }
   
   opj_free(box);
 
-  return len;
+  return (int)len;
 }
 
-int write_ppixfaix( int coff, int compno, opj_codestream_info_t cstr_info, opj_bool EPHused, int j2klen, opj_cio_t *cio)
+
+
+int opj_write_ppixfaix( int coff, int compno, opj_codestream_info_t cstr_info, OPJ_BOOL EPHused, int j2klen, opj_stream_private_t *cio,
+              opj_event_mgr_t * p_manager )
 {
-  int len, lenp, tileno, version, i, nmax, size_of_coding; /* 4 or 8*/
+  OPJ_BYTE l_data_header [8];
+  OPJ_UINT32 tileno, version, i, nmax, size_of_coding; /* 4 or 8*/
+  OPJ_UINT32 len;
+  OPJ_OFF_T lenp;
   opj_tile_info_t *tile_Idx;
   opj_packet_info_t packet;
-  int resno, precno, layno, num_packet;
+  int resno, precno, layno;
+  OPJ_UINT32 num_packet;
   int numOfres, numOfprec, numOflayers;
   packet.end_pos = packet.end_ph_pos = packet.start_pos = -1;
   (void)EPHused; /* unused ? */
@@ -105,19 +118,22 @@ int write_ppixfaix( int coff, int compno, opj_codestream_info_t cstr_info, opj_b
     version = 0;
   }
   
-  lenp = cio_tell( cio);
-  cio_skip( cio, 4);              /* L [at the end]      */
-  cio_write( cio, JPIP_FAIX, 4);  /* FAIX                */ 
-  cio_write( cio, version, 1);     /* Version 0 = 4 bytes */
+  lenp = opj_stream_tell(cio);
+  opj_stream_skip(cio, 4, p_manager);         /* L [at the end]      */
+  opj_write_bytes(l_data_header,JPIP_FAIX,4); /* FAIX */
+  opj_write_bytes(l_data_header,version,1);
+  opj_stream_write_data(cio,l_data_header,1,p_manager);/* Version 0 = 4 bytes */
 
   nmax = 0;
-  for( i=0; i<=cstr_info.numdecompos[compno]; i++)
-    nmax += cstr_info.tile[0].ph[i] * cstr_info.tile[0].pw[i] * cstr_info.numlayers;
+  for( i=0; i<=(OPJ_UINT32)cstr_info.numdecompos[compno]; i++)
+    nmax += (OPJ_UINT32)(cstr_info.tile[0].ph[i] * cstr_info.tile[0].pw[i] * cstr_info.numlayers);
   
-  cio_write( cio, nmax, size_of_coding); /* NMAX */
-  cio_write( cio, cstr_info.tw*cstr_info.th, size_of_coding);      /* M    */
+  opj_write_bytes(l_data_header,nmax,size_of_coding);         /* NMAX           */
+  opj_stream_write_data(cio,l_data_header,size_of_coding,p_manager);
+  opj_write_bytes(l_data_header,(OPJ_UINT32)(cstr_info.tw*cstr_info.th),size_of_coding);  /* M              */
+  opj_stream_write_data(cio,l_data_header,size_of_coding,p_manager);
 
-  for( tileno=0; tileno<cstr_info.tw*cstr_info.th; tileno++){
+  for( tileno=0; tileno<(OPJ_UINT32)(cstr_info.tw*cstr_info.th); tileno++){
     tile_Idx = &cstr_info.tile[ tileno];
  
     num_packet=0;
@@ -130,27 +146,29 @@ int write_ppixfaix( int coff, int compno, opj_codestream_info_t cstr_info, opj_b
 	for( layno=0; layno<numOflayers; layno++){
 
 	  switch ( cstr_info.prog){
-	  case LRCP:
+	  case OPJ_LRCP:
 	    packet = tile_Idx->packet[ ((layno*numOfres+resno)*cstr_info.numcomps+compno)*numOfprec+precno];
 	    break;
-	  case RLCP:
+	  case OPJ_RLCP:
 	    packet = tile_Idx->packet[ ((resno*numOflayers+layno)*cstr_info.numcomps+compno)*numOfprec+precno];
 	    break;
-	  case RPCL:
+	  case OPJ_RPCL:
 	    packet = tile_Idx->packet[ ((resno*numOfprec+precno)*cstr_info.numcomps+compno)*numOflayers+layno];
 	    break;
-	  case PCRL:
+	  case OPJ_PCRL:
 	    packet = tile_Idx->packet[ ((precno*cstr_info.numcomps+compno)*numOfres+resno)*numOflayers + layno];
 	    break;
-	  case CPRL:
+	  case OPJ_CPRL:
 	    packet = tile_Idx->packet[ ((compno*numOfprec+precno)*numOfres+resno)*numOflayers + layno];
 	    break;
 	  default:
 	    fprintf( stderr, "failed to ppix indexing\n");
 	  }
 
-	  cio_write( cio, packet.start_pos-coff, size_of_coding);             /* start position */
-	  cio_write( cio, packet.end_pos-packet.start_pos+1, size_of_coding); /* length         */
+    opj_write_bytes(l_data_header,(OPJ_UINT32)(packet.start_pos-coff),size_of_coding);            /* start position */
+    opj_stream_write_data(cio,l_data_header,size_of_coding,p_manager);
+    opj_write_bytes(l_data_header,(OPJ_UINT32)(packet.end_pos-packet.start_pos+1),size_of_coding); /* length         */
+    opj_stream_write_data(cio,l_data_header,size_of_coding,p_manager);
 	  
 	  num_packet++;
 	}
@@ -158,16 +176,19 @@ int write_ppixfaix( int coff, int compno, opj_codestream_info_t cstr_info, opj_b
     }
   
     while( num_packet < nmax){     /* PADDING */
-      cio_write( cio, 0, size_of_coding); /* start position            */
-      cio_write( cio, 0, size_of_coding); /* length                    */
+      opj_write_bytes(l_data_header,0,size_of_coding);/* start position            */
+      opj_stream_write_data(cio,l_data_header,size_of_coding,p_manager);
+      opj_write_bytes(l_data_header,0,size_of_coding);/* length                    */
+      opj_stream_write_data(cio,l_data_header,size_of_coding,p_manager);
       num_packet++;
     }   
   }
 
-  len = cio_tell( cio)-lenp;
-  cio_seek( cio, lenp);
-  cio_write( cio, len, 4);        /* L  */
-  cio_seek( cio, lenp+len);
+  len = (OPJ_UINT32)(opj_stream_tell(cio)-lenp);
+  opj_stream_seek(cio, lenp,p_manager);
+  opj_write_bytes(l_data_header,len,4);/* L  */
+  opj_stream_write_data(cio,l_data_header,4,p_manager);
+  opj_stream_seek(cio, lenp+len,p_manager);
 
-  return len;
+  return (int)len;
 }
diff --git a/extern/libopenjpeg/raw.c b/extern/libopenjpeg/raw.c
index 3d231bf..2498761 100644
--- a/extern/libopenjpeg/raw.c
+++ b/extern/libopenjpeg/raw.c
@@ -1,7 +1,13 @@
 /*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
- * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * Copyright (c) 2003-2014, Antonin Descampe
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
  * All rights reserved.
  *
@@ -42,22 +48,24 @@
 ==========================================================
 */
 
-opj_raw_t* raw_create(void) {
+opj_raw_t* opj_raw_create(void) {
 	opj_raw_t *raw = (opj_raw_t*)opj_malloc(sizeof(opj_raw_t));
 	return raw;
 }
 
-void raw_destroy(opj_raw_t *raw) {
+void opj_raw_destroy(opj_raw_t *raw) {
 	if(raw) {
 		opj_free(raw);
 	}
 }
 
-int raw_numbytes(opj_raw_t *raw) {
-	return raw->bp - raw->start;
+OPJ_UINT32 opj_raw_numbytes(opj_raw_t *raw) {
+	const ptrdiff_t diff = raw->bp - raw->start;
+  assert( diff <= (ptrdiff_t)0xffffffff && diff >= 0 ); /* UINT32_MAX */
+	return (OPJ_UINT32)diff;
 }
 
-void raw_init_dec(opj_raw_t *raw, unsigned char *bp, int len) {
+void opj_raw_init_dec(opj_raw_t *raw, OPJ_BYTE *bp, OPJ_UINT32 len) {
 	raw->start = bp;
 	raw->lenmax = len;
 	raw->len = 0;
@@ -65,8 +73,8 @@ void raw_init_dec(opj_raw_t *raw, unsigned char *bp, int len) {
 	raw->ct = 0;
 }
 
-int raw_decode(opj_raw_t *raw) {
-	int d;
+OPJ_UINT32 opj_raw_decode(opj_raw_t *raw) {
+	OPJ_UINT32 d;
 	if (raw->ct == 0) {
 		raw->ct = 8;
 		if (raw->len == raw->lenmax) {
diff --git a/extern/libopenjpeg/raw.h b/extern/libopenjpeg/raw.h
index 3c4b372..572c666 100644
--- a/extern/libopenjpeg/raw.h
+++ b/extern/libopenjpeg/raw.h
@@ -1,7 +1,13 @@
 /*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
- * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * Copyright (c) 2003-2014, Antonin Descampe
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
  * All rights reserved.
  *
@@ -45,19 +51,19 @@ RAW encoding operations
 */
 typedef struct opj_raw {
 	/** temporary buffer where bits are coded or decoded */
-	unsigned char c;
+	OPJ_BYTE c;
 	/** number of bits already read or free to write */
-	unsigned int ct;
+	OPJ_UINT32 ct;
 	/** maximum length to decode */
-	unsigned int lenmax;
+	OPJ_UINT32 lenmax;
 	/** length decoded */
-	unsigned int len;
+	OPJ_UINT32 len;
 	/** pointer to the current position in the buffer */
-	unsigned char *bp;
+	OPJ_BYTE *bp;
 	/** pointer to the start of the buffer */
-	unsigned char *start;
+	OPJ_BYTE *start;
 	/** pointer to the end of the buffer */
-	unsigned char *end;
+	OPJ_BYTE *end;
 } opj_raw_t;
 
 /** @name Exported functions */
@@ -67,31 +73,31 @@ typedef struct opj_raw {
 Create a new RAW handle 
 @return Returns a new RAW handle if successful, returns NULL otherwise
 */
-opj_raw_t* raw_create(void);
+opj_raw_t* opj_raw_create(void);
 /**
 Destroy a previously created RAW handle
 @param raw RAW handle to destroy
 */
-void raw_destroy(opj_raw_t *raw);
+void opj_raw_destroy(opj_raw_t *raw);
 /**
 Return the number of bytes written/read since initialisation
 @param raw RAW handle to destroy
 @return Returns the number of bytes already encoded
 */
-int raw_numbytes(opj_raw_t *raw);
+OPJ_UINT32 opj_raw_numbytes(opj_raw_t *raw);
 /**
 Initialize the decoder
 @param raw RAW handle
 @param bp Pointer to the start of the buffer from which the bytes will be read
 @param len Length of the input buffer
 */
-void raw_init_dec(opj_raw_t *raw, unsigned char *bp, int len);
+void opj_raw_init_dec(opj_raw_t *raw, OPJ_BYTE *bp, OPJ_UINT32 len);
 /**
 Decode a symbol using raw-decoder. Cfr p.506 TAUBMAN
 @param raw RAW handle
 @return Returns the decoded symbol (0 or 1)
 */
-int raw_decode(opj_raw_t *raw);
+OPJ_UINT32 opj_raw_decode(opj_raw_t *raw);
 /* ----------------------------------------------------------------------- */
 /*@}*/
 
diff --git a/extern/libopenjpeg/t1.c b/extern/libopenjpeg/t1.c
index ed9cdc3..0d6c2f6 100644
--- a/extern/libopenjpeg/t1.c
+++ b/extern/libopenjpeg/t1.c
@@ -1,9 +1,15 @@
 /*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2001-2003, David Janssens
  * Copyright (c) 2002-2003, Yannick Verschueren
- * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * Copyright (c) 2003-2014, Antonin Descampe
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
  * Copyright (c) 2007, Callum Lerwick <seg@haxxed.com>
  * All rights reserved.
@@ -39,222 +45,240 @@
 /** @name Local static functions */
 /*@{*/
 
-static INLINE char t1_getctxno_zc(int f, int orient);
-static char t1_getctxno_sc(int f);
-static INLINE int t1_getctxno_mag(int f);
-static char t1_getspb(int f);
-static short t1_getnmsedec_sig(int x, int bitpos);
-static short t1_getnmsedec_ref(int x, int bitpos);
-static void t1_updateflags(flag_t *flagsp, int s, int stride);
+static INLINE OPJ_BYTE opj_t1_getctxno_zc(OPJ_UINT32 f, OPJ_UINT32 orient);
+static OPJ_BYTE opj_t1_getctxno_sc(OPJ_UINT32 f);
+static INLINE OPJ_UINT32 opj_t1_getctxno_mag(OPJ_UINT32 f);
+static OPJ_BYTE opj_t1_getspb(OPJ_UINT32 f);
+static OPJ_INT16 opj_t1_getnmsedec_sig(OPJ_UINT32 x, OPJ_UINT32 bitpos);
+static OPJ_INT16 opj_t1_getnmsedec_ref(OPJ_UINT32 x, OPJ_UINT32 bitpos);
+static void opj_t1_updateflags(opj_flag_t *flagsp, OPJ_UINT32 s, OPJ_UINT32 stride);
 /**
 Encode significant pass
 */
-static void t1_enc_sigpass_step(
-		opj_t1_t *t1,
-		flag_t *flagsp,
-		int *datap,
-		int orient,
-		int bpno,
-		int one,
-		int *nmsedec,
-		char type,
-		int vsc);
+static void opj_t1_enc_sigpass_step(opj_t1_t *t1,
+                                    opj_flag_t *flagsp,
+                                    OPJ_INT32 *datap,
+                                    OPJ_UINT32 orient,
+                                    OPJ_INT32 bpno,
+                                    OPJ_INT32 one,
+                                    OPJ_INT32 *nmsedec,
+                                    OPJ_BYTE type,
+                                    OPJ_UINT32 vsc);
+
 /**
 Decode significant pass
 */
-static INLINE void t1_dec_sigpass_step_raw(
-		opj_t1_t *t1,
-		flag_t *flagsp,
-		int *datap,
-		int orient,
-		int oneplushalf,
-		int vsc);
-static INLINE void t1_dec_sigpass_step_mqc(
-		opj_t1_t *t1,
-		flag_t *flagsp,
-		int *datap,
-		int orient,
-		int oneplushalf);
-static INLINE void t1_dec_sigpass_step_mqc_vsc(
-		opj_t1_t *t1,
-		flag_t *flagsp,
-		int *datap,
-		int orient,
-		int oneplushalf,
-		int vsc);
+#if 0
+static void opj_t1_dec_sigpass_step(opj_t1_t *t1,
+                                    opj_flag_t *flagsp,
+                                    OPJ_INT32 *datap,
+                                    OPJ_UINT32 orient,
+                                    OPJ_INT32 oneplushalf,
+                                    OPJ_BYTE type,
+                                    OPJ_UINT32 vsc);
+#endif
+
+static INLINE void opj_t1_dec_sigpass_step_raw(
+                opj_t1_t *t1,
+                opj_flag_t *flagsp,
+                OPJ_INT32 *datap,
+                OPJ_INT32 orient,
+                OPJ_INT32 oneplushalf,
+                OPJ_INT32 vsc);
+static INLINE void opj_t1_dec_sigpass_step_mqc(
+                opj_t1_t *t1,
+                opj_flag_t *flagsp,
+                OPJ_INT32 *datap,
+                OPJ_INT32 orient,
+                OPJ_INT32 oneplushalf);
+static INLINE void opj_t1_dec_sigpass_step_mqc_vsc(
+                opj_t1_t *t1,
+                opj_flag_t *flagsp,
+                OPJ_INT32 *datap,
+                OPJ_INT32 orient,
+                OPJ_INT32 oneplushalf,
+                OPJ_INT32 vsc);
+
+
 /**
 Encode significant pass
 */
-static void t1_enc_sigpass(
-		opj_t1_t *t1,
-		int bpno,
-		int orient,
-		int *nmsedec,
-		char type,
-		int cblksty);
+static void opj_t1_enc_sigpass( opj_t1_t *t1,
+                                OPJ_INT32 bpno,
+                                OPJ_UINT32 orient,
+                                OPJ_INT32 *nmsedec,
+                                OPJ_BYTE type,
+                                OPJ_UINT32 cblksty);
+
 /**
 Decode significant pass
 */
-static void t1_dec_sigpass_raw(
-		opj_t1_t *t1,
-		int bpno,
-		int orient,
-		int cblksty);
-static void t1_dec_sigpass_mqc(
-		opj_t1_t *t1,
-		int bpno,
-		int orient);
-static void t1_dec_sigpass_mqc_vsc(
-		opj_t1_t *t1,
-		int bpno,
-		int orient);
+static void opj_t1_dec_sigpass_raw(
+                opj_t1_t *t1,
+                OPJ_INT32 bpno,
+                OPJ_INT32 orient,
+                OPJ_INT32 cblksty);
+static void opj_t1_dec_sigpass_mqc(
+                opj_t1_t *t1,
+                OPJ_INT32 bpno,
+                OPJ_INT32 orient);
+static void opj_t1_dec_sigpass_mqc_vsc(
+                opj_t1_t *t1,
+                OPJ_INT32 bpno,
+                OPJ_INT32 orient);
+
+
+
 /**
 Encode refinement pass
 */
-static void t1_enc_refpass_step(
-		opj_t1_t *t1,
-		flag_t *flagsp,
-		int *datap,
-		int bpno,
-		int one,
-		int *nmsedec,
-		char type,
-		int vsc);
+static void opj_t1_enc_refpass_step(opj_t1_t *t1,
+                                    opj_flag_t *flagsp,
+                                    OPJ_INT32 *datap,
+                                    OPJ_INT32 bpno,
+                                    OPJ_INT32 one,
+                                    OPJ_INT32 *nmsedec,
+                                    OPJ_BYTE type,
+                                    OPJ_UINT32 vsc);
+
+
 /**
-Decode refinement pass
+Encode refinement pass
 */
-static INLINE void t1_dec_refpass_step_raw(
-		opj_t1_t *t1,
-		flag_t *flagsp,
-		int *datap,
-		int poshalf,
-		int neghalf,
-		int vsc);
-static INLINE void t1_dec_refpass_step_mqc(
-		opj_t1_t *t1,
-		flag_t *flagsp,
-		int *datap,
-		int poshalf,
-		int neghalf);
-static INLINE void t1_dec_refpass_step_mqc_vsc(
-		opj_t1_t *t1,
-		flag_t *flagsp,
-		int *datap,
-		int poshalf,
-		int neghalf,
-		int vsc);
+static void opj_t1_enc_refpass( opj_t1_t *t1,
+                                OPJ_INT32 bpno,
+                                OPJ_INT32 *nmsedec,
+                                OPJ_BYTE type,
+                                OPJ_UINT32 cblksty);
 
 /**
-Encode refinement pass
+Decode refinement pass
 */
-static void t1_enc_refpass(
-		opj_t1_t *t1,
-		int bpno,
-		int *nmsedec,
-		char type,
-		int cblksty);
+static void opj_t1_dec_refpass_raw(
+                opj_t1_t *t1,
+                OPJ_INT32 bpno,
+                OPJ_INT32 cblksty);
+static void opj_t1_dec_refpass_mqc(
+                opj_t1_t *t1,
+                OPJ_INT32 bpno);
+static void opj_t1_dec_refpass_mqc_vsc(
+                opj_t1_t *t1,
+                OPJ_INT32 bpno);
+
+
 /**
 Decode refinement pass
 */
-static void t1_dec_refpass_raw(
-		opj_t1_t *t1,
-		int bpno,
-		int cblksty);
-static void t1_dec_refpass_mqc(
-		opj_t1_t *t1,
-		int bpno);
-static void t1_dec_refpass_mqc_vsc(
-		opj_t1_t *t1,
-		int bpno);
+#if 0
+static void opj_t1_dec_refpass_step(opj_t1_t *t1,
+                                    opj_flag_t *flagsp,
+                                    OPJ_INT32 *datap,
+                                    OPJ_INT32 poshalf,
+                                    OPJ_INT32 neghalf,
+                                    OPJ_BYTE type,
+                                    OPJ_UINT32 vsc);
+#endif
+
+static INLINE void  opj_t1_dec_refpass_step_raw(
+                opj_t1_t *t1,
+                opj_flag_t *flagsp,
+                OPJ_INT32 *datap,
+                OPJ_INT32 poshalf,
+                OPJ_INT32 neghalf,
+                OPJ_INT32 vsc);
+static INLINE void opj_t1_dec_refpass_step_mqc(
+                opj_t1_t *t1,
+                opj_flag_t *flagsp,
+                OPJ_INT32 *datap,
+                OPJ_INT32 poshalf,
+                OPJ_INT32 neghalf);
+static INLINE void opj_t1_dec_refpass_step_mqc_vsc(
+                opj_t1_t *t1,
+                opj_flag_t *flagsp,
+                OPJ_INT32 *datap,
+                OPJ_INT32 poshalf,
+                OPJ_INT32 neghalf,
+                OPJ_INT32 vsc);
+
+
+
 /**
 Encode clean-up pass
 */
-static void t1_enc_clnpass_step(
+static void opj_t1_enc_clnpass_step(
 		opj_t1_t *t1,
-		flag_t *flagsp,
-		int *datap,
-		int orient,
-		int bpno,
-		int one,
-		int *nmsedec,
-		int partial,
-		int vsc);
+		opj_flag_t *flagsp,
+		OPJ_INT32 *datap,
+		OPJ_UINT32 orient,
+		OPJ_INT32 bpno,
+		OPJ_INT32 one,
+		OPJ_INT32 *nmsedec,
+		OPJ_UINT32 partial,
+		OPJ_UINT32 vsc);
 /**
 Decode clean-up pass
 */
-static void t1_dec_clnpass_step_partial(
+static void opj_t1_dec_clnpass_step_partial(
 		opj_t1_t *t1,
-		flag_t *flagsp,
-		int *datap,
-		int orient,
-		int oneplushalf);
-static void t1_dec_clnpass_step(
+		opj_flag_t *flagsp,
+		OPJ_INT32 *datap,
+		OPJ_INT32 orient,
+		OPJ_INT32 oneplushalf);
+static void opj_t1_dec_clnpass_step(
 		opj_t1_t *t1,
-		flag_t *flagsp,
-		int *datap,
-		int orient,
-		int oneplushalf);
-static void t1_dec_clnpass_step_vsc(
+		opj_flag_t *flagsp,
+		OPJ_INT32 *datap,
+		OPJ_INT32 orient,
+		OPJ_INT32 oneplushalf);
+static void opj_t1_dec_clnpass_step_vsc(
 		opj_t1_t *t1,
-		flag_t *flagsp,
-		int *datap,
-		int orient,
-		int oneplushalf,
-		int partial,
-		int vsc);
+		opj_flag_t *flagsp,
+		OPJ_INT32 *datap,
+		OPJ_INT32 orient,
+		OPJ_INT32 oneplushalf,
+		OPJ_INT32 partial,
+		OPJ_INT32 vsc);
 /**
 Encode clean-up pass
 */
-static void t1_enc_clnpass(
+static void opj_t1_enc_clnpass(
 		opj_t1_t *t1,
-		int bpno,
-		int orient,
-		int *nmsedec,
-		int cblksty);
+		OPJ_INT32 bpno,
+		OPJ_UINT32 orient,
+		OPJ_INT32 *nmsedec,
+		OPJ_UINT32 cblksty);
 /**
 Decode clean-up pass
 */
-static void t1_dec_clnpass(
-		opj_t1_t *t1,
-		int bpno,
-		int orient,
-		int cblksty);
-static double t1_getwmsedec(
-		int nmsedec,
-		int compno,
-		int level,
-		int orient,
-		int bpno,
-		int qmfbid,
-		double stepsize,
-		int numcomps,
-		int mct);
-/**
-Encode 1 code-block
-@param t1 T1 handle
-@param cblk Code-block coding parameters
-@param orient
-@param compno Component number
-@param level
-@param qmfbid
-@param stepsize
-@param cblksty Code-block style
-@param numcomps
-@param mct
-@param tile
-*/
-static void t1_encode_cblk(
+static void opj_t1_dec_clnpass(
 		opj_t1_t *t1,
-		opj_tcd_cblk_enc_t* cblk,
-		int orient,
-		int compno,
-		int level,
-		int qmfbid,
-		double stepsize,
-		int cblksty,
-		int numcomps,
-		int mct,
-		opj_tcd_tile_t * tile);
+		OPJ_INT32 bpno,
+		OPJ_INT32 orient,
+		OPJ_INT32 cblksty);
+
+static OPJ_FLOAT64 opj_t1_getwmsedec(
+		OPJ_INT32 nmsedec,
+		OPJ_UINT32 compno,
+		OPJ_UINT32 level,
+		OPJ_UINT32 orient,
+		OPJ_INT32 bpno,
+		OPJ_UINT32 qmfbid,
+		OPJ_FLOAT64 stepsize,
+		OPJ_UINT32 numcomps,
+		const OPJ_FLOAT64 * mct_norms);
+
+static void opj_t1_encode_cblk( opj_t1_t *t1,
+                                opj_tcd_cblk_enc_t* cblk,
+                                OPJ_UINT32 orient,
+                                OPJ_UINT32 compno,
+                                OPJ_UINT32 level,
+                                OPJ_UINT32 qmfbid,
+                                OPJ_FLOAT64 stepsize,
+                                OPJ_UINT32 cblksty,
+                                OPJ_UINT32 numcomps,
+                                opj_tcd_tile_t * tile,
+                                const OPJ_FLOAT64 * mct_norms);
+
 /**
 Decode 1 code-block
 @param t1 T1 handle
@@ -263,12 +287,15 @@ Decode 1 code-block
 @param roishift Region of interest shifting value
 @param cblksty Code-block style
 */
-static void t1_decode_cblk(
-		opj_t1_t *t1,
-		opj_tcd_cblk_dec_t* cblk,
-		int orient,
-		int roishift,
-		int cblksty);
+static OPJ_BOOL opj_t1_decode_cblk( opj_t1_t *t1,
+                                    opj_tcd_cblk_dec_t* cblk,
+                                    OPJ_UINT32 orient,
+                                    OPJ_UINT32 roishift,
+                                    OPJ_UINT32 cblksty);
+
+OPJ_BOOL opj_t1_allocate_buffers(   opj_t1_t *t1,
+                                    OPJ_UINT32 w,
+                                    OPJ_UINT32 h);
 
 /*@}*/
 
@@ -276,25 +303,25 @@ static void t1_decode_cblk(
 
 /* ----------------------------------------------------------------------- */
 
-static char t1_getctxno_zc(int f, int orient) {
+OPJ_BYTE opj_t1_getctxno_zc(OPJ_UINT32 f, OPJ_UINT32 orient) {
 	return lut_ctxno_zc[(orient << 8) | (f & T1_SIG_OTH)];
 }
 
-static char t1_getctxno_sc(int f) {
+OPJ_BYTE opj_t1_getctxno_sc(OPJ_UINT32 f) {
 	return lut_ctxno_sc[(f & (T1_SIG_PRIM | T1_SGN)) >> 4];
 }
 
-static int t1_getctxno_mag(int f) {
-	int tmp1 = (f & T1_SIG_OTH) ? T1_CTXNO_MAG + 1 : T1_CTXNO_MAG;
-	int tmp2 = (f & T1_REFINE) ? T1_CTXNO_MAG + 2 : tmp1;
+OPJ_UINT32 opj_t1_getctxno_mag(OPJ_UINT32 f) {
+	OPJ_UINT32 tmp1 = (f & T1_SIG_OTH) ? T1_CTXNO_MAG + 1 : T1_CTXNO_MAG;
+	OPJ_UINT32 tmp2 = (f & T1_REFINE) ? T1_CTXNO_MAG + 2 : tmp1;
 	return (tmp2);
 }
 
-static char t1_getspb(int f) {
+OPJ_BYTE opj_t1_getspb(OPJ_UINT32 f) {
 	return lut_spb[(f & (T1_SIG_PRIM | T1_SGN)) >> 4];
 }
 
-static short t1_getnmsedec_sig(int x, int bitpos) {
+OPJ_INT16 opj_t1_getnmsedec_sig(OPJ_UINT32 x, OPJ_UINT32 bitpos) {
 	if (bitpos > T1_NMSEDEC_FRACBITS) {
 		return lut_nmsedec_sig[(x >> (bitpos - T1_NMSEDEC_FRACBITS)) & ((1 << T1_NMSEDEC_BITS) - 1)];
 	}
@@ -302,7 +329,7 @@ static short t1_getnmsedec_sig(int x, int bitpos) {
 	return lut_nmsedec_sig0[x & ((1 << T1_NMSEDEC_BITS) - 1)];
 }
 
-static short t1_getnmsedec_ref(int x, int bitpos) {
+OPJ_INT16 opj_t1_getnmsedec_ref(OPJ_UINT32 x, OPJ_UINT32 bitpos) {
 	if (bitpos > T1_NMSEDEC_FRACBITS) {
 		return lut_nmsedec_ref[(x >> (bitpos - T1_NMSEDEC_FRACBITS)) & ((1 << T1_NMSEDEC_BITS) - 1)];
 	}
@@ -310,11 +337,11 @@ static short t1_getnmsedec_ref(int x, int bitpos) {
     return lut_nmsedec_ref0[x & ((1 << T1_NMSEDEC_BITS) - 1)];
 }
 
-static void t1_updateflags(flag_t *flagsp, int s, int stride) {
-	flag_t *np = flagsp - stride;
-	flag_t *sp = flagsp + stride;
+void opj_t1_updateflags(opj_flag_t *flagsp, OPJ_UINT32 s, OPJ_UINT32 stride) {
+	opj_flag_t *np = flagsp - stride;
+	opj_flag_t *sp = flagsp + stride;
 
-	static const flag_t mod[] = {
+	static const opj_flag_t mod[] = {
 		T1_SIG_S, T1_SIG_S|T1_SGN_S,
 		T1_SIG_E, T1_SIG_E|T1_SGN_E,
 		T1_SIG_W, T1_SIG_W|T1_SGN_W,
@@ -334,134 +361,139 @@ static void t1_updateflags(flag_t *flagsp, int s, int stride) {
 	sp[1]  |= T1_SIG_NW;
 }
 
-static void t1_enc_sigpass_step(
-		opj_t1_t *t1,
-		flag_t *flagsp,
-		int *datap,
-		int orient,
-		int bpno,
-		int one,
-		int *nmsedec,
-		char type,
-		int vsc)
+void opj_t1_enc_sigpass_step(   opj_t1_t *t1,
+                                opj_flag_t *flagsp,
+                                OPJ_INT32 *datap,
+                                OPJ_UINT32 orient,
+                                OPJ_INT32 bpno,
+                                OPJ_INT32 one,
+                                OPJ_INT32 *nmsedec,
+                                OPJ_BYTE type,
+                                OPJ_UINT32 vsc
+                                )
 {
-	int v, flag;
+	OPJ_INT32 v;
+    OPJ_UINT32 flag;
 	
 	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
 	
-	flag = vsc ? ((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*flagsp);
+	flag = vsc ? (OPJ_UINT32)((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (OPJ_UINT32)(*flagsp);
 	if ((flag & T1_SIG_OTH) && !(flag & (T1_SIG | T1_VISIT))) {
-		v = int_abs(*datap) & one ? 1 : 0;
-		mqc_setcurctx(mqc, t1_getctxno_zc(flag, orient));	/* ESSAI */
+		v = opj_int_abs(*datap) & one ? 1 : 0;
+		opj_mqc_setcurctx(mqc, opj_t1_getctxno_zc(flag, orient));	/* ESSAI */
 		if (type == T1_TYPE_RAW) {	/* BYPASS/LAZY MODE */
-			mqc_bypass_enc(mqc, v);
+			opj_mqc_bypass_enc(mqc, (OPJ_UINT32)v);
 		} else {
-			mqc_encode(mqc, v);
+			opj_mqc_encode(mqc, (OPJ_UINT32)v);
 		}
 		if (v) {
 			v = *datap < 0 ? 1 : 0;
-			*nmsedec +=	t1_getnmsedec_sig(int_abs(*datap), bpno + T1_NMSEDEC_FRACBITS);
-			mqc_setcurctx(mqc, t1_getctxno_sc(flag));	/* ESSAI */
+			*nmsedec +=	opj_t1_getnmsedec_sig((OPJ_UINT32)opj_int_abs(*datap), (OPJ_UINT32)(bpno + T1_NMSEDEC_FRACBITS));
+			opj_mqc_setcurctx(mqc, opj_t1_getctxno_sc(flag));	/* ESSAI */
 			if (type == T1_TYPE_RAW) {	/* BYPASS/LAZY MODE */
-				mqc_bypass_enc(mqc, v);
+				opj_mqc_bypass_enc(mqc, (OPJ_UINT32)v);
 			} else {
-				mqc_encode(mqc, v ^ t1_getspb(flag));
+				opj_mqc_encode(mqc, (OPJ_UINT32)(v ^ opj_t1_getspb((OPJ_UINT32)flag)));
 			}
-			t1_updateflags(flagsp, v, t1->flags_stride);
+			opj_t1_updateflags(flagsp, (OPJ_UINT32)v, t1->flags_stride);
 		}
 		*flagsp |= T1_VISIT;
 	}
 }
 
-static INLINE void t1_dec_sigpass_step_raw(
-		opj_t1_t *t1,
-		flag_t *flagsp,
-		int *datap,
-		int orient,
-		int oneplushalf,
-		int vsc)
-{
-	int v, flag;
-	opj_raw_t *raw = t1->raw;	/* RAW component */
-	
-	OPJ_ARG_NOT_USED(orient);
-	
-	flag = vsc ? ((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*flagsp);
-	if ((flag & T1_SIG_OTH) && !(flag & (T1_SIG | T1_VISIT))) {
-			if (raw_decode(raw)) {
-				v = raw_decode(raw);	/* ESSAI */
-				*datap = v ? -oneplushalf : oneplushalf;
-				t1_updateflags(flagsp, v, t1->flags_stride);
-			}
-		*flagsp |= T1_VISIT;
-	}
-}				/* VSC and  BYPASS by Antonin */
 
-static INLINE void t1_dec_sigpass_step_mqc(
-		opj_t1_t *t1,
-		flag_t *flagsp,
-		int *datap,
-		int orient,
-		int oneplushalf)
+static INLINE void opj_t1_dec_sigpass_step_raw(
+                opj_t1_t *t1,
+                opj_flag_t *flagsp,
+                OPJ_INT32 *datap,
+                OPJ_INT32 orient,
+                OPJ_INT32 oneplushalf,
+                OPJ_INT32 vsc)
 {
-	int v, flag;
-	
-	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
-	
-	flag = *flagsp;
-	if ((flag & T1_SIG_OTH) && !(flag & (T1_SIG | T1_VISIT))) {
-			mqc_setcurctx(mqc, t1_getctxno_zc(flag, orient));
-			if (mqc_decode(mqc)) {
-				mqc_setcurctx(mqc, t1_getctxno_sc(flag));
-				v = mqc_decode(mqc) ^ t1_getspb(flag);
-				*datap = v ? -oneplushalf : oneplushalf;
-				t1_updateflags(flagsp, v, t1->flags_stride);
-			}
-		*flagsp |= T1_VISIT;
-	}
-}				/* VSC and  BYPASS by Antonin */
-
-static INLINE void t1_dec_sigpass_step_mqc_vsc(
-		opj_t1_t *t1,
-		flag_t *flagsp,
-		int *datap,
-		int orient,
-		int oneplushalf,
-		int vsc)
+        OPJ_INT32 v, flag;
+        opj_raw_t *raw = t1->raw;       /* RAW component */
+        OPJ_ARG_NOT_USED(orient);
+       
+        flag = vsc ? ((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*flagsp);
+        if ((flag & T1_SIG_OTH) && !(flag & (T1_SIG | T1_VISIT))) {
+                        if (opj_raw_decode(raw)) {
+                                v = (OPJ_INT32)opj_raw_decode(raw);    /* ESSAI */
+                                *datap = v ? -oneplushalf : oneplushalf;
+                                opj_t1_updateflags(flagsp, (OPJ_UINT32)v, t1->flags_stride);
+                        }
+                *flagsp |= T1_VISIT;
+        }
+}      
+
+INLINE void opj_t1_dec_sigpass_step_mqc(
+                opj_t1_t *t1,
+                opj_flag_t *flagsp,
+                OPJ_INT32 *datap,
+                OPJ_INT32 orient,
+                OPJ_INT32 oneplushalf)
 {
-	int v, flag;
-	
-	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
-	
-	flag = vsc ? ((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*flagsp);
-	if ((flag & T1_SIG_OTH) && !(flag & (T1_SIG | T1_VISIT))) {
-		mqc_setcurctx(mqc, t1_getctxno_zc(flag, orient));
-		if (mqc_decode(mqc)) {
-			mqc_setcurctx(mqc, t1_getctxno_sc(flag));
-			v = mqc_decode(mqc) ^ t1_getspb(flag);
-			*datap = v ? -oneplushalf : oneplushalf;
-			t1_updateflags(flagsp, v, t1->flags_stride);
-		}
-		*flagsp |= T1_VISIT;
-	}
-}				/* VSC and  BYPASS by Antonin */
-
-static void t1_enc_sigpass(
-		opj_t1_t *t1,
-		int bpno,
-		int orient,
-		int *nmsedec,
-		char type,
-		int cblksty)
+        OPJ_INT32 v, flag;
+       
+        opj_mqc_t *mqc = t1->mqc;       /* MQC component */
+       
+        flag = *flagsp;
+        if ((flag & T1_SIG_OTH) && !(flag & (T1_SIG | T1_VISIT))) {
+                        opj_mqc_setcurctx(mqc, opj_t1_getctxno_zc((OPJ_UINT32)flag, (OPJ_UINT32)orient));
+                        if (opj_mqc_decode(mqc)) {
+                                opj_mqc_setcurctx(mqc, opj_t1_getctxno_sc((OPJ_UINT32)flag));
+                                v = opj_mqc_decode(mqc) ^ opj_t1_getspb((OPJ_UINT32)flag);
+                                *datap = v ? -oneplushalf : oneplushalf;
+                                opj_t1_updateflags(flagsp, (OPJ_UINT32)v, t1->flags_stride);
+                        }
+                *flagsp |= T1_VISIT;
+        }
+}                               /* VSC and  BYPASS by Antonin */
+
+INLINE void opj_t1_dec_sigpass_step_mqc_vsc(
+                opj_t1_t *t1,
+                opj_flag_t *flagsp,
+                OPJ_INT32 *datap,
+                OPJ_INT32 orient,
+                OPJ_INT32 oneplushalf,
+                OPJ_INT32 vsc)
+{
+        OPJ_INT32 v, flag;
+       
+        opj_mqc_t *mqc = t1->mqc;       /* MQC component */
+       
+        flag = vsc ? ((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*flagsp);
+        if ((flag & T1_SIG_OTH) && !(flag & (T1_SIG | T1_VISIT))) {
+                opj_mqc_setcurctx(mqc, opj_t1_getctxno_zc((OPJ_UINT32)flag, (OPJ_UINT32)orient));
+                if (opj_mqc_decode(mqc)) {
+                        opj_mqc_setcurctx(mqc, opj_t1_getctxno_sc((OPJ_UINT32)flag));
+                        v = opj_mqc_decode(mqc) ^ opj_t1_getspb((OPJ_UINT32)flag);
+                        *datap = v ? -oneplushalf : oneplushalf;
+                        opj_t1_updateflags(flagsp, (OPJ_UINT32)v, t1->flags_stride);
+                }
+                *flagsp |= T1_VISIT;
+        }
+}                               /* VSC and  BYPASS by Antonin */
+
+
+
+void opj_t1_enc_sigpass(opj_t1_t *t1,
+                        OPJ_INT32 bpno,
+                        OPJ_UINT32 orient,
+                        OPJ_INT32 *nmsedec,
+                        OPJ_BYTE type,
+                        OPJ_UINT32 cblksty
+                        )
 {
-	int i, j, k, one, vsc;
+	OPJ_UINT32 i, j, k, vsc; 
+    OPJ_INT32 one;
+
 	*nmsedec = 0;
 	one = 1 << (bpno + T1_NMSEDEC_FRACBITS);
 	for (k = 0; k < t1->h; k += 4) {
 		for (i = 0; i < t1->w; ++i) {
 			for (j = k; j < k + 4 && j < t1->h; ++j) {
 				vsc = ((cblksty & J2K_CCP_CBLKSTY_VSC) && (j == k + 3 || j == t1->h - 1)) ? 1 : 0;
-				t1_enc_sigpass_step(
+				opj_t1_enc_sigpass_step(
 						t1,
 						&t1->flags[((j+1) * t1->flags_stride) + i + 1],
 						&t1->data[(j * t1->w) + i],
@@ -476,206 +508,214 @@ static void t1_enc_sigpass(
 	}
 }
 
-static void t1_dec_sigpass_raw(
-		opj_t1_t *t1,
-		int bpno,
-		int orient,
-		int cblksty)
+void opj_t1_dec_sigpass_raw(
+                opj_t1_t *t1,
+                OPJ_INT32 bpno,
+                OPJ_INT32 orient,
+                OPJ_INT32 cblksty)
 {
-	int i, j, k, one, half, oneplushalf, vsc;
-	one = 1 << bpno;
-	half = one >> 1;
-	oneplushalf = one | half;
-	for (k = 0; k < t1->h; k += 4) {
-		for (i = 0; i < t1->w; ++i) {
-			for (j = k; j < k + 4 && j < t1->h; ++j) {
-				vsc = ((cblksty & J2K_CCP_CBLKSTY_VSC) && (j == k + 3 || j == t1->h - 1)) ? 1 : 0;
-				t1_dec_sigpass_step_raw(
-						t1,
-						&t1->flags[((j+1) * t1->flags_stride) + i + 1],
-						&t1->data[(j * t1->w) + i],
-						orient,
-						oneplushalf,
-						vsc);
-			}
-		}
-	}
-}				/* VSC and  BYPASS by Antonin */
-
-static void t1_dec_sigpass_mqc(
-		opj_t1_t *t1,
-		int bpno,
-		int orient)
+        OPJ_INT32 one, half, oneplushalf, vsc;
+        OPJ_UINT32 i, j, k; 
+        one = 1 << bpno;
+        half = one >> 1;
+        oneplushalf = one | half;
+        for (k = 0; k < t1->h; k += 4) {
+                for (i = 0; i < t1->w; ++i) {
+                        for (j = k; j < k + 4 && j < t1->h; ++j) {
+                                vsc = ((cblksty & J2K_CCP_CBLKSTY_VSC) && (j == k + 3 || j == t1->h - 1)) ? 1 : 0;
+                                opj_t1_dec_sigpass_step_raw(
+                                                t1,
+                                                &t1->flags[((j+1) * t1->flags_stride) + i + 1],
+                                                &t1->data[(j * t1->w) + i],
+                                                orient,
+                                                oneplushalf,
+                                                vsc);
+                        }
+                }
+        }
+}                               /* VSC and  BYPASS by Antonin */
+
+void opj_t1_dec_sigpass_mqc(
+                opj_t1_t *t1,
+                OPJ_INT32 bpno,
+                OPJ_INT32 orient)
 {
-	int i, j, k, one, half, oneplushalf;
-	int *data1 = t1->data;
-	flag_t *flags1 = &t1->flags[1];
-	one = 1 << bpno;
-	half = one >> 1;
-	oneplushalf = one | half;
-	for (k = 0; k < (t1->h & ~3); k += 4) {
-		for (i = 0; i < t1->w; ++i) {
-			int *data2 = data1 + i;
-			flag_t *flags2 = flags1 + i;
-			flags2 += t1->flags_stride;
-			t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
-			data2 += t1->w;
-			flags2 += t1->flags_stride;
-			t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
-			data2 += t1->w;
-			flags2 += t1->flags_stride;
-			t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
-			data2 += t1->w;
-			flags2 += t1->flags_stride;
-			t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
-			data2 += t1->w;
-		}
-		data1 += t1->w << 2;
-		flags1 += t1->flags_stride << 2;
-	}
-	for (i = 0; i < t1->w; ++i) {
-		int *data2 = data1 + i;
-		flag_t *flags2 = flags1 + i;
-		for (j = k; j < t1->h; ++j) {
-			flags2 += t1->flags_stride;
-			t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
-			data2 += t1->w;
-		}
-	}
-}				/* VSC and  BYPASS by Antonin */
-
-static void t1_dec_sigpass_mqc_vsc(
-		opj_t1_t *t1,
-		int bpno,
-		int orient)
+        OPJ_INT32 one, half, oneplushalf;
+        OPJ_UINT32 i, j, k;
+        OPJ_INT32 *data1 = t1->data;
+        opj_flag_t *flags1 = &t1->flags[1];
+        one = 1 << bpno;
+        half = one >> 1;
+        oneplushalf = one | half;
+        for (k = 0; k < (t1->h & ~3u); k += 4) {
+                for (i = 0; i < t1->w; ++i) {
+                        OPJ_INT32 *data2 = data1 + i;
+                        opj_flag_t *flags2 = flags1 + i;
+                        flags2 += t1->flags_stride;
+                        opj_t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
+                        data2 += t1->w;
+                        flags2 += t1->flags_stride;
+                        opj_t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
+                        data2 += t1->w;
+                        flags2 += t1->flags_stride;
+                        opj_t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
+                        data2 += t1->w;
+                        flags2 += t1->flags_stride;
+                        opj_t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
+                        data2 += t1->w;
+                }
+                data1 += t1->w << 2;
+                flags1 += t1->flags_stride << 2;
+        }
+        for (i = 0; i < t1->w; ++i) {
+                OPJ_INT32 *data2 = data1 + i;
+                opj_flag_t *flags2 = flags1 + i;
+                for (j = k; j < t1->h; ++j) {
+                        flags2 += t1->flags_stride;
+                        opj_t1_dec_sigpass_step_mqc(t1, flags2, data2, orient, oneplushalf);
+                        data2 += t1->w;
+                }
+        }
+}                               /* VSC and  BYPASS by Antonin */
+
+void opj_t1_dec_sigpass_mqc_vsc(
+                opj_t1_t *t1,
+                OPJ_INT32 bpno,
+                OPJ_INT32 orient)
 {
-	int i, j, k, one, half, oneplushalf, vsc;
-	one = 1 << bpno;
-	half = one >> 1;
-	oneplushalf = one | half;
-	for (k = 0; k < t1->h; k += 4) {
-		for (i = 0; i < t1->w; ++i) {
-			for (j = k; j < k + 4 && j < t1->h; ++j) {
-				vsc = (j == k + 3 || j == t1->h - 1) ? 1 : 0;
-				t1_dec_sigpass_step_mqc_vsc(
-						t1,
-						&t1->flags[((j+1) * t1->flags_stride) + i + 1],
-						&t1->data[(j * t1->w) + i],
-						orient,
-						oneplushalf,
-						vsc);
-			}
-		}
-	}
-}				/* VSC and  BYPASS by Antonin */
-
-static void t1_enc_refpass_step(
-		opj_t1_t *t1,
-		flag_t *flagsp,
-		int *datap,
-		int bpno,
-		int one,
-		int *nmsedec,
-		char type,
-		int vsc)
+        OPJ_INT32 one, half, oneplushalf, vsc;
+        OPJ_UINT32 i, j, k;
+        one = 1 << bpno;
+        half = one >> 1;
+        oneplushalf = one | half;
+        for (k = 0; k < t1->h; k += 4) {
+                for (i = 0; i < t1->w; ++i) {
+                        for (j = k; j < k + 4 && j < t1->h; ++j) {
+                                vsc = (j == k + 3 || j == t1->h - 1) ? 1 : 0;
+                                opj_t1_dec_sigpass_step_mqc_vsc(
+                                                t1,
+                                                &t1->flags[((j+1) * t1->flags_stride) + i + 1],
+                                                &t1->data[(j * t1->w) + i],
+                                                orient,
+                                                oneplushalf,
+                                                vsc);
+                        }
+                }
+        }
+}                               /* VSC and  BYPASS by Antonin */
+
+
+
+void opj_t1_enc_refpass_step(   opj_t1_t *t1,
+                                opj_flag_t *flagsp,
+                                OPJ_INT32 *datap,
+                                OPJ_INT32 bpno,
+                                OPJ_INT32 one,
+                                OPJ_INT32 *nmsedec,
+                                OPJ_BYTE type,
+                                OPJ_UINT32 vsc)
 {
-	int v, flag;
+	OPJ_INT32 v;
+	OPJ_UINT32 flag;
 	
 	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
 	
-	flag = vsc ? ((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*flagsp);
+	flag = vsc ? (OPJ_UINT32)((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (OPJ_UINT32)(*flagsp);
 	if ((flag & (T1_SIG | T1_VISIT)) == T1_SIG) {
-		*nmsedec += t1_getnmsedec_ref(int_abs(*datap), bpno + T1_NMSEDEC_FRACBITS);
-		v = int_abs(*datap) & one ? 1 : 0;
-		mqc_setcurctx(mqc, t1_getctxno_mag(flag));	/* ESSAI */
+		*nmsedec += opj_t1_getnmsedec_ref((OPJ_UINT32)opj_int_abs(*datap), (OPJ_UINT32)(bpno + T1_NMSEDEC_FRACBITS));
+		v = opj_int_abs(*datap) & one ? 1 : 0;
+		opj_mqc_setcurctx(mqc, opj_t1_getctxno_mag(flag));	/* ESSAI */
 		if (type == T1_TYPE_RAW) {	/* BYPASS/LAZY MODE */
-			mqc_bypass_enc(mqc, v);
+			opj_mqc_bypass_enc(mqc, (OPJ_UINT32)v);
 		} else {
-			mqc_encode(mqc, v);
+			opj_mqc_encode(mqc, (OPJ_UINT32)v);
 		}
 		*flagsp |= T1_REFINE;
 	}
 }
 
-static INLINE void t1_dec_refpass_step_raw(
-		opj_t1_t *t1,
-		flag_t *flagsp,
-		int *datap,
-		int poshalf,
-		int neghalf,
-		int vsc)
+INLINE void opj_t1_dec_refpass_step_raw(
+                opj_t1_t *t1,
+                opj_flag_t *flagsp,
+                OPJ_INT32 *datap,
+                OPJ_INT32 poshalf,
+                OPJ_INT32 neghalf,
+                OPJ_INT32 vsc)
 {
-	int v, t, flag;
-	
-	opj_raw_t *raw = t1->raw;	/* RAW component */
-	
-	flag = vsc ? ((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*flagsp);
-	if ((flag & (T1_SIG | T1_VISIT)) == T1_SIG) {
-			v = raw_decode(raw);
-		t = v ? poshalf : neghalf;
-		*datap += *datap < 0 ? -t : t;
-		*flagsp |= T1_REFINE;
-	}
-}				/* VSC and  BYPASS by Antonin  */
-
-static INLINE void t1_dec_refpass_step_mqc(
-		opj_t1_t *t1,
-		flag_t *flagsp,
-		int *datap,
-		int poshalf,
-		int neghalf)
+        OPJ_INT32 v, t, flag;
+       
+        opj_raw_t *raw = t1->raw;       /* RAW component */
+       
+        flag = vsc ? ((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*flagsp);
+        if ((flag & (T1_SIG | T1_VISIT)) == T1_SIG) {
+                        v = (OPJ_INT32)opj_raw_decode(raw);
+                t = v ? poshalf : neghalf;
+                *datap += *datap < 0 ? -t : t;
+                *flagsp |= T1_REFINE;
+        }
+}                               /* VSC and  BYPASS by Antonin  */
+
+INLINE void opj_t1_dec_refpass_step_mqc(
+                opj_t1_t *t1,
+                opj_flag_t *flagsp,
+                OPJ_INT32 *datap,
+                OPJ_INT32 poshalf,
+                OPJ_INT32 neghalf)
 {
-	int v, t, flag;
-	
-	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
-	
-	flag = *flagsp;
-	if ((flag & (T1_SIG | T1_VISIT)) == T1_SIG) {
-		mqc_setcurctx(mqc, t1_getctxno_mag(flag));	/* ESSAI */
-			v = mqc_decode(mqc);
-		t = v ? poshalf : neghalf;
-		*datap += *datap < 0 ? -t : t;
-		*flagsp |= T1_REFINE;
-		}
-}				/* VSC and  BYPASS by Antonin  */
-
-static INLINE void t1_dec_refpass_step_mqc_vsc(
-		opj_t1_t *t1,
-		flag_t *flagsp,
-		int *datap,
-		int poshalf,
-		int neghalf,
-		int vsc)
+        OPJ_INT32 v, t, flag;
+       
+        opj_mqc_t *mqc = t1->mqc;       /* MQC component */
+       
+        flag = *flagsp;
+        if ((flag & (T1_SIG | T1_VISIT)) == T1_SIG) {
+                opj_mqc_setcurctx(mqc, opj_t1_getctxno_mag((OPJ_UINT32)flag));      /* ESSAI */
+                        v = opj_mqc_decode(mqc);
+                t = v ? poshalf : neghalf;
+                *datap += *datap < 0 ? -t : t;
+                *flagsp |= T1_REFINE;
+                }
+}                               /* VSC and  BYPASS by Antonin  */
+
+INLINE void opj_t1_dec_refpass_step_mqc_vsc(
+                opj_t1_t *t1,
+                opj_flag_t *flagsp,
+                OPJ_INT32 *datap,
+                OPJ_INT32 poshalf,
+                OPJ_INT32 neghalf,
+                OPJ_INT32 vsc)
 {
-	int v, t, flag;
-	
-	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
-	
-	flag = vsc ? ((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*flagsp);
-	if ((flag & (T1_SIG | T1_VISIT)) == T1_SIG) {
-		mqc_setcurctx(mqc, t1_getctxno_mag(flag));	/* ESSAI */
-		v = mqc_decode(mqc);
-		t = v ? poshalf : neghalf;
-		*datap += *datap < 0 ? -t : t;
-		*flagsp |= T1_REFINE;
-	}
-}				/* VSC and  BYPASS by Antonin  */
-
-static void t1_enc_refpass(
+        OPJ_INT32 v, t, flag;
+       
+        opj_mqc_t *mqc = t1->mqc;       /* MQC component */
+       
+        flag = vsc ? ((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*flagsp);
+        if ((flag & (T1_SIG | T1_VISIT)) == T1_SIG) {
+                opj_mqc_setcurctx(mqc, opj_t1_getctxno_mag((OPJ_UINT32)flag));      /* ESSAI */
+                v = opj_mqc_decode(mqc);
+                t = v ? poshalf : neghalf;
+                *datap += *datap < 0 ? -t : t;
+                *flagsp |= T1_REFINE;
+        }
+}                               /* VSC and  BYPASS by Antonin  */
+
+
+void opj_t1_enc_refpass(
 		opj_t1_t *t1,
-		int bpno,
-		int *nmsedec,
-		char type,
-		int cblksty)
+		OPJ_INT32 bpno,
+		OPJ_INT32 *nmsedec,
+		OPJ_BYTE type,
+		OPJ_UINT32 cblksty)
 {
-	int i, j, k, one, vsc;
+	OPJ_UINT32 i, j, k, vsc;
+    OPJ_INT32 one;
+
 	*nmsedec = 0;
 	one = 1 << (bpno + T1_NMSEDEC_FRACBITS);
 	for (k = 0; k < t1->h; k += 4) {
 		for (i = 0; i < t1->w; ++i) {
 			for (j = k; j < k + 4 && j < t1->h; ++j) {
 				vsc = ((cblksty & J2K_CCP_CBLKSTY_VSC) && (j == k + 3 || j == t1->h - 1)) ? 1 : 0;
-				t1_enc_refpass_step(
+				opj_t1_enc_refpass_step(
 						t1,
 						&t1->flags[((j+1) * t1->flags_stride) + i + 1],
 						&t1->data[(j * t1->w) + i],
@@ -689,187 +729,192 @@ static void t1_enc_refpass(
 	}
 }
 
-static void t1_dec_refpass_raw(
-		opj_t1_t *t1,
-		int bpno,
-		int cblksty)
+void opj_t1_dec_refpass_raw(
+                opj_t1_t *t1,
+                OPJ_INT32 bpno,
+                OPJ_INT32 cblksty)
 {
-	int i, j, k, one, poshalf, neghalf;
-	int vsc;
-	one = 1 << bpno;
-	poshalf = one >> 1;
-	neghalf = bpno > 0 ? -poshalf : -1;
-	for (k = 0; k < t1->h; k += 4) {
-		for (i = 0; i < t1->w; ++i) {
-			for (j = k; j < k + 4 && j < t1->h; ++j) {
-				vsc = ((cblksty & J2K_CCP_CBLKSTY_VSC) && (j == k + 3 || j == t1->h - 1)) ? 1 : 0;
-				t1_dec_refpass_step_raw(
-						t1,
-						&t1->flags[((j+1) * t1->flags_stride) + i + 1],
-						&t1->data[(j * t1->w) + i],
-						poshalf,
-						neghalf,
-						vsc);
-			}
-		}
-	}
-}				/* VSC and  BYPASS by Antonin */
-
-static void t1_dec_refpass_mqc(
-		opj_t1_t *t1,
-		int bpno)
+        OPJ_INT32 one, poshalf, neghalf;
+        OPJ_UINT32 i, j, k;
+        OPJ_INT32 vsc;
+        one = 1 << bpno;
+        poshalf = one >> 1;
+        neghalf = bpno > 0 ? -poshalf : -1;
+        for (k = 0; k < t1->h; k += 4) {
+                for (i = 0; i < t1->w; ++i) {
+                        for (j = k; j < k + 4 && j < t1->h; ++j) {
+                                vsc = ((cblksty & J2K_CCP_CBLKSTY_VSC) && (j == k + 3 || j == t1->h - 1)) ? 1 : 0;
+                                opj_t1_dec_refpass_step_raw(
+                                                t1,
+                                                &t1->flags[((j+1) * t1->flags_stride) + i + 1],
+                                                &t1->data[(j * t1->w) + i],
+                                                poshalf,
+                                                neghalf,
+                                                vsc);
+                        }
+                }
+        }
+}                               /* VSC and  BYPASS by Antonin */
+
+void opj_t1_dec_refpass_mqc(
+                opj_t1_t *t1,
+                OPJ_INT32 bpno)
 {
-	int i, j, k, one, poshalf, neghalf;
-	int *data1 = t1->data;
-	flag_t *flags1 = &t1->flags[1];
-	one = 1 << bpno;
-	poshalf = one >> 1;
-	neghalf = bpno > 0 ? -poshalf : -1;
-	for (k = 0; k < (t1->h & ~3); k += 4) {
-		for (i = 0; i < t1->w; ++i) {
-			int *data2 = data1 + i;
-			flag_t *flags2 = flags1 + i;
-			flags2 += t1->flags_stride;
-			t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
-			data2 += t1->w;
-			flags2 += t1->flags_stride;
-			t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
-			data2 += t1->w;
-			flags2 += t1->flags_stride;
-			t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
-			data2 += t1->w;
-			flags2 += t1->flags_stride;
-			t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
-			data2 += t1->w;
-		}
-		data1 += t1->w << 2;
-		flags1 += t1->flags_stride << 2;
-	}
-	for (i = 0; i < t1->w; ++i) {
-		int *data2 = data1 + i;
-		flag_t *flags2 = flags1 + i;
-		for (j = k; j < t1->h; ++j) {
-			flags2 += t1->flags_stride;
-			t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
-			data2 += t1->w;
-		}
-	}
-}				/* VSC and  BYPASS by Antonin */
-
-static void t1_dec_refpass_mqc_vsc(
-		opj_t1_t *t1,
-		int bpno)
+        OPJ_INT32 one, poshalf, neghalf;
+        OPJ_UINT32 i, j, k;
+        OPJ_INT32 *data1 = t1->data;
+        opj_flag_t *flags1 = &t1->flags[1];
+        one = 1 << bpno;
+        poshalf = one >> 1;
+        neghalf = bpno > 0 ? -poshalf : -1;
+        for (k = 0; k < (t1->h & ~3u); k += 4) {
+                for (i = 0; i < t1->w; ++i) {
+                        OPJ_INT32 *data2 = data1 + i;
+                        opj_flag_t *flags2 = flags1 + i;
+                        flags2 += t1->flags_stride;
+                        opj_t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
+                        data2 += t1->w;
+                        flags2 += t1->flags_stride;
+                        opj_t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
+                        data2 += t1->w;
+                        flags2 += t1->flags_stride;
+                        opj_t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
+                        data2 += t1->w;
+                        flags2 += t1->flags_stride;
+                        opj_t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
+                        data2 += t1->w;
+                }
+                data1 += t1->w << 2;
+                flags1 += t1->flags_stride << 2;
+        }
+        for (i = 0; i < t1->w; ++i) {
+                OPJ_INT32 *data2 = data1 + i;
+                opj_flag_t *flags2 = flags1 + i;
+                for (j = k; j < t1->h; ++j) {
+                        flags2 += t1->flags_stride;
+                        opj_t1_dec_refpass_step_mqc(t1, flags2, data2, poshalf, neghalf);
+                        data2 += t1->w;
+                }
+        }
+}                               /* VSC and  BYPASS by Antonin */
+
+void opj_t1_dec_refpass_mqc_vsc(
+                opj_t1_t *t1,
+                OPJ_INT32 bpno)
 {
-	int i, j, k, one, poshalf, neghalf;
-	int vsc;
-	one = 1 << bpno;
-	poshalf = one >> 1;
-	neghalf = bpno > 0 ? -poshalf : -1;
-	for (k = 0; k < t1->h; k += 4) {
-		for (i = 0; i < t1->w; ++i) {
-			for (j = k; j < k + 4 && j < t1->h; ++j) {
-				vsc = ((j == k + 3 || j == t1->h - 1)) ? 1 : 0;
-				t1_dec_refpass_step_mqc_vsc(
-						t1,
-						&t1->flags[((j+1) * t1->flags_stride) + i + 1],
-						&t1->data[(j * t1->w) + i],
-						poshalf,
-						neghalf,
-						vsc);
-			}
-		}
-	}
-}				/* VSC and  BYPASS by Antonin */
-
-static void t1_enc_clnpass_step(
+        OPJ_INT32 one, poshalf, neghalf;
+        OPJ_UINT32 i, j, k;
+        OPJ_INT32 vsc;
+        one = 1 << bpno;
+        poshalf = one >> 1;
+        neghalf = bpno > 0 ? -poshalf : -1;
+        for (k = 0; k < t1->h; k += 4) {
+                for (i = 0; i < t1->w; ++i) {
+                        for (j = k; j < k + 4 && j < t1->h; ++j) {
+                                vsc = ((j == k + 3 || j == t1->h - 1)) ? 1 : 0;
+                                opj_t1_dec_refpass_step_mqc_vsc(
+                                                t1,
+                                                &t1->flags[((j+1) * t1->flags_stride) + i + 1],
+                                                &t1->data[(j * t1->w) + i],
+                                                poshalf,
+                                                neghalf,
+                                                vsc);
+                        }
+                }
+        }
+}                               /* VSC and  BYPASS by Antonin */
+
+
+void opj_t1_enc_clnpass_step(
 		opj_t1_t *t1,
-		flag_t *flagsp,
-		int *datap,
-		int orient,
-		int bpno,
-		int one,
-		int *nmsedec,
-		int partial,
-		int vsc)
+		opj_flag_t *flagsp,
+		OPJ_INT32 *datap,
+		OPJ_UINT32 orient,
+		OPJ_INT32 bpno,
+		OPJ_INT32 one,
+		OPJ_INT32 *nmsedec,
+		OPJ_UINT32 partial,
+		OPJ_UINT32 vsc)
 {
-	int v, flag;
+	OPJ_INT32 v;
+	OPJ_UINT32 flag;
 	
 	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
 	
-	flag = vsc ? ((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*flagsp);
+	flag = vsc ? (OPJ_UINT32)((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (OPJ_UINT32)(*flagsp);
 	if (partial) {
 		goto LABEL_PARTIAL;
 	}
 	if (!(*flagsp & (T1_SIG | T1_VISIT))) {
-		mqc_setcurctx(mqc, t1_getctxno_zc(flag, orient));
-		v = int_abs(*datap) & one ? 1 : 0;
-		mqc_encode(mqc, v);
+		opj_mqc_setcurctx(mqc, opj_t1_getctxno_zc(flag, orient));
+		v = opj_int_abs(*datap) & one ? 1 : 0;
+		opj_mqc_encode(mqc, (OPJ_UINT32)v);
 		if (v) {
 LABEL_PARTIAL:
-			*nmsedec += t1_getnmsedec_sig(int_abs(*datap), bpno + T1_NMSEDEC_FRACBITS);
-			mqc_setcurctx(mqc, t1_getctxno_sc(flag));
+			*nmsedec += opj_t1_getnmsedec_sig((OPJ_UINT32)opj_int_abs(*datap), (OPJ_UINT32)(bpno + T1_NMSEDEC_FRACBITS));
+			opj_mqc_setcurctx(mqc, opj_t1_getctxno_sc(flag));
 			v = *datap < 0 ? 1 : 0;
-			mqc_encode(mqc, v ^ t1_getspb(flag));
-			t1_updateflags(flagsp, v, t1->flags_stride);
+			opj_mqc_encode(mqc, (OPJ_UINT32)(v ^ opj_t1_getspb((OPJ_UINT32)flag)));
+			opj_t1_updateflags(flagsp, (OPJ_UINT32)v, t1->flags_stride);
 		}
 	}
 	*flagsp &= ~T1_VISIT;
 }
 
-static void t1_dec_clnpass_step_partial(
+static void opj_t1_dec_clnpass_step_partial(
 		opj_t1_t *t1,
-		flag_t *flagsp,
-		int *datap,
-		int orient,
-		int oneplushalf)
+		opj_flag_t *flagsp,
+		OPJ_INT32 *datap,
+		OPJ_INT32 orient,
+		OPJ_INT32 oneplushalf)
 {
-	int v, flag;
+	OPJ_INT32 v, flag;
 	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
 	
 	OPJ_ARG_NOT_USED(orient);
 	
 	flag = *flagsp;
-	mqc_setcurctx(mqc, t1_getctxno_sc(flag));
-	v = mqc_decode(mqc) ^ t1_getspb(flag);
+	opj_mqc_setcurctx(mqc, opj_t1_getctxno_sc((OPJ_UINT32)flag));
+	v = opj_mqc_decode(mqc) ^ opj_t1_getspb((OPJ_UINT32)flag);
 	*datap = v ? -oneplushalf : oneplushalf;
-	t1_updateflags(flagsp, v, t1->flags_stride);
+	opj_t1_updateflags(flagsp, (OPJ_UINT32)v, t1->flags_stride);
 	*flagsp &= ~T1_VISIT;
 }				/* VSC and  BYPASS by Antonin */
 
-static void t1_dec_clnpass_step(
+static void opj_t1_dec_clnpass_step(
 		opj_t1_t *t1,
-		flag_t *flagsp,
-		int *datap,
-		int orient,
-		int oneplushalf)
+		opj_flag_t *flagsp,
+		OPJ_INT32 *datap,
+		OPJ_INT32 orient,
+		OPJ_INT32 oneplushalf)
 {
-	int v, flag;
+	OPJ_INT32 v, flag;
 	
 	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
 	
 	flag = *flagsp;
 	if (!(flag & (T1_SIG | T1_VISIT))) {
-		mqc_setcurctx(mqc, t1_getctxno_zc(flag, orient));
-		if (mqc_decode(mqc)) {
-			mqc_setcurctx(mqc, t1_getctxno_sc(flag));
-			v = mqc_decode(mqc) ^ t1_getspb(flag);
+		opj_mqc_setcurctx(mqc, opj_t1_getctxno_zc((OPJ_UINT32)flag, (OPJ_UINT32)orient));
+		if (opj_mqc_decode(mqc)) {
+			opj_mqc_setcurctx(mqc, opj_t1_getctxno_sc((OPJ_UINT32)flag));
+			v = opj_mqc_decode(mqc) ^ opj_t1_getspb((OPJ_UINT32)flag);
 			*datap = v ? -oneplushalf : oneplushalf;
-			t1_updateflags(flagsp, v, t1->flags_stride);
+			opj_t1_updateflags(flagsp, (OPJ_UINT32)v, t1->flags_stride);
 		}
 	}
 	*flagsp &= ~T1_VISIT;
 }				/* VSC and  BYPASS by Antonin */
 
-static void t1_dec_clnpass_step_vsc(
+static void opj_t1_dec_clnpass_step_vsc(
 		opj_t1_t *t1,
-		flag_t *flagsp,
-		int *datap,
-		int orient,
-		int oneplushalf,
-		int partial,
-		int vsc)
+		opj_flag_t *flagsp,
+		OPJ_INT32 *datap,
+		OPJ_INT32 orient,
+		OPJ_INT32 oneplushalf,
+		OPJ_INT32 partial,
+		OPJ_INT32 vsc)
 {
-	int v, flag;
+	OPJ_INT32 v, flag;
 	
 	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
 	
@@ -878,26 +923,28 @@ static void t1_dec_clnpass_step_vsc(
 		goto LABEL_PARTIAL;
 	}
 	if (!(flag & (T1_SIG | T1_VISIT))) {
-		mqc_setcurctx(mqc, t1_getctxno_zc(flag, orient));
-		if (mqc_decode(mqc)) {
+		opj_mqc_setcurctx(mqc, opj_t1_getctxno_zc((OPJ_UINT32)flag, (OPJ_UINT32)orient));
+		if (opj_mqc_decode(mqc)) {
 LABEL_PARTIAL:
-			mqc_setcurctx(mqc, t1_getctxno_sc(flag));
-			v = mqc_decode(mqc) ^ t1_getspb(flag);
+			opj_mqc_setcurctx(mqc, opj_t1_getctxno_sc((OPJ_UINT32)flag));
+			v = opj_mqc_decode(mqc) ^ opj_t1_getspb((OPJ_UINT32)flag);
 			*datap = v ? -oneplushalf : oneplushalf;
-			t1_updateflags(flagsp, v, t1->flags_stride);
+			opj_t1_updateflags(flagsp, (OPJ_UINT32)v, t1->flags_stride);
 		}
 	}
 	*flagsp &= ~T1_VISIT;
 }
 
-static void t1_enc_clnpass(
+void opj_t1_enc_clnpass(
 		opj_t1_t *t1,
-		int bpno,
-		int orient,
-		int *nmsedec,
-		int cblksty)
+		OPJ_INT32 bpno,
+		OPJ_UINT32 orient,
+		OPJ_INT32 *nmsedec,
+		OPJ_UINT32 cblksty)
 {
-	int i, j, k, one, agg, runlen, vsc;
+	OPJ_UINT32 i, j, k;
+	OPJ_INT32 one;
+	OPJ_UINT32 agg, runlen, vsc;
 	
 	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
 	
@@ -923,23 +970,23 @@ static void t1_enc_clnpass(
 			}
 			if (agg) {
 				for (runlen = 0; runlen < 4; ++runlen) {
-					if (int_abs(t1->data[((k + runlen)*t1->w) + i]) & one)
+					if (opj_int_abs(t1->data[((k + runlen)*t1->w) + i]) & one)
 						break;
 				}
-				mqc_setcurctx(mqc, T1_CTXNO_AGG);
-				mqc_encode(mqc, runlen != 4);
+				opj_mqc_setcurctx(mqc, T1_CTXNO_AGG);
+				opj_mqc_encode(mqc, runlen != 4);
 				if (runlen == 4) {
 					continue;
 				}
-				mqc_setcurctx(mqc, T1_CTXNO_UNI);
-				mqc_encode(mqc, runlen >> 1);
-				mqc_encode(mqc, runlen & 1);
+				opj_mqc_setcurctx(mqc, T1_CTXNO_UNI);
+				opj_mqc_encode(mqc, runlen >> 1);
+				opj_mqc_encode(mqc, runlen & 1);
 			} else {
 				runlen = 0;
 			}
 			for (j = k + runlen; j < k + 4 && j < t1->h; ++j) {
 				vsc = ((cblksty & J2K_CCP_CBLKSTY_VSC) && (j == k + 3 || j == t1->h - 1)) ? 1 : 0;
-				t1_enc_clnpass_step(
+				opj_t1_enc_clnpass_step(
 						t1,
 						&t1->flags[((j+1) * t1->flags_stride) + i + 1],
 						&t1->data[(j * t1->w) + i],
@@ -954,14 +1001,15 @@ static void t1_enc_clnpass(
 	}
 }
 
-static void t1_dec_clnpass(
+static void opj_t1_dec_clnpass(
 		opj_t1_t *t1,
-		int bpno,
-		int orient,
-		int cblksty)
+		OPJ_INT32 bpno,
+		OPJ_INT32 orient,
+		OPJ_INT32 cblksty)
 {
-	int i, j, k, one, half, oneplushalf, agg, runlen, vsc;
-	int segsym = cblksty & J2K_CCP_CBLKSTY_SEGSYM;
+	OPJ_INT32 one, half, oneplushalf, agg, runlen, vsc;
+    OPJ_UINT32 i, j, k;
+	OPJ_INT32 segsym = cblksty & J2K_CCP_CBLKSTY_SEGSYM;
 	
 	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
 	
@@ -981,71 +1029,71 @@ static void t1_dec_clnpass(
 				agg = 0;
 			}
 			if (agg) {
-				mqc_setcurctx(mqc, T1_CTXNO_AGG);
-				if (!mqc_decode(mqc)) {
+				opj_mqc_setcurctx(mqc, T1_CTXNO_AGG);
+				if (!opj_mqc_decode(mqc)) {
 					continue;
 				}
-				mqc_setcurctx(mqc, T1_CTXNO_UNI);
-				runlen = mqc_decode(mqc);
-				runlen = (runlen << 1) | mqc_decode(mqc);
+				opj_mqc_setcurctx(mqc, T1_CTXNO_UNI);
+				runlen = opj_mqc_decode(mqc);
+				runlen = (runlen << 1) | opj_mqc_decode(mqc);
 			} else {
 				runlen = 0;
 			}
-			for (j = k + runlen; j < k + 4 && j < t1->h; ++j) {
+			for (j = k + (OPJ_UINT32)runlen; j < k + 4 && j < t1->h; ++j) {
 					vsc = (j == k + 3 || j == t1->h - 1) ? 1 : 0;
-					t1_dec_clnpass_step_vsc(
+					opj_t1_dec_clnpass_step_vsc(
 						t1,
 						&t1->flags[((j+1) * t1->flags_stride) + i + 1],
 						&t1->data[(j * t1->w) + i],
 						orient,
 						oneplushalf,
-						agg && (j == k + runlen),
+						agg && (j == k + (OPJ_UINT32)runlen),
 						vsc);
 			}
 		}
 	}
 	} else {
-		int *data1 = t1->data;
-		flag_t *flags1 = &t1->flags[1];
-		for (k = 0; k < (t1->h & ~3); k += 4) {
+		OPJ_INT32 *data1 = t1->data;
+		opj_flag_t *flags1 = &t1->flags[1];
+		for (k = 0; k < (t1->h & ~3u); k += 4) {
 			for (i = 0; i < t1->w; ++i) {
-				int *data2 = data1 + i;
-				flag_t *flags2 = flags1 + i;
+				OPJ_INT32 *data2 = data1 + i;
+				opj_flag_t *flags2 = flags1 + i;
 				agg = !(MACRO_t1_flags(1 + k,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH)
 					|| MACRO_t1_flags(1 + k + 1,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH)
 					|| MACRO_t1_flags(1 + k + 2,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH)
 					|| MACRO_t1_flags(1 + k + 3,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH));
 				if (agg) {
-					mqc_setcurctx(mqc, T1_CTXNO_AGG);
-					if (!mqc_decode(mqc)) {
+					opj_mqc_setcurctx(mqc, T1_CTXNO_AGG);
+					if (!opj_mqc_decode(mqc)) {
 						continue;
 					}
-					mqc_setcurctx(mqc, T1_CTXNO_UNI);
-					runlen = mqc_decode(mqc);
-					runlen = (runlen << 1) | mqc_decode(mqc);
-					flags2 += runlen * t1->flags_stride;
-					data2 += runlen * t1->w;
-					for (j = k + runlen; j < k + 4 && j < t1->h; ++j) {
+					opj_mqc_setcurctx(mqc, T1_CTXNO_UNI);
+					runlen = opj_mqc_decode(mqc);
+					runlen = (runlen << 1) | opj_mqc_decode(mqc);
+					flags2 += (OPJ_UINT32)runlen * t1->flags_stride;
+					data2 += (OPJ_UINT32)runlen * t1->w;
+					for (j = k + (OPJ_UINT32)runlen; j < k + 4 && j < t1->h; ++j) {
 						flags2 += t1->flags_stride;
-						if (agg && (j == k + runlen)) {
-							t1_dec_clnpass_step_partial(t1, flags2, data2, orient, oneplushalf);
+						if (agg && (j == k + (OPJ_UINT32)runlen)) {
+							opj_t1_dec_clnpass_step_partial(t1, flags2, data2, orient, oneplushalf);
 						} else {
-							t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
+							opj_t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
 						}
 						data2 += t1->w;
 					}
 				} else {
 					flags2 += t1->flags_stride;
-					t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
+					opj_t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
 					data2 += t1->w;
 					flags2 += t1->flags_stride;
-					t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
+					opj_t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
 					data2 += t1->w;
 					flags2 += t1->flags_stride;
-					t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
+					opj_t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
 					data2 += t1->w;
 					flags2 += t1->flags_stride;
-					t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
+					opj_t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
 					data2 += t1->w;
 				}
 			}
@@ -1053,23 +1101,23 @@ static void t1_dec_clnpass(
 			flags1 += t1->flags_stride << 2;
 		}
 		for (i = 0; i < t1->w; ++i) {
-			int *data2 = data1 + i;
-			flag_t *flags2 = flags1 + i;
+			OPJ_INT32 *data2 = data1 + i;
+			opj_flag_t *flags2 = flags1 + i;
 			for (j = k; j < t1->h; ++j) {
 				flags2 += t1->flags_stride;
-				t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
+				opj_t1_dec_clnpass_step(t1, flags2, data2, orient, oneplushalf);
 				data2 += t1->w;
 			}
 		}
 	}
 
 	if (segsym) {
-		int v = 0;
-		mqc_setcurctx(mqc, T1_CTXNO_UNI);
-		v = mqc_decode(mqc);
-		v = (v << 1) | mqc_decode(mqc);
-		v = (v << 1) | mqc_decode(mqc);
-		v = (v << 1) | mqc_decode(mqc);
+		OPJ_INT32 v = 0;
+		opj_mqc_setcurctx(mqc, T1_CTXNO_UNI);
+		v = opj_mqc_decode(mqc);
+		v = (v << 1) | opj_mqc_decode(mqc);
+		v = (v << 1) | opj_mqc_decode(mqc);
+		v = (v << 1) | opj_mqc_decode(mqc);
 		/*
 		if (v!=0xa) {
 			opj_event_msg(t1->cinfo, EVT_WARNING, "Bad segmentation symbol %x\n", v);
@@ -1080,61 +1128,66 @@ static void t1_dec_clnpass(
 
 
 /** mod fixed_quality */
-static double t1_getwmsedec(
-		int nmsedec,
-		int compno,
-		int level,
-		int orient,
-		int bpno,
-		int qmfbid,
-		double stepsize,
-		int numcomps,
-		int mct)
+static OPJ_FLOAT64 opj_t1_getwmsedec(
+		OPJ_INT32 nmsedec,
+		OPJ_UINT32 compno,
+		OPJ_UINT32 level,
+		OPJ_UINT32 orient,
+		OPJ_INT32 bpno,
+		OPJ_UINT32 qmfbid,
+		OPJ_FLOAT64 stepsize,
+		OPJ_UINT32 numcomps,
+		const OPJ_FLOAT64 * mct_norms)
 {
-	double w1, w2, wmsedec;
+	OPJ_FLOAT64 w1 = 1, w2, wmsedec;
+    OPJ_ARG_NOT_USED(numcomps);
+
+	if (mct_norms) {
+		w1 = mct_norms[compno];
+	}
+
 	if (qmfbid == 1) {
-		w1 = (mct && numcomps==3) ? mct_getnorm(compno) : 1.0;
-		w2 = dwt_getnorm(level, orient);
-	} else {			/* if (qmfbid == 0) */
-		w1 = (mct && numcomps==3) ? mct_getnorm_real(compno) : 1.0;
-		w2 = dwt_getnorm_real(level, orient);
+		w2 = opj_dwt_getnorm(level, orient);
+	} else {	/* if (qmfbid == 0) */
+		w2 = opj_dwt_getnorm_real(level, orient);
 	}
+
 	wmsedec = w1 * w2 * stepsize * (1 << bpno);
 	wmsedec *= wmsedec * nmsedec / 8192.0;
-	
+
 	return wmsedec;
 }
 
-static opj_bool allocate_buffers(
+OPJ_BOOL opj_t1_allocate_buffers(
 		opj_t1_t *t1,
-		int w,
-		int h)
+		OPJ_UINT32 w,
+		OPJ_UINT32 h)
 {
-	int datasize=w * h;
-	int flagssize;
+	OPJ_UINT32 datasize=w * h;
+	OPJ_UINT32 flagssize;
 
 	if(datasize > t1->datasize){
 		opj_aligned_free(t1->data);
-		t1->data = (int*) opj_aligned_malloc(datasize * sizeof(int));
+		t1->data = (OPJ_INT32*) opj_aligned_malloc(datasize * sizeof(OPJ_INT32));
 		if(!t1->data){
 			return OPJ_FALSE;
 		}
 		t1->datasize=datasize;
 	}
-	memset(t1->data,0,datasize * sizeof(int));
+	memset(t1->data,0,datasize * sizeof(OPJ_INT32));
 
 	t1->flags_stride=w+2;
 	flagssize=t1->flags_stride * (h+2);
 
 	if(flagssize > t1->flagssize){
 		opj_aligned_free(t1->flags);
-		t1->flags = (flag_t*) opj_aligned_malloc(flagssize * sizeof(flag_t));
+		t1->flags = (opj_flag_t*) opj_aligned_malloc(flagssize * sizeof(opj_flag_t));
 		if(!t1->flags){
 			return OPJ_FALSE;
 		}
 		t1->flagssize=flagssize;
 	}
-	memset(t1->flags,0,flagssize * sizeof(flag_t));
+	memset(t1->flags,0,flagssize * sizeof(opj_flag_t));
 
 	t1->w=w;
 	t1->h=h;
@@ -1142,220 +1195,252 @@ static opj_bool allocate_buffers(
 	return OPJ_TRUE;
 }
 
-/** mod fixed_quality */
-static void t1_encode_cblk(
-		opj_t1_t *t1,
-		opj_tcd_cblk_enc_t* cblk,
-		int orient,
-		int compno,
-		int level,
-		int qmfbid,
-		double stepsize,
-		int cblksty,
-		int numcomps,
-		int mct,
-		opj_tcd_tile_t * tile)
+/* ----------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------- */
+/**
+ * Creates a new Tier 1 handle
+ * and initializes the look-up tables of the Tier-1 coder/decoder
+ * @return a new T1 handle if successful, returns NULL otherwise
+*/
+opj_t1_t* opj_t1_create()
 {
-	double cumwmsedec = 0.0;
+	opj_t1_t *l_t1 = 00;
 
-	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+	l_t1 = (opj_t1_t*) opj_malloc(sizeof(opj_t1_t));
+	if (!l_t1) {
+		return 00;
+	}
+	memset(l_t1,0,sizeof(opj_t1_t));
 
-	int passno, bpno, passtype;
-	int nmsedec = 0;
-	int i, max;
-	char type = T1_TYPE_MQ;
-	double tempwmsedec;
+	/* create MQC and RAW handles */
+	l_t1->mqc = opj_mqc_create();
+	if (! l_t1->mqc) {
+		opj_t1_destroy(l_t1);
+		return 00;
+	}
 
-	max = 0;
-	for (i = 0; i < t1->w * t1->h; ++i) {
-		int tmp = abs(t1->data[i]);
-		max = int_max(max, tmp);
+	l_t1->raw = opj_raw_create();
+	if (! l_t1->raw) {
+		opj_t1_destroy(l_t1);
+		return 00;
 	}
 
-	cblk->numbps = max ? (int_floorlog2(max) + 1) - T1_NMSEDEC_FRACBITS : 0;
-	
-	bpno = cblk->numbps - 1;
-	passtype = 2;
-	
-	mqc_resetstates(mqc);
-	mqc_setstate(mqc, T1_CTXNO_UNI, 0, 46);
-	mqc_setstate(mqc, T1_CTXNO_AGG, 0, 3);
-	mqc_setstate(mqc, T1_CTXNO_ZC, 0, 4);
-	mqc_init_enc(mqc, cblk->data);
+	return l_t1;
+}
+
+
+/**
+ * Destroys a previously created T1 handle
+ *
+ * @param p_t1 Tier 1 handle to destroy
+*/
+void opj_t1_destroy(opj_t1_t *p_t1)
+{
+	if (! p_t1) {
+		return;
+	}
+
+	/* destroy MQC and RAW handles */
+	opj_mqc_destroy(p_t1->mqc);
+	p_t1->mqc = 00;
+	opj_raw_destroy(p_t1->raw);
+	p_t1->raw = 00;
 	
-	for (passno = 0; bpno >= 0; ++passno) {
-		opj_tcd_pass_t *pass = &cblk->passes[passno];
-		int correction = 3;
-		type = ((bpno < (cblk->numbps - 4)) && (passtype < 2) && (cblksty & J2K_CCP_CBLKSTY_LAZY)) ? T1_TYPE_RAW : T1_TYPE_MQ;
-		
-		switch (passtype) {
-			case 0:
-				t1_enc_sigpass(t1, bpno, orient, &nmsedec, type, cblksty);
-				break;
-			case 1:
-				t1_enc_refpass(t1, bpno, &nmsedec, type, cblksty);
-				break;
-			case 2:
-				t1_enc_clnpass(t1, bpno, orient, &nmsedec, cblksty);
-				/* code switch SEGMARK (i.e. SEGSYM) */
-				if (cblksty & J2K_CCP_CBLKSTY_SEGSYM)
-					mqc_segmark_enc(mqc);
-				break;
-		}
-		
-		/* fixed_quality */
-		tempwmsedec = t1_getwmsedec(nmsedec, compno, level, orient, bpno, qmfbid, stepsize, numcomps, mct);
-		cumwmsedec += tempwmsedec;
-		tile->distotile += tempwmsedec;
-		
-		/* Code switch "RESTART" (i.e. TERMALL) */
-		if ((cblksty & J2K_CCP_CBLKSTY_TERMALL)	&& !((passtype == 2) && (bpno - 1 < 0))) {
-			if (type == T1_TYPE_RAW) {
-				mqc_flush(mqc);
-				correction = 1;
-				/* correction = mqc_bypass_flush_enc(); */
-			} else {			/* correction = mqc_restart_enc(); */
-				mqc_flush(mqc);
-				correction = 1;
-			}
-			pass->term = 1;
-		} else {
-			if (((bpno < (cblk->numbps - 4) && (passtype > 0)) 
-				|| ((bpno == (cblk->numbps - 4)) && (passtype == 2))) && (cblksty & J2K_CCP_CBLKSTY_LAZY)) {
-				if (type == T1_TYPE_RAW) {
-					mqc_flush(mqc);
-					correction = 1;
-					/* correction = mqc_bypass_flush_enc(); */
-				} else {		/* correction = mqc_restart_enc(); */
-					mqc_flush(mqc);
-					correction = 1;
-				}
-				pass->term = 1;
-			} else {
-				pass->term = 0;
-			}
-		}
-		
-		if (++passtype == 3) {
-			passtype = 0;
-			bpno--;
-		}
-		
-		if (pass->term && bpno > 0) {
-			type = ((bpno < (cblk->numbps - 4)) && (passtype < 2) && (cblksty & J2K_CCP_CBLKSTY_LAZY)) ? T1_TYPE_RAW : T1_TYPE_MQ;
-			if (type == T1_TYPE_RAW)
-				mqc_bypass_init_enc(mqc);
-			else
-				mqc_restart_init_enc(mqc);
-		}
-		
-		pass->distortiondec = cumwmsedec;
-		pass->rate = mqc_numbytes(mqc) + correction;	/* FIXME */
-		
-		/* Code-switch "RESET" */
-		if (cblksty & J2K_CCP_CBLKSTY_RESET)
-			mqc_reset_enc(mqc);
+    if (p_t1->data) {
+		opj_aligned_free(p_t1->data);
+		p_t1->data = 00;
 	}
-	
-	/* Code switch "ERTERM" (i.e. PTERM) */
-	if (cblksty & J2K_CCP_CBLKSTY_PTERM)
-		mqc_erterm_enc(mqc);
-	else /* Default coding */ if (!(cblksty & J2K_CCP_CBLKSTY_LAZY))
-		mqc_flush(mqc);
-	
-	cblk->totalpasses = passno;
 
-	for (passno = 0; passno<cblk->totalpasses; passno++) {
-		opj_tcd_pass_t *pass = &cblk->passes[passno];
-		if (pass->rate > mqc_numbytes(mqc))
-			pass->rate = mqc_numbytes(mqc);
-		/*Preventing generation of FF as last data byte of a pass*/
-		if((pass->rate>1) && (cblk->data[pass->rate - 1] == 0xFF)){
-			pass->rate--;
-		}
-		pass->len = pass->rate - (passno == 0 ? 0 : cblk->passes[passno - 1].rate);		
+	if (p_t1->flags) {
+		opj_aligned_free(p_t1->flags);
+		p_t1->flags = 00;
 	}
+
+	opj_free(p_t1);
 }
 
-static void t1_decode_cblk(
-		opj_t1_t *t1,
-		opj_tcd_cblk_dec_t* cblk,
-		int orient,
-		int roishift,
-		int cblksty)
+OPJ_BOOL opj_t1_decode_cblks(   opj_t1_t* t1,
+                            opj_tcd_tilecomp_t* tilec,
+                            opj_tccp_t* tccp
+                            )
+{
+	OPJ_UINT32 resno, bandno, precno, cblkno;
+	OPJ_UINT32 tile_w = (OPJ_UINT32)(tilec->x1 - tilec->x0);
+
+	for (resno = 0; resno < tilec->minimum_num_resolutions; ++resno) {
+		opj_tcd_resolution_t* res = &tilec->resolutions[resno];
+
+		for (bandno = 0; bandno < res->numbands; ++bandno) {
+			opj_tcd_band_t* restrict band = &res->bands[bandno];
+
+			for (precno = 0; precno < res->pw * res->ph; ++precno) {
+				opj_tcd_precinct_t* precinct = &band->precincts[precno];
+
+				for (cblkno = 0; cblkno < precinct->cw * precinct->ch; ++cblkno) {
+					opj_tcd_cblk_dec_t* cblk = &precinct->cblks.dec[cblkno];
+					OPJ_INT32* restrict datap;
+					/*void* restrict tiledp;*/
+					OPJ_UINT32 cblk_w, cblk_h;
+					OPJ_INT32 x, y;
+					OPJ_UINT32 i, j;
+
+                    if (OPJ_FALSE == opj_t1_decode_cblk(
+                                            t1,
+                                            cblk,
+                                            band->bandno,
+                                            (OPJ_UINT32)tccp->roishift,
+                                            tccp->cblksty)) {
+                            return OPJ_FALSE;
+                    }
+
+					x = cblk->x0 - band->x0;
+					y = cblk->y0 - band->y0;
+					if (band->bandno & 1) {
+						opj_tcd_resolution_t* pres = &tilec->resolutions[resno - 1];
+						x += pres->x1 - pres->x0;
+					}
+					if (band->bandno & 2) {
+						opj_tcd_resolution_t* pres = &tilec->resolutions[resno - 1];
+						y += pres->y1 - pres->y0;
+					}
+
+					datap=t1->data;
+					cblk_w = t1->w;
+					cblk_h = t1->h;
+
+					if (tccp->roishift) {
+						OPJ_INT32 thresh = 1 << tccp->roishift;
+						for (j = 0; j < cblk_h; ++j) {
+							for (i = 0; i < cblk_w; ++i) {
+								OPJ_INT32 val = datap[(j * cblk_w) + i];
+								OPJ_INT32 mag = abs(val);
+								if (mag >= thresh) {
+									mag >>= tccp->roishift;
+									datap[(j * cblk_w) + i] = val < 0 ? -mag : mag;
+								}
+							}
+						}
+					}
+
+					/*tiledp=(void*)&tilec->data[(y * tile_w) + x];*/
+					if (tccp->qmfbid == 1) {
+                        OPJ_INT32* restrict tiledp = &tilec->data[(OPJ_UINT32)y * tile_w + (OPJ_UINT32)x];
+						for (j = 0; j < cblk_h; ++j) {
+							for (i = 0; i < cblk_w; ++i) {
+								OPJ_INT32 tmp = datap[(j * cblk_w) + i];
+								((OPJ_INT32*)tiledp)[(j * tile_w) + i] = tmp / 2;
+							}
+						}
+					} else {		/* if (tccp->qmfbid == 0) */
+                        OPJ_FLOAT32* restrict tiledp = (OPJ_FLOAT32*) &tilec->data[(OPJ_UINT32)y * tile_w + (OPJ_UINT32)x];
+						for (j = 0; j < cblk_h; ++j) {
+                            OPJ_FLOAT32* restrict tiledp2 = tiledp;
+							for (i = 0; i < cblk_w; ++i) {
+                                OPJ_FLOAT32 tmp = (OPJ_FLOAT32)*datap * band->stepsize;
+                                *tiledp2 = tmp;
+                                datap++;
+                                tiledp2++;
+								/*float tmp = datap[(j * cblk_w) + i] * band->stepsize;
+								((float*)tiledp)[(j * tile_w) + i] = tmp;*/
+
+							}
+                            tiledp += tile_w;
+						}
+					}
+                    /*opj_free(cblk->data);
+					opj_free(cblk->segs);*/
+					/*cblk->segs = 00;*/
+				} /* cblkno */
+                /*opj_free(precinct->cblks.dec);*/
+			} /* precno */
+		} /* bandno */
+	} /* resno */
+        return OPJ_TRUE;
+}
+
+
+OPJ_BOOL opj_t1_decode_cblk(opj_t1_t *t1,
+                            opj_tcd_cblk_dec_t* cblk,
+                            OPJ_UINT32 orient,
+                            OPJ_UINT32 roishift,
+                            OPJ_UINT32 cblksty)
 {
 	opj_raw_t *raw = t1->raw;	/* RAW component */
 	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
 
-	int bpno, passtype;
-	int segno, passno;
-	char type = T1_TYPE_MQ; /* BYPASS mode */
+	OPJ_INT32 bpno;
+	OPJ_UINT32 passtype;
+	OPJ_UINT32 segno, passno;
+	OPJ_BYTE type = T1_TYPE_MQ; /* BYPASS mode */
 
-	if(!allocate_buffers(
+	if(!opj_t1_allocate_buffers(
 				t1,
-				cblk->x1 - cblk->x0,
-				cblk->y1 - cblk->y0))
+				(OPJ_UINT32)(cblk->x1 - cblk->x0),
+				(OPJ_UINT32)(cblk->y1 - cblk->y0)))
 	{
-		return;
+		return OPJ_FALSE;
 	}
 
-	bpno = roishift + cblk->numbps - 1;
+	bpno = (OPJ_INT32)(roishift + cblk->numbps - 1);
 	passtype = 2;
-	
-	mqc_resetstates(mqc);
-	mqc_setstate(mqc, T1_CTXNO_UNI, 0, 46);
-	mqc_setstate(mqc, T1_CTXNO_AGG, 0, 3);
-	mqc_setstate(mqc, T1_CTXNO_ZC, 0, 4);
-	
-	for (segno = 0; segno < cblk->numsegs; ++segno) {
+
+	opj_mqc_resetstates(mqc);
+	opj_mqc_setstate(mqc, T1_CTXNO_UNI, 0, 46);
+	opj_mqc_setstate(mqc, T1_CTXNO_AGG, 0, 3);
+	opj_mqc_setstate(mqc, T1_CTXNO_ZC, 0, 4);
+
+	for (segno = 0; segno < cblk->real_num_segs; ++segno) {
 		opj_tcd_seg_t *seg = &cblk->segs[segno];
-		
+
 		/* BYPASS mode */
-		type = ((bpno <= (cblk->numbps - 1) - 4) && (passtype < 2) && (cblksty & J2K_CCP_CBLKSTY_LAZY)) ? T1_TYPE_RAW : T1_TYPE_MQ;
+		type = ((bpno <= ((OPJ_INT32) (cblk->numbps) - 1) - 4) && (passtype < 2) && (cblksty & J2K_CCP_CBLKSTY_LAZY)) ? T1_TYPE_RAW : T1_TYPE_MQ;
 		/* FIXME: slviewer gets here with a null pointer. Why? Partially downloaded and/or corrupt textures? */
-		if(seg->data == NULL){
+		if(seg->data == 00){
 			continue;
 		}
 		if (type == T1_TYPE_RAW) {
-			raw_init_dec(raw, (*seg->data) + seg->dataindex, seg->len);
+			opj_raw_init_dec(raw, (*seg->data) + seg->dataindex, seg->len);
 		} else {
-			mqc_init_dec(mqc, (*seg->data) + seg->dataindex, seg->len);
+            if (OPJ_FALSE == opj_mqc_init_dec(mqc, (*seg->data) + seg->dataindex, seg->len)) {
+                    return OPJ_FALSE;
+            }
 		}
-		
-		for (passno = 0; passno < seg->numpasses; ++passno) {
-			switch (passtype) {
-				case 0:
-					if (type == T1_TYPE_RAW) {
-						t1_dec_sigpass_raw(t1, bpno+1, orient, cblksty);
-					} else {
-						if (cblksty & J2K_CCP_CBLKSTY_VSC) {
-							t1_dec_sigpass_mqc_vsc(t1, bpno+1, orient);
-						} else {
-							t1_dec_sigpass_mqc(t1, bpno+1, orient);
-						}
-					}
-					break;
-				case 1:
-					if (type == T1_TYPE_RAW) {
-						t1_dec_refpass_raw(t1, bpno+1, cblksty);
-					} else {
-						if (cblksty & J2K_CCP_CBLKSTY_VSC) {
-							t1_dec_refpass_mqc_vsc(t1, bpno+1);
-						} else {
-							t1_dec_refpass_mqc(t1, bpno+1);
-						}
-					}
-					break;
-				case 2:
-					t1_dec_clnpass(t1, bpno+1, orient, cblksty);
-					break;
-			}
-			
+
+		for (passno = 0; passno < seg->real_num_passes; ++passno) {
+            switch (passtype) {
+                case 0:
+                    if (type == T1_TYPE_RAW) {
+                        opj_t1_dec_sigpass_raw(t1, bpno+1, (OPJ_INT32)orient, (OPJ_INT32)cblksty);
+                    } else {
+                        if (cblksty & J2K_CCP_CBLKSTY_VSC) {
+                            opj_t1_dec_sigpass_mqc_vsc(t1, bpno+1, (OPJ_INT32)orient);
+                        } else {
+                            opj_t1_dec_sigpass_mqc(t1, bpno+1, (OPJ_INT32)orient);
+                        }
+                    }
+                    break;
+                case 1:
+                    if (type == T1_TYPE_RAW) {
+                            opj_t1_dec_refpass_raw(t1, bpno+1, (OPJ_INT32)cblksty);
+                    } else {
+                        if (cblksty & J2K_CCP_CBLKSTY_VSC) {
+                            opj_t1_dec_refpass_mqc_vsc(t1, bpno+1);
+                        } else {
+                            opj_t1_dec_refpass_mqc(t1, bpno+1);
+                        }
+                    }
+                    break;
+                case 2:
+                    opj_t1_dec_clnpass(t1, bpno+1, (OPJ_INT32)orient, (OPJ_INT32)cblksty);
+                    break;
+            }
+
 			if ((cblksty & J2K_CCP_CBLKSTY_RESET) && type == T1_TYPE_MQ) {
-				mqc_resetstates(mqc);
-				mqc_setstate(mqc, T1_CTXNO_UNI, 0, 46);				
-				mqc_setstate(mqc, T1_CTXNO_AGG, 0, 3);
-				mqc_setstate(mqc, T1_CTXNO_ZC, 0, 4);
+				opj_mqc_resetstates(mqc);
+				opj_mqc_setstate(mqc, T1_CTXNO_UNI, 0, 46);
+				opj_mqc_setstate(mqc, T1_CTXNO_AGG, 0, 3);
+				opj_mqc_setstate(mqc, T1_CTXNO_ZC, 0, 4);
 			}
 			if (++passtype == 3) {
 				passtype = 0;
@@ -1363,73 +1448,47 @@ static void t1_decode_cblk(
 			}
 		}
 	}
+        return OPJ_TRUE;
 }
 
-/* ----------------------------------------------------------------------- */
-
-opj_t1_t* t1_create(opj_common_ptr cinfo) {
-	opj_t1_t *t1 = (opj_t1_t*) opj_malloc(sizeof(opj_t1_t));
-	if(!t1)
-		return NULL;
 
-	t1->cinfo = cinfo;
-	/* create MQC and RAW handles */
-	t1->mqc = mqc_create();
-	t1->raw = raw_create();
-
-	t1->data=NULL;
-	t1->flags=NULL;
-	t1->datasize=0;
-	t1->flagssize=0;
 
-	return t1;
-}
 
-void t1_destroy(opj_t1_t *t1) {
-	if(t1) {
-		/* destroy MQC and RAW handles */
-		mqc_destroy(t1->mqc);
-		raw_destroy(t1->raw);
-		opj_aligned_free(t1->data);
-		opj_aligned_free(t1->flags);
-		opj_free(t1);
-	}
-}
-
-void t1_encode_cblks(
-		opj_t1_t *t1,
-		opj_tcd_tile_t *tile,
-		opj_tcp_t *tcp)
+OPJ_BOOL opj_t1_encode_cblks(   opj_t1_t *t1,
+                                opj_tcd_tile_t *tile,
+                                opj_tcp_t *tcp,
+                                const OPJ_FLOAT64 * mct_norms
+                                )
 {
-	int compno, resno, bandno, precno, cblkno;
+	OPJ_UINT32 compno, resno, bandno, precno, cblkno;
 
 	tile->distotile = 0;		/* fixed_quality */
 
 	for (compno = 0; compno < tile->numcomps; ++compno) {
 		opj_tcd_tilecomp_t* tilec = &tile->comps[compno];
 		opj_tccp_t* tccp = &tcp->tccps[compno];
-		int tile_w = tilec->x1 - tilec->x0;
+		OPJ_UINT32 tile_w = (OPJ_UINT32)(tilec->x1 - tilec->x0);
 
 		for (resno = 0; resno < tilec->numresolutions; ++resno) {
 			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
 
 			for (bandno = 0; bandno < res->numbands; ++bandno) {
 				opj_tcd_band_t* restrict band = &res->bands[bandno];
-        int bandconst = 8192 * 8192 / ((int) floor(band->stepsize * 8192));
+                OPJ_INT32 bandconst = 8192 * 8192 / ((OPJ_INT32) floor(band->stepsize * 8192));
 
 				for (precno = 0; precno < res->pw * res->ph; ++precno) {
 					opj_tcd_precinct_t *prc = &band->precincts[precno];
 
 					for (cblkno = 0; cblkno < prc->cw * prc->ch; ++cblkno) {
 						opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
-						int* restrict datap;
-						int* restrict tiledp;
-						int cblk_w;
-						int cblk_h;
-						int i, j;
-
-						int x = cblk->x0 - band->x0;
-						int y = cblk->y0 - band->y0;
+						OPJ_INT32 * restrict datap;
+						OPJ_INT32* restrict tiledp;
+						OPJ_UINT32 cblk_w;
+						OPJ_UINT32 cblk_h;
+						OPJ_UINT32 i, j;
+
+						OPJ_INT32 x = cblk->x0 - band->x0;
+						OPJ_INT32 y = cblk->y0 - band->y0;
 						if (band->bandno & 1) {
 							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
 							x += pres->x1 - pres->x0;
@@ -1439,39 +1498,39 @@ void t1_encode_cblks(
 							y += pres->y1 - pres->y0;
 						}
 
-						if(!allocate_buffers(
+						if(!opj_t1_allocate_buffers(
 									t1,
-									cblk->x1 - cblk->x0,
-									cblk->y1 - cblk->y0))
+									(OPJ_UINT32)(cblk->x1 - cblk->x0),
+									(OPJ_UINT32)(cblk->y1 - cblk->y0)))
 						{
-							return;
+							return OPJ_FALSE;
 						}
 
 						datap=t1->data;
 						cblk_w = t1->w;
 						cblk_h = t1->h;
 
-						tiledp=&tilec->data[(y * tile_w) + x];
+						tiledp=&tilec->data[(OPJ_UINT32)y * tile_w + (OPJ_UINT32)x];
 						if (tccp->qmfbid == 1) {
 							for (j = 0; j < cblk_h; ++j) {
 								for (i = 0; i < cblk_w; ++i) {
-									int tmp = tiledp[(j * tile_w) + i];
+									OPJ_INT32 tmp = tiledp[(j * tile_w) + i];
 									datap[(j * cblk_w) + i] = tmp << T1_NMSEDEC_FRACBITS;
 								}
 							}
 						} else {		/* if (tccp->qmfbid == 0) */
 							for (j = 0; j < cblk_h; ++j) {
 								for (i = 0; i < cblk_w; ++i) {
-									int tmp = tiledp[(j * tile_w) + i];
+									OPJ_INT32 tmp = tiledp[(j * tile_w) + i];
 									datap[(j * cblk_w) + i] =
-										fix_mul(
+										opj_int_fix_mul(
 										tmp,
 										bandconst) >> (11 - T1_NMSEDEC_FRACBITS);
 								}
 							}
 						}
 
-						t1_encode_cblk(
+						opj_t1_encode_cblk(
 								t1,
 								cblk,
 								band->bandno,
@@ -1481,105 +1540,218 @@ void t1_encode_cblks(
 								band->stepsize,
 								tccp->cblksty,
 								tile->numcomps,
-								tcp->mct,
-								tile);
+								tile,
+								mct_norms);
 
 					} /* cblkno */
 				} /* precno */
 			} /* bandno */
 		} /* resno  */
 	} /* compno  */
+	return OPJ_TRUE;
 }
 
-void t1_decode_cblks(
-		opj_t1_t* t1,
-		opj_tcd_tilecomp_t* tilec,
-		opj_tccp_t* tccp)
+/** mod fixed_quality */
+void opj_t1_encode_cblk(opj_t1_t *t1,
+                        opj_tcd_cblk_enc_t* cblk,
+                        OPJ_UINT32 orient,
+                        OPJ_UINT32 compno,
+                        OPJ_UINT32 level,
+                        OPJ_UINT32 qmfbid,
+                        OPJ_FLOAT64 stepsize,
+                        OPJ_UINT32 cblksty,
+                        OPJ_UINT32 numcomps,
+                        opj_tcd_tile_t * tile,
+                        const OPJ_FLOAT64 * mct_norms)
 {
-	int resno, bandno, precno, cblkno;
+	OPJ_FLOAT64 cumwmsedec = 0.0;
 
-	int tile_w = tilec->x1 - tilec->x0;
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
 
-	for (resno = 0; resno < tilec->numresolutions; ++resno) {
-		opj_tcd_resolution_t* res = &tilec->resolutions[resno];
+	OPJ_UINT32 passno;
+	OPJ_INT32 bpno;
+	OPJ_UINT32 passtype;
+	OPJ_INT32 nmsedec = 0;
+	OPJ_INT32 max;
+	OPJ_UINT32 i;
+	OPJ_BYTE type = T1_TYPE_MQ;
+	OPJ_FLOAT64 tempwmsedec;
 
-		for (bandno = 0; bandno < res->numbands; ++bandno) {
-			opj_tcd_band_t* restrict band = &res->bands[bandno];
+	max = 0;
+	for (i = 0; i < t1->w * t1->h; ++i) {
+		OPJ_INT32 tmp = abs(t1->data[i]);
+		max = opj_int_max(max, tmp);
+	}
 
-			for (precno = 0; precno < res->pw * res->ph; ++precno) {
-				opj_tcd_precinct_t* precinct = &band->precincts[precno];
+	cblk->numbps = max ? (OPJ_UINT32)((opj_int_floorlog2(max) + 1) - T1_NMSEDEC_FRACBITS) : 0;
 
-				for (cblkno = 0; cblkno < precinct->cw * precinct->ch; ++cblkno) {
-					opj_tcd_cblk_dec_t* cblk = &precinct->cblks.dec[cblkno];
-					int* restrict datap;
-					int cblk_w, cblk_h;
-					int x, y;
-					int i, j;
-
-					t1_decode_cblk(
-							t1,
-							cblk,
-							band->bandno,
-							tccp->roishift,
-							tccp->cblksty);
+	bpno = (OPJ_INT32)(cblk->numbps - 1);
+	passtype = 2;
 
-					x = cblk->x0 - band->x0;
-					y = cblk->y0 - band->y0;
-					if (band->bandno & 1) {
-						opj_tcd_resolution_t* pres = &tilec->resolutions[resno - 1];
-						x += pres->x1 - pres->x0;
-					}
-					if (band->bandno & 2) {
-						opj_tcd_resolution_t* pres = &tilec->resolutions[resno - 1];
-						y += pres->y1 - pres->y0;
-					}
+	opj_mqc_resetstates(mqc);
+	opj_mqc_setstate(mqc, T1_CTXNO_UNI, 0, 46);
+	opj_mqc_setstate(mqc, T1_CTXNO_AGG, 0, 3);
+	opj_mqc_setstate(mqc, T1_CTXNO_ZC, 0, 4);
+	opj_mqc_init_enc(mqc, cblk->data);
 
-					datap=t1->data;
-					cblk_w = t1->w;
-					cblk_h = t1->h;
+	for (passno = 0; bpno >= 0; ++passno) {
+		opj_tcd_pass_t *pass = &cblk->passes[passno];
+		OPJ_UINT32 correction = 3;
+		type = ((bpno < ((OPJ_INT32) (cblk->numbps) - 4)) && (passtype < 2) && (cblksty & J2K_CCP_CBLKSTY_LAZY)) ? T1_TYPE_RAW : T1_TYPE_MQ;
 
-					if (tccp->roishift) {
-						int thresh = 1 << tccp->roishift;
-						for (j = 0; j < cblk_h; ++j) {
-							for (i = 0; i < cblk_w; ++i) {
-								int val = datap[(j * cblk_w) + i];
-								int mag = abs(val);
-								if (mag >= thresh) {
-									mag >>= tccp->roishift;
-									datap[(j * cblk_w) + i] = val < 0 ? -mag : mag;
-								}
-							}
-						}
-					}
+		switch (passtype) {
+			case 0:
+				opj_t1_enc_sigpass(t1, bpno, orient, &nmsedec, type, cblksty);
+				break;
+			case 1:
+				opj_t1_enc_refpass(t1, bpno, &nmsedec, type, cblksty);
+				break;
+			case 2:
+				opj_t1_enc_clnpass(t1, bpno, orient, &nmsedec, cblksty);
+				/* code switch SEGMARK (i.e. SEGSYM) */
+				if (cblksty & J2K_CCP_CBLKSTY_SEGSYM)
+					opj_mqc_segmark_enc(mqc);
+				break;
+		}
 
-					if (tccp->qmfbid == 1) {
-						int* restrict tiledp = &tilec->data[(y * tile_w) + x];
-						for (j = 0; j < cblk_h; ++j) {
-							for (i = 0; i < cblk_w; ++i) {
-								int tmp = datap[(j * cblk_w) + i];
-								((int*)tiledp)[(j * tile_w) + i] = tmp / 2;
-							}
-						}
-					} else {		/* if (tccp->qmfbid == 0) */
-						float* restrict tiledp = (float*) &tilec->data[(y * tile_w) + x];
-						for (j = 0; j < cblk_h; ++j) {
-							float* restrict tiledp2 = tiledp;
-							for (i = 0; i < cblk_w; ++i) {
-								float tmp = *datap * band->stepsize;
-								*tiledp2 = tmp;
-								datap++;
-								tiledp2++;
-							}
-							tiledp += tile_w;
-						}
-					}
-					opj_free(cblk->data);
-					opj_free(cblk->segs);
-				} /* cblkno */
-				opj_free(precinct->cblks.dec);
-                precinct->cblks.dec = NULL;
-			} /* precno */
-		} /* bandno */
-	} /* resno */
+		/* fixed_quality */
+		tempwmsedec = opj_t1_getwmsedec(nmsedec, compno, level, orient, bpno, qmfbid, stepsize, numcomps,mct_norms) ;
+		cumwmsedec += tempwmsedec;
+		tile->distotile += tempwmsedec;
+
+		/* Code switch "RESTART" (i.e. TERMALL) */
+		if ((cblksty & J2K_CCP_CBLKSTY_TERMALL)	&& !((passtype == 2) && (bpno - 1 < 0))) {
+			if (type == T1_TYPE_RAW) {
+				opj_mqc_flush(mqc);
+				correction = 1;
+				/* correction = mqc_bypass_flush_enc(); */
+			} else {			/* correction = mqc_restart_enc(); */
+				opj_mqc_flush(mqc);
+				correction = 1;
+			}
+			pass->term = 1;
+		} else {
+			if (((bpno < ((OPJ_INT32) (cblk->numbps) - 4) && (passtype > 0))
+				|| ((bpno == ((OPJ_INT32)cblk->numbps - 4)) && (passtype == 2))) && (cblksty & J2K_CCP_CBLKSTY_LAZY)) {
+				if (type == T1_TYPE_RAW) {
+					opj_mqc_flush(mqc);
+					correction = 1;
+					/* correction = mqc_bypass_flush_enc(); */
+				} else {		/* correction = mqc_restart_enc(); */
+					opj_mqc_flush(mqc);
+					correction = 1;
+				}
+				pass->term = 1;
+			} else {
+				pass->term = 0;
+			}
+		}
+
+		if (++passtype == 3) {
+			passtype = 0;
+			bpno--;
+		}
+
+		if (pass->term && bpno > 0) {
+			type = ((bpno < ((OPJ_INT32) (cblk->numbps) - 4)) && (passtype < 2) && (cblksty & J2K_CCP_CBLKSTY_LAZY)) ? T1_TYPE_RAW : T1_TYPE_MQ;
+			if (type == T1_TYPE_RAW)
+				opj_mqc_bypass_init_enc(mqc);
+			else
+				opj_mqc_restart_init_enc(mqc);
+		}
+
+		pass->distortiondec = cumwmsedec;
+		pass->rate = opj_mqc_numbytes(mqc) + correction;	/* FIXME */
+
+		/* Code-switch "RESET" */
+		if (cblksty & J2K_CCP_CBLKSTY_RESET)
+			opj_mqc_reset_enc(mqc);
+	}
+
+	/* Code switch "ERTERM" (i.e. PTERM) */
+	if (cblksty & J2K_CCP_CBLKSTY_PTERM)
+		opj_mqc_erterm_enc(mqc);
+	else /* Default coding */ if (!(cblksty & J2K_CCP_CBLKSTY_LAZY))
+		opj_mqc_flush(mqc);
+
+	cblk->totalpasses = passno;
+
+	for (passno = 0; passno<cblk->totalpasses; passno++) {
+		opj_tcd_pass_t *pass = &cblk->passes[passno];
+		if (pass->rate > opj_mqc_numbytes(mqc))
+			pass->rate = opj_mqc_numbytes(mqc);
+		/*Preventing generation of FF as last data byte of a pass*/
+		if((pass->rate>1) && (cblk->data[pass->rate - 1] == 0xFF)){
+			pass->rate--;
+		}
+		pass->len = pass->rate - (passno == 0 ? 0 : cblk->passes[passno - 1].rate);
+	}
 }
 
+#if 0
+void opj_t1_dec_refpass_step(   opj_t1_t *t1,
+                                opj_flag_t *flagsp,
+                                OPJ_INT32 *datap,
+                                OPJ_INT32 poshalf,
+                                OPJ_INT32 neghalf,
+                                OPJ_BYTE type,
+                                OPJ_UINT32 vsc)
+{
+	OPJ_INT32  t;
+	OPJ_UINT32 v,flag;
+
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+	opj_raw_t *raw = t1->raw;	/* RAW component */
+
+	flag = vsc ? ((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*flagsp);
+	if ((flag & (T1_SIG | T1_VISIT)) == T1_SIG) {
+		opj_mqc_setcurctx(mqc, opj_t1_getctxno_mag(flag));	/* ESSAI */
+		if (type == T1_TYPE_RAW) {
+			v = opj_raw_decode(raw);
+		} else {
+			v = opj_mqc_decode(mqc);
+		}
+		t = v ? poshalf : neghalf;
+		*datap += *datap < 0 ? -t : t;
+		*flagsp |= T1_REFINE;
+	}
+}				/* VSC and  BYPASS by Antonin  */
+#endif
+
+
+
+#if 0
+void opj_t1_dec_sigpass_step(   opj_t1_t *t1,
+                                opj_flag_t *flagsp,
+                                OPJ_INT32 *datap,
+                                OPJ_UINT32 orient,
+                                OPJ_INT32 oneplushalf,
+                                OPJ_BYTE type,
+                                OPJ_UINT32 vsc)
+{
+	OPJ_UINT32 v, flag;
+
+	opj_raw_t *raw = t1->raw;	/* RAW component */
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+
+	flag = vsc ? ((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*flagsp);
+	if ((flag & T1_SIG_OTH) && !(flag & (T1_SIG | T1_VISIT))) {
+		if (type == T1_TYPE_RAW) {
+			if (opj_raw_decode(raw)) {
+				v = opj_raw_decode(raw);	/* ESSAI */
+				*datap = v ? -oneplushalf : oneplushalf;
+				opj_t1_updateflags(flagsp, v, t1->flags_stride);
+			}
+		} else {
+			opj_mqc_setcurctx(mqc, opj_t1_getctxno_zc(flag, orient));
+			if (opj_mqc_decode(mqc)) {
+				opj_mqc_setcurctx(mqc, opj_t1_getctxno_sc(flag));
+				v = opj_mqc_decode(mqc) ^ opj_t1_getspb(flag);
+				*datap = v ? -oneplushalf : oneplushalf;
+				opj_t1_updateflags(flagsp, v, t1->flags_stride);
+			}
+		}
+		*flagsp |= T1_VISIT;
+	}
+}				/* VSC and  BYPASS by Antonin */
+#endif
diff --git a/extern/libopenjpeg/t1.h b/extern/libopenjpeg/t1.h
index 572ec88..e5be70e 100644
--- a/extern/libopenjpeg/t1.h
+++ b/extern/libopenjpeg/t1.h
@@ -1,9 +1,15 @@
 /*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2001-2003, David Janssens
  * Copyright (c) 2002-2003, Yannick Verschueren
- * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * Copyright (c) 2003-2014, Antonin Descampe
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
  * All rights reserved.
  *
@@ -85,27 +91,25 @@ in T1.C are used by some function in TCD.C.
 
 /* ----------------------------------------------------------------------- */
 
-typedef short flag_t;
+typedef OPJ_INT16 opj_flag_t;
 
 /**
 Tier-1 coding (coding of code-block coefficients)
 */
 typedef struct opj_t1 {
-	/** codec context */
-	opj_common_ptr cinfo;
 
 	/** MQC component */
 	opj_mqc_t *mqc;
 	/** RAW component */
 	opj_raw_t *raw;
 
-	int *data;
-	flag_t *flags;
-	int w;
-	int h;
-	int datasize;
-	int flagssize;
-	int flags_stride;
+    OPJ_INT32 *data;
+	opj_flag_t *flags;
+	OPJ_UINT32 w;
+	OPJ_UINT32 h;
+	OPJ_UINT32 datasize;
+	OPJ_UINT32 flagssize;
+	OPJ_UINT32 flags_stride;
 } opj_t1_t;
 
 #define MACRO_t1_flags(x,y) t1->flags[((x)*(t1->flags_stride))+(y)]
@@ -113,32 +117,44 @@ typedef struct opj_t1 {
 /** @name Exported functions */
 /*@{*/
 /* ----------------------------------------------------------------------- */
-/**
-Create a new T1 handle 
-and initialize the look-up tables of the Tier-1 coder/decoder
-@return Returns a new T1 handle if successful, returns NULL otherwise
-@see t1_init_luts
-*/
-opj_t1_t* t1_create(opj_common_ptr cinfo);
-/**
-Destroy a previously created T1 handle
-@param t1 T1 handle to destroy
-*/
-void t1_destroy(opj_t1_t *t1);
+
 /**
 Encode the code-blocks of a tile
 @param t1 T1 handle
 @param tile The tile to encode
 @param tcp Tile coding parameters
+@param mct_norms  FIXME DOC
 */
-void t1_encode_cblks(opj_t1_t *t1, opj_tcd_tile_t *tile, opj_tcp_t *tcp);
+OPJ_BOOL opj_t1_encode_cblks(   opj_t1_t *t1,
+                                opj_tcd_tile_t *tile,
+                                opj_tcp_t *tcp,
+                                const OPJ_FLOAT64 * mct_norms);
+
 /**
 Decode the code-blocks of a tile
 @param t1 T1 handle
 @param tilec The tile to decode
 @param tccp Tile coding parameters
 */
-void t1_decode_cblks(opj_t1_t* t1, opj_tcd_tilecomp_t* tilec, opj_tccp_t* tccp);
+OPJ_BOOL opj_t1_decode_cblks(   opj_t1_t* t1,
+                                opj_tcd_tilecomp_t* tilec,
+                                opj_tccp_t* tccp);
+
+
+
+/**
+ * Creates a new Tier 1 handle
+ * and initializes the look-up tables of the Tier-1 coder/decoder
+ * @return a new T1 handle if successful, returns NULL otherwise
+*/
+opj_t1_t* opj_t1_create(void);
+
+/**
+ * Destroys a previously created T1 handle
+ *
+ * @param p_t1 Tier 1 handle to destroy
+*/
+void opj_t1_destroy(opj_t1_t *p_t1);
 /* ----------------------------------------------------------------------- */
 /*@}*/
 
diff --git a/extern/libopenjpeg/t1_generate_luts.c b/extern/libopenjpeg/t1_generate_luts.c
new file mode 100644
index 0000000..1997d39
--- /dev/null
+++ b/extern/libopenjpeg/t1_generate_luts.c
@@ -0,0 +1,282 @@
+/*
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * Copyright (c) 2003-2014, Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * Copyright (c) 2007, Callum Lerwick <seg@haxxed.com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+
+static int t1_init_ctxno_zc(int f, int orient) {
+	int h, v, d, n, t, hv;
+	n = 0;
+	h = ((f & T1_SIG_W) != 0) + ((f & T1_SIG_E) != 0);
+	v = ((f & T1_SIG_N) != 0) + ((f & T1_SIG_S) != 0);
+	d = ((f & T1_SIG_NW) != 0) + ((f & T1_SIG_NE) != 0) + ((f & T1_SIG_SE) != 0) + ((f & T1_SIG_SW) != 0);
+
+	switch (orient) {
+		case 2:
+			t = h;
+			h = v;
+			v = t;
+		case 0:
+		case 1:
+			if (!h) {
+				if (!v) {
+					if (!d)
+						n = 0;
+					else if (d == 1)
+						n = 1;
+					else
+						n = 2;
+				} else if (v == 1) {
+					n = 3;
+				} else {
+					n = 4;
+				}
+			} else if (h == 1) {
+				if (!v) {
+					if (!d)
+						n = 5;
+					else
+						n = 6;
+				} else {
+					n = 7;
+				}
+			} else
+				n = 8;
+			break;
+		case 3:
+			hv = h + v;
+			if (!d) {
+				if (!hv) {
+					n = 0;
+				} else if (hv == 1) {
+					n = 1;
+				} else {
+					n = 2;
+				}
+			} else if (d == 1) {
+				if (!hv) {
+					n = 3;
+				} else if (hv == 1) {
+					n = 4;
+				} else {
+					n = 5;
+				}
+			} else if (d == 2) {
+				if (!hv) {
+					n = 6;
+				} else {
+					n = 7;
+				}
+			} else {
+				n = 8;
+			}
+			break;
+	}
+
+	return (T1_CTXNO_ZC + n);
+}
+
+static int t1_init_ctxno_sc(int f) {
+	int hc, vc, n;
+	n = 0;
+
+	hc = opj_int_min(((f & (T1_SIG_E | T1_SGN_E)) ==
+				T1_SIG_E) + ((f & (T1_SIG_W | T1_SGN_W)) == T1_SIG_W),
+			1) - opj_int_min(((f & (T1_SIG_E | T1_SGN_E)) ==
+					(T1_SIG_E | T1_SGN_E)) +
+				((f & (T1_SIG_W | T1_SGN_W)) ==
+				 (T1_SIG_W | T1_SGN_W)), 1);
+
+	vc = opj_int_min(((f & (T1_SIG_N | T1_SGN_N)) ==
+				T1_SIG_N) + ((f & (T1_SIG_S | T1_SGN_S)) == T1_SIG_S),
+			1) - opj_int_min(((f & (T1_SIG_N | T1_SGN_N)) ==
+					(T1_SIG_N | T1_SGN_N)) +
+				((f & (T1_SIG_S | T1_SGN_S)) ==
+				 (T1_SIG_S | T1_SGN_S)), 1);
+
+	if (hc < 0) {
+		hc = -hc;
+		vc = -vc;
+	}
+	if (!hc) {
+		if (vc == -1)
+			n = 1;
+		else if (!vc)
+			n = 0;
+		else
+			n = 1;
+	} else if (hc == 1) {
+		if (vc == -1)
+			n = 2;
+		else if (!vc)
+			n = 3;
+		else
+			n = 4;
+	}
+
+	return (T1_CTXNO_SC + n);
+}
+
+static int t1_init_spb(int f) {
+	int hc, vc, n;
+
+	hc = opj_int_min(((f & (T1_SIG_E | T1_SGN_E)) ==
+				T1_SIG_E) + ((f & (T1_SIG_W | T1_SGN_W)) == T1_SIG_W),
+			1) - opj_int_min(((f & (T1_SIG_E | T1_SGN_E)) ==
+					(T1_SIG_E | T1_SGN_E)) +
+				((f & (T1_SIG_W | T1_SGN_W)) ==
+				 (T1_SIG_W | T1_SGN_W)), 1);
+
+	vc = opj_int_min(((f & (T1_SIG_N | T1_SGN_N)) ==
+				T1_SIG_N) + ((f & (T1_SIG_S | T1_SGN_S)) == T1_SIG_S),
+			1) - opj_int_min(((f & (T1_SIG_N | T1_SGN_N)) ==
+					(T1_SIG_N | T1_SGN_N)) +
+				((f & (T1_SIG_S | T1_SGN_S)) ==
+				 (T1_SIG_S | T1_SGN_S)), 1);
+
+	if (!hc && !vc)
+		n = 0;
+	else
+		n = (!(hc > 0 || (!hc && vc > 0)));
+
+	return n;
+}
+
+static void dump_array16(int array[],int size){
+	int i;
+	--size;
+	for (i = 0; i < size; ++i) {
+		printf("0x%04x, ", array[i]);
+		if(!((i+1)&0x7))
+			printf("\n  ");
+	}
+	printf("0x%04x\n};\n\n", array[size]);
+}
+
+int main(int argc, char **argv)
+{
+	int i, j;
+	double u, v, t;
+
+	int lut_ctxno_zc[1024];
+	int lut_nmsedec_sig[1 << T1_NMSEDEC_BITS];
+	int lut_nmsedec_sig0[1 << T1_NMSEDEC_BITS];
+	int lut_nmsedec_ref[1 << T1_NMSEDEC_BITS];
+	int lut_nmsedec_ref0[1 << T1_NMSEDEC_BITS];
+  (void)argc; (void)argv;
+
+	printf("/* This file was automatically generated by t1_generate_luts.c */\n\n");
+
+	/* lut_ctxno_zc */
+	for (j = 0; j < 4; ++j) {
+		for (i = 0; i < 256; ++i) {
+			int orient = j;
+			if (orient == 2) {
+				orient = 1;
+			} else if (orient == 1) {
+				orient = 2;
+			}
+			lut_ctxno_zc[(orient << 8) | i] = t1_init_ctxno_zc(i, j);
+		}
+	}
+
+	printf("static OPJ_BYTE lut_ctxno_zc[1024] = {\n  ");
+	for (i = 0; i < 1023; ++i) {
+		printf("%i, ", lut_ctxno_zc[i]);
+		if(!((i+1)&0x1f))
+			printf("\n  ");
+	}
+	printf("%i\n};\n\n", lut_ctxno_zc[1023]);
+
+	/* lut_ctxno_sc */
+	printf("static OPJ_BYTE lut_ctxno_sc[256] = {\n  ");
+	for (i = 0; i < 255; ++i) {
+		printf("0x%x, ", t1_init_ctxno_sc(i << 4));
+		if(!((i+1)&0xf))
+			printf("\n  ");
+	}
+	printf("0x%x\n};\n\n", t1_init_ctxno_sc(255 << 4));
+
+	/* lut_spb */
+	printf("static OPJ_BYTE lut_spb[256] = {\n  ");
+	for (i = 0; i < 255; ++i) {
+		printf("%i, ", t1_init_spb(i << 4));
+		if(!((i+1)&0x1f))
+			printf("\n  ");
+	}
+	printf("%i\n};\n\n", t1_init_spb(255 << 4));
+
+	/* FIXME FIXME FIXME */
+	/* fprintf(stdout,"nmsedec luts:\n"); */
+	for (i = 0; i < (1 << T1_NMSEDEC_BITS); ++i) {
+		t = i / pow(2, T1_NMSEDEC_FRACBITS);
+		u = t;
+		v = t - 1.5;
+		lut_nmsedec_sig[i] = 
+			opj_int_max(0, 
+					(int) (floor((u * u - v * v) * pow(2, T1_NMSEDEC_FRACBITS) + 0.5) / pow(2, T1_NMSEDEC_FRACBITS) * 8192.0));
+		lut_nmsedec_sig0[i] =
+			opj_int_max(0,
+					(int) (floor((u * u) * pow(2, T1_NMSEDEC_FRACBITS) + 0.5) / pow(2, T1_NMSEDEC_FRACBITS) * 8192.0));
+		u = t - 1.0;
+		if (i & (1 << (T1_NMSEDEC_BITS - 1))) {
+			v = t - 1.5;
+		} else {
+			v = t - 0.5;
+		}
+		lut_nmsedec_ref[i] =
+			opj_int_max(0,
+					(int) (floor((u * u - v * v) * pow(2, T1_NMSEDEC_FRACBITS) + 0.5) / pow(2, T1_NMSEDEC_FRACBITS) * 8192.0));
+		lut_nmsedec_ref0[i] =
+			opj_int_max(0,
+					(int) (floor((u * u) * pow(2, T1_NMSEDEC_FRACBITS) + 0.5) / pow(2, T1_NMSEDEC_FRACBITS) * 8192.0));
+	}
+
+	printf("static OPJ_INT16 lut_nmsedec_sig[1 << T1_NMSEDEC_BITS] = {\n  ");
+	dump_array16(lut_nmsedec_sig, 1 << T1_NMSEDEC_BITS);
+
+	printf("static OPJ_INT16 lut_nmsedec_sig0[1 << T1_NMSEDEC_BITS] = {\n  ");
+	dump_array16(lut_nmsedec_sig0, 1 << T1_NMSEDEC_BITS);
+
+	printf("static OPJ_INT16 lut_nmsedec_ref[1 << T1_NMSEDEC_BITS] = {\n  ");
+	dump_array16(lut_nmsedec_ref, 1 << T1_NMSEDEC_BITS);
+
+	printf("static OPJ_INT16 lut_nmsedec_ref0[1 << T1_NMSEDEC_BITS] = {\n  ");
+	dump_array16(lut_nmsedec_ref0, 1 << T1_NMSEDEC_BITS);
+
+	return 0;
+}
diff --git a/extern/libopenjpeg/t1_luts.h b/extern/libopenjpeg/t1_luts.h
index e5e33f6..37776b6 100644
--- a/extern/libopenjpeg/t1_luts.h
+++ b/extern/libopenjpeg/t1_luts.h
@@ -1,6 +1,6 @@
 /* This file was automatically generated by t1_generate_luts.c */
 
-static char lut_ctxno_zc[1024] = {
+static OPJ_BYTE lut_ctxno_zc[1024] = {
   0, 1, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
   5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
   3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
@@ -35,7 +35,7 @@ static char lut_ctxno_zc[1024] = {
   2, 5, 5, 7, 5, 7, 7, 8, 5, 7, 7, 8, 7, 8, 8, 8, 2, 5, 5, 7, 5, 7, 7, 8, 5, 7, 7, 8, 7, 8, 8, 8
 };
 
-static char lut_ctxno_sc[256] = {
+static OPJ_BYTE lut_ctxno_sc[256] = {
   0x9, 0xa, 0xc, 0xd, 0xa, 0xa, 0xd, 0xd, 0xc, 0xd, 0xc, 0xd, 0xd, 0xd, 0xd, 0xd, 
   0x9, 0xa, 0xc, 0xb, 0xa, 0x9, 0xd, 0xc, 0xc, 0xb, 0xc, 0xb, 0xd, 0xc, 0xd, 0xc, 
   0x9, 0xa, 0xc, 0xb, 0xa, 0xa, 0xb, 0xb, 0xc, 0xd, 0x9, 0xa, 0xd, 0xd, 0xa, 0xa, 
@@ -54,7 +54,7 @@ static char lut_ctxno_sc[256] = {
   0x9, 0xa, 0xc, 0xd, 0xa, 0xa, 0xd, 0xd, 0xc, 0xd, 0xc, 0xd, 0xd, 0xd, 0xd, 0xd
 };
 
-static char lut_spb[256] = {
+static OPJ_BYTE lut_spb[256] = {
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
   0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 
   0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
@@ -65,7 +65,7 @@ static char lut_spb[256] = {
   0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
 };
 
-static short lut_nmsedec_sig[1 << T1_NMSEDEC_BITS] = {
+static OPJ_INT16 lut_nmsedec_sig[1 << T1_NMSEDEC_BITS] = {
   0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
   0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
   0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
@@ -84,7 +84,7 @@ static short lut_nmsedec_sig[1 << T1_NMSEDEC_BITS] = {
   0x6c00, 0x6d80, 0x6f00, 0x7080, 0x7200, 0x7380, 0x7500, 0x7680
 };
 
-static short lut_nmsedec_sig0[1 << T1_NMSEDEC_BITS] = {
+static OPJ_INT16 lut_nmsedec_sig0[1 << T1_NMSEDEC_BITS] = {
   0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0080, 0x0080, 
   0x0080, 0x0080, 0x0100, 0x0100, 0x0100, 0x0180, 0x0180, 0x0200, 
   0x0200, 0x0280, 0x0280, 0x0300, 0x0300, 0x0380, 0x0400, 0x0400, 
@@ -103,7 +103,7 @@ static short lut_nmsedec_sig0[1 << T1_NMSEDEC_BITS] = {
   0x7080, 0x7280, 0x7480, 0x7600, 0x7800, 0x7a00, 0x7c00, 0x7e00
 };
 
-static short lut_nmsedec_ref[1 << T1_NMSEDEC_BITS] = {
+static OPJ_INT16 lut_nmsedec_ref[1 << T1_NMSEDEC_BITS] = {
   0x1800, 0x1780, 0x1700, 0x1680, 0x1600, 0x1580, 0x1500, 0x1480, 
   0x1400, 0x1380, 0x1300, 0x1280, 0x1200, 0x1180, 0x1100, 0x1080, 
   0x1000, 0x0f80, 0x0f00, 0x0e80, 0x0e00, 0x0d80, 0x0d00, 0x0c80, 
@@ -122,7 +122,7 @@ static short lut_nmsedec_ref[1 << T1_NMSEDEC_BITS] = {
   0x1400, 0x1480, 0x1500, 0x1580, 0x1600, 0x1680, 0x1700, 0x1780
 };
 
-static short lut_nmsedec_ref0[1 << T1_NMSEDEC_BITS] = {
+static OPJ_INT16 lut_nmsedec_ref0[1 << T1_NMSEDEC_BITS] = {
   0x2000, 0x1f00, 0x1e00, 0x1d00, 0x1c00, 0x1b00, 0x1a80, 0x1980, 
   0x1880, 0x1780, 0x1700, 0x1600, 0x1500, 0x1480, 0x1380, 0x1300, 
   0x1200, 0x1180, 0x1080, 0x1000, 0x0f00, 0x0e80, 0x0e00, 0x0d00, 
diff --git a/extern/libopenjpeg/t2.c b/extern/libopenjpeg/t2.c
index 2585c3d..37f9814 100644
--- a/extern/libopenjpeg/t2.c
+++ b/extern/libopenjpeg/t2.c
@@ -1,10 +1,18 @@
 /*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2001-2003, David Janssens
  * Copyright (c) 2002-2003, Yannick Verschueren
- * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * Copyright (c) 2003-2014, Antonin Descampe
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR 
+ * Copyright (c) 2012, CS Systemes d'Information, France
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -30,7 +38,6 @@
  */
 
 #include "opj_includes.h"
-#include <assert.h>
 
 /** @defgroup T2 T2 - Implementation of a tier-2 coding */
 /*@{*/
@@ -38,47 +45,104 @@
 /** @name Local static functions */
 /*@{*/
 
-static void t2_putcommacode(opj_bio_t *bio, int n);
-static int t2_getcommacode(opj_bio_t *bio);
+static void opj_t2_putcommacode(opj_bio_t *bio, OPJ_INT32 n);
+
+static OPJ_UINT32 opj_t2_getcommacode(opj_bio_t *bio); 
 /**
 Variable length code for signalling delta Zil (truncation point)
-@param bio Bit Input/Output component
-@param n delta Zil
+@param bio  Bit Input/Output component
+@param n    delta Zil
 */
-static void t2_putnumpasses(opj_bio_t *bio, int n);
-static int t2_getnumpasses(opj_bio_t *bio);
+static void opj_t2_putnumpasses(opj_bio_t *bio, OPJ_UINT32 n);
+static OPJ_UINT32 opj_t2_getnumpasses(opj_bio_t *bio);
+
 /**
 Encode a packet of a tile to a destination buffer
+@param tileno Number of the tile encoded
 @param tile Tile for which to write the packets
 @param tcp Tile coding parameters
 @param pi Packet identity
 @param dest Destination buffer
+@param p_data_written   FIXME DOC
 @param len Length of the destination buffer
-@param cstr_info Codestream information structure 
-@param tileno Number of the tile encoded
-@return 
-*/
-static int t2_encode_packet(opj_tcd_tile_t *tile, opj_tcp_t *tcp, opj_pi_iterator_t *pi, unsigned char *dest, int len, opj_codestream_info_t *cstr_info, int tileno);
-/**
-@param cblk
-@param index
-@param cblksty
-@param first
+@param cstr_info Codestream information structure
+@return
 */
-static opj_bool t2_init_seg(opj_tcd_cblk_dec_t* cblk, int index, int cblksty, int first);
+static OPJ_BOOL opj_t2_encode_packet(   OPJ_UINT32 tileno,
+                                        opj_tcd_tile_t *tile,
+                                        opj_tcp_t *tcp,
+                                        opj_pi_iterator_t *pi,
+                                        OPJ_BYTE *dest,
+                                        OPJ_UINT32 * p_data_written,
+                                        OPJ_UINT32 len,
+                                        opj_codestream_info_t *cstr_info);
+
 /**
 Decode a packet of a tile from a source buffer
 @param t2 T2 handle
-@param src Source buffer
-@param len Length of the source buffer
 @param tile Tile for which to write the packets
 @param tcp Tile coding parameters
 @param pi Packet identity
+@param src Source buffer
+@param data_read   FIXME DOC
+@param max_length  FIXME DOC
 @param pack_info Packet information
-@return 
+
+@return  FIXME DOC
 */
-static int t2_decode_packet(opj_t2_t* t2, unsigned char *src, int len, opj_tcd_tile_t *tile, 
-														opj_tcp_t *tcp, opj_pi_iterator_t *pi, opj_packet_info_t *pack_info);
+static OPJ_BOOL opj_t2_decode_packet(   opj_t2_t* t2,
+                                        opj_tcd_tile_t *tile,
+                                        opj_tcp_t *tcp,
+                                        opj_pi_iterator_t *pi,
+                                        OPJ_BYTE *src,
+                                        OPJ_UINT32 * data_read,
+                                        OPJ_UINT32 max_length,
+                                        opj_packet_info_t *pack_info);
+
+static OPJ_BOOL opj_t2_skip_packet( opj_t2_t* p_t2,
+                                    opj_tcd_tile_t *p_tile,
+                                    opj_tcp_t *p_tcp,
+                                    opj_pi_iterator_t *p_pi,
+                                    OPJ_BYTE *p_src,
+                                    OPJ_UINT32 * p_data_read,
+                                    OPJ_UINT32 p_max_length,
+                                    opj_packet_info_t *p_pack_info);
+
+static OPJ_BOOL opj_t2_read_packet_header(  opj_t2_t* p_t2,
+                                            opj_tcd_tile_t *p_tile,
+                                            opj_tcp_t *p_tcp,
+                                            opj_pi_iterator_t *p_pi,
+                                            OPJ_BOOL * p_is_data_present,
+                                            OPJ_BYTE *p_src_data,
+                                            OPJ_UINT32 * p_data_read,
+                                            OPJ_UINT32 p_max_length,
+                                            opj_packet_info_t *p_pack_info);
+
+static OPJ_BOOL opj_t2_read_packet_data(opj_t2_t* p_t2,
+                                        opj_tcd_tile_t *p_tile,
+                                        opj_pi_iterator_t *p_pi,
+                                        OPJ_BYTE *p_src_data,
+                                        OPJ_UINT32 * p_data_read,
+                                        OPJ_UINT32 p_max_length,
+                                        opj_packet_info_t *pack_info);
+
+static OPJ_BOOL opj_t2_skip_packet_data(opj_t2_t* p_t2,
+                                        opj_tcd_tile_t *p_tile,
+                                        opj_pi_iterator_t *p_pi,
+                                        OPJ_UINT32 * p_data_read,
+                                        OPJ_UINT32 p_max_length,
+                                        opj_packet_info_t *pack_info);
+
+/**
+@param cblk
+@param index
+@param cblksty
+@param first
+*/
+static OPJ_BOOL opj_t2_init_seg(    opj_tcd_cblk_dec_t* cblk,
+                                    OPJ_UINT32 index,
+                                    OPJ_UINT32 cblksty,
+                                    OPJ_UINT32 first);
 
 /*@}*/
 
@@ -87,739 +151,1194 @@ static int t2_decode_packet(opj_t2_t* t2, unsigned char *src, int len, opj_tcd_t
 /* ----------------------------------------------------------------------- */
 
 /* #define RESTART 0x04 */
+static void opj_t2_putcommacode(opj_bio_t *bio, OPJ_INT32 n) {
+        while (--n >= 0) {
+                opj_bio_write(bio, 1, 1);
+        }
+        opj_bio_write(bio, 0, 1);
+}
 
-static void t2_putcommacode(opj_bio_t *bio, int n) {
-	while (--n >= 0) {
-		bio_write(bio, 1, 1);
-	}
-	bio_write(bio, 0, 1);
+OPJ_UINT32 opj_t2_getcommacode(opj_bio_t *bio) 
+{
+    OPJ_UINT32 n = 0;
+    while (opj_bio_read(bio, 1)) {
+	    ++n;
+    }
+    return n;
 }
 
-static int t2_getcommacode(opj_bio_t *bio) {
-	int n;
-	for (n = 0; bio_read(bio, 1); n++) {
-		;
-	}
-	return n;
+void opj_t2_putnumpasses(opj_bio_t *bio, OPJ_UINT32 n) {
+        if (n == 1) {
+                opj_bio_write(bio, 0, 1);
+        } else if (n == 2) {
+                opj_bio_write(bio, 2, 2);
+        } else if (n <= 5) {
+                opj_bio_write(bio, 0xc | (n - 3), 4);
+        } else if (n <= 36) {
+                opj_bio_write(bio, 0x1e0 | (n - 6), 9);
+        } else if (n <= 164) {
+                opj_bio_write(bio, 0xff80 | (n - 37), 16);
+        }
 }
 
-static void t2_putnumpasses(opj_bio_t *bio, int n) {
-	if (n == 1) {
-		bio_write(bio, 0, 1);
-	} else if (n == 2) {
-		bio_write(bio, 2, 2);
-	} else if (n <= 5) {
-		bio_write(bio, 0xc | (n - 3), 4);
-	} else if (n <= 36) {
-		bio_write(bio, 0x1e0 | (n - 6), 9);
-	} else if (n <= 164) {
-		bio_write(bio, 0xff80 | (n - 37), 16);
-	}
+OPJ_UINT32 opj_t2_getnumpasses(opj_bio_t *bio) {
+        OPJ_UINT32 n;
+        if (!opj_bio_read(bio, 1))
+                return 1;
+        if (!opj_bio_read(bio, 1))
+                return 2;
+        if ((n = opj_bio_read(bio, 2)) != 3)
+                return (3 + n);
+        if ((n = opj_bio_read(bio, 5)) != 31)
+                return (6 + n);
+        return (37 + opj_bio_read(bio, 7));
 }
 
-static int t2_getnumpasses(opj_bio_t *bio) {
-	int n;
-	if (!bio_read(bio, 1))
-		return 1;
-	if (!bio_read(bio, 1))
-		return 2;
-	if ((n = bio_read(bio, 2)) != 3)
-		return (3 + n);
-	if ((n = bio_read(bio, 5)) != 31)
-		return (6 + n);
-	return (37 + bio_read(bio, 7));
+/* ----------------------------------------------------------------------- */
+
+OPJ_BOOL opj_t2_encode_packets( opj_t2_t* p_t2,
+                                OPJ_UINT32 p_tile_no,
+                                opj_tcd_tile_t *p_tile,
+                                OPJ_UINT32 p_maxlayers,
+                                OPJ_BYTE *p_dest,
+                                OPJ_UINT32 * p_data_written,
+                                OPJ_UINT32 p_max_len,
+                                opj_codestream_info_t *cstr_info,
+                                OPJ_UINT32 p_tp_num,
+                                OPJ_INT32 p_tp_pos,
+                                OPJ_UINT32 p_pino,
+                                J2K_T2_MODE p_t2_mode)
+{
+        OPJ_BYTE *l_current_data = p_dest;
+        OPJ_UINT32 l_nb_bytes = 0;
+        OPJ_UINT32 compno;
+        OPJ_UINT32 poc;
+        opj_pi_iterator_t *l_pi = 00;
+        opj_pi_iterator_t *l_current_pi = 00;
+        opj_image_t *l_image = p_t2->image;
+        opj_cp_t *l_cp = p_t2->cp;
+        opj_tcp_t *l_tcp = &l_cp->tcps[p_tile_no];
+        OPJ_UINT32 pocno = (l_cp->rsiz == OPJ_PROFILE_CINEMA_4K)? 2: 1;
+        OPJ_UINT32 l_max_comp = l_cp->m_specific_param.m_enc.m_max_comp_size > 0 ? l_image->numcomps : 1;
+        OPJ_UINT32 l_nb_pocs = l_tcp->numpocs + 1;
+
+        l_pi = opj_pi_initialise_encode(l_image, l_cp, p_tile_no, p_t2_mode);
+        if (!l_pi) {
+                return OPJ_FALSE;
+        }
+
+        * p_data_written = 0;
+
+        if (p_t2_mode == THRESH_CALC ){ /* Calculating threshold */
+                l_current_pi = l_pi;
+
+                for     (compno = 0; compno < l_max_comp; ++compno) {
+                        OPJ_UINT32 l_comp_len = 0;
+                        l_current_pi = l_pi;
+
+                        for (poc = 0; poc < pocno ; ++poc) {
+                                OPJ_UINT32 l_tp_num = compno;
+
+                                /* TODO MSD : check why this function cannot fail (cf. v1) */
+                                opj_pi_create_encode(l_pi, l_cp,p_tile_no,poc,l_tp_num,p_tp_pos,p_t2_mode);
+
+                                while (opj_pi_next(l_current_pi)) {
+                                        if (l_current_pi->layno < p_maxlayers) {
+                                                l_nb_bytes = 0;
+
+                                                if (! opj_t2_encode_packet(p_tile_no,p_tile, l_tcp, l_current_pi, l_current_data, &l_nb_bytes, p_max_len, cstr_info)) {
+                                                        opj_pi_destroy(l_pi, l_nb_pocs);
+                                                        return OPJ_FALSE;
+                                                }
+
+                                                l_comp_len += l_nb_bytes;
+                                                l_current_data += l_nb_bytes;
+                                                p_max_len -= l_nb_bytes;
+
+                                                * p_data_written += l_nb_bytes;
+                                        }
+                                }
+
+                                if (l_cp->m_specific_param.m_enc.m_max_comp_size) {
+                                        if (l_comp_len > l_cp->m_specific_param.m_enc.m_max_comp_size) {
+                                                opj_pi_destroy(l_pi, l_nb_pocs);
+                                                return OPJ_FALSE;
+                                        }
+                                }
+
+                                ++l_current_pi;
+                        }
+                }
+        }
+        else {  /* t2_mode == FINAL_PASS  */
+                opj_pi_create_encode(l_pi, l_cp,p_tile_no,p_pino,p_tp_num,p_tp_pos,p_t2_mode);
+
+                l_current_pi = &l_pi[p_pino];
+
+                while (opj_pi_next(l_current_pi)) {
+                        if (l_current_pi->layno < p_maxlayers) {
+                                l_nb_bytes=0;
+
+                                if (! opj_t2_encode_packet(p_tile_no,p_tile, l_tcp, l_current_pi, l_current_data, &l_nb_bytes, p_max_len, cstr_info)) {
+                                        opj_pi_destroy(l_pi, l_nb_pocs);
+                                        return OPJ_FALSE;
+                                }
+
+                                l_current_data += l_nb_bytes;
+                                p_max_len -= l_nb_bytes;
+
+                                * p_data_written += l_nb_bytes;
+
+                                /* INDEX >> */
+                                if(cstr_info) {
+                                        if(cstr_info->index_write) {
+                                                opj_tile_info_t *info_TL = &cstr_info->tile[p_tile_no];
+                                                opj_packet_info_t *info_PK = &info_TL->packet[cstr_info->packno];
+                                                if (!cstr_info->packno) {
+                                                        info_PK->start_pos = info_TL->end_header + 1;
+                                                } else {
+                                                        info_PK->start_pos = ((l_cp->m_specific_param.m_enc.m_tp_on | l_tcp->POC)&& info_PK->start_pos) ? info_PK->start_pos : info_TL->packet[cstr_info->packno - 1].end_pos + 1;
+                                                }
+                                                info_PK->end_pos = info_PK->start_pos + l_nb_bytes - 1;
+                                                info_PK->end_ph_pos += info_PK->start_pos - 1;  /* End of packet header which now only represents the distance
+                                                                                                                                                                                                                                                   to start of packet is incremented by value of start of packet*/
+                                        }
+
+                                        cstr_info->packno++;
+                                }
+                                /* << INDEX */
+                                ++p_tile->packno;
+                        }
+                }
+        }
+
+        opj_pi_destroy(l_pi, l_nb_pocs);
+
+        return OPJ_TRUE;
 }
 
-static int t2_encode_packet(opj_tcd_tile_t * tile, opj_tcp_t * tcp, opj_pi_iterator_t *pi, unsigned char *dest, int length, opj_codestream_info_t *cstr_info, int tileno) {
-	int bandno, cblkno;
-	unsigned char *c = dest;
-
-	int compno = pi->compno;	/* component value */
-	int resno  = pi->resno;		/* resolution level value */
-	int precno = pi->precno;	/* precinct value */
-	int layno  = pi->layno;		/* quality layer value */
-
-	opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
-	opj_tcd_resolution_t *res = &tilec->resolutions[resno];
-	
-	opj_bio_t *bio = NULL;	/* BIO component */
-	
-	/* <SOP 0xff91> */
-	if (tcp->csty & J2K_CP_CSTY_SOP) {
-		c[0] = 255;
-		c[1] = 145;
-		c[2] = 0;
-		c[3] = 4;
-		c[4] = (unsigned char)((tile->packno % 65536) / 256);
-		c[5] = (unsigned char)((tile->packno % 65536) % 256);
-		c += 6;
-	}
-	/* </SOP> */
-	
-	if (!layno) {
-		for (bandno = 0; bandno < res->numbands; bandno++) {
-			opj_tcd_band_t *band = &res->bands[bandno];
-			opj_tcd_precinct_t *prc = &band->precincts[precno];
-			tgt_reset(prc->incltree);
-			tgt_reset(prc->imsbtree);
-			for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-				opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
-				cblk->numpasses = 0;
-				tgt_setvalue(prc->imsbtree, cblkno, band->numbps - cblk->numbps);
-			}
-		}
-	}
-	
-	bio = bio_create();
-	bio_init_enc(bio, c, length);
-	bio_write(bio, 1, 1);		/* Empty header bit */
-	
-	/* Writing Packet header */
-	for (bandno = 0; bandno < res->numbands; bandno++) {
-		opj_tcd_band_t *band = &res->bands[bandno];
-		opj_tcd_precinct_t *prc = &band->precincts[precno];
-		for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-			opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
-			opj_tcd_layer_t *layer = &cblk->layers[layno];
-			if (!cblk->numpasses && layer->numpasses) {
-				tgt_setvalue(prc->incltree, cblkno, layno);
-			}
-		}
-		for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-			opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
-			opj_tcd_layer_t *layer = &cblk->layers[layno];
-			int increment = 0;
-			int nump = 0;
-			int len = 0, passno;
-			/* cblk inclusion bits */
-			if (!cblk->numpasses) {
-				tgt_encode(bio, prc->incltree, cblkno, layno + 1);
-			} else {
-				bio_write(bio, layer->numpasses != 0, 1);
-			}
-			/* if cblk not included, go to the next cblk  */
-			if (!layer->numpasses) {
-				continue;
-			}
-			/* if first instance of cblk --> zero bit-planes information */
-			if (!cblk->numpasses) {
-				cblk->numlenbits = 3;
-				tgt_encode(bio, prc->imsbtree, cblkno, 999);
-			}
-			/* number of coding passes included */
-			t2_putnumpasses(bio, layer->numpasses);
-			
-			/* computation of the increase of the length indicator and insertion in the header     */
-			for (passno = cblk->numpasses; passno < cblk->numpasses + layer->numpasses; passno++) {
-				opj_tcd_pass_t *pass = &cblk->passes[passno];
-				nump++;
-				len += pass->len;
-				if (pass->term || passno == (cblk->numpasses + layer->numpasses) - 1) {
-					increment = int_max(increment, int_floorlog2(len) + 1 - (cblk->numlenbits + int_floorlog2(nump)));
-					len = 0;
-					nump = 0;
-				}
-			}
-			t2_putcommacode(bio, increment);
-
-			/* computation of the new Length indicator */
-			cblk->numlenbits += increment;
-
-			/* insertion of the codeword segment length */
-			for (passno = cblk->numpasses; passno < cblk->numpasses + layer->numpasses; passno++) {
-				opj_tcd_pass_t *pass = &cblk->passes[passno];
-				nump++;
-				len += pass->len;
-				if (pass->term || passno == (cblk->numpasses + layer->numpasses) - 1) {
-					bio_write(bio, len, cblk->numlenbits + int_floorlog2(nump));
-					len = 0;
-					nump = 0;
-				}
-			}
-		}
-	}
-
-	if (bio_flush(bio)) {
-		bio_destroy(bio);
-		return -999;		/* modified to eliminate longjmp !! */
-	}
-
-	c += bio_numbytes(bio);
-	bio_destroy(bio);
-	
-	/* <EPH 0xff92> */
-	if (tcp->csty & J2K_CP_CSTY_EPH) {
-		c[0] = 255;
-		c[1] = 146;
-		c += 2;
-	}
-	/* </EPH> */
-
-	/* << INDEX */
-	/* End of packet header position. Currently only represents the distance to start of packet
-	// Will be updated later by incrementing with packet start value */
-	if(cstr_info && cstr_info->index_write) {
-		opj_packet_info_t *info_PK = &cstr_info->tile[tileno].packet[cstr_info->packno];
-		info_PK->end_ph_pos = (int)(c - dest);
-	}
-	/* INDEX >> */
-	
-	/* Writing the packet body */
-	
-	for (bandno = 0; bandno < res->numbands; bandno++) {
-		opj_tcd_band_t *band = &res->bands[bandno];
-		opj_tcd_precinct_t *prc = &band->precincts[precno];
-		for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-			opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
-			opj_tcd_layer_t *layer = &cblk->layers[layno];
-			if (!layer->numpasses) {
-				continue;
-			}
-			if (c + layer->len > dest + length) {
-				return -999;
-			}
-			
-			memcpy(c, layer->data, layer->len);
-			cblk->numpasses += layer->numpasses;
-			c += layer->len;
-			/* << INDEX */ 
-			if(cstr_info && cstr_info->index_write) {
-				opj_packet_info_t *info_PK = &cstr_info->tile[tileno].packet[cstr_info->packno];
-				info_PK->disto += layer->disto;
-				if (cstr_info->D_max < info_PK->disto) {
-					cstr_info->D_max = info_PK->disto;
-				}
-			}
-			/* INDEX >> */
-		}
-	}
-	
-	return (c - dest);
+/* see issue 80 */
+#if 0
+#define JAS_FPRINTF fprintf
+#else
+/* issue 290 */
+static void opj_null_jas_fprintf(FILE* file, const char * format, ...)
+{
+  (void)file;
+  (void)format;
 }
+#define JAS_FPRINTF opj_null_jas_fprintf
+#endif
 
-static opj_bool t2_init_seg(opj_tcd_cblk_dec_t* cblk, int index, int cblksty, int first) {
-	opj_tcd_seg_t* seg;
-    opj_tcd_seg_t* segs;
-    segs = (opj_tcd_seg_t*) opj_realloc(cblk->segs, (index + 1) * sizeof(opj_tcd_seg_t));
+OPJ_BOOL opj_t2_decode_packets( opj_t2_t *p_t2,
+                                OPJ_UINT32 p_tile_no,
+                                opj_tcd_tile_t *p_tile,
+                                OPJ_BYTE *p_src,
+                                OPJ_UINT32 * p_data_read,
+                                OPJ_UINT32 p_max_len,
+                                opj_codestream_index_t *p_cstr_index)
+{
+        OPJ_BYTE *l_current_data = p_src;
+        opj_pi_iterator_t *l_pi = 00;
+        OPJ_UINT32 pino;
+        opj_image_t *l_image = p_t2->image;
+        opj_cp_t *l_cp = p_t2->cp;
+        opj_tcp_t *l_tcp = &(p_t2->cp->tcps[p_tile_no]);
+        OPJ_UINT32 l_nb_bytes_read;
+        OPJ_UINT32 l_nb_pocs = l_tcp->numpocs + 1;
+        opj_pi_iterator_t *l_current_pi = 00;
+#ifdef TODO_MSD
+        OPJ_UINT32 curtp = 0;
+        OPJ_UINT32 tp_start_packno;
+#endif 
+        opj_packet_info_t *l_pack_info = 00;
+        opj_image_comp_t* l_img_comp = 00;
 
-    if (segs == NULL)
-    {
-        return OPJ_FALSE;
-    }
-    cblk->segs = segs;
-
-	seg = &cblk->segs[index];
-	seg->data = NULL;
-	seg->dataindex = 0;
-	seg->numpasses = 0;
-	seg->len = 0;
-	if (cblksty & J2K_CCP_CBLKSTY_TERMALL) {
-		seg->maxpasses = 1;
-	}
-	else if (cblksty & J2K_CCP_CBLKSTY_LAZY) {
-		if (first) {
-			seg->maxpasses = 10;
-		} else {
-			seg->maxpasses = (((seg - 1)->maxpasses == 1) || ((seg - 1)->maxpasses == 10)) ? 2 : 1;
-		}
-	} else {
-		seg->maxpasses = 109;
-	}
-
-    return OPJ_TRUE;
-}
+        OPJ_ARG_NOT_USED(p_cstr_index);
 
-static int t2_decode_packet(opj_t2_t* t2, unsigned char *src, int len, opj_tcd_tile_t *tile, 
-														opj_tcp_t *tcp, opj_pi_iterator_t *pi, opj_packet_info_t *pack_info) {
-	int bandno, cblkno;
-	unsigned char *c = src;
-
-	opj_cp_t *cp = t2->cp;
-
-	int compno = pi->compno;	/* component value */
-	int resno  = pi->resno;		/* resolution level value */
-	int precno = pi->precno;	/* precinct value */
-	int layno  = pi->layno;		/* quality layer value */
-
-	unsigned char *hd = NULL;
-	int present;
-	
-	opj_bio_t *bio = NULL;	/* BIO component */
-
-	opj_tcd_resolution_t* res;
-	assert(&tile->comps[compno] != NULL);
-	res = &tile->comps[compno].resolutions[resno];
-
-	if (layno == 0) {
-		for (bandno = 0; bandno < res->numbands; bandno++) {
-			opj_tcd_band_t *band = &res->bands[bandno];
-			opj_tcd_precinct_t *prc = &band->precincts[precno];
-			
-			if ((band->x1-band->x0 == 0)||(band->y1-band->y0 == 0)) continue;
-			
-			tgt_reset(prc->incltree);
-			tgt_reset(prc->imsbtree);
-			for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-				opj_tcd_cblk_dec_t* cblk = &prc->cblks.dec[cblkno];
-				cblk->numsegs = 0;
-			}
-		}
-	}
-	
-	/* SOP markers */
-	
-	if (tcp->csty & J2K_CP_CSTY_SOP) {
-		if ((*c) != 0xff || (*(c + 1) != 0x91)) {
-			opj_event_msg(t2->cinfo, EVT_WARNING, "Expected SOP marker\n");
-		} else {
-			c += 6;
-		}
-		
-		/** TODO : check the Nsop value */
-	}
-	
-	/* 
-	When the marker PPT/PPM is used the packet header are store in PPT/PPM marker
-	This part deal with this caracteristic
-	step 1: Read packet header in the saved structure
-	step 2: Return to codestream for decoding 
-	*/
-
-	bio = bio_create();
-	
-	if (cp->ppm == 1) {		/* PPM */
-		hd = cp->ppm_data;
-		bio_init_dec(bio, hd, cp->ppm_len);
-	} else if (tcp->ppt == 1) {	/* PPT */
-		hd = tcp->ppt_data;
-		bio_init_dec(bio, hd, tcp->ppt_len);
-	} else {			/* Normal Case */
-		hd = c;
-		bio_init_dec(bio, hd, src+len-hd);
-	}
-	
-	present = bio_read(bio, 1);
-	
-	if (!present) {
-		bio_inalign(bio);
-		hd += bio_numbytes(bio);
-		bio_destroy(bio);
-		
-		/* EPH markers */
-		
-		if (tcp->csty & J2K_CP_CSTY_EPH) {
-			if ((*hd) != 0xff || (*(hd + 1) != 0x92)) {
-				printf("Error : expected EPH marker\n");
-			} else {
-				hd += 2;
-			}
-		}
-
-		/* << INDEX */
-		/* End of packet header position. Currently only represents the distance to start of packet
-		// Will be updated later by incrementing with packet start value*/
-		if(pack_info) {
-			pack_info->end_ph_pos = (int)(c - src);
-		}
-		/* INDEX >> */
-		
-		if (cp->ppm == 1) {		/* PPM case */
-			cp->ppm_len += cp->ppm_data-hd;
-			cp->ppm_data = hd;
-			return (c - src);
-		}
-		if (tcp->ppt == 1) {	/* PPT case */
-			tcp->ppt_len+=tcp->ppt_data-hd;
-			tcp->ppt_data = hd;
-			return (c - src);
-		}
-		
-		return (hd - src);
-	}
-	
-	for (bandno = 0; bandno < res->numbands; bandno++) {
-		opj_tcd_band_t *band = &res->bands[bandno];
-		opj_tcd_precinct_t *prc = &band->precincts[precno];
-		
-		if ((band->x1-band->x0 == 0)||(band->y1-band->y0 == 0)) continue;
-		
-		for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-			int included, increment, n, segno;
-			opj_tcd_cblk_dec_t* cblk = &prc->cblks.dec[cblkno];
-			/* if cblk not yet included before --> inclusion tagtree */
-			if (!cblk->numsegs) {
-				included = tgt_decode(bio, prc->incltree, cblkno, layno + 1);
-				/* else one bit */
-			} else {
-				included = bio_read(bio, 1);
-			}
-			/* if cblk not included */
-			if (!included) {
-				cblk->numnewpasses = 0;
-				continue;
-			}
-			/* if cblk not yet included --> zero-bitplane tagtree */
-			if (!cblk->numsegs) {
-				int i, numimsbs;
-				for (i = 0; !tgt_decode(bio, prc->imsbtree, cblkno, i); i++) {
-					;
-				}
-				numimsbs = i - 1;
-				cblk->numbps = band->numbps - numimsbs;
-				cblk->numlenbits = 3;
-			}
-			/* number of coding passes */
-			cblk->numnewpasses = t2_getnumpasses(bio);
-			increment = t2_getcommacode(bio);
-			/* length indicator increment */
-			cblk->numlenbits += increment;
-			segno = 0;
-			if (!cblk->numsegs) {
-                if (!t2_init_seg(cblk, segno, tcp->tccps[compno].cblksty, 1))
+#ifdef TODO_MSD
+        if (p_cstr_index) {
+                l_pack_info = p_cstr_index->tile_index[p_tile_no].packet;
+        }
+#endif
+
+        /* create a packet iterator */
+        l_pi = opj_pi_create_decode(l_image, l_cp, p_tile_no);
+        if (!l_pi) {
+                return OPJ_FALSE;
+        }
+
+
+        l_current_pi = l_pi;
+
+        for     (pino = 0; pino <= l_tcp->numpocs; ++pino) {
+
+                /* if the resolution needed is too low, one dim of the tilec could be equal to zero
+                 * and no packets are used to decode this resolution and
+                 * l_current_pi->resno is always >= p_tile->comps[l_current_pi->compno].minimum_num_resolutions
+                 * and no l_img_comp->resno_decoded are computed
+                 */
+                OPJ_BOOL* first_pass_failed = (OPJ_BOOL*)opj_malloc(l_image->numcomps * sizeof(OPJ_BOOL));
+                if (!first_pass_failed)
                 {
-                    opj_event_msg(t2->cinfo, EVT_ERROR, "Out of memory\n");
-                    bio_destroy(bio);
-                    return -999;
+                    opj_pi_destroy(l_pi,l_nb_pocs);
+                    return OPJ_FALSE;
                 }
-			} else {
-				segno = cblk->numsegs - 1;
-				if (cblk->segs[segno].numpasses == cblk->segs[segno].maxpasses) {
-					++segno;
-                    if (!t2_init_seg(cblk, segno, tcp->tccps[compno].cblksty, 0))
-                    {
-                        opj_event_msg(t2->cinfo, EVT_ERROR, "Out of memory\n");
-                        bio_destroy(bio);
-                        return -999;
-                    }
-				}
-			}
-			n = cblk->numnewpasses;
-			
-			do {
-				cblk->segs[segno].numnewpasses = int_min(cblk->segs[segno].maxpasses - cblk->segs[segno].numpasses, n);
-				cblk->segs[segno].newlen = bio_read(bio, cblk->numlenbits + int_floorlog2(cblk->segs[segno].numnewpasses));
-				n -= cblk->segs[segno].numnewpasses;
-				if (n > 0) {
-					++segno;
-                    if (!t2_init_seg(cblk, segno, tcp->tccps[compno].cblksty, 0))
-                    {
-                        opj_event_msg(t2->cinfo, EVT_ERROR, "Out of memory\n");
-                        bio_destroy(bio);
-                        return -999;
-                    }
-				}
-			} while (n > 0);
-		}
-	}
-	
-	if (bio_inalign(bio)) {
-		bio_destroy(bio);
-		return -999;
-	}
-	
-	hd += bio_numbytes(bio);
-	bio_destroy(bio);
-	
-	/* EPH markers */
-	if (tcp->csty & J2K_CP_CSTY_EPH) {
-		if ((*hd) != 0xff || (*(hd + 1) != 0x92)) {
-			opj_event_msg(t2->cinfo, EVT_ERROR, "Expected EPH marker\n");
-			return -999;
-		} else {
-			hd += 2;
-		}
-	}
-
-	/* << INDEX */
-	/* End of packet header position. Currently only represents the distance to start of packet
-	// Will be updated later by incrementing with packet start value*/
-	if(pack_info) {
-		pack_info->end_ph_pos = (int)(hd - src);
-	}
-	/* INDEX >> */
-	
-	if (cp->ppm==1) {
-		cp->ppm_len+=cp->ppm_data-hd;
-		cp->ppm_data = hd;
-	} else if (tcp->ppt == 1) {
-		tcp->ppt_len+=tcp->ppt_data-hd;
-		tcp->ppt_data = hd;
-	} else {
-		c=hd;
-	}
-	
-	for (bandno = 0; bandno < res->numbands; bandno++) {
-		opj_tcd_band_t *band = &res->bands[bandno];
-		opj_tcd_precinct_t *prc = &band->precincts[precno];
-		
-		if ((band->x1-band->x0 == 0)||(band->y1-band->y0 == 0)) continue;
-		
-		for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-			opj_tcd_cblk_dec_t* cblk = &prc->cblks.dec[cblkno];
-			opj_tcd_seg_t *seg = NULL;
-			if (!cblk->numnewpasses)
-				continue;
-			if (!cblk->numsegs) {
-				seg = &cblk->segs[0];
-				cblk->numsegs++;
-				cblk->len = 0;
-			} else {
-				seg = &cblk->segs[cblk->numsegs - 1];
-				if (seg->numpasses == seg->maxpasses) {
-					seg++;
-					cblk->numsegs++;
-				}
-			}
-			
-			do {
-				if (c + seg->newlen > src + len) {
-					return -999;
-				}
+                memset(first_pass_failed, OPJ_TRUE, l_image->numcomps * sizeof(OPJ_BOOL));
 
-#ifdef USE_JPWL
-			/* we need here a j2k handle to verify if making a check to
-			the validity of cblocks parameters is selected from user (-W) */
-
-				/* let's check that we are not exceeding */
-				if ((cblk->len + seg->newlen) > 8192) {
-					opj_event_msg(t2->cinfo, EVT_WARNING,
-						"JPWL: segment too long (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\n",
-						seg->newlen, cblkno, precno, bandno, resno, compno);
-					if (!JPWL_ASSUME) {
-						opj_event_msg(t2->cinfo, EVT_ERROR, "JPWL: giving up\n");
-						return -999;
-					}
-					seg->newlen = 8192 - cblk->len;
-					opj_event_msg(t2->cinfo, EVT_WARNING, "      - truncating segment to %d\n", seg->newlen);
-					break;
-				};
+                while (opj_pi_next(l_current_pi)) {
+                  JAS_FPRINTF( stderr, "packet offset=00000166 prg=%d cmptno=%02d rlvlno=%02d prcno=%03d lyrno=%02d\n\n",
+                    l_current_pi->poc.prg1, l_current_pi->compno, l_current_pi->resno, l_current_pi->precno, l_current_pi->layno );
 
-#endif /* USE_JPWL */
-				
-				cblk->data = (unsigned char*) opj_realloc(cblk->data, (cblk->len + seg->newlen) * sizeof(unsigned char));
-				memcpy(cblk->data + cblk->len, c, seg->newlen);
-				if (seg->numpasses == 0) {
-					seg->data = &cblk->data;
-					seg->dataindex = cblk->len;
-				}
-				c += seg->newlen;
-				cblk->len += seg->newlen;
-				seg->len += seg->newlen;
-				seg->numpasses += seg->numnewpasses;
-				cblk->numnewpasses -= seg->numnewpasses;
-				if (cblk->numnewpasses > 0) {
-					seg++;
-					cblk->numsegs++;
-				}
-			} while (cblk->numnewpasses > 0);
-		}
-	}
-	
-	return (c - src);
+                        if (l_tcp->num_layers_to_decode > l_current_pi->layno
+                                        && l_current_pi->resno < p_tile->comps[l_current_pi->compno].minimum_num_resolutions) {
+                                l_nb_bytes_read = 0;
+
+                                first_pass_failed[l_current_pi->compno] = OPJ_FALSE;
+
+                                if (! opj_t2_decode_packet(p_t2,p_tile,l_tcp,l_current_pi,l_current_data,&l_nb_bytes_read,p_max_len,l_pack_info)) {
+                                        opj_pi_destroy(l_pi,l_nb_pocs);
+                                        opj_free(first_pass_failed);
+                                        return OPJ_FALSE;
+                                }
+
+                                l_img_comp = &(l_image->comps[l_current_pi->compno]);
+                                l_img_comp->resno_decoded = opj_uint_max(l_current_pi->resno, l_img_comp->resno_decoded);
+                        }
+                        else {
+                                l_nb_bytes_read = 0;
+                                if (! opj_t2_skip_packet(p_t2,p_tile,l_tcp,l_current_pi,l_current_data,&l_nb_bytes_read,p_max_len,l_pack_info)) {
+                                        opj_pi_destroy(l_pi,l_nb_pocs);
+                                        opj_free(first_pass_failed);
+                                        return OPJ_FALSE;
+                                }
+                        }
+
+                        if (first_pass_failed[l_current_pi->compno]) {
+                                l_img_comp = &(l_image->comps[l_current_pi->compno]);
+                                if (l_img_comp->resno_decoded == 0)
+                                        l_img_comp->resno_decoded = p_tile->comps[l_current_pi->compno].minimum_num_resolutions - 1;
+                        }
+
+                        l_current_data += l_nb_bytes_read;
+                        p_max_len -= l_nb_bytes_read;
+
+                        /* INDEX >> */
+#ifdef TODO_MSD
+                        if(p_cstr_info) {
+                                opj_tile_info_v2_t *info_TL = &p_cstr_info->tile[p_tile_no];
+                                opj_packet_info_t *info_PK = &info_TL->packet[p_cstr_info->packno];
+                                tp_start_packno = 0;
+                                if (!p_cstr_info->packno) {
+                                        info_PK->start_pos = info_TL->end_header + 1;
+                                } else if (info_TL->packet[p_cstr_info->packno-1].end_pos >= (OPJ_INT32)p_cstr_info->tile[p_tile_no].tp[curtp].tp_end_pos){ /* New tile part */
+                                        info_TL->tp[curtp].tp_numpacks = p_cstr_info->packno - tp_start_packno; /* Number of packets in previous tile-part */
+                                        tp_start_packno = p_cstr_info->packno;
+                                        curtp++;
+                                        info_PK->start_pos = p_cstr_info->tile[p_tile_no].tp[curtp].tp_end_header+1;
+                                } else {
+                                        info_PK->start_pos = (l_cp->m_specific_param.m_enc.m_tp_on && info_PK->start_pos) ? info_PK->start_pos : info_TL->packet[p_cstr_info->packno - 1].end_pos + 1;
+                                }
+                                info_PK->end_pos = info_PK->start_pos + l_nb_bytes_read - 1;
+                                info_PK->end_ph_pos += info_PK->start_pos - 1;  /* End of packet header which now only represents the distance */
+                                ++p_cstr_info->packno;
+                        }
+#endif
+                        /* << INDEX */
+                }
+                ++l_current_pi;
+
+                opj_free(first_pass_failed);
+        }
+        /* INDEX >> */
+#ifdef TODO_MSD
+        if
+                (p_cstr_info) {
+                p_cstr_info->tile[p_tile_no].tp[curtp].tp_numpacks = p_cstr_info->packno - tp_start_packno; /* Number of packets in last tile-part */
+        }
+#endif
+        /* << INDEX */
+
+        /* don't forget to release pi */
+        opj_pi_destroy(l_pi,l_nb_pocs);
+        *p_data_read = (OPJ_UINT32)(l_current_data - p_src);
+        return OPJ_TRUE;
 }
 
 /* ----------------------------------------------------------------------- */
 
-int t2_encode_packets(opj_t2_t* t2,int tileno, opj_tcd_tile_t *tile, int maxlayers, unsigned char *dest, int len, opj_codestream_info_t *cstr_info,int tpnum, int tppos,int pino, J2K_T2_MODE t2_mode, int cur_totnum_tp){
-	unsigned char *c = dest;
-	int e = 0;
-	int compno;
-	opj_pi_iterator_t *pi = NULL;
-	int poc;
-	opj_image_t *image = t2->image;
-	opj_cp_t *cp = t2->cp;
-	opj_tcp_t *tcp = &cp->tcps[tileno];
-	int pocno = cp->cinema == CINEMA4K_24? 2: 1;
-	int maxcomp = cp->max_comp_size > 0 ? image->numcomps : 1;
-	
-	pi = pi_initialise_encode(image, cp, tileno, t2_mode);
-	if(!pi) {
-		/* TODO: throw an error */
-		return -999;
-	}
-	
-	if(t2_mode == THRESH_CALC ){ /* Calculating threshold */
-		for(compno = 0; compno < maxcomp; compno++ ){
-			for(poc = 0; poc < pocno ; poc++){
-				int comp_len = 0;
-				int tpnum = compno;
-				if (pi_create_encode(pi, cp,tileno,poc,tpnum,tppos,t2_mode,cur_totnum_tp)) {
-					opj_event_msg(t2->cinfo, EVT_ERROR, "Error initializing Packet Iterator\n");
-					pi_destroy(pi, cp, tileno);
-					return -999;
-				}
-				while (pi_next(&pi[poc])) {
-					if (pi[poc].layno < maxlayers) {
-						e = t2_encode_packet(tile, &cp->tcps[tileno], &pi[poc], c, dest + len - c, cstr_info, tileno);
-						comp_len = comp_len + e;
-						if (e == -999) {
-							break;
-						} else {
-							c += e;
-						}
-					}
-				}
-				if (e == -999) break;
-				if (cp->max_comp_size){
-					if (comp_len > cp->max_comp_size){
-						e = -999;
-						break;
-					}
-				}
-			}
-			if (e == -999)  break;
-		}
-	}else{  /* t2_mode == FINAL_PASS  */
-		pi_create_encode(pi, cp,tileno,pino,tpnum,tppos,t2_mode,cur_totnum_tp);
-		while (pi_next(&pi[pino])) {
-			if (pi[pino].layno < maxlayers) {
-				e = t2_encode_packet(tile, &cp->tcps[tileno], &pi[pino], c, dest + len - c, cstr_info, tileno);
-				if (e == -999) {
-					break;
-				} else {
-					c += e;
-				}
-				/* INDEX >> */
-				if(cstr_info) {
-					if(cstr_info->index_write) {
-						opj_tile_info_t *info_TL = &cstr_info->tile[tileno];
-						opj_packet_info_t *info_PK = &info_TL->packet[cstr_info->packno];
-						if (!cstr_info->packno) {
-							info_PK->start_pos = info_TL->end_header + 1;
-						} else {
-							info_PK->start_pos = ((cp->tp_on | tcp->POC)&& info_PK->start_pos) ? info_PK->start_pos : info_TL->packet[cstr_info->packno - 1].end_pos + 1;
-						}
-						info_PK->end_pos = info_PK->start_pos + e - 1;
-						info_PK->end_ph_pos += info_PK->start_pos - 1;	/* End of packet header which now only represents the distance 
-																														// to start of packet is incremented by value of start of packet*/
-					}
-					
-					cstr_info->packno++;
-				}
-				/* << INDEX */
-				tile->packno++;
-			}
-		}
-	}
-	
-	pi_destroy(pi, cp, tileno);
-	
-	if (e == -999) {
-		return e;
-	}
-	
-  return (c - dest);
+/**
+ * Creates a Tier 2 handle
+ *
+ * @param       p_image         Source or destination image
+ * @param       p_cp            Image coding parameters.
+ * @return              a new T2 handle if successful, NULL otherwise.
+*/
+opj_t2_t* opj_t2_create(opj_image_t *p_image, opj_cp_t *p_cp)
+{
+        /* create the t2 structure */
+        opj_t2_t *l_t2 = (opj_t2_t*)opj_malloc(sizeof(opj_t2_t));
+        if (!l_t2) {
+                return NULL;
+        }
+        memset(l_t2,0,sizeof(opj_t2_t));
+
+        l_t2->image = p_image;
+        l_t2->cp = p_cp;
+
+        return l_t2;
 }
 
-int t2_decode_packets(opj_t2_t *t2, unsigned char *src, int len, int tileno, opj_tcd_tile_t *tile, opj_codestream_info_t *cstr_info) {
-	unsigned char *c = src;
-	opj_pi_iterator_t *pi;
-	int pino, e = 0;
-	int n = 0, curtp = 0;
-	int tp_start_packno;
-
-	opj_image_t *image = t2->image;
-	opj_cp_t *cp = t2->cp;
-	
-	/* create a packet iterator */
-	pi = pi_create_decode(image, cp, tileno);
-	if(!pi) {
-		/* TODO: throw an error */
-		return -999;
-	}
-
-	tp_start_packno = 0;
-	
-	for (pino = 0; pino <= cp->tcps[tileno].numpocs; pino++) {
-		while (pi_next(&pi[pino])) {
-			if ((cp->layer==0) || (cp->layer>=((pi[pino].layno)+1))) {
-				opj_packet_info_t *pack_info;
-				if (cstr_info)
-					pack_info = &cstr_info->tile[tileno].packet[cstr_info->packno];
-				else
-					pack_info = NULL;
-				e = t2_decode_packet(t2, c, src + len - c, tile, &cp->tcps[tileno], &pi[pino], pack_info);
-			} else {
-				e = 0;
-			}
-            if(e == -999)
-            {
-                pi_destroy(pi, cp, tileno);
-                return -999;
-            }
-			/* progression in resolution */
-			image->comps[pi[pino].compno].resno_decoded =	
-				(e > 0) ? 
-				int_max(pi[pino].resno, image->comps[pi[pino].compno].resno_decoded) 
-				: image->comps[pi[pino].compno].resno_decoded;
-			n++;
-
-			/* INDEX >> */
-			if(cstr_info) {
-				opj_tile_info_t *info_TL = &cstr_info->tile[tileno];
-				opj_packet_info_t *info_PK = &info_TL->packet[cstr_info->packno];
-				if (!cstr_info->packno) {
-					info_PK->start_pos = info_TL->end_header + 1;
-				} else if (info_TL->packet[cstr_info->packno-1].end_pos >= (int)cstr_info->tile[tileno].tp[curtp].tp_end_pos){ /* New tile part*/
-					info_TL->tp[curtp].tp_numpacks = cstr_info->packno - tp_start_packno; /* Number of packets in previous tile-part*/
-          info_TL->tp[curtp].tp_start_pack = tp_start_packno;
-					tp_start_packno = cstr_info->packno;
-					curtp++;
-					info_PK->start_pos = cstr_info->tile[tileno].tp[curtp].tp_end_header+1;
-				} else {
-					info_PK->start_pos = (cp->tp_on && info_PK->start_pos) ? info_PK->start_pos : info_TL->packet[cstr_info->packno - 1].end_pos + 1;
-				}
-				info_PK->end_pos = info_PK->start_pos + e - 1;
-				info_PK->end_ph_pos += info_PK->start_pos - 1;	/* End of packet header which now only represents the distance 
-																												// to start of packet is incremented by value of start of packet*/
-				cstr_info->packno++;
-			}
-			/* << INDEX */
-			
-			if (e == -999) {		/* ADD */
-				break;
-			} else {
-				c += e;
-			}			
-		}
-	}
-	/* INDEX >> */
-	if(cstr_info) {
-		cstr_info->tile[tileno].tp[curtp].tp_numpacks = cstr_info->packno - tp_start_packno; /* Number of packets in last tile-part*/
-    cstr_info->tile[tileno].tp[curtp].tp_start_pack = tp_start_packno;
-	}
-	/* << INDEX */
-
-	/* don't forget to release pi */
-	pi_destroy(pi, cp, tileno);
-	
-	if (e == -999) {
-		return e;
-	}
-	
-	return (c - src);
+void opj_t2_destroy(opj_t2_t *t2) {
+        if(t2) {
+                opj_free(t2);
+        }
 }
 
-/* ----------------------------------------------------------------------- */
+OPJ_BOOL opj_t2_decode_packet(  opj_t2_t* p_t2,
+                                opj_tcd_tile_t *p_tile,
+                                opj_tcp_t *p_tcp,
+                                opj_pi_iterator_t *p_pi,
+                                OPJ_BYTE *p_src,
+                                OPJ_UINT32 * p_data_read,
+                                OPJ_UINT32 p_max_length,
+                                opj_packet_info_t *p_pack_info)
+{
+        OPJ_BOOL l_read_data;
+        OPJ_UINT32 l_nb_bytes_read = 0;
+        OPJ_UINT32 l_nb_total_bytes_read = 0;
+
+        *p_data_read = 0;
 
-opj_t2_t* t2_create(opj_common_ptr cinfo, opj_image_t *image, opj_cp_t *cp) {
-	/* create the tcd structure */
-	opj_t2_t *t2 = (opj_t2_t*)opj_malloc(sizeof(opj_t2_t));
-	if(!t2) return NULL;
-	t2->cinfo = cinfo;
-	t2->image = image;
-	t2->cp = cp;
+        if (! opj_t2_read_packet_header(p_t2,p_tile,p_tcp,p_pi,&l_read_data,p_src,&l_nb_bytes_read,p_max_length,p_pack_info)) {
+                return OPJ_FALSE;
+        }
 
-	return t2;
+        p_src += l_nb_bytes_read;
+        l_nb_total_bytes_read += l_nb_bytes_read;
+        p_max_length -= l_nb_bytes_read;
+
+        /* we should read data for the packet */
+        if (l_read_data) {
+                l_nb_bytes_read = 0;
+
+                if (! opj_t2_read_packet_data(p_t2,p_tile,p_pi,p_src,&l_nb_bytes_read,p_max_length,p_pack_info)) {
+                        return OPJ_FALSE;
+                }
+
+                l_nb_total_bytes_read += l_nb_bytes_read;
+        }
+
+        *p_data_read = l_nb_total_bytes_read;
+
+        return OPJ_TRUE;
 }
 
-void t2_destroy(opj_t2_t *t2) {
-	if(t2) {
-		opj_free(t2);
-	}
+OPJ_BOOL opj_t2_encode_packet(  OPJ_UINT32 tileno,
+                                opj_tcd_tile_t * tile,
+                                opj_tcp_t * tcp,
+                                opj_pi_iterator_t *pi,
+                                OPJ_BYTE *dest,
+                                OPJ_UINT32 * p_data_written,
+                                OPJ_UINT32 length,
+                                opj_codestream_info_t *cstr_info)
+{
+        OPJ_UINT32 bandno, cblkno;
+        OPJ_BYTE* c = dest;
+        OPJ_UINT32 l_nb_bytes;
+        OPJ_UINT32 compno = pi->compno;     /* component value */
+        OPJ_UINT32 resno  = pi->resno;      /* resolution level value */
+        OPJ_UINT32 precno = pi->precno;     /* precinct value */
+        OPJ_UINT32 layno  = pi->layno;      /* quality layer value */
+        OPJ_UINT32 l_nb_blocks;
+        opj_tcd_band_t *band = 00;
+        opj_tcd_cblk_enc_t* cblk = 00;
+        opj_tcd_pass_t *pass = 00;
+
+        opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+        opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+
+        opj_bio_t *bio = 00;    /* BIO component */
+
+        /* <SOP 0xff91> */
+        if (tcp->csty & J2K_CP_CSTY_SOP) {
+                c[0] = 255;
+                c[1] = 145;
+                c[2] = 0;
+                c[3] = 4;
+#if 0
+                c[4] = (tile->packno % 65536) / 256;
+                c[5] = (tile->packno % 65536) % 256;
+#else
+                c[4] = (tile->packno >> 8) & 0xff; /* packno is uint32_t */
+                c[5] = tile->packno & 0xff;
+#endif
+                c += 6;
+                length -= 6;
+        }
+        /* </SOP> */
+
+        if (!layno) {
+                band = res->bands;
+
+                for(bandno = 0; bandno < res->numbands; ++bandno) {
+                        opj_tcd_precinct_t *prc = &band->precincts[precno];
+
+                        opj_tgt_reset(prc->incltree);
+                        opj_tgt_reset(prc->imsbtree);
+
+                        l_nb_blocks = prc->cw * prc->ch;
+                        for     (cblkno = 0; cblkno < l_nb_blocks; ++cblkno) {
+                                cblk = &prc->cblks.enc[cblkno];
+
+                                cblk->numpasses = 0;
+                                opj_tgt_setvalue(prc->imsbtree, cblkno, band->numbps - (OPJ_INT32)cblk->numbps);
+                        }
+                        ++band;
+                }
+        }
+
+        bio = opj_bio_create();
+        opj_bio_init_enc(bio, c, length);
+        opj_bio_write(bio, 1, 1);           /* Empty header bit */
+
+        /* Writing Packet header */
+        band = res->bands;
+        for (bandno = 0; bandno < res->numbands; ++bandno)      {
+                opj_tcd_precinct_t *prc = &band->precincts[precno];
+
+                l_nb_blocks = prc->cw * prc->ch;
+                cblk = prc->cblks.enc;
+
+                for (cblkno = 0; cblkno < l_nb_blocks; ++cblkno) {
+                        opj_tcd_layer_t *layer = &cblk->layers[layno];
+
+                        if (!cblk->numpasses && layer->numpasses) {
+                                opj_tgt_setvalue(prc->incltree, cblkno, (OPJ_INT32)layno);
+                        }
+
+                        ++cblk;
+                }
+
+                cblk = prc->cblks.enc;
+                for (cblkno = 0; cblkno < l_nb_blocks; cblkno++) {
+                        opj_tcd_layer_t *layer = &cblk->layers[layno];
+                        OPJ_UINT32 increment = 0;
+                        OPJ_UINT32 nump = 0;
+                        OPJ_UINT32 len = 0, passno;
+                        OPJ_UINT32 l_nb_passes;
+
+                        /* cblk inclusion bits */
+                        if (!cblk->numpasses) {
+                                opj_tgt_encode(bio, prc->incltree, cblkno, (OPJ_INT32)(layno + 1));
+                        } else {
+                                opj_bio_write(bio, layer->numpasses != 0, 1);
+                        }
+
+                        /* if cblk not included, go to the next cblk  */
+                        if (!layer->numpasses) {
+                                ++cblk;
+                                continue;
+                        }
+
+                        /* if first instance of cblk --> zero bit-planes information */
+                        if (!cblk->numpasses) {
+                                cblk->numlenbits = 3;
+                                opj_tgt_encode(bio, prc->imsbtree, cblkno, 999);
+                        }
+
+                        /* number of coding passes included */
+                        opj_t2_putnumpasses(bio, layer->numpasses);
+                        l_nb_passes = cblk->numpasses + layer->numpasses;
+                        pass = cblk->passes +  cblk->numpasses;
+
+                        /* computation of the increase of the length indicator and insertion in the header     */
+                        for (passno = cblk->numpasses; passno < l_nb_passes; ++passno) {
+                                ++nump;
+                                len += pass->len;
+
+                                if (pass->term || passno == (cblk->numpasses + layer->numpasses) - 1) {
+                                  increment = (OPJ_UINT32)opj_int_max((OPJ_INT32)increment, opj_int_floorlog2((OPJ_INT32)len) + 1
+                                    - ((OPJ_INT32)cblk->numlenbits + opj_int_floorlog2((OPJ_INT32)nump)));
+                                        len = 0;
+                                        nump = 0;
+                                }
+
+                                ++pass;
+                        }
+                        opj_t2_putcommacode(bio, (OPJ_INT32)increment);
+
+                        /* computation of the new Length indicator */
+                        cblk->numlenbits += increment;
+
+                        pass = cblk->passes +  cblk->numpasses;
+                        /* insertion of the codeword segment length */
+                        for (passno = cblk->numpasses; passno < l_nb_passes; ++passno) {
+                                nump++;
+                                len += pass->len;
+
+                                if (pass->term || passno == (cblk->numpasses + layer->numpasses) - 1) {
+                                        opj_bio_write(bio, (OPJ_UINT32)len, cblk->numlenbits + (OPJ_UINT32)opj_int_floorlog2((OPJ_INT32)nump));
+                                        len = 0;
+                                        nump = 0;
+                                }
+                                ++pass;
+                        }
+
+                        ++cblk;
+                }
+
+                ++band;
+        }
+
+        if (!opj_bio_flush(bio)) {
+                opj_bio_destroy(bio);
+                return OPJ_FALSE;               /* modified to eliminate longjmp !! */
+        }
+
+        l_nb_bytes = (OPJ_UINT32)opj_bio_numbytes(bio);
+        c += l_nb_bytes;
+        length -= l_nb_bytes;
+
+        opj_bio_destroy(bio);
+
+        /* <EPH 0xff92> */
+        if (tcp->csty & J2K_CP_CSTY_EPH) {
+                c[0] = 255;
+                c[1] = 146;
+                c += 2;
+                length -= 2;
+        }
+        /* </EPH> */
+
+        /* << INDEX */
+        /* End of packet header position. Currently only represents the distance to start of packet
+           Will be updated later by incrementing with packet start value*/
+        if(cstr_info && cstr_info->index_write) {
+                opj_packet_info_t *info_PK = &cstr_info->tile[tileno].packet[cstr_info->packno];
+                info_PK->end_ph_pos = (OPJ_INT32)(c - dest);
+        }
+        /* INDEX >> */
+
+        /* Writing the packet body */
+        band = res->bands;
+        for (bandno = 0; bandno < res->numbands; bandno++) {
+                opj_tcd_precinct_t *prc = &band->precincts[precno];
+
+                l_nb_blocks = prc->cw * prc->ch;
+                cblk = prc->cblks.enc;
+
+                for (cblkno = 0; cblkno < l_nb_blocks; ++cblkno) {
+                        opj_tcd_layer_t *layer = &cblk->layers[layno];
+
+                        if (!layer->numpasses) {
+                                ++cblk;
+                                continue;
+                        }
+
+                        if (layer->len > length) {
+                                return OPJ_FALSE;
+                        }
+
+                        memcpy(c, layer->data, layer->len);
+                        cblk->numpasses += layer->numpasses;
+                        c += layer->len;
+                        length -= layer->len;
+
+                        /* << INDEX */
+                        if(cstr_info && cstr_info->index_write) {
+                                opj_packet_info_t *info_PK = &cstr_info->tile[tileno].packet[cstr_info->packno];
+                                info_PK->disto += layer->disto;
+                                if (cstr_info->D_max < info_PK->disto) {
+                                        cstr_info->D_max = info_PK->disto;
+                                }
+                        }
+
+                        ++cblk;
+                        /* INDEX >> */
+                }
+                ++band;
+        }
+
+        assert( c >= dest );
+        * p_data_written += (OPJ_UINT32)(c - dest);
+
+        return OPJ_TRUE;
+}
+
+static OPJ_BOOL opj_t2_skip_packet( opj_t2_t* p_t2,
+                                    opj_tcd_tile_t *p_tile,
+                                    opj_tcp_t *p_tcp,
+                                    opj_pi_iterator_t *p_pi,
+                                    OPJ_BYTE *p_src,
+                                    OPJ_UINT32 * p_data_read,
+                                    OPJ_UINT32 p_max_length,
+                                    opj_packet_info_t *p_pack_info)
+{
+        OPJ_BOOL l_read_data;
+        OPJ_UINT32 l_nb_bytes_read = 0;
+        OPJ_UINT32 l_nb_total_bytes_read = 0;
+
+        *p_data_read = 0;
+
+        if (! opj_t2_read_packet_header(p_t2,p_tile,p_tcp,p_pi,&l_read_data,p_src,&l_nb_bytes_read,p_max_length,p_pack_info)) {
+                return OPJ_FALSE;
+        }
+
+        p_src += l_nb_bytes_read;
+        l_nb_total_bytes_read += l_nb_bytes_read;
+        p_max_length -= l_nb_bytes_read;
+
+        /* we should read data for the packet */
+        if (l_read_data) {
+                l_nb_bytes_read = 0;
+
+                if (! opj_t2_skip_packet_data(p_t2,p_tile,p_pi,&l_nb_bytes_read,p_max_length,p_pack_info)) {
+                        return OPJ_FALSE;
+                }
+
+                l_nb_total_bytes_read += l_nb_bytes_read;
+        }
+        *p_data_read = l_nb_total_bytes_read;
+
+        return OPJ_TRUE;
 }
 
 
+OPJ_BOOL opj_t2_read_packet_header( opj_t2_t* p_t2,
+                                    opj_tcd_tile_t *p_tile,
+                                    opj_tcp_t *p_tcp,
+                                    opj_pi_iterator_t *p_pi,
+                                    OPJ_BOOL * p_is_data_present,
+                                    OPJ_BYTE *p_src_data,
+                                    OPJ_UINT32 * p_data_read,
+                                    OPJ_UINT32 p_max_length,
+                                    opj_packet_info_t *p_pack_info)
+
+{
+        /* loop */
+        OPJ_UINT32 bandno, cblkno;
+        OPJ_UINT32 l_nb_code_blocks;
+        OPJ_UINT32 l_remaining_length;
+        OPJ_UINT32 l_header_length;
+        OPJ_UINT32 * l_modified_length_ptr = 00;
+        OPJ_BYTE *l_current_data = p_src_data;
+        opj_cp_t *l_cp = p_t2->cp;
+        opj_bio_t *l_bio = 00;  /* BIO component */
+        opj_tcd_band_t *l_band = 00;
+        opj_tcd_cblk_dec_t* l_cblk = 00;
+        opj_tcd_resolution_t* l_res = &p_tile->comps[p_pi->compno].resolutions[p_pi->resno];
+
+        OPJ_BYTE *l_header_data = 00;
+        OPJ_BYTE **l_header_data_start = 00;
+
+        OPJ_UINT32 l_present;
+
+        if (p_pi->layno == 0) {
+                l_band = l_res->bands;
+
+                /* reset tagtrees */
+                for (bandno = 0; bandno < l_res->numbands; ++bandno) {
+                        opj_tcd_precinct_t *l_prc = &l_band->precincts[p_pi->precno];
+
+                        if ( ! ((l_band->x1-l_band->x0 == 0)||(l_band->y1-l_band->y0 == 0)) ) {
+                                opj_tgt_reset(l_prc->incltree);
+                                opj_tgt_reset(l_prc->imsbtree);
+                                l_cblk = l_prc->cblks.dec;
+
+                                l_nb_code_blocks = l_prc->cw * l_prc->ch;
+                                for (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno) {
+                                        l_cblk->numsegs = 0;
+                                        l_cblk->real_num_segs = 0;
+                                        ++l_cblk;
+                                }
+                        }
+
+                        ++l_band;
+                }
+        }
+
+        /* SOP markers */
+
+        if (p_tcp->csty & J2K_CP_CSTY_SOP) {
+                if (p_max_length < 6) {
+                        /* TODO opj_event_msg(p_t2->cinfo->event_mgr, EVT_WARNING, "Not enough space for expected SOP marker\n"); */
+                        printf("Not enough space for expected SOP marker\n");
+                } else if ((*l_current_data) != 0xff || (*(l_current_data + 1) != 0x91)) {
+                        /* TODO opj_event_msg(p_t2->cinfo->event_mgr, EVT_WARNING, "Expected SOP marker\n"); */
+                        printf("Expected SOP marker\n");
+                        fprintf(stderr, "Error : expected SOP marker\n");
+                } else {
+                        l_current_data += 6;
+                }
+
+                /** TODO : check the Nsop value */
+        }
+
+        /*
+        When the marker PPT/PPM is used the packet header are store in PPT/PPM marker
+        This part deal with this caracteristic
+        step 1: Read packet header in the saved structure
+        step 2: Return to codestream for decoding
+        */
+
+        l_bio = opj_bio_create();
+        if (! l_bio) {
+                return OPJ_FALSE;
+        }
 
+        if (l_cp->ppm == 1) { /* PPM */
+                l_header_data_start = &l_cp->ppm_data;
+                l_header_data = *l_header_data_start;
+                l_modified_length_ptr = &(l_cp->ppm_len);
+
+        }
+        else if (p_tcp->ppt == 1) { /* PPT */
+                l_header_data_start = &(p_tcp->ppt_data);
+                l_header_data = *l_header_data_start;
+                l_modified_length_ptr = &(p_tcp->ppt_len);
+        }
+        else {  /* Normal Case */
+                l_header_data_start = &(l_current_data);
+                l_header_data = *l_header_data_start;
+                l_remaining_length = (OPJ_UINT32)(p_src_data+p_max_length-l_header_data);
+                l_modified_length_ptr = &(l_remaining_length);
+        }
+
+        opj_bio_init_dec(l_bio, l_header_data,*l_modified_length_ptr);
+
+        l_present = opj_bio_read(l_bio, 1);
+        JAS_FPRINTF(stderr, "present=%d \n", l_present );
+        if (!l_present) {
+            /* TODO MSD: no test to control the output of this function*/
+                opj_bio_inalign(l_bio);
+                l_header_data += opj_bio_numbytes(l_bio);
+                opj_bio_destroy(l_bio);
+
+                /* EPH markers */
+                if (p_tcp->csty & J2K_CP_CSTY_EPH) {
+                        if (p_max_length < 2) {
+                                fprintf(stderr, "Not enough space for expected EPH marker\n");
+                        } else if ((*l_header_data) != 0xff || (*(l_header_data + 1) != 0x92)) {
+                                fprintf(stderr, "Error : expected EPH marker\n");
+                        } else {
+                                l_header_data += 2;
+                        }
+                }
+
+                l_header_length = (OPJ_UINT32)(l_header_data - *l_header_data_start);
+                *l_modified_length_ptr -= l_header_length;
+                *l_header_data_start += l_header_length;
+
+                /* << INDEX */
+                /* End of packet header position. Currently only represents the distance to start of packet
+                   Will be updated later by incrementing with packet start value */
+                if (p_pack_info) {
+                        p_pack_info->end_ph_pos = (OPJ_INT32)(l_current_data - p_src_data);
+                }
+                /* INDEX >> */
+
+                * p_is_data_present = OPJ_FALSE;
+                *p_data_read = (OPJ_UINT32)(l_current_data - p_src_data);
+                return OPJ_TRUE;
+        }
+
+        l_band = l_res->bands;
+        for (bandno = 0; bandno < l_res->numbands; ++bandno) {
+                opj_tcd_precinct_t *l_prc = &(l_band->precincts[p_pi->precno]);
+
+                if ((l_band->x1-l_band->x0 == 0)||(l_band->y1-l_band->y0 == 0)) {
+                        ++l_band;
+                        continue;
+                }
+
+                l_nb_code_blocks = l_prc->cw * l_prc->ch;
+                l_cblk = l_prc->cblks.dec;
+                for (cblkno = 0; cblkno < l_nb_code_blocks; cblkno++) {
+                        OPJ_UINT32 l_included,l_increment, l_segno;
+                        OPJ_INT32 n;
+
+                        /* if cblk not yet included before --> inclusion tagtree */
+                        if (!l_cblk->numsegs) {
+                                l_included = opj_tgt_decode(l_bio, l_prc->incltree, cblkno, (OPJ_INT32)(p_pi->layno + 1));
+                                /* else one bit */
+                        }
+                        else {
+                                l_included = opj_bio_read(l_bio, 1);
+                        }
+
+                        /* if cblk not included */
+                        if (!l_included) {
+                                l_cblk->numnewpasses = 0;
+                                ++l_cblk;
+        JAS_FPRINTF(stderr, "included=%d \n", l_included);
+                                continue;
+                        }
+
+                        /* if cblk not yet included --> zero-bitplane tagtree */
+                        if (!l_cblk->numsegs) {
+                                OPJ_UINT32 i = 0;
+
+                                while (!opj_tgt_decode(l_bio, l_prc->imsbtree, cblkno, (OPJ_INT32)i)) {
+                                        ++i;
+                                }
+
+                                l_cblk->numbps = (OPJ_UINT32)l_band->numbps + 1 - i;
+                                l_cblk->numlenbits = 3;
+                        }
+
+                        /* number of coding passes */
+                        l_cblk->numnewpasses = opj_t2_getnumpasses(l_bio);
+                        l_increment = opj_t2_getcommacode(l_bio);
+
+                        /* length indicator increment */
+                        l_cblk->numlenbits += l_increment;
+                        l_segno = 0;
+
+                        if (!l_cblk->numsegs) {
+                                if (! opj_t2_init_seg(l_cblk, l_segno, p_tcp->tccps[p_pi->compno].cblksty, 1)) {
+                                        opj_bio_destroy(l_bio);
+                                        return OPJ_FALSE;
+                                }
+                        }
+                        else {
+                                l_segno = l_cblk->numsegs - 1;
+                                if (l_cblk->segs[l_segno].numpasses == l_cblk->segs[l_segno].maxpasses) {
+                                        ++l_segno;
+                                        if (! opj_t2_init_seg(l_cblk, l_segno, p_tcp->tccps[p_pi->compno].cblksty, 0)) {
+                                                opj_bio_destroy(l_bio);
+                                                return OPJ_FALSE;
+                                        }
+                                }
+                        }
+                        n = (OPJ_INT32)l_cblk->numnewpasses;
+
+                        do {
+                                l_cblk->segs[l_segno].numnewpasses = (OPJ_UINT32)opj_int_min((OPJ_INT32)(l_cblk->segs[l_segno].maxpasses - l_cblk->segs[l_segno].numpasses), n);
+                                l_cblk->segs[l_segno].newlen = opj_bio_read(l_bio, l_cblk->numlenbits + opj_uint_floorlog2(l_cblk->segs[l_segno].numnewpasses));
+                                        JAS_FPRINTF(stderr, "included=%d numnewpasses=%d increment=%d len=%d \n", l_included, l_cblk->segs[l_segno].numnewpasses, l_increment, l_cblk->segs[l_segno].newlen );
+
+                                n -= (OPJ_INT32)l_cblk->segs[l_segno].numnewpasses;
+                                if (n > 0) {
+                                        ++l_segno;
+
+                                        if (! opj_t2_init_seg(l_cblk, l_segno, p_tcp->tccps[p_pi->compno].cblksty, 0)) {
+                                                opj_bio_destroy(l_bio);
+                                                return OPJ_FALSE;
+                                        }
+                                }
+                        } while (n > 0);
+
+                        ++l_cblk;
+                }
+
+                ++l_band;
+        }
+
+        if (!opj_bio_inalign(l_bio)) {
+                opj_bio_destroy(l_bio);
+                return OPJ_FALSE;
+        }
+
+        l_header_data += opj_bio_numbytes(l_bio);
+        opj_bio_destroy(l_bio);
+
+        /* EPH markers */
+        if (p_tcp->csty & J2K_CP_CSTY_EPH) {
+                if (p_max_length < 2) {
+                        fprintf(stderr, "Not enough space for expected EPH marker\n");
+                } else if ((*l_header_data) != 0xff || (*(l_header_data + 1) != 0x92)) {
+                        /* TODO opj_event_msg(t2->cinfo->event_mgr, EVT_ERROR, "Expected EPH marker\n"); */
+                        fprintf(stderr, "Error : expected EPH marker\n");
+                } else {
+                        l_header_data += 2;
+                }
+        }
 
+        l_header_length = (OPJ_UINT32)(l_header_data - *l_header_data_start);
+        JAS_FPRINTF( stderr, "hdrlen=%d \n", l_header_length );
+        JAS_FPRINTF( stderr, "packet body\n");
+        *l_modified_length_ptr -= l_header_length;
+        *l_header_data_start += l_header_length;
 
+        /* << INDEX */
+        /* End of packet header position. Currently only represents the distance to start of packet
+         Will be updated later by incrementing with packet start value */
+        if (p_pack_info) {
+                p_pack_info->end_ph_pos = (OPJ_INT32)(l_current_data - p_src_data);
+        }
+        /* INDEX >> */
+
+        *p_is_data_present = OPJ_TRUE;
+        *p_data_read = (OPJ_UINT32)(l_current_data - p_src_data);
+
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_t2_read_packet_data(   opj_t2_t* p_t2,
+                                    opj_tcd_tile_t *p_tile,
+                                    opj_pi_iterator_t *p_pi,
+                                    OPJ_BYTE *p_src_data,
+                                    OPJ_UINT32 * p_data_read,
+                                    OPJ_UINT32 p_max_length,
+                                    opj_packet_info_t *pack_info)
+{
+        OPJ_UINT32 bandno, cblkno;
+        OPJ_UINT32 l_nb_code_blocks;
+        OPJ_BYTE *l_current_data = p_src_data;
+        opj_tcd_band_t *l_band = 00;
+        opj_tcd_cblk_dec_t* l_cblk = 00;
+        opj_tcd_resolution_t* l_res = &p_tile->comps[p_pi->compno].resolutions[p_pi->resno];
+
+        OPJ_ARG_NOT_USED(p_t2);
+        OPJ_ARG_NOT_USED(pack_info);
+
+        l_band = l_res->bands;
+        for (bandno = 0; bandno < l_res->numbands; ++bandno) {
+                opj_tcd_precinct_t *l_prc = &l_band->precincts[p_pi->precno];
+
+                if ((l_band->x1-l_band->x0 == 0)||(l_band->y1-l_band->y0 == 0)) {
+                        ++l_band;
+                        continue;
+                }
+
+                l_nb_code_blocks = l_prc->cw * l_prc->ch;
+                l_cblk = l_prc->cblks.dec;
+
+                for (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno) {
+                        opj_tcd_seg_t *l_seg = 00;
+
+                        if (!l_cblk->numnewpasses) {
+                                /* nothing to do */
+                                ++l_cblk;
+                                continue;
+                        }
+
+                        if (!l_cblk->numsegs) {
+                                l_seg = l_cblk->segs;
+                                ++l_cblk->numsegs;
+                                l_cblk->data_current_size = 0;
+                        }
+                        else {
+                                l_seg = &l_cblk->segs[l_cblk->numsegs - 1];
+
+                                if (l_seg->numpasses == l_seg->maxpasses) {
+                                        ++l_seg;
+                                        ++l_cblk->numsegs;
+                                }
+                        }
+
+                        do {
+                                if (l_current_data + l_seg->newlen > p_src_data + p_max_length) {
+                                        fprintf(stderr, "read: segment too long (%d) with max (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\n",
+                                                l_seg->newlen, p_max_length, cblkno, p_pi->precno, bandno, p_pi->resno, p_pi->compno);
+                                        return OPJ_FALSE;
+                                }
+
+#ifdef USE_JPWL
+                        /* we need here a j2k handle to verify if making a check to
+                        the validity of cblocks parameters is selected from user (-W) */
+
+                                /* let's check that we are not exceeding */
+                                if ((l_cblk->len + l_seg->newlen) > 8192) {
+                                        opj_event_msg(p_t2->cinfo, EVT_WARNING,
+                                                "JPWL: segment too long (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\n",
+                                                l_seg->newlen, cblkno, p_pi->precno, bandno, p_pi->resno, p_pi->compno);
+                                        if (!JPWL_ASSUME) {
+                                                opj_event_msg(p_t2->cinfo, EVT_ERROR, "JPWL: giving up\n");
+                                                return OPJ_FALSE;
+                                        }
+                                        l_seg->newlen = 8192 - l_cblk->len;
+                                        opj_event_msg(p_t2->cinfo, EVT_WARNING, "      - truncating segment to %d\n", l_seg->newlen);
+                                        break;
+                                };
+
+#endif /* USE_JPWL */
+                                /* Check if the cblk->data have allocated enough memory */
+                                if ((l_cblk->data_current_size + l_seg->newlen) > l_cblk->data_max_size) {
+                                    OPJ_BYTE* new_cblk_data = (OPJ_BYTE*) opj_realloc(l_cblk->data, l_cblk->data_current_size + l_seg->newlen);
+                                    if(! new_cblk_data) {
+                                        opj_free(l_cblk->data);
+                                        l_cblk->data_max_size = 0;
+                                        /* opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to realloc code block cata!\n"); */
+                                        return OPJ_FALSE;
+                                    }
+                                    l_cblk->data_max_size = l_cblk->data_current_size + l_seg->newlen;
+                                    l_cblk->data = new_cblk_data;
+                                }
+                               
+                                memcpy(l_cblk->data + l_cblk->data_current_size, l_current_data, l_seg->newlen);
+
+                                if (l_seg->numpasses == 0) {
+                                        l_seg->data = &l_cblk->data;
+                                        l_seg->dataindex = l_cblk->data_current_size;
+                                }
+
+                                l_current_data += l_seg->newlen;
+                                l_seg->numpasses += l_seg->numnewpasses;
+                                l_cblk->numnewpasses -= l_seg->numnewpasses;
+
+                                l_seg->real_num_passes = l_seg->numpasses;
+                                l_cblk->data_current_size += l_seg->newlen;
+                                l_seg->len += l_seg->newlen;
+
+                                if (l_cblk->numnewpasses > 0) {
+                                        ++l_seg;
+                                        ++l_cblk->numsegs;
+                                }
+                        } while (l_cblk->numnewpasses > 0);
+
+                        l_cblk->real_num_segs = l_cblk->numsegs;
+                        ++l_cblk;
+                } /* next code_block */
+
+                ++l_band;
+        }
+
+        *(p_data_read) = (OPJ_UINT32)(l_current_data - p_src_data);
+
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_t2_skip_packet_data(   opj_t2_t* p_t2,
+                                    opj_tcd_tile_t *p_tile,
+                                    opj_pi_iterator_t *p_pi,
+                                    OPJ_UINT32 * p_data_read,
+                                    OPJ_UINT32 p_max_length,
+                                    opj_packet_info_t *pack_info)
+{
+        OPJ_UINT32 bandno, cblkno;
+        OPJ_UINT32 l_nb_code_blocks;
+        opj_tcd_band_t *l_band = 00;
+        opj_tcd_cblk_dec_t* l_cblk = 00;
+        opj_tcd_resolution_t* l_res = &p_tile->comps[p_pi->compno].resolutions[p_pi->resno];
+
+        OPJ_ARG_NOT_USED(p_t2);
+        OPJ_ARG_NOT_USED(pack_info);
+
+        *p_data_read = 0;
+        l_band = l_res->bands;
+
+        for (bandno = 0; bandno < l_res->numbands; ++bandno) {
+                opj_tcd_precinct_t *l_prc = &l_band->precincts[p_pi->precno];
+
+                if ((l_band->x1-l_band->x0 == 0)||(l_band->y1-l_band->y0 == 0)) {
+                        ++l_band;
+                        continue;
+                }
+
+                l_nb_code_blocks = l_prc->cw * l_prc->ch;
+                l_cblk = l_prc->cblks.dec;
+
+                for (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno) {
+                        opj_tcd_seg_t *l_seg = 00;
+
+                        if (!l_cblk->numnewpasses) {
+                                /* nothing to do */
+                                ++l_cblk;
+                                continue;
+                        }
+
+                        if (!l_cblk->numsegs) {
+                                l_seg = l_cblk->segs;
+                                ++l_cblk->numsegs;
+                                l_cblk->data_current_size = 0;
+                        }
+                        else {
+                                l_seg = &l_cblk->segs[l_cblk->numsegs - 1];
+
+                                if (l_seg->numpasses == l_seg->maxpasses) {
+                                        ++l_seg;
+                                        ++l_cblk->numsegs;
+                                }
+                        }
+
+                        do {
+                                if (* p_data_read + l_seg->newlen > p_max_length) {
+                                        fprintf(stderr, "skip: segment too long (%d) with max (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\n",
+                                                l_seg->newlen, p_max_length, cblkno, p_pi->precno, bandno, p_pi->resno, p_pi->compno);
+                                        return OPJ_FALSE;
+                                }
+
+#ifdef USE_JPWL
+                        /* we need here a j2k handle to verify if making a check to
+                        the validity of cblocks parameters is selected from user (-W) */
+
+                                /* let's check that we are not exceeding */
+                                if ((l_cblk->len + l_seg->newlen) > 8192) {
+                                        opj_event_msg(p_t2->cinfo, EVT_WARNING,
+                                                "JPWL: segment too long (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\n",
+                                                l_seg->newlen, cblkno, p_pi->precno, bandno, p_pi->resno, p_pi->compno);
+                                        if (!JPWL_ASSUME) {
+                                                opj_event_msg(p_t2->cinfo, EVT_ERROR, "JPWL: giving up\n");
+                                                return -999;
+                                        }
+                                        l_seg->newlen = 8192 - l_cblk->len;
+                                        opj_event_msg(p_t2->cinfo, EVT_WARNING, "      - truncating segment to %d\n", l_seg->newlen);
+                                        break;
+                                };
+
+#endif /* USE_JPWL */
+                                        JAS_FPRINTF(stderr, "p_data_read (%d) newlen (%d) \n", *p_data_read, l_seg->newlen );
+                                *(p_data_read) += l_seg->newlen;
+
+                                l_seg->numpasses += l_seg->numnewpasses;
+                                l_cblk->numnewpasses -= l_seg->numnewpasses;
+                                if (l_cblk->numnewpasses > 0)
+                                {
+                                        ++l_seg;
+                                        ++l_cblk->numsegs;
+                                }
+                        } while (l_cblk->numnewpasses > 0);
+
+                        ++l_cblk;
+                }
+
+                ++l_band;
+        }
+
+        return OPJ_TRUE;
+}
+
+
+OPJ_BOOL opj_t2_init_seg(   opj_tcd_cblk_dec_t* cblk,
+                            OPJ_UINT32 index, 
+                            OPJ_UINT32 cblksty, 
+                            OPJ_UINT32 first)
+{
+        opj_tcd_seg_t* seg = 00;
+        OPJ_UINT32 l_nb_segs = index + 1;
+
+        if (l_nb_segs > cblk->m_current_max_segs) {
+                opj_tcd_seg_t* new_segs;
+                cblk->m_current_max_segs += OPJ_J2K_DEFAULT_NB_SEGS;
+
+                new_segs = (opj_tcd_seg_t*) opj_realloc(cblk->segs, cblk->m_current_max_segs * sizeof(opj_tcd_seg_t));
+                if(! new_segs) {
+                        opj_free(cblk->segs);
+                        cblk->segs = NULL;
+                        cblk->m_current_max_segs = 0;
+                        /* opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to initialize segment %d\n", l_nb_segs); */
+                        return OPJ_FALSE;
+                }
+                cblk->segs = new_segs;
+        }
+
+        seg = &cblk->segs[index];
+        memset(seg,0,sizeof(opj_tcd_seg_t));
+
+        if (cblksty & J2K_CCP_CBLKSTY_TERMALL) {
+                seg->maxpasses = 1;
+        }
+        else if (cblksty & J2K_CCP_CBLKSTY_LAZY) {
+                if (first) {
+                        seg->maxpasses = 10;
+                } else {
+                        seg->maxpasses = (((seg - 1)->maxpasses == 1) || ((seg - 1)->maxpasses == 10)) ? 2 : 1;
+                }
+        } else {
+                seg->maxpasses = 109;
+        }
+
+        return OPJ_TRUE;
+}
diff --git a/extern/libopenjpeg/t2.h b/extern/libopenjpeg/t2.h
index 2151ba6..931141e 100644
--- a/extern/libopenjpeg/t2.h
+++ b/extern/libopenjpeg/t2.h
@@ -1,10 +1,18 @@
 /*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2001-2003, David Janssens
  * Copyright (c) 2002-2003, Yannick Verschueren
- * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * Copyright (c) 2003-2014, Antonin Descampe
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR 
+ * Copyright (c) 2012, CS Systemes d'Information, France
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -43,8 +51,6 @@
 Tier-2 coding
 */
 typedef struct opj_t2 {
-	/** codec context */
-	opj_common_ptr cinfo;
 
 	/** Encoding: pointer to the src image. Decoding: pointer to the dst image. */
 	opj_image_t *image;
@@ -58,44 +64,66 @@ typedef struct opj_t2 {
 
 /**
 Encode the packets of a tile to a destination buffer
-@param t2 T2 handle
-@param tileno number of the tile encoded
-@param tile the tile for which to write the packets
-@param maxlayers maximum number of layers
-@param dest the destination buffer
-@param len the length of the destination buffer
-@param cstr_info Codestream information structure 
-@param tpnum Tile part number of the current tile
-@param tppos The position of the tile part flag in the progression order
-@param pino 
-@param t2_mode If == 0 In Threshold calculation ,If == 1 Final pass
-@param cur_totnum_tp The total number of tile parts in the current tile
+@param t2               T2 handle
+@param tileno           number of the tile encoded
+@param tile             the tile for which to write the packets
+@param maxlayers        maximum number of layers
+@param dest             the destination buffer
+@param p_data_written   FIXME DOC
+@param len              the length of the destination buffer
+@param cstr_info        Codestream information structure
+@param tpnum            Tile part number of the current tile
+@param tppos            The position of the tile part flag in the progression order
+@param pino             FIXME DOC
+@param t2_mode          If == 0 In Threshold calculation ,If == 1 Final pass
 */
-int t2_encode_packets(opj_t2_t* t2,int tileno, opj_tcd_tile_t *tile, int maxlayers, unsigned char *dest, int len, opj_codestream_info_t *cstr_info,int tpnum, int tppos,int pino,J2K_T2_MODE t2_mode,int cur_totnum_tp);
+OPJ_BOOL opj_t2_encode_packets(	opj_t2_t* t2,
+								OPJ_UINT32 tileno,
+								opj_tcd_tile_t *tile,
+								OPJ_UINT32 maxlayers,
+								OPJ_BYTE *dest,
+								OPJ_UINT32 * p_data_written,
+								OPJ_UINT32 len,
+								opj_codestream_info_t *cstr_info,
+								OPJ_UINT32 tpnum,
+								OPJ_INT32 tppos,
+								OPJ_UINT32 pino,
+								J2K_T2_MODE t2_mode);
+
 /**
 Decode the packets of a tile from a source buffer
 @param t2 T2 handle
-@param src the source buffer
-@param len length of the source buffer
 @param tileno number that identifies the tile for which to decode the packets
 @param tile tile for which to decode the packets
-@param cstr_info Codestream information structure
+@param src         FIXME DOC
+@param p_data_read the source buffer
+@param len length of the source buffer
+@param cstr_info   FIXME DOC
+
+@return FIXME DOC
  */
-int t2_decode_packets(opj_t2_t *t2, unsigned char *src, int len, int tileno, opj_tcd_tile_t *tile, opj_codestream_info_t *cstr_info);
+OPJ_BOOL opj_t2_decode_packets(	opj_t2_t *t2,
+                                OPJ_UINT32 tileno,
+                                opj_tcd_tile_t *tile,
+                                OPJ_BYTE *src,
+                                OPJ_UINT32 * p_data_read,
+                                OPJ_UINT32 len,
+                                opj_codestream_index_t *cstr_info);
 
 /**
-Create a T2 handle
-@param cinfo Codec context info
-@param image Source or destination image
-@param cp Image coding parameters
-@return Returns a new T2 handle if successful, returns NULL otherwise
+ * Creates a Tier 2 handle
+ *
+ * @param	p_image		Source or destination image
+ * @param	p_cp		Image coding parameters.
+ * @return		a new T2 handle if successful, NULL otherwise.
 */
-opj_t2_t* t2_create(opj_common_ptr cinfo, opj_image_t *image, opj_cp_t *cp);
+opj_t2_t* opj_t2_create(opj_image_t *p_image, opj_cp_t *p_cp);
+
 /**
 Destroy a T2 handle
 @param t2 T2 handle to destroy
 */
-void t2_destroy(opj_t2_t *t2);
+void opj_t2_destroy(opj_t2_t *t2);
 
 /* ----------------------------------------------------------------------- */
 /*@}*/
diff --git a/extern/libopenjpeg/tcd.c b/extern/libopenjpeg/tcd.c
index 62904eb..79262fc 100644
--- a/extern/libopenjpeg/tcd.c
+++ b/extern/libopenjpeg/tcd.c
@@ -1,11 +1,19 @@
 /*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2001-2003, David Janssens
  * Copyright (c) 2002-2003, Yannick Verschueren
- * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * Copyright (c) 2003-2014, Antonin Descampe
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
  * Copyright (c) 2006-2007, Parvatha Elangovan
+ * Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR 
+ * Copyright (c) 2012, CS Systemes d'Information, France
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -30,1572 +38,2092 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#define _ISOC99_SOURCE /* lrintf is C99 */
 #include "opj_includes.h"
-#include <assert.h>
 
+/* ----------------------------------------------------------------------- */
+
+/* TODO MSD: */
+#ifdef TODO_MSD 
 void tcd_dump(FILE *fd, opj_tcd_t *tcd, opj_tcd_image_t * img) {
-	int tileno, compno, resno, bandno, precno;/*, cblkno;*/
-
-	fprintf(fd, "image {\n");
-	fprintf(fd, "  tw=%d, th=%d x0=%d x1=%d y0=%d y1=%d\n", 
-		img->tw, img->th, tcd->image->x0, tcd->image->x1, tcd->image->y0, tcd->image->y1);
-
-	for (tileno = 0; tileno < img->th * img->tw; tileno++) {
-		opj_tcd_tile_t *tile = &tcd->tcd_image->tiles[tileno];
-		fprintf(fd, "  tile {\n");
-		fprintf(fd, "    x0=%d, y0=%d, x1=%d, y1=%d, numcomps=%d\n",
-			tile->x0, tile->y0, tile->x1, tile->y1, tile->numcomps);
-		for (compno = 0; compno < tile->numcomps; compno++) {
-			opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
-			fprintf(fd, "    tilec {\n");
-			fprintf(fd,
-				"      x0=%d, y0=%d, x1=%d, y1=%d, numresolutions=%d\n",
-				tilec->x0, tilec->y0, tilec->x1, tilec->y1, tilec->numresolutions);
-			for (resno = 0; resno < tilec->numresolutions; resno++) {
-				opj_tcd_resolution_t *res = &tilec->resolutions[resno];
-				fprintf(fd, "\n   res {\n");
-				fprintf(fd,
-					"          x0=%d, y0=%d, x1=%d, y1=%d, pw=%d, ph=%d, numbands=%d\n",
-					res->x0, res->y0, res->x1, res->y1, res->pw, res->ph, res->numbands);
-				for (bandno = 0; bandno < res->numbands; bandno++) {
-					opj_tcd_band_t *band = &res->bands[bandno];
-					fprintf(fd, "        band {\n");
-					fprintf(fd,
-						"          x0=%d, y0=%d, x1=%d, y1=%d, stepsize=%f, numbps=%d\n",
-						band->x0, band->y0, band->x1, band->y1, band->stepsize, band->numbps);
-					for (precno = 0; precno < res->pw * res->ph; precno++) {
-						opj_tcd_precinct_t *prec = &band->precincts[precno];
-						fprintf(fd, "          prec {\n");
-						fprintf(fd,
-							"            x0=%d, y0=%d, x1=%d, y1=%d, cw=%d, ch=%d\n",
-							prec->x0, prec->y0, prec->x1, prec->y1, prec->cw, prec->ch);
-						/*
-						for (cblkno = 0; cblkno < prec->cw * prec->ch; cblkno++) {
-							opj_tcd_cblk_t *cblk = &prec->cblks[cblkno];
-							fprintf(fd, "            cblk {\n");
-							fprintf(fd,
-								"              x0=%d, y0=%d, x1=%d, y1=%d\n",
-								cblk->x0, cblk->y0, cblk->x1, cblk->y1);
-							fprintf(fd, "            }\n");
-						}
-						*/
-						fprintf(fd, "          }\n");
-					}
-					fprintf(fd, "        }\n");
-				}
-				fprintf(fd, "      }\n");
-			}
-			fprintf(fd, "    }\n");
-		}
-		fprintf(fd, "  }\n");
-	}
-	fprintf(fd, "}\n");
+        int tileno, compno, resno, bandno, precno;/*, cblkno;*/
+
+        fprintf(fd, "image {\n");
+        fprintf(fd, "  tw=%d, th=%d x0=%d x1=%d y0=%d y1=%d\n", 
+                img->tw, img->th, tcd->image->x0, tcd->image->x1, tcd->image->y0, tcd->image->y1);
+
+        for (tileno = 0; tileno < img->th * img->tw; tileno++) {
+                opj_tcd_tile_t *tile = &tcd->tcd_image->tiles[tileno];
+                fprintf(fd, "  tile {\n");
+                fprintf(fd, "    x0=%d, y0=%d, x1=%d, y1=%d, numcomps=%d\n",
+                        tile->x0, tile->y0, tile->x1, tile->y1, tile->numcomps);
+                for (compno = 0; compno < tile->numcomps; compno++) {
+                        opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+                        fprintf(fd, "    tilec {\n");
+                        fprintf(fd,
+                                "      x0=%d, y0=%d, x1=%d, y1=%d, numresolutions=%d\n",
+                                tilec->x0, tilec->y0, tilec->x1, tilec->y1, tilec->numresolutions);
+                        for (resno = 0; resno < tilec->numresolutions; resno++) {
+                                opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+                                fprintf(fd, "\n   res {\n");
+                                fprintf(fd,
+                                        "          x0=%d, y0=%d, x1=%d, y1=%d, pw=%d, ph=%d, numbands=%d\n",
+                                        res->x0, res->y0, res->x1, res->y1, res->pw, res->ph, res->numbands);
+                                for (bandno = 0; bandno < res->numbands; bandno++) {
+                                        opj_tcd_band_t *band = &res->bands[bandno];
+                                        fprintf(fd, "        band {\n");
+                                        fprintf(fd,
+                                                "          x0=%d, y0=%d, x1=%d, y1=%d, stepsize=%f, numbps=%d\n",
+                                                band->x0, band->y0, band->x1, band->y1, band->stepsize, band->numbps);
+                                        for (precno = 0; precno < res->pw * res->ph; precno++) {
+                                                opj_tcd_precinct_t *prec = &band->precincts[precno];
+                                                fprintf(fd, "          prec {\n");
+                                                fprintf(fd,
+                                                        "            x0=%d, y0=%d, x1=%d, y1=%d, cw=%d, ch=%d\n",
+                                                        prec->x0, prec->y0, prec->x1, prec->y1, prec->cw, prec->ch);
+                                                /*
+                                                for (cblkno = 0; cblkno < prec->cw * prec->ch; cblkno++) {
+                                                        opj_tcd_cblk_t *cblk = &prec->cblks[cblkno];
+                                                        fprintf(fd, "            cblk {\n");
+                                                        fprintf(fd,
+                                                                "              x0=%d, y0=%d, x1=%d, y1=%d\n",
+                                                                cblk->x0, cblk->y0, cblk->x1, cblk->y1);
+                                                        fprintf(fd, "            }\n");
+                                                }
+                                                */
+                                                fprintf(fd, "          }\n");
+                                        }
+                                        fprintf(fd, "        }\n");
+                                }
+                                fprintf(fd, "      }\n");
+                        }
+                        fprintf(fd, "    }\n");
+                }
+                fprintf(fd, "  }\n");
+        }
+        fprintf(fd, "}\n");
 }
+#endif
+/**
+* Allocates memory for a decoding code block.
+*/
+static OPJ_BOOL opj_tcd_code_block_dec_allocate (opj_tcd_cblk_dec_t * p_code_block);
+
+/**
+ * Deallocates the decoding data of the given precinct.
+ */
+static void opj_tcd_code_block_dec_deallocate (opj_tcd_precinct_t * p_precinct);
+
+/**
+ * Allocates memory for an encoding code block.
+ */
+static OPJ_BOOL opj_tcd_code_block_enc_allocate (opj_tcd_cblk_enc_t * p_code_block);
+
+/**
+ * Deallocates the encoding data of the given precinct.
+ */
+static void opj_tcd_code_block_enc_deallocate (opj_tcd_precinct_t * p_precinct);
+
+
+/**
+Free the memory allocated for encoding
+@param tcd TCD handle
+*/
+static void opj_tcd_free_tile(opj_tcd_t *tcd);
+
+
+static OPJ_BOOL opj_tcd_t2_decode ( opj_tcd_t *p_tcd,
+                                    OPJ_BYTE * p_src_data,
+                                    OPJ_UINT32 * p_data_read,
+                                    OPJ_UINT32 p_max_src_size,
+                                    opj_codestream_index_t *p_cstr_index );
+
+static OPJ_BOOL opj_tcd_t1_decode (opj_tcd_t *p_tcd);
+
+static OPJ_BOOL opj_tcd_dwt_decode (opj_tcd_t *p_tcd);
+
+static OPJ_BOOL opj_tcd_mct_decode (opj_tcd_t *p_tcd);
+
+static OPJ_BOOL opj_tcd_dc_level_shift_decode (opj_tcd_t *p_tcd);
+
+
+static OPJ_BOOL opj_tcd_dc_level_shift_encode ( opj_tcd_t *p_tcd );
+
+static OPJ_BOOL opj_tcd_mct_encode ( opj_tcd_t *p_tcd );
+
+static OPJ_BOOL opj_tcd_dwt_encode ( opj_tcd_t *p_tcd );
+
+static OPJ_BOOL opj_tcd_t1_encode ( opj_tcd_t *p_tcd );
+
+static OPJ_BOOL opj_tcd_t2_encode (     opj_tcd_t *p_tcd,
+                                                                    OPJ_BYTE * p_dest_data,
+                                                                    OPJ_UINT32 * p_data_written,
+                                                                    OPJ_UINT32 p_max_dest_size,
+                                                                    opj_codestream_info_t *p_cstr_info );
+
+static OPJ_BOOL opj_tcd_rate_allocate_encode(   opj_tcd_t *p_tcd,
+                                                                                        OPJ_BYTE * p_dest_data,
+                                                                                        OPJ_UINT32 p_max_dest_size,
+                                                                                        opj_codestream_info_t *p_cstr_info );
 
 /* ----------------------------------------------------------------------- */
 
 /**
 Create a new TCD handle
 */
-opj_tcd_t* tcd_create(opj_common_ptr cinfo) {
-	/* create the tcd structure */
-	opj_tcd_t *tcd = (opj_tcd_t*)opj_malloc(sizeof(opj_tcd_t));
-	if(!tcd) return NULL;
-	tcd->cinfo = cinfo;
-	tcd->tcd_image = (opj_tcd_image_t*)opj_malloc(sizeof(opj_tcd_image_t));
-	if(!tcd->tcd_image) {
-		opj_free(tcd);
-		return NULL;
-	}
-
-	return tcd;
+opj_tcd_t* opj_tcd_create(OPJ_BOOL p_is_decoder)
+{
+        opj_tcd_t *l_tcd = 00;
+
+        /* create the tcd structure */
+        l_tcd = (opj_tcd_t*) opj_malloc(sizeof(opj_tcd_t));
+        if (!l_tcd) {
+                return 00;
+        }
+        memset(l_tcd,0,sizeof(opj_tcd_t));
+
+        l_tcd->m_is_decoder = p_is_decoder ? 1 : 0;
+
+        l_tcd->tcd_image = (opj_tcd_image_t*)opj_malloc(sizeof(opj_tcd_image_t));
+        if (!l_tcd->tcd_image) {
+                opj_free(l_tcd);
+                return 00;
+        }
+        memset(l_tcd->tcd_image,0,sizeof(opj_tcd_image_t));
+
+        return l_tcd;
+}
+
+
+/* ----------------------------------------------------------------------- */
+
+void opj_tcd_rateallocate_fixed(opj_tcd_t *tcd) {
+        OPJ_UINT32 layno;
+
+        for (layno = 0; layno < tcd->tcp->numlayers; layno++) {
+                opj_tcd_makelayer_fixed(tcd, layno, 1);
+        }
+}
+
+
+void opj_tcd_makelayer( opj_tcd_t *tcd,
+                                                OPJ_UINT32 layno,
+                                                OPJ_FLOAT64 thresh,
+                                                OPJ_UINT32 final)
+{
+        OPJ_UINT32 compno, resno, bandno, precno, cblkno;
+        OPJ_UINT32 passno;
+
+        opj_tcd_tile_t *tcd_tile = tcd->tcd_image->tiles;
+
+        tcd_tile->distolayer[layno] = 0;        /* fixed_quality */
+
+        for (compno = 0; compno < tcd_tile->numcomps; compno++) {
+                opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];
+
+                for (resno = 0; resno < tilec->numresolutions; resno++) {
+                        opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+
+                        for (bandno = 0; bandno < res->numbands; bandno++) {
+                                opj_tcd_band_t *band = &res->bands[bandno];
+
+                                for (precno = 0; precno < res->pw * res->ph; precno++) {
+                                        opj_tcd_precinct_t *prc = &band->precincts[precno];
+
+                                        for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+                                                opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];
+                                                opj_tcd_layer_t *layer = &cblk->layers[layno];
+                                                OPJ_UINT32 n;
+
+                                                if (layno == 0) {
+                                                        cblk->numpassesinlayers = 0;
+                                                }
+
+                                                n = cblk->numpassesinlayers;
+
+                                                for (passno = cblk->numpassesinlayers; passno < cblk->totalpasses; passno++) {
+                                                        OPJ_UINT32 dr;
+                                                        OPJ_FLOAT64 dd;
+                                                        opj_tcd_pass_t *pass = &cblk->passes[passno];
+
+                                                        if (n == 0) {
+                                                                dr = pass->rate;
+                                                                dd = pass->distortiondec;
+                                                        } else {
+                                                                dr = pass->rate - cblk->passes[n - 1].rate;
+                                                                dd = pass->distortiondec - cblk->passes[n - 1].distortiondec;
+                                                        }
+
+                                                        if (!dr) {
+                                                                if (dd != 0)
+                                                                        n = passno + 1;
+                                                                continue;
+                                                        }
+                                                        if (dd / dr >= thresh)
+                                                                n = passno + 1;
+                                                }
+
+                                                layer->numpasses = n - cblk->numpassesinlayers;
+
+                                                if (!layer->numpasses) {
+                                                        layer->disto = 0;
+                                                        continue;
+                                                }
+
+                                                if (cblk->numpassesinlayers == 0) {
+                                                        layer->len = cblk->passes[n - 1].rate;
+                                                        layer->data = cblk->data;
+                                                        layer->disto = cblk->passes[n - 1].distortiondec;
+                                                } else {
+                                                        layer->len = cblk->passes[n - 1].rate - cblk->passes[cblk->numpassesinlayers - 1].rate;
+                                                        layer->data = cblk->data + cblk->passes[cblk->numpassesinlayers - 1].rate;
+                                                        layer->disto = cblk->passes[n - 1].distortiondec - cblk->passes[cblk->numpassesinlayers - 1].distortiondec;
+                                                }
+
+                                                tcd_tile->distolayer[layno] += layer->disto;    /* fixed_quality */
+
+                                                if (final)
+                                                        cblk->numpassesinlayers = n;
+                                        }
+                                }
+                        }
+                }
+        }
+}
+
+void opj_tcd_makelayer_fixed(opj_tcd_t *tcd, OPJ_UINT32 layno, OPJ_UINT32 final) {
+        OPJ_UINT32 compno, resno, bandno, precno, cblkno;
+        OPJ_INT32 value;                        /*, matrice[tcd_tcp->numlayers][tcd_tile->comps[0].numresolutions][3]; */
+        OPJ_INT32 matrice[10][10][3];
+        OPJ_UINT32 i, j, k;
+
+        opj_cp_t *cp = tcd->cp;
+        opj_tcd_tile_t *tcd_tile = tcd->tcd_image->tiles;
+        opj_tcp_t *tcd_tcp = tcd->tcp;
+
+        for (compno = 0; compno < tcd_tile->numcomps; compno++) {
+                opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];
+
+                for (i = 0; i < tcd_tcp->numlayers; i++) {
+                        for (j = 0; j < tilec->numresolutions; j++) {
+                                for (k = 0; k < 3; k++) {
+                                        matrice[i][j][k] =
+                                                (OPJ_INT32) ((OPJ_FLOAT32)cp->m_specific_param.m_enc.m_matrice[i * tilec->numresolutions * 3 + j * 3 + k]
+                                                * (OPJ_FLOAT32) (tcd->image->comps[compno].prec / 16.0));
+                                }
+                        }
+                }
+
+                for (resno = 0; resno < tilec->numresolutions; resno++) {
+                        opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+
+                        for (bandno = 0; bandno < res->numbands; bandno++) {
+                                opj_tcd_band_t *band = &res->bands[bandno];
+
+                                for (precno = 0; precno < res->pw * res->ph; precno++) {
+                                        opj_tcd_precinct_t *prc = &band->precincts[precno];
+
+                                        for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+                                                opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];
+                                                opj_tcd_layer_t *layer = &cblk->layers[layno];
+                                                OPJ_UINT32 n;
+                                                OPJ_INT32 imsb = (OPJ_INT32)(tcd->image->comps[compno].prec - cblk->numbps); /* number of bit-plan equal to zero */
+
+                                                /* Correction of the matrix of coefficient to include the IMSB information */
+                                                if (layno == 0) {
+                                                        value = matrice[layno][resno][bandno];
+                                                        if (imsb >= value) {
+                                                                value = 0;
+                                                        } else {
+                                                                value -= imsb;
+                                                        }
+                                                } else {
+                                                        value = matrice[layno][resno][bandno] - matrice[layno - 1][resno][bandno];
+                                                        if (imsb >= matrice[layno - 1][resno][bandno]) {
+                                                                value -= (imsb - matrice[layno - 1][resno][bandno]);
+                                                                if (value < 0) {
+                                                                        value = 0;
+                                                                }
+                                                        }
+                                                }
+
+                                                if (layno == 0) {
+                                                        cblk->numpassesinlayers = 0;
+                                                }
+
+                                                n = cblk->numpassesinlayers;
+                                                if (cblk->numpassesinlayers == 0) {
+                                                        if (value != 0) {
+                                                                n = 3 * (OPJ_UINT32)value - 2 + cblk->numpassesinlayers;
+                                                        } else {
+                                                                n = cblk->numpassesinlayers;
+                                                        }
+                                                } else {
+                                                        n = 3 * (OPJ_UINT32)value + cblk->numpassesinlayers;
+                                                }
+
+                                                layer->numpasses = n - cblk->numpassesinlayers;
+
+                                                if (!layer->numpasses)
+                                                        continue;
+
+                                                if (cblk->numpassesinlayers == 0) {
+                                                        layer->len = cblk->passes[n - 1].rate;
+                                                        layer->data = cblk->data;
+                                                } else {
+                                                        layer->len = cblk->passes[n - 1].rate - cblk->passes[cblk->numpassesinlayers - 1].rate;
+                                                        layer->data = cblk->data + cblk->passes[cblk->numpassesinlayers - 1].rate;
+                                                }
+
+                                                if (final)
+                                                        cblk->numpassesinlayers = n;
+                                        }
+                                }
+                        }
+                }
+        }
+}
+
+OPJ_BOOL opj_tcd_rateallocate(  opj_tcd_t *tcd,
+                                                                OPJ_BYTE *dest,
+                                                                OPJ_UINT32 * p_data_written,
+                                                                OPJ_UINT32 len,
+                                                                opj_codestream_info_t *cstr_info)
+{
+        OPJ_UINT32 compno, resno, bandno, precno, cblkno, layno;
+        OPJ_UINT32 passno;
+        OPJ_FLOAT64 min, max;
+        OPJ_FLOAT64 cumdisto[100];      /* fixed_quality */
+        const OPJ_FLOAT64 K = 1;                /* 1.1; fixed_quality */
+        OPJ_FLOAT64 maxSE = 0;
+
+        opj_cp_t *cp = tcd->cp;
+        opj_tcd_tile_t *tcd_tile = tcd->tcd_image->tiles;
+        opj_tcp_t *tcd_tcp = tcd->tcp;
+
+        min = DBL_MAX;
+        max = 0;
+
+        tcd_tile->numpix = 0;           /* fixed_quality */
+
+        for (compno = 0; compno < tcd_tile->numcomps; compno++) {
+                opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];
+                tilec->numpix = 0;
+
+                for (resno = 0; resno < tilec->numresolutions; resno++) {
+                        opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+
+                        for (bandno = 0; bandno < res->numbands; bandno++) {
+                                opj_tcd_band_t *band = &res->bands[bandno];
+
+                                for (precno = 0; precno < res->pw * res->ph; precno++) {
+                                        opj_tcd_precinct_t *prc = &band->precincts[precno];
+
+                                        for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+                                                opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];
+
+                                                for (passno = 0; passno < cblk->totalpasses; passno++) {
+                                                        opj_tcd_pass_t *pass = &cblk->passes[passno];
+                                                        OPJ_INT32 dr;
+                                                        OPJ_FLOAT64 dd, rdslope;
+
+                                                        if (passno == 0) {
+                                                                dr = (OPJ_INT32)pass->rate;
+                                                                dd = pass->distortiondec;
+                                                        } else {
+                                                                dr = (OPJ_INT32)(pass->rate - cblk->passes[passno - 1].rate);
+                                                                dd = pass->distortiondec - cblk->passes[passno - 1].distortiondec;
+                                                        }
+
+                                                        if (dr == 0) {
+                                                                continue;
+                                                        }
+
+                                                        rdslope = dd / dr;
+                                                        if (rdslope < min) {
+                                                                min = rdslope;
+                                                        }
+
+                                                        if (rdslope > max) {
+                                                                max = rdslope;
+                                                        }
+                                                } /* passno */
+
+                                                /* fixed_quality */
+                                                tcd_tile->numpix += ((cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0));
+                                                tilec->numpix += ((cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0));
+                                        } /* cbklno */
+                                } /* precno */
+                        } /* bandno */
+                } /* resno */
+
+                maxSE += (((OPJ_FLOAT64)(1 << tcd->image->comps[compno].prec) - 1.0)
+                        * ((OPJ_FLOAT64)(1 << tcd->image->comps[compno].prec) -1.0))
+                        * ((OPJ_FLOAT64)(tilec->numpix));
+        } /* compno */
+
+        /* index file */
+        if(cstr_info) {
+                opj_tile_info_t *tile_info = &cstr_info->tile[tcd->tcd_tileno];
+                tile_info->numpix = tcd_tile->numpix;
+                tile_info->distotile = tcd_tile->distotile;
+                tile_info->thresh = (OPJ_FLOAT64 *) opj_malloc(tcd_tcp->numlayers * sizeof(OPJ_FLOAT64));
+        }
+
+        for (layno = 0; layno < tcd_tcp->numlayers; layno++) {
+                OPJ_FLOAT64 lo = min;
+                OPJ_FLOAT64 hi = max;
+                OPJ_BOOL success = OPJ_FALSE;
+                OPJ_UINT32 maxlen = tcd_tcp->rates[layno] ? opj_uint_min(((OPJ_UINT32) ceil(tcd_tcp->rates[layno])), len) : len;
+                OPJ_FLOAT64 goodthresh = 0;
+                OPJ_FLOAT64 stable_thresh = 0;
+                OPJ_UINT32 i;
+                OPJ_FLOAT64 distotarget;                /* fixed_quality */
+
+                /* fixed_quality */
+                distotarget = tcd_tile->distotile - ((K * maxSE) / pow((OPJ_FLOAT32)10, tcd_tcp->distoratio[layno] / 10));
+
+                /* Don't try to find an optimal threshold but rather take everything not included yet, if
+                  -r xx,yy,zz,0   (disto_alloc == 1 and rates == 0)
+                  -q xx,yy,zz,0   (fixed_quality == 1 and distoratio == 0)
+                  ==> possible to have some lossy layers and the last layer for sure lossless */
+                if ( ((cp->m_specific_param.m_enc.m_disto_alloc==1) && (tcd_tcp->rates[layno]>0)) || ((cp->m_specific_param.m_enc.m_fixed_quality==1) && (tcd_tcp->distoratio[layno]>0))) {
+                        opj_t2_t*t2 = opj_t2_create(tcd->image, cp);
+                        OPJ_FLOAT64 thresh = 0;
+
+                        if (t2 == 00) {
+                                return OPJ_FALSE;
+                        }
+
+                        for     (i = 0; i < 128; ++i) {
+                                OPJ_FLOAT64 distoachieved = 0;  /* fixed_quality */
+
+                                thresh = (lo + hi) / 2;
+
+                                opj_tcd_makelayer(tcd, layno, thresh, 0);
+
+                                if (cp->m_specific_param.m_enc.m_fixed_quality) {       /* fixed_quality */
+                                        if(OPJ_IS_CINEMA(cp->rsiz)){
+                                                if (! opj_t2_encode_packets(t2,tcd->tcd_tileno, tcd_tile, layno + 1, dest, p_data_written, maxlen, cstr_info,tcd->cur_tp_num,tcd->tp_pos,tcd->cur_pino,THRESH_CALC)) {
+
+                                                        lo = thresh;
+                                                        continue;
+                                                }
+                                                else {
+                                                        distoachieved = layno == 0 ?
+                                                                        tcd_tile->distolayer[0] : cumdisto[layno - 1] + tcd_tile->distolayer[layno];
+
+                                                        if (distoachieved < distotarget) {
+                                                                hi=thresh;
+                                                                stable_thresh = thresh;
+                                                                continue;
+                                                        }else{
+                                                                lo=thresh;
+                                                        }
+                                                }
+                                        }else{
+                                                distoachieved = (layno == 0) ?
+                                                                tcd_tile->distolayer[0] : (cumdisto[layno - 1] + tcd_tile->distolayer[layno]);
+
+                                                if (distoachieved < distotarget) {
+                                                        hi = thresh;
+                                                        stable_thresh = thresh;
+                                                        continue;
+                                                }
+                                                lo = thresh;
+                                        }
+                                } else {
+                                        if (! opj_t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1, dest,p_data_written, maxlen, cstr_info,tcd->cur_tp_num,tcd->tp_pos,tcd->cur_pino,THRESH_CALC))
+                                        {
+                                                /* TODO: what to do with l ??? seek / tell ??? */
+                                                /* opj_event_msg(tcd->cinfo, EVT_INFO, "rate alloc: len=%d, max=%d\n", l, maxlen); */
+                                                lo = thresh;
+                                                continue;
+                                        }
+
+                                        hi = thresh;
+                                        stable_thresh = thresh;
+                                }
+                        }
+
+                        success = OPJ_TRUE;
+                        goodthresh = stable_thresh == 0? thresh : stable_thresh;
+
+                        opj_t2_destroy(t2);
+                } else {
+                        success = OPJ_TRUE;
+                        goodthresh = min;
+                }
+
+                if (!success) {
+                        return OPJ_FALSE;
+                }
+
+                if(cstr_info) { /* Threshold for Marcela Index */
+                        cstr_info->tile[tcd->tcd_tileno].thresh[layno] = goodthresh;
+                }
+
+                opj_tcd_makelayer(tcd, layno, goodthresh, 1);
+
+                /* fixed_quality */
+                cumdisto[layno] = (layno == 0) ? tcd_tile->distolayer[0] : (cumdisto[layno - 1] + tcd_tile->distolayer[layno]);
+        }
+
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_tcd_init( opj_tcd_t *p_tcd,
+                                           opj_image_t * p_image,
+                                           opj_cp_t * p_cp )
+{
+        OPJ_UINT32 l_tile_comp_size;
+
+        p_tcd->image = p_image;
+        p_tcd->cp = p_cp;
+
+        p_tcd->tcd_image->tiles = (opj_tcd_tile_t *) opj_malloc(sizeof(opj_tcd_tile_t));
+        if (! p_tcd->tcd_image->tiles) {
+                return OPJ_FALSE;
+        }
+        memset(p_tcd->tcd_image->tiles,0, sizeof(opj_tcd_tile_t));
+
+        l_tile_comp_size = p_image->numcomps * (OPJ_UINT32)sizeof(opj_tcd_tilecomp_t);
+        p_tcd->tcd_image->tiles->comps = (opj_tcd_tilecomp_t *) opj_malloc(l_tile_comp_size);
+        if (! p_tcd->tcd_image->tiles->comps ) {
+                return OPJ_FALSE;
+        }
+        memset( p_tcd->tcd_image->tiles->comps , 0 , l_tile_comp_size);
+
+        p_tcd->tcd_image->tiles->numcomps = p_image->numcomps;
+        p_tcd->tp_pos = p_cp->m_specific_param.m_enc.m_tp_pos;
+
+        return OPJ_TRUE;
 }
 
 /**
 Destroy a previously created TCD handle
 */
-void tcd_destroy(opj_tcd_t *tcd) {
-	if(tcd) {
-		opj_free(tcd->tcd_image);
-		opj_free(tcd);
-	}
+void opj_tcd_destroy(opj_tcd_t *tcd) {
+        if (tcd) {
+                opj_tcd_free_tile(tcd);
+
+                if (tcd->tcd_image) {
+                        opj_free(tcd->tcd_image);
+                        tcd->tcd_image = 00;
+                }
+                opj_free(tcd);
+        }
 }
 
 /* ----------------------------------------------------------------------- */
+#define OPJ_MACRO_TCD_ALLOCATE(FUNCTION,TYPE,FRACTION,ELEMENT,FUNCTION_ELEMENT)                                                                                                                                       \
+OPJ_BOOL FUNCTION (     opj_tcd_t *p_tcd,                        \
+                        OPJ_UINT32 p_tile_no                        \
+                        )                                           \
+{                                                                   \
+        OPJ_UINT32 (*l_gain_ptr)(OPJ_UINT32) = 00;                  \
+        OPJ_UINT32 compno, resno, bandno, precno, cblkno;           \
+        opj_tcp_t * l_tcp = 00;                                  \
+        opj_cp_t * l_cp = 00;                                    \
+        opj_tcd_tile_t * l_tile = 00;                            \
+        opj_tccp_t *l_tccp = 00;                                    \
+        opj_tcd_tilecomp_t *l_tilec = 00;                        \
+        opj_image_comp_t * l_image_comp = 00;                       \
+        opj_tcd_resolution_t *l_res = 00;                        \
+        opj_tcd_band_t *l_band = 00;                             \
+        opj_stepsize_t * l_step_size = 00;                          \
+        opj_tcd_precinct_t *l_current_precinct = 00;             \
+        TYPE* l_code_block = 00;                                    \
+        opj_image_t *l_image = 00;                                  \
+        OPJ_UINT32 p,q;                                             \
+        OPJ_UINT32 l_level_no;                                      \
+        OPJ_UINT32 l_pdx, l_pdy;                                    \
+        OPJ_UINT32 l_gain;                                          \
+        OPJ_INT32 l_x0b, l_y0b;                                     \
+        /* extent of precincts , top left, bottom right**/          \
+        OPJ_INT32 l_tl_prc_x_start, l_tl_prc_y_start, l_br_prc_x_end, l_br_prc_y_end;                                                                                                                             \
+        /* number of precinct for a resolution */                   \
+        OPJ_UINT32 l_nb_precincts;                                  \
+        /* room needed to store l_nb_precinct precinct for a resolution */                                                                                                                                        \
+        OPJ_UINT32 l_nb_precinct_size;                              \
+        /* number of code blocks for a precinct*/                   \
+        OPJ_UINT32 l_nb_code_blocks;                                \
+        /* room needed to store l_nb_code_blocks code blocks for a precinct*/                                                                                                                                     \
+        OPJ_UINT32 l_nb_code_blocks_size;                           \
+        /* size of data for a tile */                               \
+        OPJ_UINT32 l_data_size;                                     \
+                                                                    \
+        l_cp = p_tcd->cp;                                           \
+        l_tcp = &(l_cp->tcps[p_tile_no]);                           \
+        l_tile = p_tcd->tcd_image->tiles;                           \
+        l_tccp = l_tcp->tccps;                                      \
+        l_tilec = l_tile->comps;                                    \
+        l_image = p_tcd->image;                                     \
+        l_image_comp = p_tcd->image->comps;                         \
+                                                                    \
+        p = p_tile_no % l_cp->tw;       /* tile coordinates */      \
+        q = p_tile_no / l_cp->tw;                                   \
+        /*fprintf(stderr, "Tile coordinate = %d,%d\n", p, q);*/     \
+                                                                    \
+        /* 4 borders of the tile rescale on the image if necessary */                                                                                                                                             \
+        l_tile->x0 = opj_int_max((OPJ_INT32)(l_cp->tx0 + p * l_cp->tdx), (OPJ_INT32)l_image->x0);                                                                                                                                             \
+        l_tile->y0 = opj_int_max((OPJ_INT32)(l_cp->ty0 + q * l_cp->tdy), (OPJ_INT32)l_image->y0);                                                                                                                                             \
+        l_tile->x1 = opj_int_min((OPJ_INT32)(l_cp->tx0 + (p + 1) * l_cp->tdx), (OPJ_INT32)l_image->x1);                                                                                                                                       \
+        l_tile->y1 = opj_int_min((OPJ_INT32)(l_cp->ty0 + (q + 1) * l_cp->tdy), (OPJ_INT32)l_image->y1);                                                                                                                                       \
+        /* testcase 1888.pdf.asan.35.988 */ \
+        if (l_tccp->numresolutions == 0) { \
+            fprintf(stderr, "tiles require at least one resolution\n"); \
+            return OPJ_FALSE; \
+        } \
+        /*fprintf(stderr, "Tile border = %d,%d,%d,%d\n", l_tile->x0, l_tile->y0,l_tile->x1,l_tile->y1);*/                                                                                                         \
+                                                                    \
+        /*tile->numcomps = image->numcomps; */                      \
+        for(compno = 0; compno < l_tile->numcomps; ++compno) {      \
+                /*fprintf(stderr, "compno = %d/%d\n", compno, l_tile->numcomps);*/                                                                                                                                \
+                                                                    \
+                /* border of each l_tile component (global) */      \
+                l_tilec->x0 = opj_int_ceildiv(l_tile->x0, (OPJ_INT32)l_image_comp->dx);                                                                                                                                          \
+                l_tilec->y0 = opj_int_ceildiv(l_tile->y0, (OPJ_INT32)l_image_comp->dy);                                                                                                                                          \
+                l_tilec->x1 = opj_int_ceildiv(l_tile->x1, (OPJ_INT32)l_image_comp->dx);                                                                                                                                          \
+                l_tilec->y1 = opj_int_ceildiv(l_tile->y1, (OPJ_INT32)l_image_comp->dy);                                                                                                                                          \
+                /*fprintf(stderr, "\tTile compo border = %d,%d,%d,%d\n", l_tilec->x0, l_tilec->y0,l_tilec->x1,l_tilec->y1);*/                                                                                     \
+                                                                    \
+                l_data_size = (OPJ_UINT32)(l_tilec->x1 - l_tilec->x0)           \
+                * (OPJ_UINT32)(l_tilec->y1 - l_tilec->y0) * (OPJ_UINT32)sizeof(OPJ_UINT32 );\
+                l_tilec->numresolutions = l_tccp->numresolutions;   \
+                if (l_tccp->numresolutions < l_cp->m_specific_param.m_dec.m_reduce) {                                                                                                                             \
+                        l_tilec->minimum_num_resolutions = 1;       \
+                }                                                   \
+                else {                                              \
+                        l_tilec->minimum_num_resolutions = l_tccp->numresolutions                                                                                                                                 \
+                        - l_cp->m_specific_param.m_dec.m_reduce;    \
+                }                                                   \
+                                                                    \
+                if (l_tilec->data == 00) {                          \
+                        l_tilec->data = (OPJ_INT32 *) opj_malloc(l_data_size);                                                                                                                                    \
+                        if (! l_tilec->data ) {                     \
+                                return OPJ_FALSE;                   \
+                        }                                           \
+                        /*fprintf(stderr, "\tAllocate data of tilec (int): %d x OPJ_UINT32\n",l_data_size);*/                                                                                                     \
+                                                                    \
+                        l_tilec->data_size = l_data_size;           \
+                }                                                   \
+                else if (l_data_size > l_tilec->data_size) {        \
+                        OPJ_INT32 * new_data = (OPJ_INT32 *) opj_realloc(l_tilec->data, l_data_size);                                                                                                             \
+                        /* opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to handle tile data\n");                                                                                                 */  \
+                        fprintf(stderr, "Not enough memory to handle tile data\n");                                                                                                                               \
+                        if (! new_data) {                           \
+                                opj_free(l_tilec->data);            \
+                                l_tilec->data = NULL;               \
+                                l_tilec->data_size = 0;             \
+                                return OPJ_FALSE;                   \
+                        }                                           \
+                        l_tilec->data = new_data;                   \
+                        /*fprintf(stderr, "\tReallocate data of tilec (int): from %d to %d x OPJ_UINT32\n", l_tilec->data_size, l_data_size);*/                                                                   \
+                        l_tilec->data_size = l_data_size;           \
+                }                                                   \
+                                                                    \
+                l_data_size = l_tilec->numresolutions * (OPJ_UINT32)sizeof(opj_tcd_resolution_t);                                                                                                                          \
+                                                                    \
+                if (l_tilec->resolutions == 00) {                   \
+                        l_tilec->resolutions = (opj_tcd_resolution_t *) opj_malloc(l_data_size);                                                                                                               \
+                        if (! l_tilec->resolutions ) {              \
+                                return OPJ_FALSE;                   \
+                        }                                           \
+                        /*fprintf(stderr, "\tAllocate resolutions of tilec (opj_tcd_resolution_t): %d\n",l_data_size);*/                                                                                       \
+                        l_tilec->resolutions_size = l_data_size;    \
+                        memset(l_tilec->resolutions,0,l_data_size); \
+                }                                                   \
+                else if (l_data_size > l_tilec->resolutions_size) { \
+                        opj_tcd_resolution_t* new_resolutions = (opj_tcd_resolution_t *) opj_realloc(l_tilec->resolutions, l_data_size);                                                                    \
+                        if (! new_resolutions) {                    \
+                                /* opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to tile resolutions\n");                                                                                         */  \
+                                fprintf(stderr, "Not enough memory to tile resolutions\n");                                                                                                                       \
+                                opj_free(l_tilec->resolutions);     \
+                                l_tilec->resolutions = NULL;        \
+                                l_tilec->resolutions_size = 0;      \
+                                return OPJ_FALSE;                   \
+                        }                                           \
+                        l_tilec->resolutions = new_resolutions;     \
+                        /*fprintf(stderr, "\tReallocate data of tilec (int): from %d to %d x OPJ_UINT32\n", l_tilec->resolutions_size, l_data_size);*/                                                            \
+                        memset(((OPJ_BYTE*) l_tilec->resolutions)+l_tilec->resolutions_size,0,l_data_size - l_tilec->resolutions_size);                                                                           \
+                        l_tilec->resolutions_size = l_data_size;    \
+                }                                                   \
+                                                                    \
+                l_level_no = l_tilec->numresolutions - 1;           \
+                l_res = l_tilec->resolutions;                       \
+                l_step_size = l_tccp->stepsizes;                    \
+                if (l_tccp->qmfbid == 0) {                          \
+                        l_gain_ptr = &opj_dwt_getgain_real;         \
+                }                                                   \
+                else {                                              \
+                        l_gain_ptr  = &opj_dwt_getgain;             \
+                }                                                   \
+                /*fprintf(stderr, "\tlevel_no=%d\n",l_level_no);*/  \
+                                                                                                                                                                                                                  \
+                for(resno = 0; resno < l_tilec->numresolutions; ++resno) {                                                                                                                                        \
+                        /*fprintf(stderr, "\t\tresno = %d/%d\n", resno, l_tilec->numresolutions);*/                                                                                                               \
+                        OPJ_INT32 tlcbgxstart, tlcbgystart /*, brcbgxend, brcbgyend*/;                                                                                                                                 \
+                        OPJ_UINT32 cbgwidthexpn, cbgheightexpn;                                                                                                                                                   \
+                        OPJ_UINT32 cblkwidthexpn, cblkheightexpn;                                                                                                                                                 \
+                                                                                                                                                                                                                  \
+                        /* border for each resolution level (global) */                                                                                                                                           \
+                        l_res->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32)l_level_no);                                                                                                                                     \
+                        l_res->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32)l_level_no);                                                                                                                                     \
+                        l_res->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32)l_level_no);                                                                                                                                     \
+                        l_res->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32)l_level_no);                                                                                                                                     \
+                        /*fprintf(stderr, "\t\t\tres_x0= %d, res_y0 =%d, res_x1=%d, res_y1=%d\n", l_res->x0, l_res->y0, l_res->x1, l_res->y1);*/                                                                  \
+                        /* p. 35, table A-23, ISO/IEC FDIS154444-1 : 2000 (18 august 2000) */                                                                                                                     \
+                        l_pdx = l_tccp->prcw[resno];                                                                                                                                                              \
+                        l_pdy = l_tccp->prch[resno];                                                                                                                                                              \
+                        /*fprintf(stderr, "\t\t\tpdx=%d, pdy=%d\n", l_pdx, l_pdy);*/                                                                                                                              \
+                        /* p. 64, B.6, ISO/IEC FDIS15444-1 : 2000 (18 august 2000)  */                                                                                                                            \
+                        l_tl_prc_x_start = opj_int_floordivpow2(l_res->x0, (OPJ_INT32)l_pdx) << l_pdx;                                                                                                                           \
+                        l_tl_prc_y_start = opj_int_floordivpow2(l_res->y0, (OPJ_INT32)l_pdy) << l_pdy;                                                                                                                           \
+                        l_br_prc_x_end = opj_int_ceildivpow2(l_res->x1, (OPJ_INT32)l_pdx) << l_pdx;                                                                                                                              \
+                        l_br_prc_y_end = opj_int_ceildivpow2(l_res->y1, (OPJ_INT32)l_pdy) << l_pdy;                                                                                                                              \
+                        /*fprintf(stderr, "\t\t\tprc_x_start=%d, prc_y_start=%d, br_prc_x_end=%d, br_prc_y_end=%d \n", l_tl_prc_x_start, l_tl_prc_y_start, l_br_prc_x_end ,l_br_prc_y_end );*/                    \
+                                                                                                                                                                                                                  \
+                        l_res->pw = (l_res->x0 == l_res->x1) ? 0 : (OPJ_UINT32)((l_br_prc_x_end - l_tl_prc_x_start) >> l_pdx);                                                                                                \
+                        l_res->ph = (l_res->y0 == l_res->y1) ? 0 : (OPJ_UINT32)((l_br_prc_y_end - l_tl_prc_y_start) >> l_pdy);                                                                                                \
+                        /*fprintf(stderr, "\t\t\tres_pw=%d, res_ph=%d\n", l_res->pw, l_res->ph );*/                                                                                                               \
+                                                                                                                                                                                                                  \
+                        l_nb_precincts = l_res->pw * l_res->ph;                                                                                                                                                   \
+                        l_nb_precinct_size = l_nb_precincts * (OPJ_UINT32)sizeof(opj_tcd_precinct_t);                                                                                                                      \
+                        if (resno == 0) {                                                                                                                                                                         \
+                                tlcbgxstart = l_tl_prc_x_start;                                                                                                                                                   \
+                                tlcbgystart = l_tl_prc_y_start;                                                                                                                                                   \
+                                /*brcbgxend = l_br_prc_x_end;*/                                                                                                                                                       \
+                               /* brcbgyend = l_br_prc_y_end;*/                                                                                                                                                       \
+                                cbgwidthexpn = l_pdx;                                                                                                                                                             \
+                                cbgheightexpn = l_pdy;                                                                                                                                                            \
+                                l_res->numbands = 1;                                                                                                                                                              \
+                        }                                                                                                                                                                                         \
+                        else {                                                                                                                                                                                    \
+                                tlcbgxstart = opj_int_ceildivpow2(l_tl_prc_x_start, 1);                                                                                                                               \
+                                tlcbgystart = opj_int_ceildivpow2(l_tl_prc_y_start, 1);                                                                                                                               \
+                                /*brcbgxend = opj_int_ceildivpow2(l_br_prc_x_end, 1);*/                                                                                                                            \
+                                /*brcbgyend = opj_int_ceildivpow2(l_br_prc_y_end, 1);*/                                                                                                                            \
+                                cbgwidthexpn = l_pdx - 1;                                                                                                                                                         \
+                                cbgheightexpn = l_pdy - 1;                                                                                                                                                        \
+                                l_res->numbands = 3;                                                                                                                                                              \
+                        }                                                                                                                                                                                         \
+                                                                                                                                                                                                                  \
+                        cblkwidthexpn = opj_uint_min(l_tccp->cblkw, cbgwidthexpn);                                                                                                                                    \
+                        cblkheightexpn = opj_uint_min(l_tccp->cblkh, cbgheightexpn);                                                                                                                                  \
+                        l_band = l_res->bands;                                                                                                                                                                    \
+                                                                                                                                                                                                                  \
+                        for (bandno = 0; bandno < l_res->numbands; ++bandno) {                                                                                                                                    \
+                                OPJ_INT32 numbps;                                                                                                                                                                 \
+                                /*fprintf(stderr, "\t\t\tband_no=%d/%d\n", bandno, l_res->numbands );*/                                                                                                           \
+                                                                                                                                                                                                                  \
+                                if (resno == 0) {                                                                                                                                                                 \
+                                        l_band->bandno = 0 ;                                                                                                                                                      \
+                                        l_band->x0 = opj_int_ceildivpow2(l_tilec->x0, (OPJ_INT32)l_level_no);                                                                                                                    \
+                                        l_band->y0 = opj_int_ceildivpow2(l_tilec->y0, (OPJ_INT32)l_level_no);                                                                                                                    \
+                                        l_band->x1 = opj_int_ceildivpow2(l_tilec->x1, (OPJ_INT32)l_level_no);                                                                                                                    \
+                                        l_band->y1 = opj_int_ceildivpow2(l_tilec->y1, (OPJ_INT32)l_level_no);                                                                                                                    \
+                                }                                                                                                                                                                                 \
+                                else {                                                                                                                                                                            \
+                                        l_band->bandno = bandno + 1;                                                                                                                                              \
+                                        /* x0b = 1 if bandno = 1 or 3 */                                                                                                                                          \
+                                        l_x0b = l_band->bandno&1;                                                                                                                                                 \
+                                        /* y0b = 1 if bandno = 2 or 3 */                                                                                                                                          \
+                                        l_y0b = (OPJ_INT32)((l_band->bandno)>>1);                                                                                                                                              \
+                                        /* l_band border (global) */                                                                                                                                              \
+                                        l_band->x0 = opj_int_ceildivpow2(l_tilec->x0 - (1 << l_level_no) * l_x0b, (OPJ_INT32)(l_level_no + 1));                                                                                    \
+                                        l_band->y0 = opj_int_ceildivpow2(l_tilec->y0 - (1 << l_level_no) * l_y0b, (OPJ_INT32)(l_level_no + 1));                                                                                    \
+                                        l_band->x1 = opj_int_ceildivpow2(l_tilec->x1 - (1 << l_level_no) * l_x0b, (OPJ_INT32)(l_level_no + 1));                                                                                    \
+                                        l_band->y1 = opj_int_ceildivpow2(l_tilec->y1 - (1 << l_level_no) * l_y0b, (OPJ_INT32)(l_level_no + 1));                                                                                    \
+                                }                                                                                                                                                                                 \
+                                                                                                                                                                                                                  \
+                                /** avoid an if with storing function pointer */                                                                                                                                  \
+                                l_gain = (*l_gain_ptr) (l_band->bandno);                                                                                                                                          \
+                                numbps = (OPJ_INT32)(l_image_comp->prec + l_gain);                                                                                                                                             \
+                                l_band->stepsize = (OPJ_FLOAT32)(((1.0 + l_step_size->mant / 2048.0) * pow(2.0, (OPJ_INT32) (numbps - l_step_size->expn)))) * FRACTION;                                           \
+                                l_band->numbps = l_step_size->expn + (OPJ_INT32)l_tccp->numgbits - 1;      /* WHY -1 ? */                                                                                                    \
+                                                                                                                                                                                                                  \
+                                if (! l_band->precincts) {                                                                                                                                                        \
+                                        l_band->precincts = (opj_tcd_precinct_t *) opj_malloc( /*3 * */ l_nb_precinct_size);                                                                                   \
+                                        if (! l_band->precincts) {                                                                                                                                                \
+                                                return OPJ_FALSE;                                                                                                                                                 \
+                                        }                                                                                                                                                                         \
+                                        /*fprintf(stderr, "\t\t\t\tAllocate precincts of a band (opj_tcd_precinct_t): %d\n",l_nb_precinct_size);     */                                                        \
+                                        memset(l_band->precincts,0,l_nb_precinct_size);                                                                                                                           \
+                                        l_band->precincts_data_size = l_nb_precinct_size;                                                                                                                         \
+                                }                                                                                                                                                                                 \
+                                else if (l_band->precincts_data_size < l_nb_precinct_size) {                                                                                                                      \
+                                                                                                                                                                                                                  \
+                                        opj_tcd_precinct_t * new_precincts = (opj_tcd_precinct_t *) opj_realloc(l_band->precincts,/*3 * */ l_nb_precinct_size);                                             \
+                                        if (! new_precincts) {                                                                                                                                                    \
+                                                /* opj_event_msg(p_manager, EVT_ERROR, "Not enough memory to handle band precints\n");                                                                    */   \
+                                                fprintf(stderr, "Not enough memory to handle band precints\n");                                                                                                   \
+                                                opj_free(l_band->precincts);                                                                                                                                      \
+                                                l_band->precincts = NULL;                                                                                                                                         \
+                                                l_band->precincts_data_size = 0;                                                                                                                                  \
+                                                return OPJ_FALSE;                                                                                                                                                 \
+                                        }                                                                                                                                                                         \
+                                        l_band->precincts = new_precincts;                                                                                                                                        \
+                                        /*fprintf(stderr, "\t\t\t\tReallocate precincts of a band (opj_tcd_precinct_t): from %d to %d\n",l_band->precincts_data_size, l_nb_precinct_size);*/                   \
+                                        memset(((OPJ_BYTE *) l_band->precincts) + l_band->precincts_data_size,0,l_nb_precinct_size - l_band->precincts_data_size);                                                \
+                                        l_band->precincts_data_size = l_nb_precinct_size;                                                                                                                         \
+                                }                                                                                                                                                                                 \
+                                                                                                                                                                                                                  \
+                                l_current_precinct = l_band->precincts;                                                                                                                                           \
+                                for     (precno = 0; precno < l_nb_precincts; ++precno) {                                                                                                                         \
+                                        OPJ_INT32 tlcblkxstart, tlcblkystart, brcblkxend, brcblkyend;                                                                                                             \
+                                        OPJ_INT32 cbgxstart = tlcbgxstart + (OPJ_INT32)(precno % l_res->pw) * (1 << cbgwidthexpn);                                                                                           \
+                                        OPJ_INT32 cbgystart = tlcbgystart + (OPJ_INT32)(precno / l_res->pw) * (1 << cbgheightexpn);                                                                                          \
+                                        OPJ_INT32 cbgxend = cbgxstart + (1 << cbgwidthexpn);                                                                                                                      \
+                                        OPJ_INT32 cbgyend = cbgystart + (1 << cbgheightexpn);                                                                                                                     \
+                                        /*fprintf(stderr, "\t precno=%d; bandno=%d, resno=%d; compno=%d\n", precno, bandno , resno, compno);*/                                                                    \
+                                        /*fprintf(stderr, "\t tlcbgxstart(=%d) + (precno(=%d) percent res->pw(=%d)) * (1 << cbgwidthexpn(=%d)) \n",tlcbgxstart,precno,l_res->pw,cbgwidthexpn);*/                  \
+                                                                                                                                                                                                                  \
+                                        /* precinct size (global) */                                                                                                                                              \
+                                        /*fprintf(stderr, "\t cbgxstart=%d, l_band->x0 = %d \n",cbgxstart, l_band->x0);*/                                                                                         \
+                                                                                                                                                                                                                  \
+                                        l_current_precinct->x0 = opj_int_max(cbgxstart, l_band->x0);                                                                                                                  \
+                                        l_current_precinct->y0 = opj_int_max(cbgystart, l_band->y0);                                                                                                                  \
+                                        l_current_precinct->x1 = opj_int_min(cbgxend, l_band->x1);                                                                                                                    \
+                                        l_current_precinct->y1 = opj_int_min(cbgyend, l_band->y1);                                                                                                                    \
+                                        /*fprintf(stderr, "\t prc_x0=%d; prc_y0=%d, prc_x1=%d; prc_y1=%d\n",l_current_precinct->x0, l_current_precinct->y0 ,l_current_precinct->x1, l_current_precinct->y1);*/    \
+                                                                                                                                                                                                                  \
+                                        tlcblkxstart = opj_int_floordivpow2(l_current_precinct->x0, (OPJ_INT32)cblkwidthexpn) << cblkwidthexpn;                                                                                  \
+                                        /*fprintf(stderr, "\t tlcblkxstart =%d\n",tlcblkxstart );*/                                                                                                               \
+                                        tlcblkystart = opj_int_floordivpow2(l_current_precinct->y0, (OPJ_INT32)cblkheightexpn) << cblkheightexpn;                                                                                \
+                                        /*fprintf(stderr, "\t tlcblkystart =%d\n",tlcblkystart );*/                                                                                                               \
+                                        brcblkxend = opj_int_ceildivpow2(l_current_precinct->x1, (OPJ_INT32)cblkwidthexpn) << cblkwidthexpn;                                                                                     \
+                                        /*fprintf(stderr, "\t brcblkxend =%d\n",brcblkxend );*/                                                                                                                   \
+                                        brcblkyend = opj_int_ceildivpow2(l_current_precinct->y1, (OPJ_INT32)cblkheightexpn) << cblkheightexpn;                                                                                   \
+                                        /*fprintf(stderr, "\t brcblkyend =%d\n",brcblkyend );*/                                                                                                                   \
+                                        l_current_precinct->cw = (OPJ_UINT32)((brcblkxend - tlcblkxstart) >> cblkwidthexpn);                                                                                                    \
+                                        l_current_precinct->ch = (OPJ_UINT32)((brcblkyend - tlcblkystart) >> cblkheightexpn);                                                                                                   \
+                                                                                                                                                                                                                  \
+                                        l_nb_code_blocks = l_current_precinct->cw * l_current_precinct->ch;                                                                                                       \
+                                        /*fprintf(stderr, "\t\t\t\t precinct_cw = %d x recinct_ch = %d\n",l_current_precinct->cw, l_current_precinct->ch);      */                                                \
+                                        l_nb_code_blocks_size = l_nb_code_blocks * (OPJ_UINT32)sizeof(TYPE);                                                                                                                  \
+                                                                                                                                                                                                                  \
+                                        if (! l_current_precinct->cblks.ELEMENT) {                                                                                                                                \
+                                                l_current_precinct->cblks.ELEMENT = (TYPE*) opj_malloc(l_nb_code_blocks_size);                                                                                    \
+                                                if (! l_current_precinct->cblks.ELEMENT ) {                                                                                                                       \
+                                                        return OPJ_FALSE;                                                                                                                                         \
+                                                }                                                                                                                                                                 \
+                                                /*fprintf(stderr, "\t\t\t\tAllocate cblks of a precinct (opj_tcd_cblk_dec_t): %d\n",l_nb_code_blocks_size);*/                                                  \
+                                                                                                                                                                                                                  \
+                                                memset(l_current_precinct->cblks.ELEMENT,0,l_nb_code_blocks_size);                                                                                                \
+                                                                                                                                                                                                                  \
+                                                l_current_precinct->block_size = l_nb_code_blocks_size;                                                                                                           \
+                                        }                                                                                                                                                                         \
+                                        else if (l_nb_code_blocks_size > l_current_precinct->block_size) {                                                                                                        \
+                                                TYPE *new_ELEMENT = (TYPE*) opj_realloc(l_current_precinct->cblks.ELEMENT, l_nb_code_blocks_size);                                                                \
+                                                if (! new_ELEMENT) {                                                                                                                                              \
+                                                        opj_free(l_current_precinct->cblks.ELEMENT);                                                                                                              \
+                                                        l_current_precinct->cblks.ELEMENT = NULL;                                                                                                                 \
+                                                        l_current_precinct->block_size = 0;                                                                                                                       \
+                                                        /* opj_event_msg(p_manager, EVT_ERROR, "Not enough memory for current precinct codeblock element\n");                                              */  \
+                                                        fprintf(stderr, "Not enough memory for current precinct codeblock element\n");                                                                            \
+                                                        return OPJ_FALSE;                                                                                                                                         \
+                                                }                                                                                                                                                                 \
+                                                l_current_precinct->cblks.ELEMENT = new_ELEMENT;                                                                                                                  \
+                                                /*fprintf(stderr, "\t\t\t\tReallocate cblks of a precinct (opj_tcd_cblk_dec_t): from %d to %d\n",l_current_precinct->block_size, l_nb_code_blocks_size);     */\
+                                                                                                                                                                                                                  \
+                                                memset(((OPJ_BYTE *) l_current_precinct->cblks.ELEMENT) + l_current_precinct->block_size                                                                          \
+                                                                ,0                                                                                                                                                \
+                                                                ,l_nb_code_blocks_size - l_current_precinct->block_size);                                                                                         \
+                                                                                                                                                                                                                  \
+                                                l_current_precinct->block_size = l_nb_code_blocks_size;                                                                                                           \
+                                        }                                                                                                                                                                         \
+                                                                                                                                                                                                                  \
+                                        if (! l_current_precinct->incltree) {                                                                                                                                     \
+                                                l_current_precinct->incltree = opj_tgt_create(l_current_precinct->cw,                                                                                              \
+                                                                l_current_precinct->ch);                                                                                                                          \
+                                        }                                                                                                                                                                         \
+                                        else{                                                                                                                                                                     \
+                                                l_current_precinct->incltree = opj_tgt_init(l_current_precinct->incltree,                                                                                             \
+                                                                l_current_precinct->cw,                                                                                                                           \
+                                                                l_current_precinct->ch);                                                                                                                          \
+                                        }                                                                                                                                                                         \
+                                                                                                                                                                                                                  \
+                                        if (! l_current_precinct->incltree)     {                                                                                                                                 \
+                                                fprintf(stderr, "WARNING: No incltree created.\n");                                                                                                               \
+                                                /*return OPJ_FALSE;*/                                                                                                                                             \
+                                        }                                                                                                                                                                         \
+                                                                                                                                                                                                                  \
+                                        if (! l_current_precinct->imsbtree) {                                                                                                                                     \
+                                                l_current_precinct->imsbtree = opj_tgt_create(                                                                                                                     \
+                                                                l_current_precinct->cw,                                                                                                                           \
+                                                                l_current_precinct->ch);                                                                                                                          \
+                                        }                                                                                                                                                                         \
+                                        else {                                                                                                                                                                    \
+                                                l_current_precinct->imsbtree = opj_tgt_init(                                                                                                                          \
+                                                                l_current_precinct->imsbtree,                                                                                                                     \
+                                                                l_current_precinct->cw,                                                                                                                           \
+                                                                l_current_precinct->ch);                                                                                                                          \
+                                        }                                                                                                                                                                         \
+                                                                                                                                                                                                                  \
+                                        if (! l_current_precinct->imsbtree) {                                                                                                                                     \
+                                                fprintf(stderr, "WARNING: No imsbtree created.\n");                                                                                                               \
+                                                /*return OPJ_FALSE;*/                                                                                                                                             \
+                                        }                                                                                                                                                                         \
+                                                                                                                                                                                                                  \
+                                        l_code_block = l_current_precinct->cblks.ELEMENT;                                                                                                                         \
+                                                                                                                                                                                                                  \
+                                        for (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno) {                                                                                                                   \
+                                                OPJ_INT32 cblkxstart = tlcblkxstart + (OPJ_INT32)(cblkno % l_current_precinct->cw) * (1 << cblkwidthexpn);                                                                   \
+                                                OPJ_INT32 cblkystart = tlcblkystart + (OPJ_INT32)(cblkno / l_current_precinct->cw) * (1 << cblkheightexpn);                                                                  \
+                                                OPJ_INT32 cblkxend = cblkxstart + (1 << cblkwidthexpn);                                                                                                           \
+                                                OPJ_INT32 cblkyend = cblkystart + (1 << cblkheightexpn);                                                                                                          \
+                                                                                                                                                                                                                  \
+                                                /* code-block size (global) */                                                                                                                                    \
+                                                l_code_block->x0 = opj_int_max(cblkxstart, l_current_precinct->x0);                                                                                                   \
+                                                l_code_block->y0 = opj_int_max(cblkystart, l_current_precinct->y0);                                                                                                   \
+                                                l_code_block->x1 = opj_int_min(cblkxend, l_current_precinct->x1);                                                                                                     \
+                                                l_code_block->y1 = opj_int_min(cblkyend, l_current_precinct->y1);                                                                                                     \
+                                                                                                                                                                                                                  \
+                                                if (! FUNCTION_ELEMENT(l_code_block)) {                                                                                                                           \
+                                                        return OPJ_FALSE;                                                                                                                                         \
+                                                }                                                                                                                                                                 \
+                                                ++l_code_block;                                                                                                                                                   \
+                                        }                                                                                                                                                                         \
+                                        ++l_current_precinct;                                                                                                                                                     \
+                                } /* precno */                                                                                                                                                                    \
+                                ++l_band;                                                                                                                                                                         \
+                                ++l_step_size;                                                                                                                                                                    \
+                        } /* bandno */                                                                                                                                                                            \
+                        ++l_res;                                                                                                                                                                                  \
+                        --l_level_no;                                                                                                                                                                             \
+                } /* resno */                                                                                                                                                                                     \
+                ++l_tccp;                                                                                                                                                                                         \
+                ++l_tilec;                                                                                                                                                                                        \
+                ++l_image_comp;                                                                                                                                                                                   \
+        } /* compno */                                                                                                                                                                                            \
+        return OPJ_TRUE;                                                                                                                                                                                          \
+}                                                                                                                                                                                                                 \
+
+
+OPJ_MACRO_TCD_ALLOCATE(opj_tcd_init_encode_tile, opj_tcd_cblk_enc_t, 1.f, enc, opj_tcd_code_block_enc_allocate)
+OPJ_MACRO_TCD_ALLOCATE(opj_tcd_init_decode_tile, opj_tcd_cblk_dec_t, 0.5f, dec, opj_tcd_code_block_dec_allocate)
+
+#undef OPJ_MACRO_TCD_ALLOCATE
+
+/**
+ * Allocates memory for an encoding code block.
+ */
+OPJ_BOOL opj_tcd_code_block_enc_allocate (opj_tcd_cblk_enc_t * p_code_block)
+{
+        if (! p_code_block->data) {
+
+                p_code_block->data = (OPJ_BYTE*) opj_malloc(OPJ_J2K_DEFAULT_CBLK_DATA_SIZE*2); /*why +1 ?*/
+                if(! p_code_block->data) {
+                        return OPJ_FALSE;
+                }
+
+                p_code_block->data[0] = 0;
+                p_code_block->data+=1;
+
+                /* no memset since data */
+                p_code_block->layers = (opj_tcd_layer_t*) opj_malloc(100 * sizeof(opj_tcd_layer_t));
+                if (! p_code_block->layers) {
+                        return OPJ_FALSE;
+                }
+
+                p_code_block->passes = (opj_tcd_pass_t*) opj_malloc(100 * sizeof(opj_tcd_pass_t));
+                if (! p_code_block->passes) {
+                        return OPJ_FALSE;
+                }
+        }
+
+        memset(p_code_block->layers,0,100 * sizeof(opj_tcd_layer_t));
+        memset(p_code_block->passes,0,100 * sizeof(opj_tcd_pass_t));
 
-void tcd_malloc_encode(opj_tcd_t *tcd, opj_image_t * image, opj_cp_t * cp, int curtileno) {
-	int tileno, compno, resno, bandno, precno, cblkno;
-
-	tcd->image = image;
-	tcd->cp = cp;
-	tcd->tcd_image->tw = cp->tw;
-	tcd->tcd_image->th = cp->th;
-	tcd->tcd_image->tiles = (opj_tcd_tile_t *) opj_malloc(sizeof(opj_tcd_tile_t));
-	
-	for (tileno = 0; tileno < 1; tileno++) {
-		opj_tcp_t *tcp = &cp->tcps[curtileno];
-		int j;
-
-		/* cfr p59 ISO/IEC FDIS15444-1 : 2000 (18 august 2000) */
-		int p = curtileno % cp->tw;	/* si numerotation matricielle .. */
-		int q = curtileno / cp->tw;	/* .. coordonnees de la tile (q,p) q pour ligne et p pour colonne */
-
-		/* opj_tcd_tile_t *tile=&tcd->tcd_image->tiles[tileno]; */
-		opj_tcd_tile_t *tile = tcd->tcd_image->tiles;
-
-		/* 4 borders of the tile rescale on the image if necessary */
-		tile->x0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
-		tile->y0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
-		tile->x1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
-		tile->y1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
-		tile->numcomps = image->numcomps;
-		/* tile->PPT=image->PPT;  */
-
-		/* Modification of the RATE >> */
-		for (j = 0; j < tcp->numlayers; j++) {
-			tcp->rates[j] = tcp->rates[j] ? 
-				cp->tp_on ? 
-					(((float) (tile->numcomps 
-					* (tile->x1 - tile->x0) 
-					* (tile->y1 - tile->y0)
-					* image->comps[0].prec))
-					/(tcp->rates[j] * 8 * image->comps[0].dx * image->comps[0].dy)) - (((tcd->cur_totnum_tp - 1) * 14 )/ tcp->numlayers)
-					:
-				((float) (tile->numcomps 
-					* (tile->x1 - tile->x0) 
-					* (tile->y1 - tile->y0) 
-					* image->comps[0].prec))/ 
-					(tcp->rates[j] * 8 * image->comps[0].dx * image->comps[0].dy)
-					: 0;
-
-			if (tcp->rates[j]) {
-				if (j && tcp->rates[j] < tcp->rates[j - 1] + 10) {
-					tcp->rates[j] = tcp->rates[j - 1] + 20;
-				} else {
-					if (!j && tcp->rates[j] < 30)
-						tcp->rates[j] = 30;
-				}
-				
-				if(j == (tcp->numlayers-1)){
-					tcp->rates[j] = tcp->rates[j]- 2;
-				}
-			}
-		}
-		/* << Modification of the RATE */
-		
-		tile->comps = (opj_tcd_tilecomp_t *) opj_malloc(image->numcomps * sizeof(opj_tcd_tilecomp_t));
-		for (compno = 0; compno < tile->numcomps; compno++) {
-			opj_tccp_t *tccp = &tcp->tccps[compno];
-
-			opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
-
-			/* border of each tile component (global) */
-			tilec->x0 = int_ceildiv(tile->x0, image->comps[compno].dx);
-			tilec->y0 = int_ceildiv(tile->y0, image->comps[compno].dy);
-			tilec->x1 = int_ceildiv(tile->x1, image->comps[compno].dx);
-			tilec->y1 = int_ceildiv(tile->y1, image->comps[compno].dy);
-			
-			tilec->data = (int *) opj_aligned_malloc((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0) * sizeof(int));
-			tilec->numresolutions = tccp->numresolutions;
-
-			tilec->resolutions = (opj_tcd_resolution_t *) opj_malloc(tilec->numresolutions * sizeof(opj_tcd_resolution_t));
-			
-			for (resno = 0; resno < tilec->numresolutions; resno++) {
-				int pdx, pdy;
-				int levelno = tilec->numresolutions - 1 - resno;
-				int tlprcxstart, tlprcystart, brprcxend, brprcyend;
-				int tlcbgxstart, tlcbgystart, brcbgxend, brcbgyend;
-				int cbgwidthexpn, cbgheightexpn;
-				int cblkwidthexpn, cblkheightexpn;
-
-				opj_tcd_resolution_t *res = &tilec->resolutions[resno];
-				
-				/* border for each resolution level (global) */
-				res->x0 = int_ceildivpow2(tilec->x0, levelno);
-				res->y0 = int_ceildivpow2(tilec->y0, levelno);
-				res->x1 = int_ceildivpow2(tilec->x1, levelno);
-				res->y1 = int_ceildivpow2(tilec->y1, levelno);
-				
-				res->numbands = resno == 0 ? 1 : 3;
-				/* p. 35, table A-23, ISO/IEC FDIS154444-1 : 2000 (18 august 2000) */
-				if (tccp->csty & J2K_CCP_CSTY_PRT) {
-					pdx = tccp->prcw[resno];
-					pdy = tccp->prch[resno];
-				} else {
-					pdx = 15;
-					pdy = 15;
-				}
-				/* p. 64, B.6, ISO/IEC FDIS15444-1 : 2000 (18 august 2000)  */
-				tlprcxstart = int_floordivpow2(res->x0, pdx) << pdx;
-				tlprcystart = int_floordivpow2(res->y0, pdy) << pdy;
-				
-				brprcxend = int_ceildivpow2(res->x1, pdx) << pdx;
-				brprcyend = int_ceildivpow2(res->y1, pdy) << pdy;
-				
-				res->pw = (brprcxend - tlprcxstart) >> pdx;
-				res->ph = (brprcyend - tlprcystart) >> pdy;
-				
-				if (resno == 0) {
-					tlcbgxstart = tlprcxstart;
-					tlcbgystart = tlprcystart;
-					brcbgxend = brprcxend;
-					brcbgyend = brprcyend;
-					cbgwidthexpn = pdx;
-					cbgheightexpn = pdy;
-				} else {
-					tlcbgxstart = int_ceildivpow2(tlprcxstart, 1);
-					tlcbgystart = int_ceildivpow2(tlprcystart, 1);
-					brcbgxend = int_ceildivpow2(brprcxend, 1);
-					brcbgyend = int_ceildivpow2(brprcyend, 1);
-					cbgwidthexpn = pdx - 1;
-					cbgheightexpn = pdy - 1;
-				}
-        (void)brcbgyend;
-        (void)brcbgxend;
-
-				cblkwidthexpn = int_min(tccp->cblkw, cbgwidthexpn);
-				cblkheightexpn = int_min(tccp->cblkh, cbgheightexpn);
-				
-				for (bandno = 0; bandno < res->numbands; bandno++) {
-					int x0b, y0b, i;
-					int gain, numbps;
-					opj_stepsize_t *ss = NULL;
-
-					opj_tcd_band_t *band = &res->bands[bandno];
-
-					band->bandno = resno == 0 ? 0 : bandno + 1;
-					x0b = (band->bandno == 1) || (band->bandno == 3) ? 1 : 0;
-					y0b = (band->bandno == 2) || (band->bandno == 3) ? 1 : 0;
-					
-					if (band->bandno == 0) {
-						/* band border (global) */
-						band->x0 = int_ceildivpow2(tilec->x0, levelno);
-						band->y0 = int_ceildivpow2(tilec->y0, levelno);
-						band->x1 = int_ceildivpow2(tilec->x1, levelno);
-						band->y1 = int_ceildivpow2(tilec->y1, levelno);
-					} else {
-						/* band border (global) */
-						band->x0 = int_ceildivpow2(tilec->x0 - (1 << levelno) * x0b, levelno + 1);
-						band->y0 = int_ceildivpow2(tilec->y0 - (1 << levelno) * y0b, levelno + 1);
-						band->x1 = int_ceildivpow2(tilec->x1 - (1 << levelno) * x0b, levelno + 1);
-						band->y1 = int_ceildivpow2(tilec->y1 - (1 << levelno) * y0b, levelno + 1);
-					}
-					
-					ss = &tccp->stepsizes[resno == 0 ? 0 : 3 * (resno - 1) + bandno + 1];
-					gain = tccp->qmfbid == 0 ? dwt_getgain_real(band->bandno) : dwt_getgain(band->bandno);					
-					numbps = image->comps[compno].prec + gain;
-					
-					band->stepsize = (float)((1.0 + ss->mant / 2048.0) * pow(2.0, numbps - ss->expn));
-					band->numbps = ss->expn + tccp->numgbits - 1;	/* WHY -1 ? */
-					
-					band->precincts = (opj_tcd_precinct_t *) opj_malloc(3 * res->pw * res->ph * sizeof(opj_tcd_precinct_t));
-					
-					for (i = 0; i < res->pw * res->ph * 3; i++) {
-						band->precincts[i].imsbtree = NULL;
-						band->precincts[i].incltree = NULL;
-						band->precincts[i].cblks.enc = NULL;
-					}
-					
-					for (precno = 0; precno < res->pw * res->ph; precno++) {
-						int tlcblkxstart, tlcblkystart, brcblkxend, brcblkyend;
-
-						int cbgxstart = tlcbgxstart + (precno % res->pw) * (1 << cbgwidthexpn);
-						int cbgystart = tlcbgystart + (precno / res->pw) * (1 << cbgheightexpn);
-						int cbgxend = cbgxstart + (1 << cbgwidthexpn);
-						int cbgyend = cbgystart + (1 << cbgheightexpn);
-
-						opj_tcd_precinct_t *prc = &band->precincts[precno];
-
-						/* precinct size (global) */
-						prc->x0 = int_max(cbgxstart, band->x0);
-						prc->y0 = int_max(cbgystart, band->y0);
-						prc->x1 = int_min(cbgxend, band->x1);
-						prc->y1 = int_min(cbgyend, band->y1);
-
-						tlcblkxstart = int_floordivpow2(prc->x0, cblkwidthexpn) << cblkwidthexpn;
-						tlcblkystart = int_floordivpow2(prc->y0, cblkheightexpn) << cblkheightexpn;
-						brcblkxend = int_ceildivpow2(prc->x1, cblkwidthexpn) << cblkwidthexpn;
-						brcblkyend = int_ceildivpow2(prc->y1, cblkheightexpn) << cblkheightexpn;
-						prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
-						prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
-
-						prc->cblks.enc = (opj_tcd_cblk_enc_t*) opj_calloc((prc->cw * prc->ch), sizeof(opj_tcd_cblk_enc_t));
-						prc->incltree = tgt_create(prc->cw, prc->ch);
-						prc->imsbtree = tgt_create(prc->cw, prc->ch);
-						
-						for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-							int cblkxstart = tlcblkxstart + (cblkno % prc->cw) * (1 << cblkwidthexpn);
-							int cblkystart = tlcblkystart + (cblkno / prc->cw) * (1 << cblkheightexpn);
-							int cblkxend = cblkxstart + (1 << cblkwidthexpn);
-							int cblkyend = cblkystart + (1 << cblkheightexpn);
-							
-							opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
-
-							/* code-block size (global) */
-							cblk->x0 = int_max(cblkxstart, prc->x0);
-							cblk->y0 = int_max(cblkystart, prc->y0);
-							cblk->x1 = int_min(cblkxend, prc->x1);
-							cblk->y1 = int_min(cblkyend, prc->y1);
-							cblk->data = (unsigned char*) opj_calloc(9728+2, sizeof(unsigned char));
-							/* FIXME: mqc_init_enc and mqc_byteout underrun the buffer if we don't do this. Why? */
-							cblk->data[0] = 0;
-							cblk->data[1] = 0;
-							cblk->data += 2;
-							cblk->layers = (opj_tcd_layer_t*) opj_calloc(100, sizeof(opj_tcd_layer_t));
-							cblk->passes = (opj_tcd_pass_t*) opj_calloc(100, sizeof(opj_tcd_pass_t));
-						}
-					}
-				}
-			}
-		}
-	}
-	
-	/* tcd_dump(stdout, tcd, &tcd->tcd_image); */
+        return OPJ_TRUE;
 }
 
-void tcd_free_encode(opj_tcd_t *tcd) {
-	int tileno, compno, resno, bandno, precno, cblkno;
-
-	for (tileno = 0; tileno < 1; tileno++) {
-		opj_tcd_tile_t *tile = tcd->tcd_image->tiles;
-
-		for (compno = 0; compno < tile->numcomps; compno++) {
-			opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
-
-			for (resno = 0; resno < tilec->numresolutions; resno++) {
-				opj_tcd_resolution_t *res = &tilec->resolutions[resno];
-
-				for (bandno = 0; bandno < res->numbands; bandno++) {
-					opj_tcd_band_t *band = &res->bands[bandno];
-
-					for (precno = 0; precno < res->pw * res->ph; precno++) {
-						opj_tcd_precinct_t *prc = &band->precincts[precno];
-
-						if (prc->incltree != NULL) {
-							tgt_destroy(prc->incltree);
-							prc->incltree = NULL;
-						}
-						if (prc->imsbtree != NULL) {
-							tgt_destroy(prc->imsbtree);	
-							prc->imsbtree = NULL;
-						}
-						for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-							opj_free(prc->cblks.enc[cblkno].data - 2);
-							opj_free(prc->cblks.enc[cblkno].layers);
-							opj_free(prc->cblks.enc[cblkno].passes);
-						}
-						opj_free(prc->cblks.enc);
-					} /* for (precno */
-					opj_free(band->precincts);
-					band->precincts = NULL;
-				} /* for (bandno */
-			} /* for (resno */
-			opj_free(tilec->resolutions);
-			tilec->resolutions = NULL;
-		} /* for (compno */
-		opj_free(tile->comps);
-		tile->comps = NULL;
-	} /* for (tileno */
-	opj_free(tcd->tcd_image->tiles);
-	tcd->tcd_image->tiles = NULL;
+/**
+ * Allocates memory for a decoding code block.
+ */
+OPJ_BOOL opj_tcd_code_block_dec_allocate (opj_tcd_cblk_dec_t * p_code_block)
+{
+        OPJ_UINT32 l_seg_size;
+
+        if (! p_code_block->data) {
+
+                p_code_block->data = (OPJ_BYTE*) opj_malloc(OPJ_J2K_DEFAULT_CBLK_DATA_SIZE);
+                if (! p_code_block->data) {
+                        return OPJ_FALSE;
+                }
+                p_code_block->data_max_size = OPJ_J2K_DEFAULT_CBLK_DATA_SIZE;
+                /*fprintf(stderr, "Allocate 8192 elements of code_block->data\n");*/
+
+                l_seg_size = OPJ_J2K_DEFAULT_NB_SEGS * sizeof(opj_tcd_seg_t);
+                p_code_block->segs = (opj_tcd_seg_t *) opj_malloc(l_seg_size);
+                if (! p_code_block->segs) {
+                        return OPJ_FALSE;
+                }
+                memset(p_code_block->segs,0,l_seg_size);
+                /*fprintf(stderr, "Allocate %d elements of code_block->data\n", OPJ_J2K_DEFAULT_NB_SEGS * sizeof(opj_tcd_seg_t));*/
+
+                p_code_block->m_current_max_segs = OPJ_J2K_DEFAULT_NB_SEGS;
+                /*fprintf(stderr, "m_current_max_segs of code_block->data = %d\n", p_code_block->m_current_max_segs);*/
+        }
+        /* TODO */
+        /*p_code_block->numsegs = 0; */
+
+        return OPJ_TRUE;
 }
 
-void tcd_init_encode(opj_tcd_t *tcd, opj_image_t * image, opj_cp_t * cp, int curtileno) {
-	int tileno, compno, resno, bandno, precno, cblkno;
-
-	for (tileno = 0; tileno < 1; tileno++) {
-		opj_tcp_t *tcp = &cp->tcps[curtileno];
-		int j;
-		/* cfr p59 ISO/IEC FDIS15444-1 : 2000 (18 august 2000) */
-		int p = curtileno % cp->tw;
-		int q = curtileno / cp->tw;
-
-		opj_tcd_tile_t *tile = tcd->tcd_image->tiles;
-		
-		/* 4 borders of the tile rescale on the image if necessary */
-		tile->x0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
-		tile->y0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
-		tile->x1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
-		tile->y1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
-		
-		tile->numcomps = image->numcomps;
-		/* tile->PPT=image->PPT; */
-
-		/* Modification of the RATE >> */
-		for (j = 0; j < tcp->numlayers; j++) {
-			tcp->rates[j] = tcp->rates[j] ? 
-				cp->tp_on ? 
-					(((float) (tile->numcomps 
-					* (tile->x1 - tile->x0) 
-					* (tile->y1 - tile->y0)
-					* image->comps[0].prec))
-					/(tcp->rates[j] * 8 * image->comps[0].dx * image->comps[0].dy)) - (((tcd->cur_totnum_tp - 1) * 14 )/ tcp->numlayers)
-					:
-				((float) (tile->numcomps 
-					* (tile->x1 - tile->x0) 
-					* (tile->y1 - tile->y0) 
-					* image->comps[0].prec))/ 
-					(tcp->rates[j] * 8 * image->comps[0].dx * image->comps[0].dy)
-					: 0;
-
-			if (tcp->rates[j]) {
-				if (j && tcp->rates[j] < tcp->rates[j - 1] + 10) {
-					tcp->rates[j] = tcp->rates[j - 1] + 20;
-				} else {
-					if (!j && tcp->rates[j] < 30)
-						tcp->rates[j] = 30;
-				}
-			}
-		}
-		/* << Modification of the RATE */
-
-		/* tile->comps=(opj_tcd_tilecomp_t*)opj_realloc(tile->comps,image->numcomps*sizeof(opj_tcd_tilecomp_t)); */
-		for (compno = 0; compno < tile->numcomps; compno++) {
-			opj_tccp_t *tccp = &tcp->tccps[compno];
-			
-			opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
-
-			/* border of each tile component (global) */
-			tilec->x0 = int_ceildiv(tile->x0, image->comps[compno].dx);
-			tilec->y0 = int_ceildiv(tile->y0, image->comps[compno].dy);
-			tilec->x1 = int_ceildiv(tile->x1, image->comps[compno].dx);
-			tilec->y1 = int_ceildiv(tile->y1, image->comps[compno].dy);
-			
-			tilec->data = (int *) opj_aligned_malloc((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0) * sizeof(int));
-			tilec->numresolutions = tccp->numresolutions;
-			/* tilec->resolutions=(opj_tcd_resolution_t*)opj_realloc(tilec->resolutions,tilec->numresolutions*sizeof(opj_tcd_resolution_t)); */
-			for (resno = 0; resno < tilec->numresolutions; resno++) {
-				int pdx, pdy;
-
-				int levelno = tilec->numresolutions - 1 - resno;
-				int tlprcxstart, tlprcystart, brprcxend, brprcyend;
-				int tlcbgxstart, tlcbgystart, brcbgxend, brcbgyend;
-				int cbgwidthexpn, cbgheightexpn;
-				int cblkwidthexpn, cblkheightexpn;
-				
-				opj_tcd_resolution_t *res = &tilec->resolutions[resno];
-
-				/* border for each resolution level (global) */
-				res->x0 = int_ceildivpow2(tilec->x0, levelno);
-				res->y0 = int_ceildivpow2(tilec->y0, levelno);
-				res->x1 = int_ceildivpow2(tilec->x1, levelno);
-				res->y1 = int_ceildivpow2(tilec->y1, levelno);	
-				res->numbands = resno == 0 ? 1 : 3;
-
-				/* p. 35, table A-23, ISO/IEC FDIS154444-1 : 2000 (18 august 2000) */
-				if (tccp->csty & J2K_CCP_CSTY_PRT) {
-					pdx = tccp->prcw[resno];
-					pdy = tccp->prch[resno];
-				} else {
-					pdx = 15;
-					pdy = 15;
-				}
-				/* p. 64, B.6, ISO/IEC FDIS15444-1 : 2000 (18 august 2000)  */
-				tlprcxstart = int_floordivpow2(res->x0, pdx) << pdx;
-				tlprcystart = int_floordivpow2(res->y0, pdy) << pdy;
-				brprcxend = int_ceildivpow2(res->x1, pdx) << pdx;
-				brprcyend = int_ceildivpow2(res->y1, pdy) << pdy;
-				
-				res->pw = (brprcxend - tlprcxstart) >> pdx;
-				res->ph = (brprcyend - tlprcystart) >> pdy;
-				
-				if (resno == 0) {
-					tlcbgxstart = tlprcxstart;
-					tlcbgystart = tlprcystart;
-					brcbgxend = brprcxend;
-					brcbgyend = brprcyend;
-					cbgwidthexpn = pdx;
-					cbgheightexpn = pdy;
-				} else {
-					tlcbgxstart = int_ceildivpow2(tlprcxstart, 1);
-					tlcbgystart = int_ceildivpow2(tlprcystart, 1);
-					brcbgxend = int_ceildivpow2(brprcxend, 1);
-					brcbgyend = int_ceildivpow2(brprcyend, 1);
-					cbgwidthexpn = pdx - 1;
-					cbgheightexpn = pdy - 1;
-				}
-        (void)brcbgyend;
-        (void)brcbgxend;
-				
-				cblkwidthexpn = int_min(tccp->cblkw, cbgwidthexpn);
-				cblkheightexpn = int_min(tccp->cblkh, cbgheightexpn);
-				
-				for (bandno = 0; bandno < res->numbands; bandno++) {
-					int x0b, y0b;
-					int gain, numbps;
-					opj_stepsize_t *ss = NULL;
-
-					opj_tcd_band_t *band = &res->bands[bandno];
-
-					band->bandno = resno == 0 ? 0 : bandno + 1;
-					x0b = (band->bandno == 1) || (band->bandno == 3) ? 1 : 0;
-					y0b = (band->bandno == 2) || (band->bandno == 3) ? 1 : 0;
-					
-					if (band->bandno == 0) {
-						/* band border */
-						band->x0 = int_ceildivpow2(tilec->x0, levelno);
-						band->y0 = int_ceildivpow2(tilec->y0, levelno);
-						band->x1 = int_ceildivpow2(tilec->x1, levelno);
-						band->y1 = int_ceildivpow2(tilec->y1, levelno);
-					} else {
-						band->x0 = int_ceildivpow2(tilec->x0 - (1 << levelno) * x0b, levelno + 1);
-						band->y0 = int_ceildivpow2(tilec->y0 - (1 << levelno) * y0b, levelno + 1);
-						band->x1 = int_ceildivpow2(tilec->x1 - (1 << levelno) * x0b, levelno + 1);
-						band->y1 = int_ceildivpow2(tilec->y1 - (1 << levelno) * y0b, levelno + 1);
-					}
-					
-					ss = &tccp->stepsizes[resno == 0 ? 0 : 3 * (resno - 1) + bandno + 1];
-					gain = tccp->qmfbid == 0 ? dwt_getgain_real(band->bandno) : dwt_getgain(band->bandno);
-					numbps = image->comps[compno].prec + gain;
-					band->stepsize = (float)((1.0 + ss->mant / 2048.0) * pow(2.0, numbps - ss->expn));
-					band->numbps = ss->expn + tccp->numgbits - 1;	/* WHY -1 ? */
-					
-					for (precno = 0; precno < res->pw * res->ph; precno++) {
-						int tlcblkxstart, tlcblkystart, brcblkxend, brcblkyend;
-
-						int cbgxstart = tlcbgxstart + (precno % res->pw) * (1 << cbgwidthexpn);
-						int cbgystart = tlcbgystart + (precno / res->pw) * (1 << cbgheightexpn);
-						int cbgxend = cbgxstart + (1 << cbgwidthexpn);
-						int cbgyend = cbgystart + (1 << cbgheightexpn);
-						
-						opj_tcd_precinct_t *prc = &band->precincts[precno];
-
-						/* precinct size (global) */
-						prc->x0 = int_max(cbgxstart, band->x0);
-						prc->y0 = int_max(cbgystart, band->y0);
-						prc->x1 = int_min(cbgxend, band->x1);
-						prc->y1 = int_min(cbgyend, band->y1);
-
-						tlcblkxstart = int_floordivpow2(prc->x0, cblkwidthexpn) << cblkwidthexpn;
-						tlcblkystart = int_floordivpow2(prc->y0, cblkheightexpn) << cblkheightexpn;
-						brcblkxend = int_ceildivpow2(prc->x1, cblkwidthexpn) << cblkwidthexpn;
-						brcblkyend = int_ceildivpow2(prc->y1, cblkheightexpn) << cblkheightexpn;
-						prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
-						prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
-
-						opj_free(prc->cblks.enc);
-						prc->cblks.enc = (opj_tcd_cblk_enc_t*) opj_calloc(prc->cw * prc->ch, sizeof(opj_tcd_cblk_enc_t));
-
-						if (prc->incltree != NULL) {
-							tgt_destroy(prc->incltree);
-						}
-						if (prc->imsbtree != NULL) {
-							tgt_destroy(prc->imsbtree);
-						}
-						
-						prc->incltree = tgt_create(prc->cw, prc->ch);
-						prc->imsbtree = tgt_create(prc->cw, prc->ch);
-
-						for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-							int cblkxstart = tlcblkxstart + (cblkno % prc->cw) * (1 << cblkwidthexpn);
-							int cblkystart = tlcblkystart + (cblkno / prc->cw) * (1 << cblkheightexpn);
-							int cblkxend = cblkxstart + (1 << cblkwidthexpn);
-							int cblkyend = cblkystart + (1 << cblkheightexpn);
-
-							opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
-
-							/* code-block size (global) */
-							cblk->x0 = int_max(cblkxstart, prc->x0);
-							cblk->y0 = int_max(cblkystart, prc->y0);
-							cblk->x1 = int_min(cblkxend, prc->x1);
-							cblk->y1 = int_min(cblkyend, prc->y1);
-							cblk->data = (unsigned char*) opj_calloc(8192+2, sizeof(unsigned char));
-							/* FIXME: mqc_init_enc and mqc_byteout underrun the buffer if we don't do this. Why? */
-							cblk->data[0] = 0;
-							cblk->data[1] = 0;
-							cblk->data += 2;
-							cblk->layers = (opj_tcd_layer_t*) opj_calloc(100, sizeof(opj_tcd_layer_t));
-							cblk->passes = (opj_tcd_pass_t*) opj_calloc(100, sizeof(opj_tcd_pass_t));
-						}
-					} /* precno */
-				} /* bandno */
-			} /* resno */
-		} /* compno */
-	} /* tileno */
-
-	/* tcd_dump(stdout, tcd, &tcd->tcd_image); */
+OPJ_UINT32 opj_tcd_get_decoded_tile_size ( opj_tcd_t *p_tcd )
+{
+        OPJ_UINT32 i;
+        OPJ_UINT32 l_data_size = 0;
+        opj_image_comp_t * l_img_comp = 00;
+        opj_tcd_tilecomp_t * l_tile_comp = 00;
+        opj_tcd_resolution_t * l_res = 00;
+        OPJ_UINT32 l_size_comp, l_remaining;
+
+        l_tile_comp = p_tcd->tcd_image->tiles->comps;
+        l_img_comp = p_tcd->image->comps;
+
+        for (i=0;i<p_tcd->image->numcomps;++i) {
+                l_size_comp = l_img_comp->prec >> 3; /*(/ 8)*/
+                l_remaining = l_img_comp->prec & 7;  /* (%8) */
+
+                if(l_remaining) {
+                        ++l_size_comp;
+                }
+
+                if (l_size_comp == 3) {
+                        l_size_comp = 4;
+                }
+
+                l_res = l_tile_comp->resolutions + l_tile_comp->minimum_num_resolutions - 1;
+                l_data_size += l_size_comp * (OPJ_UINT32)((l_res->x1 - l_res->x0) * (l_res->y1 - l_res->y0));
+                ++l_img_comp;
+                ++l_tile_comp;
+        }
+
+        return l_data_size;
 }
 
-void tcd_malloc_decode(opj_tcd_t *tcd, opj_image_t * image, opj_cp_t * cp) {
-	int i, j, tileno, p, q;
-	unsigned int x0 = 0, y0 = 0, x1 = 0, y1 = 0, w, h;
-
-	tcd->image = image;
-	tcd->tcd_image->tw = cp->tw;
-	tcd->tcd_image->th = cp->th;
-    tcd->tcd_image->tiles = (opj_tcd_tile_t *) opj_calloc(cp->tw * cp->th, sizeof(opj_tcd_tile_t));
-
-	/* 
-	Allocate place to store the decoded data = final image
-	Place limited by the tile really present in the codestream 
-	*/
-
-	for (j = 0; j < cp->tileno_size; j++) {
-		opj_tcd_tile_t *tile;
-		
-		tileno = cp->tileno[j];		
-		tile = &(tcd->tcd_image->tiles[cp->tileno[tileno]]);		
-		tile->numcomps = image->numcomps;
-		tile->comps = (opj_tcd_tilecomp_t*) opj_calloc(image->numcomps, sizeof(opj_tcd_tilecomp_t));
-	}
-
-	for (i = 0; i < image->numcomps; i++) {
-		for (j = 0; j < cp->tileno_size; j++) {
-			opj_tcd_tile_t *tile;
-			opj_tcd_tilecomp_t *tilec;
-			
-			/* cfr p59 ISO/IEC FDIS15444-1 : 2000 (18 august 2000) */
-			
-			tileno = cp->tileno[j];
-			
-			tile = &(tcd->tcd_image->tiles[cp->tileno[tileno]]);
-			tilec = &tile->comps[i];
-			
-			p = tileno % cp->tw;	/* si numerotation matricielle .. */
-			q = tileno / cp->tw;	/* .. coordonnees de la tile (q,p) q pour ligne et p pour colonne */
-			
-			/* 4 borders of the tile rescale on the image if necessary */
-			tile->x0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
-			tile->y0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
-			tile->x1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
-			tile->y1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
-
-			tilec->x0 = int_ceildiv(tile->x0, image->comps[i].dx);
-			tilec->y0 = int_ceildiv(tile->y0, image->comps[i].dy);
-			tilec->x1 = int_ceildiv(tile->x1, image->comps[i].dx);
-			tilec->y1 = int_ceildiv(tile->y1, image->comps[i].dy);
-
-			x0 = j == 0 ? tilec->x0 : int_min(x0, (unsigned int) tilec->x0);
-			y0 = j == 0 ? tilec->y0 : int_min(y0,	(unsigned int) tilec->y0);
-			x1 = j == 0 ? tilec->x1 : int_max(x1,	(unsigned int) tilec->x1);
-			y1 = j == 0 ? tilec->y1 : int_max(y1,	(unsigned int) tilec->y1);
-		}
-
-		w = int_ceildivpow2(x1 - x0, image->comps[i].factor);
-		h = int_ceildivpow2(y1 - y0, image->comps[i].factor);
-
-		image->comps[i].w = w;
-		image->comps[i].h = h;
-		image->comps[i].x0 = x0;
-		image->comps[i].y0 = y0;
-	}
+OPJ_BOOL opj_tcd_encode_tile(   opj_tcd_t *p_tcd,
+                                                        OPJ_UINT32 p_tile_no,
+                                                        OPJ_BYTE *p_dest,
+                                                        OPJ_UINT32 * p_data_written,
+                                                        OPJ_UINT32 p_max_length,
+                                                        opj_codestream_info_t *p_cstr_info)
+{
+
+        if (p_tcd->cur_tp_num == 0) {
+
+                p_tcd->tcd_tileno = p_tile_no;
+                p_tcd->tcp = &p_tcd->cp->tcps[p_tile_no];
+
+                /* INDEX >> "Precinct_nb_X et Precinct_nb_Y" */
+                if(p_cstr_info)  {
+                        OPJ_UINT32 l_num_packs = 0;
+                        OPJ_UINT32 i;
+                        opj_tcd_tilecomp_t *l_tilec_idx = &p_tcd->tcd_image->tiles->comps[0];        /* based on component 0 */
+                        opj_tccp_t *l_tccp = p_tcd->tcp->tccps; /* based on component 0 */
+
+                        for (i = 0; i < l_tilec_idx->numresolutions; i++) {
+                                opj_tcd_resolution_t *l_res_idx = &l_tilec_idx->resolutions[i];
+
+                                p_cstr_info->tile[p_tile_no].pw[i] = (int)l_res_idx->pw;
+                                p_cstr_info->tile[p_tile_no].ph[i] = (int)l_res_idx->ph;
+
+                                l_num_packs += l_res_idx->pw * l_res_idx->ph;
+                                p_cstr_info->tile[p_tile_no].pdx[i] = (int)l_tccp->prcw[i];
+                                p_cstr_info->tile[p_tile_no].pdy[i] = (int)l_tccp->prch[i];
+                        }
+                        p_cstr_info->tile[p_tile_no].packet = (opj_packet_info_t*) opj_calloc((size_t)p_cstr_info->numcomps * (size_t)p_cstr_info->numlayers * l_num_packs, sizeof(opj_packet_info_t));
+                }
+                /* << INDEX */
+
+                /* FIXME _ProfStart(PGROUP_DC_SHIFT); */
+                /*---------------TILE-------------------*/
+                if (! opj_tcd_dc_level_shift_encode(p_tcd)) {
+                        return OPJ_FALSE;
+                }
+                /* FIXME _ProfStop(PGROUP_DC_SHIFT); */
+
+                /* FIXME _ProfStart(PGROUP_MCT); */
+                if (! opj_tcd_mct_encode(p_tcd)) {
+                        return OPJ_FALSE;
+                }
+                /* FIXME _ProfStop(PGROUP_MCT); */
+
+                /* FIXME _ProfStart(PGROUP_DWT); */
+                if (! opj_tcd_dwt_encode(p_tcd)) {
+                        return OPJ_FALSE;
+                }
+                /* FIXME  _ProfStop(PGROUP_DWT); */
+
+                /* FIXME  _ProfStart(PGROUP_T1); */
+                if (! opj_tcd_t1_encode(p_tcd)) {
+                        return OPJ_FALSE;
+                }
+                /* FIXME _ProfStop(PGROUP_T1); */
+
+                /* FIXME _ProfStart(PGROUP_RATE); */
+                if (! opj_tcd_rate_allocate_encode(p_tcd,p_dest,p_max_length,p_cstr_info)) {
+                        return OPJ_FALSE;
+                }
+                /* FIXME _ProfStop(PGROUP_RATE); */
+
+        }
+        /*--------------TIER2------------------*/
+
+        /* INDEX */
+        if (p_cstr_info) {
+                p_cstr_info->index_write = 1;
+        }
+        /* FIXME _ProfStart(PGROUP_T2); */
+
+        if (! opj_tcd_t2_encode(p_tcd,p_dest,p_data_written,p_max_length,p_cstr_info)) {
+                return OPJ_FALSE;
+        }
+        /* FIXME _ProfStop(PGROUP_T2); */
+
+        /*---------------CLEAN-------------------*/
+
+        return OPJ_TRUE;
 }
 
-void tcd_malloc_decode_tile(opj_tcd_t *tcd, opj_image_t * image, opj_cp_t * cp, int tileno, opj_codestream_info_t *cstr_info) {
-	int compno, resno, bandno, precno, cblkno;
-	opj_tcp_t *tcp;
-	opj_tcd_tile_t *tile;
-
-	OPJ_ARG_NOT_USED(cstr_info);
-
-	tcd->cp = cp;
-	
-	tcp = &(cp->tcps[cp->tileno[tileno]]);
-	tile = &(tcd->tcd_image->tiles[cp->tileno[tileno]]);
-	
-	tileno = cp->tileno[tileno];
-	
-	for (compno = 0; compno < tile->numcomps; compno++) {
-		opj_tccp_t *tccp = &tcp->tccps[compno];
-		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
-		
-		if (tccp->numresolutions <= 0)
-		{
-			cp->tileno[tileno] = -1;
-			return;
-		}
-
-		/* border of each tile component (global) */
-		tilec->x0 = int_ceildiv(tile->x0, image->comps[compno].dx);
-		tilec->y0 = int_ceildiv(tile->y0, image->comps[compno].dy);
-		tilec->x1 = int_ceildiv(tile->x1, image->comps[compno].dx);
-		tilec->y1 = int_ceildiv(tile->y1, image->comps[compno].dy);
-
-		tilec->numresolutions = tccp->numresolutions;
-		tilec->resolutions = (opj_tcd_resolution_t *) opj_malloc(tilec->numresolutions * sizeof(opj_tcd_resolution_t));
-		
-		for (resno = 0; resno < tilec->numresolutions; resno++) {
-			int pdx, pdy;
-			int levelno = tilec->numresolutions - 1 - resno;
-			int tlprcxstart, tlprcystart, brprcxend, brprcyend;
-			int tlcbgxstart, tlcbgystart, brcbgxend, brcbgyend;
-			int cbgwidthexpn, cbgheightexpn;
-			int cblkwidthexpn, cblkheightexpn;
-			
-			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
-			
-			/* border for each resolution level (global) */
-			res->x0 = int_ceildivpow2(tilec->x0, levelno);
-			res->y0 = int_ceildivpow2(tilec->y0, levelno);
-			res->x1 = int_ceildivpow2(tilec->x1, levelno);
-			res->y1 = int_ceildivpow2(tilec->y1, levelno);
-			res->numbands = resno == 0 ? 1 : 3;
-			
-			/* p. 35, table A-23, ISO/IEC FDIS154444-1 : 2000 (18 august 2000) */
-			if (tccp->csty & J2K_CCP_CSTY_PRT) {
-				pdx = tccp->prcw[resno];
-				pdy = tccp->prch[resno];
-			} else {
-				pdx = 15;
-				pdy = 15;
-			}			
-			
-			/* p. 64, B.6, ISO/IEC FDIS15444-1 : 2000 (18 august 2000)  */
-			tlprcxstart = int_floordivpow2(res->x0, pdx) << pdx;
-			tlprcystart = int_floordivpow2(res->y0, pdy) << pdy;
-			brprcxend = int_ceildivpow2(res->x1, pdx) << pdx;
-			brprcyend = int_ceildivpow2(res->y1, pdy) << pdy;
-			
-			res->pw = (res->x0 == res->x1) ? 0 : ((brprcxend - tlprcxstart) >> pdx);
-			res->ph = (res->y0 == res->y1) ? 0 : ((brprcyend - tlprcystart) >> pdy);
-			
-			if (resno == 0) {
-				tlcbgxstart = tlprcxstart;
-				tlcbgystart = tlprcystart;
-				brcbgxend = brprcxend;
-				brcbgyend = brprcyend;
-				cbgwidthexpn = pdx;
-				cbgheightexpn = pdy;
-			} else {
-				tlcbgxstart = int_ceildivpow2(tlprcxstart, 1);
-				tlcbgystart = int_ceildivpow2(tlprcystart, 1);
-				brcbgxend = int_ceildivpow2(brprcxend, 1);
-				brcbgyend = int_ceildivpow2(brprcyend, 1);
-				cbgwidthexpn = pdx - 1;
-				cbgheightexpn = pdy - 1;
-			}
-      (void)brcbgyend;
-      (void)brcbgxend;
-			
-			cblkwidthexpn = int_min(tccp->cblkw, cbgwidthexpn);
-			cblkheightexpn = int_min(tccp->cblkh, cbgheightexpn);
-			
-			for (bandno = 0; bandno < res->numbands; bandno++) {
-				int x0b, y0b;
-				int gain, numbps;
-				opj_stepsize_t *ss = NULL;
-				
-				opj_tcd_band_t *band = &res->bands[bandno];
-				band->bandno = resno == 0 ? 0 : bandno + 1;
-				x0b = (band->bandno == 1) || (band->bandno == 3) ? 1 : 0;
-				y0b = (band->bandno == 2) || (band->bandno == 3) ? 1 : 0;
-				
-				if (band->bandno == 0) {
-					/* band border (global) */
-					band->x0 = int_ceildivpow2(tilec->x0, levelno);
-					band->y0 = int_ceildivpow2(tilec->y0, levelno);
-					band->x1 = int_ceildivpow2(tilec->x1, levelno);
-					band->y1 = int_ceildivpow2(tilec->y1, levelno);
-				} else {
-					/* band border (global) */
-					band->x0 = int_ceildivpow2(tilec->x0 - (1 << levelno) * x0b, levelno + 1);
-					band->y0 = int_ceildivpow2(tilec->y0 - (1 << levelno) * y0b, levelno + 1);
-					band->x1 = int_ceildivpow2(tilec->x1 - (1 << levelno) * x0b, levelno + 1);
-					band->y1 = int_ceildivpow2(tilec->y1 - (1 << levelno) * y0b, levelno + 1);
-				}
-				
-				ss = &tccp->stepsizes[resno == 0 ? 0 : 3 * (resno - 1) + bandno + 1];
-				gain = tccp->qmfbid == 0 ? dwt_getgain_real(band->bandno) : dwt_getgain(band->bandno);
-				numbps = image->comps[compno].prec + gain;
-				band->stepsize = (float)(((1.0 + ss->mant / 2048.0) * pow(2.0, numbps - ss->expn)) * 0.5);
-				band->numbps = ss->expn + tccp->numgbits - 1;	/* WHY -1 ? */
-				
-				band->precincts = (opj_tcd_precinct_t *) opj_malloc(res->pw * res->ph * sizeof(opj_tcd_precinct_t));
-				
-				for (precno = 0; precno < res->pw * res->ph; precno++) {
-					int tlcblkxstart, tlcblkystart, brcblkxend, brcblkyend;
-					int cbgxstart = tlcbgxstart + (precno % res->pw) * (1 << cbgwidthexpn);
-					int cbgystart = tlcbgystart + (precno / res->pw) * (1 << cbgheightexpn);
-					int cbgxend = cbgxstart + (1 << cbgwidthexpn);
-					int cbgyend = cbgystart + (1 << cbgheightexpn);
-					
-					opj_tcd_precinct_t *prc = &band->precincts[precno];
-					/* precinct size (global) */
-					prc->x0 = int_max(cbgxstart, band->x0);
-					prc->y0 = int_max(cbgystart, band->y0);
-					prc->x1 = int_min(cbgxend, band->x1);
-					prc->y1 = int_min(cbgyend, band->y1);
-					
-					tlcblkxstart = int_floordivpow2(prc->x0, cblkwidthexpn) << cblkwidthexpn;
-					tlcblkystart = int_floordivpow2(prc->y0, cblkheightexpn) << cblkheightexpn;
-					brcblkxend = int_ceildivpow2(prc->x1, cblkwidthexpn) << cblkwidthexpn;
-					brcblkyend = int_ceildivpow2(prc->y1, cblkheightexpn) << cblkheightexpn;
-					prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
-					prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
-
-					prc->cblks.dec = (opj_tcd_cblk_dec_t*) opj_malloc(prc->cw * prc->ch * sizeof(opj_tcd_cblk_dec_t));
-
-					prc->incltree = tgt_create(prc->cw, prc->ch);
-					prc->imsbtree = tgt_create(prc->cw, prc->ch);
-					
-					for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-						int cblkxstart = tlcblkxstart + (cblkno % prc->cw) * (1 << cblkwidthexpn);
-						int cblkystart = tlcblkystart + (cblkno / prc->cw) * (1 << cblkheightexpn);
-						int cblkxend = cblkxstart + (1 << cblkwidthexpn);
-						int cblkyend = cblkystart + (1 << cblkheightexpn);					
-
-						opj_tcd_cblk_dec_t* cblk = &prc->cblks.dec[cblkno];
-						cblk->data = NULL;
-						cblk->segs = NULL;
-						/* code-block size (global) */
-						cblk->x0 = int_max(cblkxstart, prc->x0);
-						cblk->y0 = int_max(cblkystart, prc->y0);
-						cblk->x1 = int_min(cblkxend, prc->x1);
-						cblk->y1 = int_min(cblkyend, prc->y1);
-						cblk->numsegs = 0;
-					}
-				} /* precno */
-			} /* bandno */
-		} /* resno */
-	} /* compno */
-	/* tcd_dump(stdout, tcd, &tcd->tcd_image); */
+OPJ_BOOL opj_tcd_decode_tile(   opj_tcd_t *p_tcd,
+                                OPJ_BYTE *p_src,
+                                OPJ_UINT32 p_max_length,
+                                OPJ_UINT32 p_tile_no,
+                                opj_codestream_index_t *p_cstr_index
+                                )
+{
+        OPJ_UINT32 l_data_read;
+        p_tcd->tcd_tileno = p_tile_no;
+        p_tcd->tcp = &(p_tcd->cp->tcps[p_tile_no]);
+
+#ifdef TODO_MSD /* FIXME */
+        /* INDEX >>  */
+        if(p_cstr_info) {
+                OPJ_UINT32 resno, compno, numprec = 0;
+                for (compno = 0; compno < (OPJ_UINT32) p_cstr_info->numcomps; compno++) {
+                        opj_tcp_t *tcp = &p_tcd->cp->tcps[0];
+                        opj_tccp_t *tccp = &tcp->tccps[compno];
+                        opj_tcd_tilecomp_t *tilec_idx = &p_tcd->tcd_image->tiles->comps[compno];
+                        for (resno = 0; resno < tilec_idx->numresolutions; resno++) {
+                                opj_tcd_resolution_t *res_idx = &tilec_idx->resolutions[resno];
+                                p_cstr_info->tile[p_tile_no].pw[resno] = res_idx->pw;
+                                p_cstr_info->tile[p_tile_no].ph[resno] = res_idx->ph;
+                                numprec += res_idx->pw * res_idx->ph;
+                                p_cstr_info->tile[p_tile_no].pdx[resno] = tccp->prcw[resno];
+                                p_cstr_info->tile[p_tile_no].pdy[resno] = tccp->prch[resno];
+                        }
+                }
+                p_cstr_info->tile[p_tile_no].packet = (opj_packet_info_t *) opj_malloc(p_cstr_info->numlayers * numprec * sizeof(opj_packet_info_t));
+                p_cstr_info->packno = 0;
+        }
+        /* << INDEX */
+#endif
+
+        /*--------------TIER2------------------*/
+        /* FIXME _ProfStart(PGROUP_T2); */
+        l_data_read = 0;
+        if (! opj_tcd_t2_decode(p_tcd, p_src, &l_data_read, p_max_length, p_cstr_index))
+        {
+                return OPJ_FALSE;
+        }
+        /* FIXME _ProfStop(PGROUP_T2); */
+
+        /*------------------TIER1-----------------*/
+
+        /* FIXME _ProfStart(PGROUP_T1); */
+        if
+                (! opj_tcd_t1_decode(p_tcd))
+        {
+                return OPJ_FALSE;
+        }
+        /* FIXME _ProfStop(PGROUP_T1); */
+
+        /*----------------DWT---------------------*/
+
+        /* FIXME _ProfStart(PGROUP_DWT); */
+        if
+                (! opj_tcd_dwt_decode(p_tcd))
+        {
+                return OPJ_FALSE;
+        }
+        /* FIXME _ProfStop(PGROUP_DWT); */
+
+        /*----------------MCT-------------------*/
+        /* FIXME _ProfStart(PGROUP_MCT); */
+        if
+                (! opj_tcd_mct_decode(p_tcd))
+        {
+                return OPJ_FALSE;
+        }
+        /* FIXME _ProfStop(PGROUP_MCT); */
+
+        /* FIXME _ProfStart(PGROUP_DC_SHIFT); */
+        if
+                (! opj_tcd_dc_level_shift_decode(p_tcd))
+        {
+                return OPJ_FALSE;
+        }
+        /* FIXME _ProfStop(PGROUP_DC_SHIFT); */
+
+
+        /*---------------TILE-------------------*/
+        return OPJ_TRUE;
 }
 
-void tcd_makelayer_fixed(opj_tcd_t *tcd, int layno, int final) {
-	int compno, resno, bandno, precno, cblkno;
-	int value;			/*, matrice[tcd_tcp->numlayers][tcd_tile->comps[0].numresolutions][3]; */
-	int matrice[10][10][3];
-	int i, j, k;
-
-	opj_cp_t *cp = tcd->cp;
-	opj_tcd_tile_t *tcd_tile = tcd->tcd_tile;
-	opj_tcp_t *tcd_tcp = tcd->tcp;
-
-	/*matrice=(int*)opj_malloc(tcd_tcp->numlayers*tcd_tile->comps[0].numresolutions*3*sizeof(int)); */
-	
-	for (compno = 0; compno < tcd_tile->numcomps; compno++) {
-		opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];
-		for (i = 0; i < tcd_tcp->numlayers; i++) {
-			for (j = 0; j < tilec->numresolutions; j++) {
-				for (k = 0; k < 3; k++) {
-					matrice[i][j][k] =
-						(int) (cp->matrice[i * tilec->numresolutions * 3 + j * 3 + k] 
-						* (float) (tcd->image->comps[compno].prec / 16.0));
-				}
-			}
-		}
-        
-		for (resno = 0; resno < tilec->numresolutions; resno++) {
-			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
-			for (bandno = 0; bandno < res->numbands; bandno++) {
-				opj_tcd_band_t *band = &res->bands[bandno];
-				for (precno = 0; precno < res->pw * res->ph; precno++) {
-					opj_tcd_precinct_t *prc = &band->precincts[precno];
-					for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-						opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];
-						opj_tcd_layer_t *layer = &cblk->layers[layno];
-						int n;
-						int imsb = tcd->image->comps[compno].prec - cblk->numbps;	/* number of bit-plan equal to zero */
-						/* Correction of the matrix of coefficient to include the IMSB information */
-						if (layno == 0) {
-							value = matrice[layno][resno][bandno];
-							if (imsb >= value) {
-								value = 0;
-							} else {
-								value -= imsb;
-							}
-						} else {
-							value =	matrice[layno][resno][bandno] -	matrice[layno - 1][resno][bandno];
-							if (imsb >= matrice[layno - 1][resno][bandno]) {
-								value -= (imsb - matrice[layno - 1][resno][bandno]);
-								if (value < 0) {
-									value = 0;
-								}
-							}
-						}
-						
-						if (layno == 0) {
-							cblk->numpassesinlayers = 0;
-						}
-						
-						n = cblk->numpassesinlayers;
-						if (cblk->numpassesinlayers == 0) {
-							if (value != 0) {
-								n = 3 * value - 2 + cblk->numpassesinlayers;
-							} else {
-								n = cblk->numpassesinlayers;
-							}
-						} else {
-							n = 3 * value + cblk->numpassesinlayers;
-						}
-						
-						layer->numpasses = n - cblk->numpassesinlayers;
-						
-						if (!layer->numpasses)
-							continue;
-						
-						if (cblk->numpassesinlayers == 0) {
-							layer->len = cblk->passes[n - 1].rate;
-							layer->data = cblk->data;
-						} else {
-							layer->len = cblk->passes[n - 1].rate - cblk->passes[cblk->numpassesinlayers - 1].rate;
-							layer->data = cblk->data + cblk->passes[cblk->numpassesinlayers - 1].rate;
-						}
-						if (final)
-							cblk->numpassesinlayers = n;
-					}
-				}
-			}
-		}
-	}
+OPJ_BOOL opj_tcd_update_tile_data ( opj_tcd_t *p_tcd,
+                                    OPJ_BYTE * p_dest,
+                                    OPJ_UINT32 p_dest_length
+                                    )
+{
+        OPJ_UINT32 i,j,k,l_data_size = 0;
+        opj_image_comp_t * l_img_comp = 00;
+        opj_tcd_tilecomp_t * l_tilec = 00;
+        opj_tcd_resolution_t * l_res;
+        OPJ_UINT32 l_size_comp, l_remaining;
+        OPJ_UINT32 l_stride, l_width,l_height;
+
+        l_data_size = opj_tcd_get_decoded_tile_size(p_tcd);
+        if (l_data_size > p_dest_length) {
+                return OPJ_FALSE;
+        }
+
+        l_tilec = p_tcd->tcd_image->tiles->comps;
+        l_img_comp = p_tcd->image->comps;
+
+        for (i=0;i<p_tcd->image->numcomps;++i) {
+                l_size_comp = l_img_comp->prec >> 3; /*(/ 8)*/
+                l_remaining = l_img_comp->prec & 7;  /* (%8) */
+                l_res = l_tilec->resolutions + l_img_comp->resno_decoded;
+                l_width = (OPJ_UINT32)(l_res->x1 - l_res->x0);
+                l_height = (OPJ_UINT32)(l_res->y1 - l_res->y0);
+                l_stride = (OPJ_UINT32)(l_tilec->x1 - l_tilec->x0) - l_width;
+
+                if (l_remaining) {
+                        ++l_size_comp;
+                }
+
+                if (l_size_comp == 3) {
+                        l_size_comp = 4;
+                }
+
+                switch (l_size_comp)
+                        {
+                        case 1:
+                                {
+                                        OPJ_CHAR * l_dest_ptr = (OPJ_CHAR *) p_dest;
+                                        const OPJ_INT32 * l_src_ptr = l_tilec->data;
+
+                                        if (l_img_comp->sgnd) {
+                                                for (j=0;j<l_height;++j) {
+                                                        for (k=0;k<l_width;++k) {
+                                                                *(l_dest_ptr++) = (OPJ_CHAR) (*(l_src_ptr++));
+                                                        }
+                                                        l_src_ptr += l_stride;
+                                                }
+                                        }
+                                        else {
+                                                for (j=0;j<l_height;++j) {
+                                                        for     (k=0;k<l_width;++k) {
+                                                                *(l_dest_ptr++) = (OPJ_CHAR) ((*(l_src_ptr++))&0xff);
+                                                        }
+                                                        l_src_ptr += l_stride;
+                                                }
+                                        }
+
+                                        p_dest = (OPJ_BYTE *)l_dest_ptr;
+                                }
+                                break;
+                        case 2:
+                                {
+                                        const OPJ_INT32 * l_src_ptr = l_tilec->data;
+                                        OPJ_INT16 * l_dest_ptr = (OPJ_INT16 *) p_dest;
+
+                                        if (l_img_comp->sgnd) {
+                                                for (j=0;j<l_height;++j) {
+                                                        for (k=0;k<l_width;++k) {
+                                                                *(l_dest_ptr++) = (OPJ_INT16) (*(l_src_ptr++));
+                                                        }
+                                                        l_src_ptr += l_stride;
+                                                }
+                                        }
+                                        else {
+                                                for (j=0;j<l_height;++j) {
+                                                        for (k=0;k<l_width;++k) {
+                                                                *(l_dest_ptr++) = (OPJ_INT16) ((*(l_src_ptr++))&0xffff);
+                                                        }
+                                                        l_src_ptr += l_stride;
+                                                }
+                                        }
+
+                                        p_dest = (OPJ_BYTE*) l_dest_ptr;
+                                }
+                                break;
+                        case 4:
+                                {
+                                        OPJ_INT32 * l_dest_ptr = (OPJ_INT32 *) p_dest;
+                                        OPJ_INT32 * l_src_ptr = l_tilec->data;
+
+                                        for (j=0;j<l_height;++j) {
+                                                for (k=0;k<l_width;++k) {
+                                                        *(l_dest_ptr++) = (*(l_src_ptr++));
+                                                }
+                                                l_src_ptr += l_stride;
+                                        }
+
+                                        p_dest = (OPJ_BYTE*) l_dest_ptr;
+                                }
+                                break;
+                }
+
+                ++l_img_comp;
+                ++l_tilec;
+        }
+
+        return OPJ_TRUE;
 }
 
-void tcd_rateallocate_fixed(opj_tcd_t *tcd) {
-	int layno;
-	for (layno = 0; layno < tcd->tcp->numlayers; layno++) {
-		tcd_makelayer_fixed(tcd, layno, 1);
-	}
+
+
+
+void opj_tcd_free_tile(opj_tcd_t *p_tcd)
+{
+        OPJ_UINT32 compno, resno, bandno, precno;
+        opj_tcd_tile_t *l_tile = 00;
+        opj_tcd_tilecomp_t *l_tile_comp = 00;
+        opj_tcd_resolution_t *l_res = 00;
+        opj_tcd_band_t *l_band = 00;
+        opj_tcd_precinct_t *l_precinct = 00;
+        OPJ_UINT32 l_nb_resolutions, l_nb_precincts;
+        void (* l_tcd_code_block_deallocate) (opj_tcd_precinct_t *) = 00;
+
+        if (! p_tcd) {
+                return;
+        }
+
+        if (! p_tcd->tcd_image) {
+                return;
+        }
+
+        if (p_tcd->m_is_decoder) {
+                l_tcd_code_block_deallocate = opj_tcd_code_block_dec_deallocate;
+        }
+        else {
+                l_tcd_code_block_deallocate = opj_tcd_code_block_enc_deallocate;
+        }
+
+        l_tile = p_tcd->tcd_image->tiles;
+        if (! l_tile) {
+                return;
+        }
+
+        l_tile_comp = l_tile->comps;
+
+        for (compno = 0; compno < l_tile->numcomps; ++compno) {
+                l_res = l_tile_comp->resolutions;
+                if (l_res) {
+
+                        l_nb_resolutions = l_tile_comp->resolutions_size / sizeof(opj_tcd_resolution_t);
+                        for (resno = 0; resno < l_nb_resolutions; ++resno) {
+                                l_band = l_res->bands;
+                                for     (bandno = 0; bandno < 3; ++bandno) {
+                                        l_precinct = l_band->precincts;
+                                        if (l_precinct) {
+
+                                                l_nb_precincts = l_band->precincts_data_size / sizeof(opj_tcd_precinct_t);
+                                                for (precno = 0; precno < l_nb_precincts; ++precno) {
+                                                        opj_tgt_destroy(l_precinct->incltree);
+                                                        l_precinct->incltree = 00;
+                                                        opj_tgt_destroy(l_precinct->imsbtree);
+                                                        l_precinct->imsbtree = 00;
+                                                        (*l_tcd_code_block_deallocate) (l_precinct);
+                                                        ++l_precinct;
+                                                }
+
+                                                opj_free(l_band->precincts);
+                                                l_band->precincts = 00;
+                                        }
+                                        ++l_band;
+                                } /* for (resno */
+                                ++l_res;
+                        }
+
+                        opj_free(l_tile_comp->resolutions);
+                        l_tile_comp->resolutions = 00;
+                }
+
+                if (l_tile_comp->data) {
+                        opj_free(l_tile_comp->data);
+                        l_tile_comp->data = 00;
+                }
+                ++l_tile_comp;
+        }
+
+        opj_free(l_tile->comps);
+        l_tile->comps = 00;
+        opj_free(p_tcd->tcd_image->tiles);
+        p_tcd->tcd_image->tiles = 00;
 }
 
-void tcd_makelayer(opj_tcd_t *tcd, int layno, double thresh, int final) {
-	int compno, resno, bandno, precno, cblkno, passno;
-	
-	opj_tcd_tile_t *tcd_tile = tcd->tcd_tile;
-
-	tcd_tile->distolayer[layno] = 0;	/* fixed_quality */
-	
-	for (compno = 0; compno < tcd_tile->numcomps; compno++) {
-		opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];
-		for (resno = 0; resno < tilec->numresolutions; resno++) {
-			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
-			for (bandno = 0; bandno < res->numbands; bandno++) {
-				opj_tcd_band_t *band = &res->bands[bandno];
-				for (precno = 0; precno < res->pw * res->ph; precno++) {
-					opj_tcd_precinct_t *prc = &band->precincts[precno];
-					for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-						opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];
-						opj_tcd_layer_t *layer = &cblk->layers[layno];
-						
-						int n;
-						if (layno == 0) {
-							cblk->numpassesinlayers = 0;
-						}
-						n = cblk->numpassesinlayers;
-						for (passno = cblk->numpassesinlayers; passno < cblk->totalpasses; passno++) {
-							int dr;
-							double dd;
-							opj_tcd_pass_t *pass = &cblk->passes[passno];
-							if (n == 0) {
-								dr = pass->rate;
-								dd = pass->distortiondec;
-							} else {
-								dr = pass->rate - cblk->passes[n - 1].rate;
-								dd = pass->distortiondec - cblk->passes[n - 1].distortiondec;
-							}
-							if (!dr) {
-								if (dd != 0)
-									n = passno + 1;
-								continue;
-							}
-							if (dd / dr >= thresh)
-								n = passno + 1;
-						}
-						layer->numpasses = n - cblk->numpassesinlayers;
-						
-						if (!layer->numpasses) {
-							layer->disto = 0;
-							continue;
-						}
-						if (cblk->numpassesinlayers == 0) {
-							layer->len = cblk->passes[n - 1].rate;
-							layer->data = cblk->data;
-							layer->disto = cblk->passes[n - 1].distortiondec;
-						} else {
-							layer->len = cblk->passes[n - 1].rate -	cblk->passes[cblk->numpassesinlayers - 1].rate;
-							layer->data = cblk->data + cblk->passes[cblk->numpassesinlayers - 1].rate;
-							layer->disto = cblk->passes[n - 1].distortiondec - cblk->passes[cblk->numpassesinlayers - 1].distortiondec;
-						}
-						
-						tcd_tile->distolayer[layno] += layer->disto;	/* fixed_quality */
-						
-						if (final)
-							cblk->numpassesinlayers = n;
-					}
-				}
-			}
-		}
-	}
+
+OPJ_BOOL opj_tcd_t2_decode (opj_tcd_t *p_tcd,
+                            OPJ_BYTE * p_src_data,
+                            OPJ_UINT32 * p_data_read,
+                            OPJ_UINT32 p_max_src_size,
+                            opj_codestream_index_t *p_cstr_index
+                            )
+{
+        opj_t2_t * l_t2;
+
+        l_t2 = opj_t2_create(p_tcd->image, p_tcd->cp);
+        if (l_t2 == 00) {
+                return OPJ_FALSE;
+        }
+
+        if (! opj_t2_decode_packets(
+                                        l_t2,
+                                        p_tcd->tcd_tileno,
+                                        p_tcd->tcd_image->tiles,
+                                        p_src_data,
+                                        p_data_read,
+                                        p_max_src_size,
+                                        p_cstr_index)) {
+                opj_t2_destroy(l_t2);
+                return OPJ_FALSE;
+        }
+
+        opj_t2_destroy(l_t2);
+
+        /*---------------CLEAN-------------------*/
+        return OPJ_TRUE;
 }
 
-opj_bool tcd_rateallocate(opj_tcd_t *tcd, unsigned char *dest, int len, opj_codestream_info_t *cstr_info) {
-	int compno, resno, bandno, precno, cblkno, passno, layno;
-	double min, max;
-	double cumdisto[100];	/* fixed_quality */
-	const double K = 1;		/* 1.1; fixed_quality */
-	double maxSE = 0;
-
-	opj_cp_t *cp = tcd->cp;
-	opj_tcd_tile_t *tcd_tile = tcd->tcd_tile;
-	opj_tcp_t *tcd_tcp = tcd->tcp;
-
-	min = DBL_MAX;
-	max = 0;
-	
-	tcd_tile->numpix = 0;		/* fixed_quality */
-	
-	for (compno = 0; compno < tcd_tile->numcomps; compno++) {
-		opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];
-		tilec->numpix = 0;
-
-		for (resno = 0; resno < tilec->numresolutions; resno++) {
-			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
-
-			for (bandno = 0; bandno < res->numbands; bandno++) {
-				opj_tcd_band_t *band = &res->bands[bandno];
-
-				for (precno = 0; precno < res->pw * res->ph; precno++) {
-					opj_tcd_precinct_t *prc = &band->precincts[precno];
-
-					for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-						opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];
-
-						for (passno = 0; passno < cblk->totalpasses; passno++) {
-							opj_tcd_pass_t *pass = &cblk->passes[passno];
-							int dr;
-							double dd, rdslope;
-							if (passno == 0) {
-								dr = pass->rate;
-								dd = pass->distortiondec;
-							} else {
-								dr = pass->rate - cblk->passes[passno - 1].rate;
-								dd = pass->distortiondec - cblk->passes[passno - 1].distortiondec;
-							}
-							if (dr == 0) {
-								continue;
-							}
-							rdslope = dd / dr;
-							if (rdslope < min) {
-								min = rdslope;
-							}
-							if (rdslope > max) {
-								max = rdslope;
-							}
-						} /* passno */
-						
-						/* fixed_quality */
-						tcd_tile->numpix += ((cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0));
-						tilec->numpix += ((cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0));
-					} /* cbklno */
-				} /* precno */
-			} /* bandno */
-		} /* resno */
-		
-		maxSE += (((double)(1 << tcd->image->comps[compno].prec) - 1.0) 
-			* ((double)(1 << tcd->image->comps[compno].prec) -1.0)) 
-			* ((double)(tilec->numpix));
-	} /* compno */
-	
-	/* index file */
-	if(cstr_info) {
-		opj_tile_info_t *tile_info = &cstr_info->tile[tcd->tcd_tileno];
-		tile_info->numpix = tcd_tile->numpix;
-		tile_info->distotile = tcd_tile->distotile;
-		tile_info->thresh = (double *) opj_malloc(tcd_tcp->numlayers * sizeof(double));
-	}
-	
-	for (layno = 0; layno < tcd_tcp->numlayers; layno++) {
-		double lo = min;
-		double hi = max;
-		int success = 0;
-		int maxlen = tcd_tcp->rates[layno] ? int_min(((int) ceil(tcd_tcp->rates[layno])), len) : len;
-		double goodthresh = 0;
-		double stable_thresh = 0;
-		int i;
-		double distotarget;		/* fixed_quality */
-		
-		/* fixed_quality */
-		distotarget = tcd_tile->distotile - ((K * maxSE) / pow((float)10, tcd_tcp->distoratio[layno] / 10));
-        
-		/* Don't try to find an optimal threshold but rather take everything not included yet, if
-		  -r xx,yy,zz,0   (disto_alloc == 1 and rates == 0)
-		  -q xx,yy,zz,0	  (fixed_quality == 1 and distoratio == 0)
-		  ==> possible to have some lossy layers and the last layer for sure lossless */
-		if ( ((cp->disto_alloc==1) && (tcd_tcp->rates[layno]>0)) || ((cp->fixed_quality==1) && (tcd_tcp->distoratio[layno]>0))) {
-			opj_t2_t *t2 = t2_create(tcd->cinfo, tcd->image, cp);
-			double thresh = 0;
-
-			for (i = 0; i < 128; i++) {
-				int l = 0;
-				double distoachieved = 0;	/* fixed_quality */
-				thresh = (lo + hi) / 2;
-				
-				tcd_makelayer(tcd, layno, thresh, 0);
-				
-				if (cp->fixed_quality) {	/* fixed_quality */
-					if(cp->cinema){
-						l = t2_encode_packets(t2,tcd->tcd_tileno, tcd_tile, layno + 1, dest, maxlen, cstr_info,tcd->cur_tp_num,tcd->tp_pos,tcd->cur_pino,THRESH_CALC, tcd->cur_totnum_tp);
-						if (l == -999) {
-							lo = thresh;
-							continue;
-						}else{
-           		distoachieved =	layno == 0 ? 
-							tcd_tile->distolayer[0]	: cumdisto[layno - 1] + tcd_tile->distolayer[layno];
-							if (distoachieved < distotarget) {
-								hi=thresh; 
-								stable_thresh = thresh;
-								continue;
-							}else{
-								lo=thresh;
-							}
-						}
-					}else{
-						distoachieved =	(layno == 0) ? 
-							tcd_tile->distolayer[0]	: (cumdisto[layno - 1] + tcd_tile->distolayer[layno]);
-						if (distoachieved < distotarget) {
-							hi = thresh;
-							stable_thresh = thresh;
-							continue;
-						}
-						lo = thresh;
-					}
-				} else {
-					l = t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1, dest, maxlen, cstr_info,tcd->cur_tp_num,tcd->tp_pos,tcd->cur_pino,THRESH_CALC, tcd->cur_totnum_tp);
-					/* TODO: what to do with l ??? seek / tell ??? */
-					/* opj_event_msg(tcd->cinfo, EVT_INFO, "rate alloc: len=%d, max=%d\n", l, maxlen); */
-					if (l == -999) {
-						lo = thresh;
-						continue;
-					}
-					hi = thresh;
-					stable_thresh = thresh;
-				}
-			}
-			success = 1;
-			goodthresh = stable_thresh == 0? thresh : stable_thresh;
-			t2_destroy(t2);
-		} else {
-			success = 1;
-			goodthresh = min;
-		}
-		
-		if (!success) {
-			return OPJ_FALSE;
-		}
-		
-		if(cstr_info) {	/* Threshold for Marcela Index */
-			cstr_info->tile[tcd->tcd_tileno].thresh[layno] = goodthresh;
-		}
-		tcd_makelayer(tcd, layno, goodthresh, 1);
-        
-		/* fixed_quality */
-		cumdisto[layno] = (layno == 0) ? tcd_tile->distolayer[0] : (cumdisto[layno - 1] + tcd_tile->distolayer[layno]);	
-	}
-
-	return OPJ_TRUE;
+OPJ_BOOL opj_tcd_t1_decode ( opj_tcd_t *p_tcd )
+{
+        OPJ_UINT32 compno;
+        opj_t1_t * l_t1;
+        opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;
+        opj_tcd_tilecomp_t* l_tile_comp = l_tile->comps;
+        opj_tccp_t * l_tccp = p_tcd->tcp->tccps;
+
+
+        l_t1 = opj_t1_create();
+        if (l_t1 == 00) {
+                return OPJ_FALSE;
+        }
+
+        for (compno = 0; compno < l_tile->numcomps; ++compno) {
+                /* The +3 is headroom required by the vectorized DWT */
+                if (OPJ_FALSE == opj_t1_decode_cblks(l_t1, l_tile_comp, l_tccp)) {
+                        opj_t1_destroy(l_t1);
+                        return OPJ_FALSE;
+                }
+                ++l_tile_comp;
+                ++l_tccp;
+        }
+
+        opj_t1_destroy(l_t1);
+
+        return OPJ_TRUE;
 }
 
-int tcd_encode_tile(opj_tcd_t *tcd, int tileno, unsigned char *dest, int len, opj_codestream_info_t *cstr_info) {
-	int compno;
-	int l, i, numpacks = 0;
-	opj_tcd_tile_t *tile = NULL;
-	opj_tcp_t *tcd_tcp = NULL;
-	opj_cp_t *cp = NULL;
-
-	opj_tcp_t *tcp = &tcd->cp->tcps[0];
-	opj_tccp_t *tccp = &tcp->tccps[0];
-	opj_image_t *image = tcd->image;
-	
-	opj_t1_t *t1 = NULL;		/* T1 component */
-	opj_t2_t *t2 = NULL;		/* T2 component */
-
-	tcd->tcd_tileno = tileno;
-	tcd->tcd_tile = tcd->tcd_image->tiles;
-	tcd->tcp = &tcd->cp->tcps[tileno];
-
-	tile = tcd->tcd_tile;
-	tcd_tcp = tcd->tcp;
-	cp = tcd->cp;
-
-	if(tcd->cur_tp_num == 0){
-		tcd->encoding_time = opj_clock();	/* time needed to encode a tile */
-		/* INDEX >> "Precinct_nb_X et Precinct_nb_Y" */
-		if(cstr_info) {
-			opj_tcd_tilecomp_t *tilec_idx = &tile->comps[0];	/* based on component 0 */
-			for (i = 0; i < tilec_idx->numresolutions; i++) {
-				opj_tcd_resolution_t *res_idx = &tilec_idx->resolutions[i];
-				
-				cstr_info->tile[tileno].pw[i] = res_idx->pw;
-				cstr_info->tile[tileno].ph[i] = res_idx->ph;
-				
-				numpacks += res_idx->pw * res_idx->ph;
-				
-				cstr_info->tile[tileno].pdx[i] = tccp->prcw[i];
-				cstr_info->tile[tileno].pdy[i] = tccp->prch[i];
-			}
-			cstr_info->tile[tileno].packet = (opj_packet_info_t*) opj_calloc(cstr_info->numcomps * cstr_info->numlayers * numpacks, sizeof(opj_packet_info_t));
-		}
-		/* << INDEX */
-		
-		/*---------------TILE-------------------*/
-		
-		for (compno = 0; compno < tile->numcomps; compno++) {
-			int x, y;
-			
-			int adjust = image->comps[compno].sgnd ? 0 : 1 << (image->comps[compno].prec - 1);
-			int offset_x = int_ceildiv(image->x0, image->comps[compno].dx);
-			int offset_y = int_ceildiv(image->y0, image->comps[compno].dy);
-			
-			opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
-			int tw = tilec->x1 - tilec->x0;
-			int w = int_ceildiv(image->x1 - image->x0, image->comps[compno].dx);
-			
-			/* extract tile data */
-			
-			if (tcd_tcp->tccps[compno].qmfbid == 1) {
-				for (y = tilec->y0; y < tilec->y1; y++) {
-					/* start of the src tile scanline */
-					int *data = &image->comps[compno].data[(tilec->x0 - offset_x) + (y - offset_y) * w];
-					/* start of the dst tile scanline */
-					int *tile_data = &tilec->data[(y - tilec->y0) * tw];
-					for (x = tilec->x0; x < tilec->x1; x++) {
-						*tile_data++ = *data++ - adjust;
-					}
-				}
-			} else if (tcd_tcp->tccps[compno].qmfbid == 0) {
-				for (y = tilec->y0; y < tilec->y1; y++) {
-					/* start of the src tile scanline */
-					int *data = &image->comps[compno].data[(tilec->x0 - offset_x) + (y - offset_y) * w];
-					/* start of the dst tile scanline */
-					int *tile_data = &tilec->data[(y - tilec->y0) * tw];
-					for (x = tilec->x0; x < tilec->x1; x++) {
-						*tile_data++ = (*data++ - adjust) << 11;
-					}
-					
-				}
-			}
-		}
-		
-		/*----------------MCT-------------------*/
-		if (tcd_tcp->mct) {
-			int samples = (tile->comps[0].x1 - tile->comps[0].x0) * (tile->comps[0].y1 - tile->comps[0].y0);
-			if (tcd_tcp->tccps[0].qmfbid == 0) {
-				mct_encode_real(tile->comps[0].data, tile->comps[1].data, tile->comps[2].data, samples);
-			} else {
-				mct_encode(tile->comps[0].data, tile->comps[1].data, tile->comps[2].data, samples);
-			}
-		}
-		
-		/*----------------DWT---------------------*/
-		
-		for (compno = 0; compno < tile->numcomps; compno++) {
-			opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
-			if (tcd_tcp->tccps[compno].qmfbid == 1) {
-				dwt_encode(tilec);
-			} else if (tcd_tcp->tccps[compno].qmfbid == 0) {
-				dwt_encode_real(tilec);
-			}
-		}
-		
-		/*------------------TIER1-----------------*/
-		t1 = t1_create(tcd->cinfo);
-		t1_encode_cblks(t1, tile, tcd_tcp);
-		t1_destroy(t1);
-		
-		/*-----------RATE-ALLOCATE------------------*/
-		
-		/* INDEX */
-		if(cstr_info) {
-			cstr_info->index_write = 0;
-		}
-		if (cp->disto_alloc || cp->fixed_quality) {	/* fixed_quality */
-			/* Normal Rate/distortion allocation */
-			tcd_rateallocate(tcd, dest, len, cstr_info);
-		} else {
-			/* Fixed layer allocation */
-			tcd_rateallocate_fixed(tcd);
-		}
-	}
-	/*--------------TIER2------------------*/
-
-	/* INDEX */
-	if(cstr_info) {
-		cstr_info->index_write = 1;
-	}
-
-	t2 = t2_create(tcd->cinfo, image, cp);
-	l = t2_encode_packets(t2,tileno, tile, tcd_tcp->numlayers, dest, len, cstr_info,tcd->tp_num,tcd->tp_pos,tcd->cur_pino,FINAL_PASS,tcd->cur_totnum_tp);
-	t2_destroy(t2);
-	
-	/*---------------CLEAN-------------------*/
-
-	
-	if(tcd->cur_tp_num == tcd->cur_totnum_tp - 1){
-		tcd->encoding_time = opj_clock() - tcd->encoding_time;
-		opj_event_msg(tcd->cinfo, EVT_INFO, "- tile encoded in %f s\n", tcd->encoding_time);
-
-		/* cleaning memory */
-		for (compno = 0; compno < tile->numcomps; compno++) {
-			opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
-			opj_aligned_free(tilec->data);
-		}
-	}
-
-	return l;
+
+OPJ_BOOL opj_tcd_dwt_decode ( opj_tcd_t *p_tcd )
+{
+        OPJ_UINT32 compno;
+        opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;
+        opj_tcd_tilecomp_t * l_tile_comp = l_tile->comps;
+        opj_tccp_t * l_tccp = p_tcd->tcp->tccps;
+        opj_image_comp_t * l_img_comp = p_tcd->image->comps;
+
+        for (compno = 0; compno < l_tile->numcomps; compno++) {
+                /*
+                if (tcd->cp->reduce != 0) {
+                        tcd->image->comps[compno].resno_decoded =
+                                tile->comps[compno].numresolutions - tcd->cp->reduce - 1;
+                        if (tcd->image->comps[compno].resno_decoded < 0)
+                        {
+                                return false;
+                        }
+                }
+                numres2decode = tcd->image->comps[compno].resno_decoded + 1;
+                if(numres2decode > 0){
+                */
+
+                if (l_tccp->qmfbid == 1) {
+                        if (! opj_dwt_decode(l_tile_comp, l_img_comp->resno_decoded+1)) {
+                                return OPJ_FALSE;
+                        }
+                }
+                else {
+                        if (! opj_dwt_decode_real(l_tile_comp, l_img_comp->resno_decoded+1)) {
+                                return OPJ_FALSE;
+                        }
+                }
+
+                ++l_tile_comp;
+                ++l_img_comp;
+                ++l_tccp;
+        }
+
+        return OPJ_TRUE;
 }
+OPJ_BOOL opj_tcd_mct_decode ( opj_tcd_t *p_tcd )
+{
+        opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;
+        opj_tcp_t * l_tcp = p_tcd->tcp;
+        opj_tcd_tilecomp_t * l_tile_comp = l_tile->comps;
+        OPJ_UINT32 l_samples,i;
+
+        if (! l_tcp->mct) {
+                return OPJ_TRUE;
+        }
 
-opj_bool tcd_decode_tile(opj_tcd_t *tcd, unsigned char *src, int len, int tileno, opj_codestream_info_t *cstr_info) {
-	int l;
-	int compno;
-	int eof = 0;
-	double tile_time, t1_time, dwt_time;
-	opj_tcd_tile_t *tile = NULL;
-
-	opj_t1_t *t1 = NULL;		/* T1 component */
-	opj_t2_t *t2 = NULL;		/* T2 component */
-	
-	tcd->tcd_tileno = tileno;
-	tcd->tcd_tile = &(tcd->tcd_image->tiles[tileno]);
-	tcd->tcp = &(tcd->cp->tcps[tileno]);
-	tile = tcd->tcd_tile;
-	
-	tile_time = opj_clock();	/* time needed to decode a tile */
-	opj_event_msg(tcd->cinfo, EVT_INFO, "tile %d of %d\n", tileno + 1, tcd->cp->tw * tcd->cp->th);
-
-	/* INDEX >>  */
-	if(cstr_info) {
-		int resno, compno, numprec = 0;
-		for (compno = 0; compno < cstr_info->numcomps; compno++) {
-			opj_tcp_t *tcp = &tcd->cp->tcps[0];
-			opj_tccp_t *tccp = &tcp->tccps[compno];
-			opj_tcd_tilecomp_t *tilec_idx = &tile->comps[compno];	
-			for (resno = 0; resno < tilec_idx->numresolutions; resno++) {
-				opj_tcd_resolution_t *res_idx = &tilec_idx->resolutions[resno];
-				cstr_info->tile[tileno].pw[resno] = res_idx->pw;
-				cstr_info->tile[tileno].ph[resno] = res_idx->ph;
-				numprec += res_idx->pw * res_idx->ph;
-				if (tccp->csty & J2K_CP_CSTY_PRT) {
-					cstr_info->tile[tileno].pdx[resno] = tccp->prcw[resno];
-					cstr_info->tile[tileno].pdy[resno] = tccp->prch[resno];
-				}
-				else {
-					cstr_info->tile[tileno].pdx[resno] = 15;
-					cstr_info->tile[tileno].pdy[resno] = 15;
-				}
-			}
-		}
-		cstr_info->tile[tileno].packet = (opj_packet_info_t *) opj_malloc(cstr_info->numlayers * numprec * sizeof(opj_packet_info_t));
-		cstr_info->packno = 0;
-	}
-	/* << INDEX */
-	
-	/*--------------TIER2------------------*/
-	
-	t2 = t2_create(tcd->cinfo, tcd->image, tcd->cp);
-	l = t2_decode_packets(t2, src, len, tileno, tile, cstr_info);
-	t2_destroy(t2);
-
-	if (l == -999) {
-		eof = 1;
-		opj_event_msg(tcd->cinfo, EVT_ERROR, "tcd_decode: incomplete bistream\n");
-    return OPJ_FALSE;
-	}
-	
-	/*------------------TIER1-----------------*/
-	
-	t1_time = opj_clock();	/* time needed to decode a tile */
-	t1 = t1_create(tcd->cinfo);
-    if (t1 == NULL)
-    {
-        opj_event_msg(tcd->cinfo, EVT_ERROR, "Out of memory\n");
-        t1_destroy(t1);
-        return OPJ_FALSE;
-    }
-
-	for (compno = 0; compno < tile->numcomps; ++compno) {
-		opj_tcd_tilecomp_t* tilec = &tile->comps[compno];
-		/* The +3 is headroom required by the vectorized DWT */
-		tilec->data = (int*) opj_aligned_malloc((((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0))+3) * sizeof(int));
-        if (tilec->data == NULL)
-        {
-            opj_event_msg(tcd->cinfo, EVT_ERROR, "Out of memory\n");
-            t1_destroy(t1);
-            return OPJ_FALSE;
+        l_samples = (OPJ_UINT32)((l_tile_comp->x1 - l_tile_comp->x0) * (l_tile_comp->y1 - l_tile_comp->y0));
+
+        if (l_tile->numcomps >= 3 ){
+                /* testcase 1336.pdf.asan.47.376 */
+                if ((l_tile->comps[0].x1 - l_tile->comps[0].x0) * (l_tile->comps[0].y1 - l_tile->comps[0].y0) < (OPJ_INT32)l_samples ||
+                    (l_tile->comps[1].x1 - l_tile->comps[1].x0) * (l_tile->comps[1].y1 - l_tile->comps[1].y0) < (OPJ_INT32)l_samples ||
+                    (l_tile->comps[2].x1 - l_tile->comps[2].x0) * (l_tile->comps[2].y1 - l_tile->comps[2].y0) < (OPJ_INT32)l_samples) {
+                        fprintf(stderr, "Tiles don't all have the same dimension. Skip the MCT step.\n");
+                        return OPJ_FALSE;
+                }
+                else if (l_tcp->mct == 2) {
+                        OPJ_BYTE ** l_data;
+
+                        if (! l_tcp->m_mct_decoding_matrix) {
+                                return OPJ_TRUE;
+                        }
+
+                        l_data = (OPJ_BYTE **) opj_malloc(l_tile->numcomps*sizeof(OPJ_BYTE*));
+                        if (! l_data) {
+                                return OPJ_FALSE;
+                        }
+
+                        for (i=0;i<l_tile->numcomps;++i) {
+                                l_data[i] = (OPJ_BYTE*) l_tile_comp->data;
+                                ++l_tile_comp;
+                        }
+
+                        if (! opj_mct_decode_custom(/* MCT data */
+                                                                        (OPJ_BYTE*) l_tcp->m_mct_decoding_matrix,
+                                                                        /* size of components */
+                                                                        l_samples,
+                                                                        /* components */
+                                                                        l_data,
+                                                                        /* nb of components (i.e. size of pData) */
+                                                                        l_tile->numcomps,
+                                                                        /* tells if the data is signed */
+                                                                        p_tcd->image->comps->sgnd)) {
+                                opj_free(l_data);
+                                return OPJ_FALSE;
+                        }
+
+                        opj_free(l_data);
+                }
+                else {
+                        if (l_tcp->tccps->qmfbid == 1) {
+                                opj_mct_decode(     l_tile->comps[0].data,
+                                                        l_tile->comps[1].data,
+                                                        l_tile->comps[2].data,
+                                                        l_samples);
+                        }
+                        else {
+                            opj_mct_decode_real((OPJ_FLOAT32*)l_tile->comps[0].data,
+                                                (OPJ_FLOAT32*)l_tile->comps[1].data,
+                                                (OPJ_FLOAT32*)l_tile->comps[2].data,
+                                                l_samples);
+                        }
+                }
+        }
+        else {
+                /* FIXME need to use opj_event_msg function */
+                fprintf(stderr,"Number of components (%d) is inconsistent with a MCT. Skip the MCT step.\n",l_tile->numcomps);
         }
 
-		t1_decode_cblks(t1, tilec, &tcd->tcp->tccps[compno]);
-	}
-	t1_destroy(t1);
-	t1_time = opj_clock() - t1_time;
-	opj_event_msg(tcd->cinfo, EVT_INFO, "- tiers-1 took %f s\n", t1_time);
-	
-	/*----------------DWT---------------------*/
-
-	dwt_time = opj_clock();	/* time needed to decode a tile */
-	for (compno = 0; compno < tile->numcomps; compno++) {
-		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
-		int numres2decode;
-
-		if (tcd->cp->reduce != 0) {
-			if ( tile->comps[compno].numresolutions < ( tcd->cp->reduce - 1 ) ) {				
-				opj_event_msg(tcd->cinfo, EVT_ERROR, "Error decoding tile. The number of resolutions to remove [%d+1] is higher than the number "
-					" of resolutions in the original codestream [%d]\nModify the cp_reduce parameter.\n", tcd->cp->reduce, tile->comps[compno].numresolutions);
-				return OPJ_FALSE;
-			}
-      else {
-		  	tcd->image->comps[compno].resno_decoded =
-				tile->comps[compno].numresolutions - tcd->cp->reduce - 1;
-      }
-		}
-
-		numres2decode = tcd->image->comps[compno].resno_decoded + 1;
-		if(numres2decode > 0){
-			if (tcd->tcp->tccps[compno].qmfbid == 1) {
-				dwt_decode(tilec, numres2decode);
-			} else {
-				dwt_decode_real(tilec, numres2decode);
-			}
-		}
-	}
-	dwt_time = opj_clock() - dwt_time;
-	opj_event_msg(tcd->cinfo, EVT_INFO, "- dwt took %f s\n", dwt_time);
-
-	/*----------------MCT-------------------*/
-
-	if (tcd->tcp->mct) {
-		int n = (tile->comps[0].x1 - tile->comps[0].x0) * (tile->comps[0].y1 - tile->comps[0].y0);
-
-		if (tile->numcomps >= 3 ){
-      /* testcase 1336.pdf.asan.47.376 */
-      if ((tile->comps[0].x1 - tile->comps[0].x0) * (tile->comps[0].y1 - tile->comps[0].y0) < n ||
-        (  tile->comps[1].x1 - tile->comps[1].x0) * (tile->comps[1].y1 - tile->comps[1].y0) < n ||
-        (  tile->comps[2].x1 - tile->comps[2].x0) * (tile->comps[2].y1 - tile->comps[2].y0) < n) {
-        opj_event_msg(tcd->cinfo, EVT_ERROR, "Tiles don't all have the same dimension. Skip the MCT step.\n");
-        return OPJ_FALSE;
-      }
-			if (tcd->tcp->tccps[0].qmfbid == 1) {
-				mct_decode(
-						tile->comps[0].data,
-						tile->comps[1].data,
-						tile->comps[2].data,
-						n);
-			} else {
-				mct_decode_real(
-						(float*)tile->comps[0].data,
-						(float*)tile->comps[1].data,
-						(float*)tile->comps[2].data,
-						n);
-			}
-		} else{
-			opj_event_msg(tcd->cinfo, EVT_WARNING,"Number of components (%d) is inconsistent with a MCT. Skip the MCT step.\n",tile->numcomps);
-		}
-	}
-
-	/*---------------TILE-------------------*/
-
-	for (compno = 0; compno < tile->numcomps; ++compno) {
-		opj_tcd_tilecomp_t* tilec = &tile->comps[compno];
-		opj_image_comp_t* imagec = &tcd->image->comps[compno];
-		opj_tcd_resolution_t* res = &tilec->resolutions[imagec->resno_decoded];
-		int adjust = imagec->sgnd ? 0 : 1 << (imagec->prec - 1);
-		int min = imagec->sgnd ? -(1 << (imagec->prec - 1)) : 0;
-		int max = imagec->sgnd ?  (1 << (imagec->prec - 1)) - 1 : (1 << imagec->prec) - 1;
-
-		int tw = tilec->x1 - tilec->x0;
-		int w = imagec->w;
-
-		int i, j;
-		int offset_x = int_ceildivpow2(imagec->x0, imagec->factor);
-		int offset_y = int_ceildivpow2(imagec->y0, imagec->factor);
-    /* NR-DEC-2977.pdf.asan.67.2198.jp2-52-decode */
-    if( res->x0 - offset_x < 0 || res->x1 - offset_x < 0
-     || res->y0 - offset_y < 0 || res->y1 - offset_y < 0 )
-      {
-      opj_event_msg(tcd->cinfo, EVT_ERROR, "Impossible offsets %d / %d\n", offset_x, offset_y);
-      return OPJ_FALSE;
-      }
-    assert( 0 <= res->x0 - offset_x && 0 <= res->x1 - offset_x );
-    assert( 0 <= res->y0 - offset_y && 0 <= res->y1 - offset_y );
-
-		if(!imagec->data){
-			imagec->data = (int*) opj_malloc(imagec->w * imagec->h * sizeof(int));
-		}
-        if (!imagec->data)
-        {
-            opj_event_msg(tcd->cinfo, EVT_ERROR, "Out of memory\n");
-            return OPJ_FALSE;
+        return OPJ_TRUE;
+}
+
+
+OPJ_BOOL opj_tcd_dc_level_shift_decode ( opj_tcd_t *p_tcd )
+{
+        OPJ_UINT32 compno;
+        opj_tcd_tilecomp_t * l_tile_comp = 00;
+        opj_tccp_t * l_tccp = 00;
+        opj_image_comp_t * l_img_comp = 00;
+        opj_tcd_resolution_t* l_res = 00;
+        opj_tcd_tile_t * l_tile;
+        OPJ_UINT32 l_width,l_height,i,j;
+        OPJ_INT32 * l_current_ptr;
+        OPJ_INT32 l_min, l_max;
+        OPJ_UINT32 l_stride;
+
+        l_tile = p_tcd->tcd_image->tiles;
+        l_tile_comp = l_tile->comps;
+        l_tccp = p_tcd->tcp->tccps;
+        l_img_comp = p_tcd->image->comps;
+
+        for (compno = 0; compno < l_tile->numcomps; compno++) {
+                l_res = l_tile_comp->resolutions + l_img_comp->resno_decoded;
+                l_width = (OPJ_UINT32)(l_res->x1 - l_res->x0);
+                l_height = (OPJ_UINT32)(l_res->y1 - l_res->y0);
+                l_stride = (OPJ_UINT32)(l_tile_comp->x1 - l_tile_comp->x0) - l_width;
+
+                assert(l_height == 0 || l_width + l_stride <= l_tile_comp->data_size / l_height); /*MUPDF*/
+
+                if (l_img_comp->sgnd) {
+                        l_min = -(1 << (l_img_comp->prec - 1));
+                        l_max = (1 << (l_img_comp->prec - 1)) - 1;
+                }
+                else {
+            l_min = 0;
+                        l_max = (1 << l_img_comp->prec) - 1;
+                }
+
+                l_current_ptr = l_tile_comp->data;
+
+                if (l_tccp->qmfbid == 1) {
+                        for (j=0;j<l_height;++j) {
+                                for (i = 0; i < l_width; ++i) {
+                                        *l_current_ptr = opj_int_clamp(*l_current_ptr + l_tccp->m_dc_level_shift, l_min, l_max);
+                                        ++l_current_ptr;
+                                }
+                                l_current_ptr += l_stride;
+                        }
+                }
+                else {
+                        for (j=0;j<l_height;++j) {
+                                for (i = 0; i < l_width; ++i) {
+                                        OPJ_FLOAT32 l_value = *((OPJ_FLOAT32 *) l_current_ptr);
+                                        *l_current_ptr = opj_int_clamp((OPJ_INT32)lrintf(l_value) + l_tccp->m_dc_level_shift, l_min, l_max); ;
+                                        ++l_current_ptr;
+                                }
+                                l_current_ptr += l_stride;
+                        }
+                }
+
+                ++l_img_comp;
+                ++l_tccp;
+                ++l_tile_comp;
         }
-		if(tcd->tcp->tccps[compno].qmfbid == 1) {
-			for(j = res->y0; j < res->y1; ++j) {
-				for(i = res->x0; i < res->x1; ++i) {
-					int v = tilec->data[i - res->x0 + (j - res->y0) * tw];
-					v += adjust;
-          /*assert( (i - offset_x) + (j - offset_y) * w >= 0 );*/
-					imagec->data[(i - offset_x) + (j - offset_y) * w] = int_clamp(v, min, max);
-				}
-			}
-		}else{
-			for(j = res->y0; j < res->y1; ++j) {
-				for(i = res->x0; i < res->x1; ++i) {
-					float tmp = ((float*)tilec->data)[i - res->x0 + (j - res->y0) * tw];
-					int v = lrintf(tmp);
-					v += adjust;
-          /*assert( (i - offset_x) + (j - offset_y) * w >= 0 );*/
-					imagec->data[(i - offset_x) + (j - offset_y) * w] = int_clamp(v, min, max);
-				}
-			}
-		}
-		opj_aligned_free(tilec->data);
-	}
-
-	tile_time = opj_clock() - tile_time;	/* time needed to decode a tile */
-	opj_event_msg(tcd->cinfo, EVT_INFO, "- tile decoded in %f s\n", tile_time);
-
-	if (eof) {
-		return OPJ_FALSE;
-	}
-	
-	return OPJ_TRUE;
+
+        return OPJ_TRUE;
 }
 
-void tcd_free_decode(opj_tcd_t *tcd) {
-	opj_tcd_image_t *tcd_image = tcd->tcd_image;	
-    int i = 0;
-    for (i = 0; i < tcd_image->tw * tcd_image->th; i++)
-    {
-        tcd_free_decode_tile(tcd, i);
-    }
 
-	opj_free(tcd_image->tiles);
+
+/**
+ * Deallocates the encoding data of the given precinct.
+ */
+void opj_tcd_code_block_dec_deallocate (opj_tcd_precinct_t * p_precinct)
+{
+        OPJ_UINT32 cblkno , l_nb_code_blocks;
+
+        opj_tcd_cblk_dec_t * l_code_block = p_precinct->cblks.dec;
+        if (l_code_block) {
+                /*fprintf(stderr,"deallocate codeblock:{\n");*/
+                /*fprintf(stderr,"\t x0=%d, y0=%d, x1=%d, y1=%d\n",l_code_block->x0, l_code_block->y0, l_code_block->x1, l_code_block->y1);*/
+                /*fprintf(stderr,"\t numbps=%d, numlenbits=%d, len=%d, numnewpasses=%d, real_num_segs=%d, m_current_max_segs=%d\n ",
+                                l_code_block->numbps, l_code_block->numlenbits, l_code_block->len, l_code_block->numnewpasses, l_code_block->real_num_segs, l_code_block->m_current_max_segs );*/
+
+
+                l_nb_code_blocks = p_precinct->block_size / sizeof(opj_tcd_cblk_dec_t);
+                /*fprintf(stderr,"nb_code_blocks =%d\t}\n", l_nb_code_blocks);*/
+
+                for (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno) {
+
+                        if (l_code_block->data) {
+                                opj_free(l_code_block->data);
+                                l_code_block->data = 00;
+                        }
+
+                        if (l_code_block->segs) {
+                                opj_free(l_code_block->segs );
+                                l_code_block->segs = 00;
+                        }
+
+                        ++l_code_block;
+                }
+
+                opj_free(p_precinct->cblks.dec);
+                p_precinct->cblks.dec = 00;
+        }
 }
 
-void tcd_free_decode_tile(opj_tcd_t *tcd, int tileno) {
-    int compno,resno,bandno,precno,cblkno;
-
-	opj_tcd_image_t *tcd_image = tcd->tcd_image;
-
-	opj_tcd_tile_t *tile = &tcd_image->tiles[tileno];
-    if (tile->comps != NULL) {
-        for (compno = 0; compno < tile->numcomps; compno++) {
-            opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
-            for (resno = 0; resno < tilec->numresolutions; resno++) {
-                opj_tcd_resolution_t *res = &tilec->resolutions[resno];
-                for (bandno = 0; bandno < res->numbands; bandno++) {
-                    opj_tcd_band_t *band = &res->bands[bandno];
-                    for (precno = 0; precno < res->ph * res->pw; precno++) {
-                        opj_tcd_precinct_t *prec = &band->precincts[precno];
-                        if (prec->cblks.dec != NULL) {
-                            for (cblkno = 0; cblkno < prec->cw * prec->ch; ++cblkno) {
-                                opj_tcd_cblk_dec_t* cblk = &prec->cblks.dec[cblkno];
-                                opj_free(cblk->data);
-                                opj_free(cblk->segs);
-                            }
-                            opj_free(prec->cblks.dec);
+/**
+ * Deallocates the encoding data of the given precinct.
+ */
+void opj_tcd_code_block_enc_deallocate (opj_tcd_precinct_t * p_precinct)
+{       
+        OPJ_UINT32 cblkno , l_nb_code_blocks;
+
+        opj_tcd_cblk_enc_t * l_code_block = p_precinct->cblks.enc;
+        if (l_code_block) {
+                l_nb_code_blocks = p_precinct->block_size / sizeof(opj_tcd_cblk_enc_t);
+                
+                for     (cblkno = 0; cblkno < l_nb_code_blocks; ++cblkno)  {
+                        if (l_code_block->data) {
+                                opj_free(l_code_block->data - 1);
+                                l_code_block->data = 00;
+                        }
+
+                        if (l_code_block->layers) {
+                                opj_free(l_code_block->layers );
+                                l_code_block->layers = 00;
                         }
-                        if (prec->imsbtree != NULL) tgt_destroy(prec->imsbtree);
-                        if (prec->incltree != NULL) tgt_destroy(prec->incltree);
-
-
-                    }
-                    opj_free(band->precincts);
-				}
-			}
-            opj_free(tilec->resolutions);
-		}
-        opj_free(tile->comps);
-        tile->comps = NULL;
-	}
+
+                        if (l_code_block->passes) {
+                                opj_free(l_code_block->passes );
+                                l_code_block->passes = 00;
+                        }
+                        ++l_code_block;
+                }
+
+                opj_free(p_precinct->cblks.enc);
+                
+                p_precinct->cblks.enc = 00;
+        }
+}
+
+OPJ_UINT32 opj_tcd_get_encoded_tile_size ( opj_tcd_t *p_tcd )
+{
+        OPJ_UINT32 i,l_data_size = 0;
+        opj_image_comp_t * l_img_comp = 00;
+        opj_tcd_tilecomp_t * l_tilec = 00;
+        OPJ_UINT32 l_size_comp, l_remaining;
+
+        l_tilec = p_tcd->tcd_image->tiles->comps;
+        l_img_comp = p_tcd->image->comps;
+        for (i=0;i<p_tcd->image->numcomps;++i) {
+                l_size_comp = l_img_comp->prec >> 3; /*(/ 8)*/
+                l_remaining = l_img_comp->prec & 7;  /* (%8) */
+
+                if (l_remaining) {
+                        ++l_size_comp;
+                }
+
+                if (l_size_comp == 3) {
+                        l_size_comp = 4;
+                }
+
+                l_data_size += l_size_comp * (OPJ_UINT32)((l_tilec->x1 - l_tilec->x0) * (l_tilec->y1 - l_tilec->y0));
+                ++l_img_comp;
+                ++l_tilec;
+        }
+
+        return l_data_size;
+}
+                
+OPJ_BOOL opj_tcd_dc_level_shift_encode ( opj_tcd_t *p_tcd )
+{
+        OPJ_UINT32 compno;
+        opj_tcd_tilecomp_t * l_tile_comp = 00;
+        opj_tccp_t * l_tccp = 00;
+        opj_image_comp_t * l_img_comp = 00;
+        opj_tcd_tile_t * l_tile;
+        OPJ_UINT32 l_nb_elem,i;
+        OPJ_INT32 * l_current_ptr;
+
+        l_tile = p_tcd->tcd_image->tiles;
+        l_tile_comp = l_tile->comps;
+        l_tccp = p_tcd->tcp->tccps;
+        l_img_comp = p_tcd->image->comps;
+
+        for (compno = 0; compno < l_tile->numcomps; compno++) {
+                l_current_ptr = l_tile_comp->data;
+                l_nb_elem = (OPJ_UINT32)((l_tile_comp->x1 - l_tile_comp->x0) * (l_tile_comp->y1 - l_tile_comp->y0));
+
+                if (l_tccp->qmfbid == 1) {
+                        for     (i = 0; i < l_nb_elem; ++i) {
+                                *l_current_ptr -= l_tccp->m_dc_level_shift ;
+                                ++l_current_ptr;
+                        }
+                }
+                else {
+                        for (i = 0; i < l_nb_elem; ++i) {
+                                *l_current_ptr = (*l_current_ptr - l_tccp->m_dc_level_shift) << 11 ;
+                                ++l_current_ptr;
+                        }
+                }
+
+                ++l_img_comp;
+                ++l_tccp;
+                ++l_tile_comp;
+        }
+
+        return OPJ_TRUE;
 }
 
+OPJ_BOOL opj_tcd_mct_encode ( opj_tcd_t *p_tcd )
+{
+        opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;
+        opj_tcd_tilecomp_t * l_tile_comp = p_tcd->tcd_image->tiles->comps;
+        OPJ_UINT32 samples = (OPJ_UINT32)((l_tile_comp->x1 - l_tile_comp->x0) * (l_tile_comp->y1 - l_tile_comp->y0));
+        OPJ_UINT32 i;
+        OPJ_BYTE ** l_data = 00;
+        opj_tcp_t * l_tcp = p_tcd->tcp;
+
+        if(!p_tcd->tcp->mct) {
+                return OPJ_TRUE;
+        }
 
+        if (p_tcd->tcp->mct == 2) {
+                if (! p_tcd->tcp->m_mct_coding_matrix) {
+                        return OPJ_TRUE;
+                }
+
+        l_data = (OPJ_BYTE **) opj_malloc(l_tile->numcomps*sizeof(OPJ_BYTE*));
+                if (! l_data) {
+                        return OPJ_FALSE;
+                }
+
+                for (i=0;i<l_tile->numcomps;++i) {
+                        l_data[i] = (OPJ_BYTE*) l_tile_comp->data;
+                        ++l_tile_comp;
+                }
+
+                if (! opj_mct_encode_custom(/* MCT data */
+                                        (OPJ_BYTE*) p_tcd->tcp->m_mct_coding_matrix,
+                                        /* size of components */
+                                        samples,
+                                        /* components */
+                                        l_data,
+                                        /* nb of components (i.e. size of pData) */
+                                        l_tile->numcomps,
+                                        /* tells if the data is signed */
+                                        p_tcd->image->comps->sgnd) )
+                {
+            opj_free(l_data);
+                        return OPJ_FALSE;
+                }
+
+                opj_free(l_data);
+        }
+        else if (l_tcp->tccps->qmfbid == 0) {
+                opj_mct_encode_real(l_tile->comps[0].data, l_tile->comps[1].data, l_tile->comps[2].data, samples);
+        }
+        else {
+                opj_mct_encode(l_tile->comps[0].data, l_tile->comps[1].data, l_tile->comps[2].data, samples);
+        }
+
+        return OPJ_TRUE;
+}
 
+OPJ_BOOL opj_tcd_dwt_encode ( opj_tcd_t *p_tcd )
+{
+        opj_tcd_tile_t * l_tile = p_tcd->tcd_image->tiles;
+        opj_tcd_tilecomp_t * l_tile_comp = p_tcd->tcd_image->tiles->comps;
+        opj_tccp_t * l_tccp = p_tcd->tcp->tccps;
+        OPJ_UINT32 compno;
+
+        for (compno = 0; compno < l_tile->numcomps; ++compno) {
+                if (l_tccp->qmfbid == 1) {
+                        if (! opj_dwt_encode(l_tile_comp)) {
+                                return OPJ_FALSE;
+                        }
+                }
+                else if (l_tccp->qmfbid == 0) {
+                        if (! opj_dwt_encode_real(l_tile_comp)) {
+                                return OPJ_FALSE;
+                        }
+                }
+
+                ++l_tile_comp;
+                ++l_tccp;
+        }
+
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_tcd_t1_encode ( opj_tcd_t *p_tcd )
+{
+        opj_t1_t * l_t1;
+        const OPJ_FLOAT64 * l_mct_norms;
+        opj_tcp_t * l_tcp = p_tcd->tcp;
+
+        l_t1 = opj_t1_create();
+        if (l_t1 == 00) {
+                return OPJ_FALSE;
+        }
+
+        if (l_tcp->mct == 1) {
+                /* irreversible encoding */
+                if (l_tcp->tccps->qmfbid == 0) {
+                        l_mct_norms = opj_mct_get_mct_norms_real();
+                }
+                else {
+                        l_mct_norms = opj_mct_get_mct_norms();
+                }
+        }
+        else {
+                l_mct_norms = (const OPJ_FLOAT64 *) (l_tcp->mct_norms);
+        }
+
+        if (! opj_t1_encode_cblks(l_t1, p_tcd->tcd_image->tiles , l_tcp, l_mct_norms)) {
+        opj_t1_destroy(l_t1);
+                return OPJ_FALSE;
+        }
+
+        opj_t1_destroy(l_t1);
+
+        return OPJ_TRUE;
+}
+
+OPJ_BOOL opj_tcd_t2_encode (opj_tcd_t *p_tcd,
+                                                OPJ_BYTE * p_dest_data,
+                                                OPJ_UINT32 * p_data_written,
+                                                OPJ_UINT32 p_max_dest_size,
+                                                opj_codestream_info_t *p_cstr_info )
+{
+        opj_t2_t * l_t2;
+
+        l_t2 = opj_t2_create(p_tcd->image, p_tcd->cp);
+        if (l_t2 == 00) {
+                return OPJ_FALSE;
+        }
+
+        if (! opj_t2_encode_packets(
+                                        l_t2,
+                                        p_tcd->tcd_tileno,
+                                        p_tcd->tcd_image->tiles,
+                                        p_tcd->tcp->numlayers,
+                                        p_dest_data,
+                                        p_data_written,
+                                        p_max_dest_size,
+                                        p_cstr_info,
+                                        p_tcd->tp_num,
+                                        p_tcd->tp_pos,
+                                        p_tcd->cur_pino,
+                                        FINAL_PASS))
+        {
+                opj_t2_destroy(l_t2);
+                return OPJ_FALSE;
+        }
+
+        opj_t2_destroy(l_t2);
+
+        /*---------------CLEAN-------------------*/
+        return OPJ_TRUE;
+}
+
+
+OPJ_BOOL opj_tcd_rate_allocate_encode(  opj_tcd_t *p_tcd,
+                                                                            OPJ_BYTE * p_dest_data,
+                                                                            OPJ_UINT32 p_max_dest_size,
+                                                                            opj_codestream_info_t *p_cstr_info )
+{
+        opj_cp_t * l_cp = p_tcd->cp;
+        OPJ_UINT32 l_nb_written = 0;
+
+        if (p_cstr_info)  {
+                p_cstr_info->index_write = 0;
+        }
+
+        if (l_cp->m_specific_param.m_enc.m_disto_alloc|| l_cp->m_specific_param.m_enc.m_fixed_quality)  {
+                /* fixed_quality */
+                /* Normal Rate/distortion allocation */
+                if (! opj_tcd_rateallocate(p_tcd, p_dest_data,&l_nb_written, p_max_dest_size, p_cstr_info)) {
+                        return OPJ_FALSE;
+                }
+        }
+        else {
+                /* Fixed layer allocation */
+                opj_tcd_rateallocate_fixed(p_tcd);
+        }
+
+        return OPJ_TRUE;
+}
+
+
+OPJ_BOOL opj_tcd_copy_tile_data (       opj_tcd_t *p_tcd,
+                                                                    OPJ_BYTE * p_src,
+                                                                    OPJ_UINT32 p_src_length )
+{
+        OPJ_UINT32 i,j,l_data_size = 0;
+        opj_image_comp_t * l_img_comp = 00;
+        opj_tcd_tilecomp_t * l_tilec = 00;
+        OPJ_UINT32 l_size_comp, l_remaining;
+        OPJ_UINT32 l_nb_elem;
+
+        l_data_size = opj_tcd_get_encoded_tile_size(p_tcd);
+        if (l_data_size != p_src_length) {
+                return OPJ_FALSE;
+        }
+
+        l_tilec = p_tcd->tcd_image->tiles->comps;
+        l_img_comp = p_tcd->image->comps;
+        for (i=0;i<p_tcd->image->numcomps;++i) {
+                l_size_comp = l_img_comp->prec >> 3; /*(/ 8)*/
+                l_remaining = l_img_comp->prec & 7;  /* (%8) */
+                l_nb_elem = (OPJ_UINT32)((l_tilec->x1 - l_tilec->x0) * (l_tilec->y1 - l_tilec->y0));
+
+                if (l_remaining) {
+                        ++l_size_comp;
+                }
+
+                if (l_size_comp == 3) {
+                        l_size_comp = 4;
+                }
+
+                switch (l_size_comp) {
+                        case 1:
+                                {
+                                        OPJ_CHAR * l_src_ptr = (OPJ_CHAR *) p_src;
+                                        OPJ_INT32 * l_dest_ptr = l_tilec->data;
+
+                                        if (l_img_comp->sgnd) {
+                                                for (j=0;j<l_nb_elem;++j) {
+                                                        *(l_dest_ptr++) = (OPJ_INT32) (*(l_src_ptr++));
+                                                }
+                                        }
+                                        else {
+                                                for (j=0;j<l_nb_elem;++j) {
+                                                        *(l_dest_ptr++) = (*(l_src_ptr++))&0xff;
+                                                }
+                                        }
+
+                                        p_src = (OPJ_BYTE*) l_src_ptr;
+                                }
+                                break;
+                        case 2:
+                                {
+                                        OPJ_INT32 * l_dest_ptr = l_tilec->data;
+                                        OPJ_INT16 * l_src_ptr = (OPJ_INT16 *) p_src;
+
+                                        if (l_img_comp->sgnd) {
+                                                for (j=0;j<l_nb_elem;++j) {
+                                                        *(l_dest_ptr++) = (OPJ_INT32) (*(l_src_ptr++));
+                                                }
+                                        }
+                                        else {
+                                                for (j=0;j<l_nb_elem;++j) {
+                                                        *(l_dest_ptr++) = (*(l_src_ptr++))&0xffff;
+                                                }
+                                        }
+
+                                        p_src = (OPJ_BYTE*) l_src_ptr;
+                                }
+                                break;
+                        case 4:
+                                {
+                                        OPJ_INT32 * l_src_ptr = (OPJ_INT32 *) p_src;
+                                        OPJ_INT32 * l_dest_ptr = l_tilec->data;
+
+                                        for (j=0;j<l_nb_elem;++j) {
+                                                *(l_dest_ptr++) = (OPJ_INT32) (*(l_src_ptr++));
+                                        }
+
+                                        p_src = (OPJ_BYTE*) l_src_ptr;
+                                }
+                                break;
+                }
+
+                ++l_img_comp;
+                ++l_tilec;
+        }
+
+        return OPJ_TRUE;
+}
diff --git a/extern/libopenjpeg/tcd.h b/extern/libopenjpeg/tcd.h
index e3f93ad..360923b 100644
--- a/extern/libopenjpeg/tcd.h
+++ b/extern/libopenjpeg/tcd.h
@@ -1,10 +1,18 @@
 /*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2001-2003, David Janssens
  * Copyright (c) 2002-2003, Yannick Verschueren
- * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * Copyright (c) 2003-2014, Antonin Descampe
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR 
+ * Copyright (c) 2012, CS Systemes d'Information, France
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -34,170 +42,180 @@
 @file tcd.h
 @brief Implementation of a tile coder/decoder (TCD)
 
-The functions in TCD.C have for goal to encode or decode each tile independently from
-each other. The functions in TCD.C are used by some function in J2K.C.
+The functions in TCD.C encode or decode each tile independently from
+each other. The functions in TCD.C are used by other functions in J2K.C.
 */
 
 /** @defgroup TCD TCD - Implementation of a tile coder/decoder */
 /*@{*/
 
 /**
-FIXME: documentation
+FIXME DOC
 */
 typedef struct opj_tcd_seg {
-  unsigned char** data;
-  int dataindex;
-  int numpasses;
-  int len;
-  int maxpasses;
-  int numnewpasses;
-  int newlen;
+	OPJ_BYTE ** data;
+	OPJ_UINT32 dataindex;
+	OPJ_UINT32 numpasses;
+	OPJ_UINT32 real_num_passes;
+	OPJ_UINT32 len;
+	OPJ_UINT32 maxpasses;
+	OPJ_UINT32 numnewpasses;
+	OPJ_UINT32 newlen;
 } opj_tcd_seg_t;
 
 /**
-FIXME: documentation
+FIXME DOC
 */
 typedef struct opj_tcd_pass {
-  int rate;
-  double distortiondec;
-  int term, len;
+	OPJ_UINT32 rate;
+	OPJ_FLOAT64 distortiondec;
+	OPJ_UINT32 len;
+	OPJ_UINT32 term : 1;
 } opj_tcd_pass_t;
 
 /**
-FIXME: documentation
+FIXME DOC
 */
 typedef struct opj_tcd_layer {
-  int numpasses;		/* Number of passes in the layer */
-  int len;			/* len of information */
-  double disto;			/* add for index (Cfr. Marcela) */
-  unsigned char *data;		/* data */
+	OPJ_UINT32 numpasses;		/* Number of passes in the layer */
+	OPJ_UINT32 len;				/* len of information */
+	OPJ_FLOAT64 disto;			/* add for index (Cfr. Marcela) */
+	OPJ_BYTE *data;				/* data */
 } opj_tcd_layer_t;
 
 /**
-FIXME: documentation
+FIXME DOC
 */
 typedef struct opj_tcd_cblk_enc {
-  unsigned char* data;	/* Data */
-  opj_tcd_layer_t* layers;	/* layer information */
-  opj_tcd_pass_t* passes;	/* information about the passes */
-  int x0, y0, x1, y1;		/* dimension of the code-blocks : left upper corner (x0, y0) right low corner (x1,y1) */
-  int numbps;
-  int numlenbits;
-  int numpasses;		/* number of pass already done for the code-blocks */
-  int numpassesinlayers;	/* number of passes in the layer */
-  int totalpasses;		/* total number of passes */
+	OPJ_BYTE* data;					/* Data */
+	opj_tcd_layer_t* layers;		/* layer information */
+	opj_tcd_pass_t* passes;		/* information about the passes */
+	OPJ_INT32 x0, y0, x1, y1;		/* dimension of the code-blocks : left upper corner (x0, y0) right low corner (x1,y1) */
+	OPJ_UINT32 numbps;
+	OPJ_UINT32 numlenbits;
+	OPJ_UINT32 numpasses;			/* number of pass already done for the code-blocks */
+	OPJ_UINT32 numpassesinlayers;	/* number of passes in the layer */
+	OPJ_UINT32 totalpasses;			/* total number of passes */
 } opj_tcd_cblk_enc_t;
 
+
 typedef struct opj_tcd_cblk_dec {
-  unsigned char* data;	/* Data */
-  opj_tcd_seg_t* segs;		/* segments informations */
-	int x0, y0, x1, y1;		/* dimension of the code-blocks : left upper corner (x0, y0) right low corner (x1,y1) */
-  int numbps;
-  int numlenbits;
-  int len;			/* length */
-  int numnewpasses;		/* number of pass added to the code-blocks */
-  int numsegs;			/* number of segments */
+	OPJ_BYTE * data;				/* Data */
+	opj_tcd_seg_t* segs;			/* segments information */
+	OPJ_INT32 x0, y0, x1, y1;		/* position of the code-blocks : left upper corner (x0, y0) right low corner (x1,y1) */
+	OPJ_UINT32 numbps;
+	OPJ_UINT32 numlenbits;
+    OPJ_UINT32 data_max_size;		/* Size of allocated data buffer */
+	OPJ_UINT32 data_current_size;	/* Size of used data buffer */
+	OPJ_UINT32 numnewpasses;		/* number of pass added to the code-blocks */
+	OPJ_UINT32 numsegs;				/* number of segments */
+	OPJ_UINT32 real_num_segs;
+	OPJ_UINT32 m_current_max_segs;
 } opj_tcd_cblk_dec_t;
 
 /**
-FIXME: documentation
+FIXME DOC
 */
 typedef struct opj_tcd_precinct {
-  int x0, y0, x1, y1;		/* dimension of the precinct : left upper corner (x0, y0) right low corner (x1,y1) */
-  int cw, ch;			/* number of precinct in width and heigth */
-  union{		/* code-blocks informations */
-	  opj_tcd_cblk_enc_t* enc;
-	  opj_tcd_cblk_dec_t* dec;
-  } cblks;
-  opj_tgt_tree_t *incltree;		/* inclusion tree */
-  opj_tgt_tree_t *imsbtree;		/* IMSB tree */
+	OPJ_INT32 x0, y0, x1, y1;		/* dimension of the precinct : left upper corner (x0, y0) right low corner (x1,y1) */
+	OPJ_UINT32 cw, ch;				/* number of precinct in width and height */
+	union{							/* code-blocks information */
+		opj_tcd_cblk_enc_t* enc;
+		opj_tcd_cblk_dec_t* dec;
+	} cblks;
+	OPJ_UINT32 block_size;			/* size taken by cblks (in bytes) */
+	opj_tgt_tree_t *incltree;	    /* inclusion tree */
+	opj_tgt_tree_t *imsbtree;	    /* IMSB tree */
 } opj_tcd_precinct_t;
 
 /**
-FIXME: documentation
+FIXME DOC
 */
 typedef struct opj_tcd_band {
-  int x0, y0, x1, y1;		/* dimension of the subband : left upper corner (x0, y0) right low corner (x1,y1) */
-  int bandno;
-  opj_tcd_precinct_t *precincts;	/* precinct information */
-  int numbps;
-  float stepsize;
+	OPJ_INT32 x0, y0, x1, y1;		/* dimension of the subband : left upper corner (x0, y0) right low corner (x1,y1) */
+	OPJ_UINT32 bandno;
+	opj_tcd_precinct_t *precincts;	/* precinct information */
+	OPJ_UINT32 precincts_data_size;	/* size of data taken by precincts */
+	OPJ_INT32 numbps;
+	OPJ_FLOAT32 stepsize;
 } opj_tcd_band_t;
 
 /**
-FIXME: documentation
+FIXME DOC
 */
 typedef struct opj_tcd_resolution {
-  int x0, y0, x1, y1;		/* dimension of the resolution level : left upper corner (x0, y0) right low corner (x1,y1) */
-  int pw, ph;
-  int numbands;			/* number sub-band for the resolution level */
-  opj_tcd_band_t bands[3];		/* subband information */
+	OPJ_INT32 x0, y0, x1, y1;		/* dimension of the resolution level : left upper corner (x0, y0) right low corner (x1,y1) */
+	OPJ_UINT32 pw, ph;
+	OPJ_UINT32 numbands;			/* number sub-band for the resolution level */
+	opj_tcd_band_t bands[3];		/* subband information */
 } opj_tcd_resolution_t;
 
 /**
-FIXME: documentation
+FIXME DOC
 */
-typedef struct opj_tcd_tilecomp {
-  int x0, y0, x1, y1;		/* dimension of component : left upper corner (x0, y0) right low corner (x1,y1) */
-  int numresolutions;		/* number of resolutions level */
-  opj_tcd_resolution_t *resolutions;	/* resolutions information */
-  int *data;			/* data of the component */
-  int numpix;			/* add fixed_quality */
+typedef struct opj_tcd_tilecomp
+{
+	OPJ_INT32 x0, y0, x1, y1;				/* dimension of component : left upper corner (x0, y0) right low corner (x1,y1) */
+	OPJ_UINT32 numresolutions;				/* number of resolutions level */
+	OPJ_UINT32 minimum_num_resolutions;		/* number of resolutions level to decode (at max)*/
+	opj_tcd_resolution_t *resolutions;	/* resolutions information */
+	OPJ_UINT32 resolutions_size;			/* size of data for resolutions (in bytes) */
+	OPJ_INT32 *data;						/* data of the component */
+	OPJ_UINT32 data_size;					/* size of the data of the component */
+	OPJ_INT32 numpix;						/* add fixed_quality */
 } opj_tcd_tilecomp_t;
 
+
 /**
-FIXME: documentation
+FIXME DOC
 */
 typedef struct opj_tcd_tile {
-  int x0, y0, x1, y1;		/* dimension of the tile : left upper corner (x0, y0) right low corner (x1,y1) */
-  int numcomps;			/* number of components in tile */
-  opj_tcd_tilecomp_t *comps;	/* Components information */
-  int numpix;			/* add fixed_quality */
-  double distotile;		/* add fixed_quality */
-  double distolayer[100];	/* add fixed_quality */
-  /** packet number */
-  int packno;
+	OPJ_INT32 x0, y0, x1, y1;		/* dimension of the tile : left upper corner (x0, y0) right low corner (x1,y1) */
+	OPJ_UINT32 numcomps;			/* number of components in tile */
+	opj_tcd_tilecomp_t *comps;	/* Components information */
+	OPJ_INT32 numpix;				/* add fixed_quality */
+	OPJ_FLOAT64 distotile;			/* add fixed_quality */
+	OPJ_FLOAT64 distolayer[100];	/* add fixed_quality */
+	OPJ_UINT32 packno;              /* packet number */
 } opj_tcd_tile_t;
 
 /**
-FIXME: documentation
+FIXME DOC
 */
-typedef struct opj_tcd_image {
-  int tw, th;			/* number of tiles in width and heigth */
-  opj_tcd_tile_t *tiles;		/* Tiles information */
-} opj_tcd_image_t;
+typedef struct opj_tcd_image
+{
+	opj_tcd_tile_t *tiles;		/* Tiles information */
+}
+opj_tcd_image_t;
+
 
 /**
 Tile coder/decoder
 */
-typedef struct opj_tcd {
+typedef struct opj_tcd
+{
 	/** Position of the tilepart flag in Progression order*/
-	int tp_pos;
+	OPJ_INT32 tp_pos;
 	/** Tile part number*/
-	int tp_num;
+	OPJ_UINT32 tp_num;
 	/** Current tile part number*/
-	int cur_tp_num;
+	OPJ_UINT32 cur_tp_num;
 	/** Total number of tileparts of the current tile*/
-	int cur_totnum_tp;
+	OPJ_UINT32 cur_totnum_tp;
 	/** Current Packet iterator number */
-	int cur_pino;
-	/** codec context */
-	opj_common_ptr cinfo;
-
+	OPJ_UINT32 cur_pino;
 	/** info on each image tile */
 	opj_tcd_image_t *tcd_image;
-	/** image */
+	/** image header */
 	opj_image_t *image;
 	/** coding parameters */
 	opj_cp_t *cp;
-	/** pointer to the current encoded/decoded tile */
-	opj_tcd_tile_t *tcd_tile;
 	/** coding/decoding parameters common to all tiles */
 	opj_tcp_t *tcp;
 	/** current encoded/decoded tile */
-	int tcd_tileno;
-	/** Time taken to encode a tile*/
-	double encoding_time;
+	OPJ_UINT32 tcd_tileno;
+	/** tell if the tcd is a decoder. */
+	OPJ_UINT32 m_is_decoder : 1;
 } opj_tcd_t;
 
 /** @name Exported functions */
@@ -207,76 +225,126 @@ typedef struct opj_tcd {
 /**
 Dump the content of a tcd structure
 */
-void tcd_dump(FILE *fd, opj_tcd_t *tcd, opj_tcd_image_t *img);
+/*void tcd_dump(FILE *fd, opj_tcd_t *tcd, opj_tcd_image_t *img);*/ /* TODO MSD shoul use the new v2 structures */ 
+
 /**
 Create a new TCD handle
-@param cinfo Codec context info
+@param p_is_decoder FIXME DOC
 @return Returns a new TCD handle if successful returns NULL otherwise
 */
-opj_tcd_t* tcd_create(opj_common_ptr cinfo);
+opj_tcd_t* opj_tcd_create(OPJ_BOOL p_is_decoder);
+
 /**
 Destroy a previously created TCD handle
 @param tcd TCD handle to destroy
 */
-void tcd_destroy(opj_tcd_t *tcd);
-/**
-Initialize the tile coder (allocate the memory)
-@param tcd TCD handle
-@param image Raw image
-@param cp Coding parameters
-@param curtileno Number that identifies the tile that will be encoded
-*/
-void tcd_malloc_encode(opj_tcd_t *tcd, opj_image_t * image, opj_cp_t * cp, int curtileno);
+void opj_tcd_destroy(opj_tcd_t *tcd);
+
 /**
-Free the memory allocated for encoding
-@param tcd TCD handle
+ * Initialize the tile coder and may reuse some memory.
+ * @param	p_tcd		TCD handle.
+ * @param	p_image		raw image.
+ * @param	p_cp		coding parameters.
+ *
+ * @return true if the encoding values could be set (false otherwise).
 */
-void tcd_free_encode(opj_tcd_t *tcd);
+OPJ_BOOL opj_tcd_init(	opj_tcd_t *p_tcd,
+						opj_image_t * p_image,
+						opj_cp_t * p_cp );
+
 /**
-Initialize the tile coder (reuses the memory allocated by tcd_malloc_encode)
-@param tcd TCD handle
-@param image Raw image
-@param cp Coding parameters
-@param curtileno Number that identifies the tile that will be encoded
-*/
-void tcd_init_encode(opj_tcd_t *tcd, opj_image_t * image, opj_cp_t * cp, int curtileno);
+ * Allocates memory for decoding a specific tile.
+ *
+ * @param	p_tcd		the tile decoder.
+ * @param	p_tile_no	the index of the tile received in sequence. This not necessarily lead to the
+ * tile at index p_tile_no.
+ *
+ * @return	true if the remaining data is sufficient.
+ */
+OPJ_BOOL opj_tcd_init_decode_tile(opj_tcd_t *p_tcd, OPJ_UINT32 p_tile_no);
+
+void opj_tcd_makelayer_fixed(opj_tcd_t *tcd, OPJ_UINT32 layno, OPJ_UINT32 final);
+
+void opj_tcd_rateallocate_fixed(opj_tcd_t *tcd);
+
+void opj_tcd_makelayer(	opj_tcd_t *tcd,
+						OPJ_UINT32 layno,
+						OPJ_FLOAT64 thresh,
+						OPJ_UINT32 final);
+
+OPJ_BOOL opj_tcd_rateallocate(	opj_tcd_t *tcd,
+								OPJ_BYTE *dest,
+								OPJ_UINT32 * p_data_written,
+								OPJ_UINT32 len,
+								opj_codestream_info_t *cstr_info);
+
 /**
-Initialize the tile decoder
-@param tcd TCD handle
-@param image Raw image
-@param cp Coding parameters
-*/
-void tcd_malloc_decode(opj_tcd_t *tcd, opj_image_t * image, opj_cp_t * cp);
-void tcd_malloc_decode_tile(opj_tcd_t *tcd, opj_image_t * image, opj_cp_t * cp, int tileno, opj_codestream_info_t *cstr_info);
-void tcd_makelayer_fixed(opj_tcd_t *tcd, int layno, int final);
-void tcd_rateallocate_fixed(opj_tcd_t *tcd);
-void tcd_makelayer(opj_tcd_t *tcd, int layno, double thresh, int final);
-opj_bool tcd_rateallocate(opj_tcd_t *tcd, unsigned char *dest, int len, opj_codestream_info_t *cstr_info);
+ * Gets the maximum tile size that will be taken by the tile once decoded.
+ */
+OPJ_UINT32 opj_tcd_get_decoded_tile_size (opj_tcd_t *p_tcd );
+
 /**
-Encode a tile from the raw image into a buffer
-@param tcd TCD handle
-@param tileno Number that identifies one of the tiles to be encoded
-@param dest Destination buffer
-@param len Length of destination buffer
-@param cstr_info Codestream information structure 
-@return 
+ * Encodes a tile from the raw image into the given buffer.
+ * @param	p_tcd			Tile Coder handle
+ * @param	p_tile_no		Index of the tile to encode.
+ * @param	p_dest			Destination buffer
+ * @param	p_data_written	pointer to an int that is incremented by the number of bytes really written on p_dest
+ * @param	p_len			Maximum length of the destination buffer
+ * @param	p_cstr_info		Codestream information structure
+ * @return  true if the coding is successfull.
 */
-int tcd_encode_tile(opj_tcd_t *tcd, int tileno, unsigned char *dest, int len, opj_codestream_info_t *cstr_info);
+OPJ_BOOL opj_tcd_encode_tile(   opj_tcd_t *p_tcd,
+							    OPJ_UINT32 p_tile_no,
+							    OPJ_BYTE *p_dest,
+							    OPJ_UINT32 * p_data_written,
+							    OPJ_UINT32 p_len,
+							    struct opj_codestream_info *p_cstr_info);
+
+
 /**
 Decode a tile from a buffer into a raw image
 @param tcd TCD handle
 @param src Source buffer
 @param len Length of source buffer
 @param tileno Number that identifies one of the tiles to be decoded
-@param cstr_info Codestream information structure
+@param cstr_info  FIXME DOC
 */
-opj_bool tcd_decode_tile(opj_tcd_t *tcd, unsigned char *src, int len, int tileno, opj_codestream_info_t *cstr_info);
+OPJ_BOOL opj_tcd_decode_tile(   opj_tcd_t *tcd,
+							    OPJ_BYTE *src,
+							    OPJ_UINT32 len,
+							    OPJ_UINT32 tileno,
+							    opj_codestream_index_t *cstr_info);
+
+
 /**
-Free the memory allocated for decoding
-@param tcd TCD handle
+ * Copies tile data from the system onto the given memory block.
+ */
+OPJ_BOOL opj_tcd_update_tile_data (	opj_tcd_t *p_tcd,
+								    OPJ_BYTE * p_dest,
+								    OPJ_UINT32 p_dest_length );
+
+/**
+ *
+ */
+OPJ_UINT32 opj_tcd_get_encoded_tile_size ( opj_tcd_t *p_tcd );
+
+/**
+ * Initialize the tile coder and may reuse some meory.
+ *
+ * @param	p_tcd		TCD handle.
+ * @param	p_tile_no	current tile index to encode.
+ *
+ * @return true if the encoding values could be set (false otherwise).
 */
-void tcd_free_decode(opj_tcd_t *tcd);
-void tcd_free_decode_tile(opj_tcd_t *tcd, int tileno);
+OPJ_BOOL opj_tcd_init_encode_tile (	opj_tcd_t *p_tcd,
+								    OPJ_UINT32 p_tile_no );
+
+/**
+ * Copies tile data from the given memory block onto the system.
+ */
+OPJ_BOOL opj_tcd_copy_tile_data (opj_tcd_t *p_tcd,
+                                 OPJ_BYTE * p_src,
+                                 OPJ_UINT32 p_src_length );
 
 /* ----------------------------------------------------------------------- */
 /*@}*/
diff --git a/extern/libopenjpeg/tgt.c b/extern/libopenjpeg/tgt.c
index a5dbcd3..e77adb3 100644
--- a/extern/libopenjpeg/tgt.c
+++ b/extern/libopenjpeg/tgt.c
@@ -1,10 +1,18 @@
 /*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2001-2003, David Janssens
  * Copyright (c) 2002-2003, Yannick Verschueren
- * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * Copyright (c) 2003-2014, Antonin Descampe
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * Copyright (c) 2008, 2011-2012, Centre National d'Etudes Spatiales (CNES), FR 
+ * Copyright (c) 2012, CS Systemes d'Information, France
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -37,177 +45,293 @@
 ==========================================================
 */
 
-opj_tgt_tree_t *tgt_create(int numleafsh, int numleafsv) {
-	int nplh[32];
-	int nplv[32];
-	opj_tgt_node_t *node = NULL;
-	opj_tgt_node_t *parentnode = NULL;
-	opj_tgt_node_t *parentnode0 = NULL;
-	opj_tgt_tree_t *tree = NULL;
-	int i, j, k;
-	int numlvls;
-	int n;
-
-	tree = (opj_tgt_tree_t *) opj_malloc(sizeof(opj_tgt_tree_t));
-	if(!tree) return NULL;
-	tree->numleafsh = numleafsh;
-	tree->numleafsv = numleafsv;
-
-	numlvls = 0;
-	nplh[0] = numleafsh;
-	nplv[0] = numleafsv;
-	tree->numnodes = 0;
-	do {
-		n = nplh[numlvls] * nplv[numlvls];
-		nplh[numlvls + 1] = (nplh[numlvls] + 1) / 2;
-		nplv[numlvls + 1] = (nplv[numlvls] + 1) / 2;
-		tree->numnodes += n;
-		++numlvls;
-	} while (n > 1);
-	
-	/* ADD */
-	if (tree->numnodes == 0) {
-		opj_free(tree);
-		return NULL;
-	}
-
-	tree->nodes = (opj_tgt_node_t*) opj_calloc(tree->numnodes, sizeof(opj_tgt_node_t));
-	if(!tree->nodes) {
-		opj_free(tree);
-		return NULL;
-	}
-
-	node = tree->nodes;
-	parentnode = &tree->nodes[tree->numleafsh * tree->numleafsv];
-	parentnode0 = parentnode;
-	
-	for (i = 0; i < numlvls - 1; ++i) {
-		for (j = 0; j < nplv[i]; ++j) {
-			k = nplh[i];
-			while (--k >= 0) {
-				node->parent = parentnode;
-				++node;
-				if (--k >= 0) {
-					node->parent = parentnode;
-					++node;
-				}
-				++parentnode;
-			}
-			if ((j & 1) || j == nplv[i] - 1) {
-				parentnode0 = parentnode;
-			} else {
-				parentnode = parentnode0;
-				parentnode0 += nplh[i];
-			}
-		}
-	}
-	node->parent = 0;
-	
-	tgt_reset(tree);
-	
-	return tree;
+opj_tgt_tree_t *opj_tgt_create(OPJ_UINT32 numleafsh, OPJ_UINT32 numleafsv) {
+        OPJ_INT32 nplh[32];
+        OPJ_INT32 nplv[32];
+        opj_tgt_node_t *node = 00;
+        opj_tgt_node_t *l_parent_node = 00;
+        opj_tgt_node_t *l_parent_node0 = 00;
+        opj_tgt_tree_t *tree = 00;
+        OPJ_UINT32 i;
+        OPJ_INT32  j,k;
+        OPJ_UINT32 numlvls;
+        OPJ_UINT32 n;
+
+        tree = (opj_tgt_tree_t *) opj_malloc(sizeof(opj_tgt_tree_t));
+        if(!tree) {
+                fprintf(stderr, "ERROR in tgt_create while allocating tree\n");
+                return 00;
+        }
+        memset(tree,0,sizeof(opj_tgt_tree_t));
+
+        tree->numleafsh = numleafsh;
+        tree->numleafsv = numleafsv;
+
+        numlvls = 0;
+        nplh[0] = (OPJ_INT32)numleafsh;
+        nplv[0] = (OPJ_INT32)numleafsv;
+        tree->numnodes = 0;
+        do {
+                n = (OPJ_UINT32)(nplh[numlvls] * nplv[numlvls]);
+                nplh[numlvls + 1] = (nplh[numlvls] + 1) / 2;
+                nplv[numlvls + 1] = (nplv[numlvls] + 1) / 2;
+                tree->numnodes += n;
+                ++numlvls;
+        } while (n > 1);
+
+        /* ADD */
+        if (tree->numnodes == 0) {
+                opj_free(tree);
+                fprintf(stderr, "WARNING in tgt_create tree->numnodes == 0, no tree created.\n");
+                return 00;
+        }
+
+        tree->nodes = (opj_tgt_node_t*) opj_calloc(tree->numnodes, sizeof(opj_tgt_node_t));
+        if(!tree->nodes) {
+                fprintf(stderr, "ERROR in tgt_create while allocating node of the tree\n");
+                opj_free(tree);
+                return 00;
+        }
+        memset(tree->nodes,0,tree->numnodes * sizeof(opj_tgt_node_t));
+        tree->nodes_size = tree->numnodes * (OPJ_UINT32)sizeof(opj_tgt_node_t);
+
+        node = tree->nodes;
+        l_parent_node = &tree->nodes[tree->numleafsh * tree->numleafsv];
+        l_parent_node0 = l_parent_node;
+
+        for (i = 0; i < numlvls - 1; ++i) {
+                for (j = 0; j < nplv[i]; ++j) {
+                        k = nplh[i];
+                        while (--k >= 0) {
+                                node->parent = l_parent_node;
+                                ++node;
+                                if (--k >= 0) {
+                                        node->parent = l_parent_node;
+                                        ++node;
+                                }
+                                ++l_parent_node;
+                        }
+                        if ((j & 1) || j == nplv[i] - 1) {
+                                l_parent_node0 = l_parent_node;
+                        } else {
+                                l_parent_node = l_parent_node0;
+                                l_parent_node0 += nplh[i];
+                        }
+                }
+        }
+        node->parent = 0;
+        opj_tgt_reset(tree);
+        return tree;
 }
 
-void tgt_destroy(opj_tgt_tree_t *tree) {
-	opj_free(tree->nodes);
-	opj_free(tree);
+/**
+ * Reinitialises a tag-tree from an existing one.
+ *
+ * @param       p_tree                          the tree to reinitialize.
+ * @param       p_num_leafs_h           the width of the array of leafs of the tree
+ * @param       p_num_leafs_v           the height of the array of leafs of the tree
+ * @return      a new tag-tree if successful, NULL otherwise
+*/
+opj_tgt_tree_t *opj_tgt_init(opj_tgt_tree_t * p_tree,OPJ_UINT32 p_num_leafs_h, OPJ_UINT32 p_num_leafs_v)
+{
+        OPJ_INT32 l_nplh[32];
+        OPJ_INT32 l_nplv[32];
+        opj_tgt_node_t *l_node = 00;
+        opj_tgt_node_t *l_parent_node = 00;
+        opj_tgt_node_t *l_parent_node0 = 00;
+        OPJ_UINT32 i;
+        OPJ_INT32 j,k;
+        OPJ_UINT32 l_num_levels;
+        OPJ_UINT32 n;
+        OPJ_UINT32 l_node_size;
+
+        if (! p_tree){
+                return 00;
+        }
+
+        if ((p_tree->numleafsh != p_num_leafs_h) || (p_tree->numleafsv != p_num_leafs_v)) {
+                p_tree->numleafsh = p_num_leafs_h;
+                p_tree->numleafsv = p_num_leafs_v;
+
+                l_num_levels = 0;
+                l_nplh[0] = (OPJ_INT32)p_num_leafs_h;
+                l_nplv[0] = (OPJ_INT32)p_num_leafs_v;
+                p_tree->numnodes = 0;
+                do
+                {
+                        n = (OPJ_UINT32)(l_nplh[l_num_levels] * l_nplv[l_num_levels]);
+                        l_nplh[l_num_levels + 1] = (l_nplh[l_num_levels] + 1) / 2;
+                        l_nplv[l_num_levels + 1] = (l_nplv[l_num_levels] + 1) / 2;
+                        p_tree->numnodes += n;
+                        ++l_num_levels;
+                }
+                while (n > 1);
+
+                /* ADD */
+                if (p_tree->numnodes == 0) {
+                        opj_tgt_destroy(p_tree);
+                        return 00;
+                }
+                l_node_size = p_tree->numnodes * (OPJ_UINT32)sizeof(opj_tgt_node_t);
+                
+                if (l_node_size > p_tree->nodes_size) {
+                        opj_tgt_node_t* new_nodes = (opj_tgt_node_t*) opj_realloc(p_tree->nodes, l_node_size);
+                        if (! new_nodes) {
+                                fprintf(stderr, "ERROR Not enough memory to reinitialize the tag tree\n");
+                                opj_tgt_destroy(p_tree);
+                                return 00;
+                        }
+                        p_tree->nodes = new_nodes;
+                        memset(((char *) p_tree->nodes) + p_tree->nodes_size, 0 , l_node_size - p_tree->nodes_size);
+                        p_tree->nodes_size = l_node_size;
+                }
+                l_node = p_tree->nodes;
+                l_parent_node = &p_tree->nodes[p_tree->numleafsh * p_tree->numleafsv];
+                l_parent_node0 = l_parent_node;
+
+                for (i = 0; i < l_num_levels - 1; ++i) {
+                        for (j = 0; j < l_nplv[i]; ++j) {
+                                k = l_nplh[i];
+                                while (--k >= 0) {
+                                        l_node->parent = l_parent_node;
+                                        ++l_node;
+                                        if (--k >= 0) {
+                                                l_node->parent = l_parent_node;
+                                                ++l_node;
+                                        }
+                                        ++l_parent_node;
+                                        }
+                                if ((j & 1) || j == l_nplv[i] - 1)
+                                {
+                                        l_parent_node0 = l_parent_node;
+                                }
+                                else
+                                {
+                                        l_parent_node = l_parent_node0;
+                                        l_parent_node0 += l_nplh[i];
+                                }
+                        }
+                }
+                l_node->parent = 0;
+        }
+        opj_tgt_reset(p_tree);
+
+        return p_tree;
 }
 
-void tgt_reset(opj_tgt_tree_t *tree) {
-	int i;
-
-	if (NULL == tree)
-		return;
-	
-	for (i = 0; i < tree->numnodes; i++) {
-		tree->nodes[i].value = 999;
-		tree->nodes[i].low = 0;
-		tree->nodes[i].known = 0;
-	}
+void opj_tgt_destroy(opj_tgt_tree_t *p_tree)
+{
+        if (! p_tree) {
+                return;
+        }
+
+        if (p_tree->nodes) {
+                opj_free(p_tree->nodes);
+                p_tree->nodes = 00;
+        }
+        opj_free(p_tree);
 }
 
-void tgt_setvalue(opj_tgt_tree_t *tree, int leafno, int value) {
-	opj_tgt_node_t *node;
-	node = &tree->nodes[leafno];
-	while (node && node->value > value) {
-		node->value = value;
-		node = node->parent;
-	}
+void opj_tgt_reset(opj_tgt_tree_t *p_tree) {
+        OPJ_UINT32 i;
+        opj_tgt_node_t * l_current_node = 00;;
+
+        if (! p_tree) {
+                return;
+        }
+
+        l_current_node = p_tree->nodes;
+        for     (i = 0; i < p_tree->numnodes; ++i)
+        {
+                l_current_node->value = 999;
+                l_current_node->low = 0;
+                l_current_node->known = 0;
+                ++l_current_node;
+        }
 }
 
-void tgt_encode(opj_bio_t *bio, opj_tgt_tree_t *tree, int leafno, int threshold) {
-	opj_tgt_node_t *stk[31];
-	opj_tgt_node_t **stkptr;
-	opj_tgt_node_t *node;
-	int low;
-
-	stkptr = stk;
-	node = &tree->nodes[leafno];
-	while (node->parent) {
-		*stkptr++ = node;
-		node = node->parent;
-	}
-	
-	low = 0;
-	for (;;) {
-		if (low > node->low) {
-			node->low = low;
-		} else {
-			low = node->low;
-		}
-		
-		while (low < threshold) {
-			if (low >= node->value) {
-				if (!node->known) {
-					bio_write(bio, 1, 1);
-					node->known = 1;
-				}
-				break;
-			}
-			bio_write(bio, 0, 1);
-			++low;
-		}
-		
-		node->low = low;
-		if (stkptr == stk)
-			break;
-		node = *--stkptr;
-	}
+void opj_tgt_setvalue(opj_tgt_tree_t *tree, OPJ_UINT32 leafno, OPJ_INT32 value) {
+        opj_tgt_node_t *node;
+        node = &tree->nodes[leafno];
+        while (node && node->value > value) {
+                node->value = value;
+                node = node->parent;
+        }
 }
 
-int tgt_decode(opj_bio_t *bio, opj_tgt_tree_t *tree, int leafno, int threshold) {
-	opj_tgt_node_t *stk[31];
-	opj_tgt_node_t **stkptr;
-	opj_tgt_node_t *node;
-	int low;
-
-	stkptr = stk;
-	node = &tree->nodes[leafno];
-	while (node->parent) {
-		*stkptr++ = node;
-		node = node->parent;
-	}
-	
-	low = 0;
-	for (;;) {
-		if (low > node->low) {
-			node->low = low;
-		} else {
-			low = node->low;
-		}
-		while (low < threshold && low < node->value) {
-			if (bio_read(bio, 1)) {
-				node->value = low;
-			} else {
-				++low;
-			}
-		}
-		node->low = low;
-		if (stkptr == stk) {
-			break;
-		}
-		node = *--stkptr;
-	}
-	
-	return (node->value < threshold) ? 1 : 0;
+void opj_tgt_encode(opj_bio_t *bio, opj_tgt_tree_t *tree, OPJ_UINT32 leafno, OPJ_INT32 threshold) {
+        opj_tgt_node_t *stk[31];
+        opj_tgt_node_t **stkptr;
+        opj_tgt_node_t *node;
+        OPJ_INT32 low;
+
+        stkptr = stk;
+        node = &tree->nodes[leafno];
+        while (node->parent) {
+                *stkptr++ = node;
+                node = node->parent;
+        }
+        
+        low = 0;
+        for (;;) {
+                if (low > node->low) {
+                        node->low = low;
+                } else {
+                        low = node->low;
+                }
+                
+                while (low < threshold) {
+                        if (low >= node->value) {
+                                if (!node->known) {
+                                        opj_bio_write(bio, 1, 1);
+                                        node->known = 1;
+                                }
+                                break;
+                        }
+                        opj_bio_write(bio, 0, 1);
+                        ++low;
+                }
+                
+                node->low = low;
+                if (stkptr == stk)
+                        break;
+                node = *--stkptr;
+        }
+}
+
+OPJ_UINT32 opj_tgt_decode(opj_bio_t *bio, opj_tgt_tree_t *tree, OPJ_UINT32 leafno, OPJ_INT32 threshold) {
+        opj_tgt_node_t *stk[31];
+        opj_tgt_node_t **stkptr;
+        opj_tgt_node_t *node;
+        OPJ_INT32 low;
+
+        stkptr = stk;
+        node = &tree->nodes[leafno];
+        while (node->parent) {
+                *stkptr++ = node;
+                node = node->parent;
+        }
+        
+        low = 0;
+        for (;;) {
+                if (low > node->low) {
+                        node->low = low;
+                } else {
+                        low = node->low;
+                }
+                while (low < threshold && low < node->value) {
+                        if (opj_bio_read(bio, 1)) {
+                                node->value = low;
+                        } else {
+                                ++low;
+                        }
+                }
+                node->low = low;
+                if (stkptr == stk) {
+                        break;
+                }
+                node = *--stkptr;
+        }
+        
+        return (node->value < threshold) ? 1 : 0;
 }
diff --git a/extern/libopenjpeg/tgt.h b/extern/libopenjpeg/tgt.h
index c08c8da..3d152f8 100644
--- a/extern/libopenjpeg/tgt.h
+++ b/extern/libopenjpeg/tgt.h
@@ -1,10 +1,19 @@
 /*
- * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2007, Professor Benoit Macq
+ * The copyright in this software is being made available under the 2-clauses 
+ * BSD License, included below. This software may be subject to other third 
+ * party and contributor rights, including patent rights, and no such rights
+ * are granted under this license.
+ *
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2001-2003, David Janssens
  * Copyright (c) 2002-2003, Yannick Verschueren
- * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * Copyright (c) 2003-2014, Antonin Descampe
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * Copyright (c) 2008, Jerome Fimes, Communications & Systemes <jerome.fimes@c-s.fr>
+ * Copyright (c) 2011-2012, Centre National d'Etudes Spatiales (CNES), France 
+ * Copyright (c) 2012, CS Systemes d'Information, France
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -46,22 +55,25 @@ are used by some function in T2.C.
 Tag node
 */
 typedef struct opj_tgt_node {
-  struct opj_tgt_node *parent;
-  int value;
-  int low;
-  int known;
+    struct opj_tgt_node *parent;
+    OPJ_INT32 value;
+    OPJ_INT32 low;
+    OPJ_UINT32 known;
 } opj_tgt_node_t;
 
 /**
 Tag tree
 */
-typedef struct opj_tgt_tree {
-  int numleafsh;
-  int numleafsv;
-  int numnodes;
-  opj_tgt_node_t *nodes;
+typedef struct opj_tgt_tree
+{
+	OPJ_UINT32  numleafsh;
+	OPJ_UINT32  numleafsv;
+	OPJ_UINT32 numnodes;
+	opj_tgt_node_t *nodes;
+	OPJ_UINT32  nodes_size;		/* maximum size taken by nodes */
 } opj_tgt_tree_t;
 
+
 /** @name Exported functions */
 /*@{*/
 /* ----------------------------------------------------------------------- */
@@ -71,24 +83,38 @@ Create a tag-tree
 @param numleafsv Height of the array of leafs of the tree
 @return Returns a new tag-tree if successful, returns NULL otherwise
 */
-opj_tgt_tree_t *tgt_create(int numleafsh, int numleafsv);
+opj_tgt_tree_t *opj_tgt_create(OPJ_UINT32 numleafsh, OPJ_UINT32 numleafsv);
+
+/**
+ * Reinitialises a tag-tree from an exixting one.
+ *
+ * @param	p_tree				the tree to reinitialize.
+ * @param	p_num_leafs_h		the width of the array of leafs of the tree
+ * @param	p_num_leafs_v		the height of the array of leafs of the tree
+ * @return	a new tag-tree if successful, NULL otherwise
+*/
+opj_tgt_tree_t *opj_tgt_init(opj_tgt_tree_t * p_tree, 
+                             OPJ_UINT32  p_num_leafs_h, 
+                             OPJ_UINT32  p_num_leafs_v);
 /**
 Destroy a tag-tree, liberating memory
 @param tree Tag-tree to destroy
 */
-void tgt_destroy(opj_tgt_tree_t *tree);
+void opj_tgt_destroy(opj_tgt_tree_t *tree);
 /**
 Reset a tag-tree (set all leaves to 0)
 @param tree Tag-tree to reset
 */
-void tgt_reset(opj_tgt_tree_t *tree);
+void opj_tgt_reset(opj_tgt_tree_t *tree);
 /**
 Set the value of a leaf of a tag-tree
 @param tree Tag-tree to modify
 @param leafno Number that identifies the leaf to modify
 @param value New value of the leaf
 */
-void tgt_setvalue(opj_tgt_tree_t *tree, int leafno, int value);
+void opj_tgt_setvalue(opj_tgt_tree_t *tree, 
+                      OPJ_UINT32 leafno, 
+                      OPJ_INT32 value);
 /**
 Encode the value of a leaf of the tag-tree up to a given threshold
 @param bio Pointer to a BIO handle
@@ -96,7 +122,10 @@ Encode the value of a leaf of the tag-tree up to a given threshold
 @param leafno Number that identifies the leaf to encode
 @param threshold Threshold to use when encoding value of the leaf
 */
-void tgt_encode(opj_bio_t *bio, opj_tgt_tree_t *tree, int leafno, int threshold);
+void opj_tgt_encode(opj_bio_t *bio, 
+                    opj_tgt_tree_t *tree, 
+                    OPJ_UINT32 leafno, 
+                    OPJ_INT32 threshold);
 /**
 Decode the value of a leaf of the tag-tree up to a given threshold
 @param bio Pointer to a BIO handle
@@ -105,7 +134,10 @@ Decode the value of a leaf of the tag-tree up to a given threshold
 @param threshold Threshold to use when decoding value of the leaf
 @return Returns 1 if the node's value < threshold, returns 0 otherwise
 */
-int tgt_decode(opj_bio_t *bio, opj_tgt_tree_t *tree, int leafno, int threshold);
+OPJ_UINT32 opj_tgt_decode(opj_bio_t *bio, 
+                          opj_tgt_tree_t *tree, 
+                          OPJ_UINT32 leafno, 
+                          OPJ_INT32 threshold);
 /* ----------------------------------------------------------------------- */
 /*@}*/
 
diff --git a/extern/libopenjpeg/thix_manager.c b/extern/libopenjpeg/thix_manager.c
index aa55f21..0967b1e 100644
--- a/extern/libopenjpeg/thix_manager.c
+++ b/extern/libopenjpeg/thix_manager.c
@@ -1,8 +1,8 @@
 /*
  * $Id: thix_manager.c 897 2011-08-28 21:43:57Z Kaori.Hagihara@gmail.com $
  *
- * Copyright (c) 2002-2011, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2011, Professor Benoit Macq
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2003-2004, Yannick Verschueren
  * Copyright (c) 2010-2011, Kaori Hagihara
  * All rights reserved.
@@ -33,88 +33,102 @@
  *  \brief Modification of jpip.c from 2KAN indexer
  */
 
-#include <stdlib.h>
-#include <stdio.h>
-#include <string.h>
 #include "opj_includes.h"
 
-/* 
- * Write tile-part headers mhix box
- *
- * @param[in] coff      offset of j2k codestream
- * @param[in] cstr_info codestream information
- * @param[in] tileno    tile number
- * @param[in] cio       file output handle
- * @return              length of mhix box
- */
-int write_tilemhix( int coff, opj_codestream_info_t cstr_info, int tileno, opj_cio_t *cio);
 
-int write_thix( int coff, opj_codestream_info_t cstr_info, opj_cio_t *cio)
+
+int opj_write_thix( int coff, opj_codestream_info_t cstr_info, opj_stream_private_t *cio,
+              opj_event_mgr_t * p_manager )
 {
-  int len, lenp, i;
+  OPJ_BYTE l_data_header [4];
+  int i;
   int tileno;
   opj_jp2_box_t *box;
+  OPJ_UINT32 len;
+  OPJ_OFF_T lenp;
 
   lenp = 0;
-  box = (opj_jp2_box_t *)opj_calloc( cstr_info.tw*cstr_info.th, sizeof(opj_jp2_box_t));
+  box = (opj_jp2_box_t *)opj_calloc( (size_t)(cstr_info.tw*cstr_info.th), sizeof(opj_jp2_box_t));
 
   for ( i = 0; i < 2 ; i++ ){
     if (i)
-      cio_seek( cio, lenp);
+      opj_stream_seek( cio, lenp, p_manager);
 
-    lenp = cio_tell( cio);
-    cio_skip( cio, 4);              /* L [at the end] */
-    cio_write( cio, JPIP_THIX, 4);  /* THIX           */
-    write_manf( i, cstr_info.tw*cstr_info.th, box, cio);
+    lenp = opj_stream_tell(cio);
+    opj_stream_skip(cio, 4, p_manager);             /* L [at the end] */
+    opj_write_bytes(l_data_header,JPIP_THIX,4); /* THIX */
+    opj_stream_write_data(cio,l_data_header,4,p_manager);
+
+    opj_write_manf( i, cstr_info.tw*cstr_info.th, box, cio, p_manager);
     
     for (tileno = 0; tileno < cstr_info.tw*cstr_info.th; tileno++){
-      box[tileno].length = write_tilemhix( coff, cstr_info, tileno, cio);
+      box[tileno].length = (OPJ_UINT32)opj_write_tilemhix( coff, cstr_info, tileno, cio,p_manager);
       box[tileno].type = JPIP_MHIX;
     }
  
-    len = cio_tell( cio)-lenp;
-    cio_seek( cio, lenp);
-    cio_write( cio, len, 4);        /* L              */
-    cio_seek( cio, lenp+len);
+    len = (OPJ_UINT32)(opj_stream_tell(cio)-lenp);
+    opj_stream_seek(cio, lenp, p_manager);
+    opj_write_bytes(l_data_header,len,4); /* L              */
+    opj_stream_write_data(cio,l_data_header,4,p_manager);
+    opj_stream_seek( cio, lenp+len,p_manager);
+
   }
 
   opj_free(box);
 
-  return len;
+  return (int)len;
 }
 
-int write_tilemhix( int coff, opj_codestream_info_t cstr_info, int tileno, opj_cio_t *cio)
+/* 
+ * Write tile-part headers mhix box
+ *
+ * @param[in] coff      offset of j2k codestream
+ * @param[in] cstr_info codestream information
+ * @param[in] tileno    tile number
+ * @param[in] cio       file output handle
+ * @return              length of mhix box
+ */
+int opj_write_tilemhix( int coff, opj_codestream_info_t cstr_info, int tileno, opj_stream_private_t *cio,
+              opj_event_mgr_t * p_manager )
 {
+  OPJ_BYTE l_data_header [8];
   int i;
   opj_tile_info_t tile;
   opj_tp_info_t tp;
-  int len, lenp;
   opj_marker_info_t *marker;
+  OPJ_UINT32 len;
+  OPJ_OFF_T lenp;
 
-  lenp = cio_tell( cio);
-  cio_skip( cio, 4);                               /* L [at the end]                    */
-  cio_write( cio, JPIP_MHIX, 4);                   /* MHIX                              */
+  lenp = opj_stream_tell (cio);
+  opj_stream_skip(cio, 4, p_manager);               /* L [at the end]                    */
+  opj_write_bytes(l_data_header,JPIP_MHIX,4);       /* MHIX                              */
+  opj_stream_write_data(cio,l_data_header,4,p_manager);
 
   tile = cstr_info.tile[tileno];
   tp = tile.tp[0];
 
-  cio_write( cio, tp.tp_end_header-tp.tp_start_pos+1, 8);  /* TLEN                              */ 
+  opj_write_bytes(l_data_header,(OPJ_UINT32)(tp.tp_end_header-tp.tp_start_pos+1), 8);        /* TLEN                              */
+  opj_stream_write_data(cio,l_data_header,8,p_manager);
 
   marker = cstr_info.tile[tileno].marker;
 
   for( i=0; i<cstr_info.tile[tileno].marknum; i++){             /* Marker restricted to 1 apparition */
-    cio_write( cio, marker[i].type, 2);
-    cio_write( cio, 0, 2);
-    cio_write( cio, marker[i].pos-coff, 8);
-    cio_write( cio, marker[i].len, 2);
+    opj_write_bytes( l_data_header, marker[i].type, 2);
+    opj_write_bytes( l_data_header+2, 0, 2);
+    opj_stream_write_data(cio,l_data_header,4,p_manager);
+    opj_write_bytes( l_data_header, (OPJ_UINT32)(marker[i].pos-coff), 8);
+    opj_stream_write_data(cio,l_data_header,8,p_manager);
+    opj_write_bytes( l_data_header, (OPJ_UINT32)marker[i].len, 2);
+    opj_stream_write_data(cio,l_data_header,2,p_manager);
   }
      
   /*  free( marker);*/
 
-  len = cio_tell( cio) - lenp;
-  cio_seek( cio, lenp);
-  cio_write( cio, len, 4);        /* L           */
-  cio_seek( cio, lenp+len);
+  len = (OPJ_UINT32)(opj_stream_tell(cio)-lenp);
+  opj_stream_seek(cio, lenp,p_manager);
+  opj_write_bytes(l_data_header,len,4);/* L  */
+  opj_stream_write_data(cio,l_data_header,4,p_manager);
+  opj_stream_seek(cio, lenp+len,p_manager);
 
-  return len;
+  return (int)len;
 }
diff --git a/extern/libopenjpeg/tpix_manager.c b/extern/libopenjpeg/tpix_manager.c
index 9ba9e7f..74c02ba 100644
--- a/extern/libopenjpeg/tpix_manager.c
+++ b/extern/libopenjpeg/tpix_manager.c
@@ -1,8 +1,8 @@
 /*
  * $Id: tpix_manager.c 897 2011-08-28 21:43:57Z Kaori.Hagihara@gmail.com $
  *
- * Copyright (c) 2002-2011, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
- * Copyright (c) 2002-2011, Professor Benoit Macq
+ * Copyright (c) 2002-2014, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2014, Professor Benoit Macq
  * Copyright (c) 2003-2004, Yannick Verschueren
  * Copyright (c) 2010-2011, Kaori Hagihara
  * All rights reserved.
@@ -33,11 +33,18 @@
  *  \brief Modification of jpip.c from 2KAN indexer
  */
 
-#include <math.h>
 #include "opj_includes.h"
 
 #define MAX(a,b) ((a)>(b)?(a):(b))
 
+/* 
+ * Get number of maximum tile parts per tile
+ *
+ * @param[in] cstr_info codestream information
+ * @return              number of maximum tile parts per tile
+ */
+int get_num_max_tile_parts( opj_codestream_info_t cstr_info);
+
 
 /* 
  * Write faix box of tpix
@@ -49,46 +56,51 @@
  * @param[in] cio       file output handle
  * @return              length of faix box
  */
-int write_tpixfaix( int coff, int compno, opj_codestream_info_t cstr_info, int j2klen, opj_cio_t *cio);
 
-
-int write_tpix( int coff, opj_codestream_info_t cstr_info, int j2klen, opj_cio_t *cio)
+int opj_write_tpix( int coff, 
+                    opj_codestream_info_t cstr_info, 
+                    int j2klen, opj_stream_private_t *cio,
+                    opj_event_mgr_t * p_manager )
 {
-  int len, lenp;
-  lenp = cio_tell( cio);
-  cio_skip( cio, 4);              /* L [at the end] */
-  cio_write( cio, JPIP_TPIX, 4);  /* TPIX           */
+  OPJ_BYTE l_data_header [4];
+  OPJ_UINT32 len;
+  OPJ_OFF_T lenp;
+
+  lenp = opj_stream_tell(cio);
+  opj_stream_skip(cio, 4, p_manager);
+  opj_write_bytes(l_data_header,JPIP_TPIX,4); /* TPIX */
+  opj_stream_write_data(cio,l_data_header,4,p_manager);
   
-  write_tpixfaix( coff, 0, cstr_info, j2klen, cio);
+  opj_write_tpixfaix( coff, 0, cstr_info, j2klen, cio,p_manager);
 
-  len = cio_tell( cio)-lenp;
-  cio_seek( cio, lenp);
-  cio_write( cio, len, 4);        /* L              */
-  cio_seek( cio, lenp+len);
+  len = (OPJ_UINT32)(opj_stream_tell(cio)-lenp);
+ 
+  opj_stream_skip(cio, lenp, p_manager);
+  opj_write_bytes(l_data_header,len,4);/* L              */
+  opj_stream_write_data(cio,l_data_header,4,p_manager);
+  opj_stream_seek(cio, lenp+len,p_manager);
 
-  return len;
+  return (int)len;
 }
 
-
-/* 
- * Get number of maximum tile parts per tile
- *
- * @param[in] cstr_info codestream information
- * @return              number of maximum tile parts per tile
- */
-int get_num_max_tile_parts( opj_codestream_info_t cstr_info);
-
-int write_tpixfaix( int coff, int compno, opj_codestream_info_t cstr_info, int j2klen, opj_cio_t *cio)
+int opj_write_tpixfaix( int coff,
+                        int compno, 
+                        opj_codestream_info_t cstr_info, 
+                        int j2klen, 
+                        opj_stream_private_t *cio,
+                        opj_event_mgr_t * p_manager )
 {
-  int len, lenp;
-  int i, j;
-  int Aux;
-  int num_max_tile_parts;
-  int size_of_coding; /* 4 or 8 */
+  OPJ_UINT32 len;
+  OPJ_OFF_T lenp;
+  OPJ_UINT32 i, j;
+  OPJ_UINT32 Aux;
+  OPJ_UINT32 num_max_tile_parts;
+  OPJ_UINT32 size_of_coding; /* 4 or 8 */
   opj_tp_info_t tp;
-  int version;
+  OPJ_BYTE l_data_header [8];
+  OPJ_UINT32 version;
 
-  num_max_tile_parts = get_num_max_tile_parts( cstr_info);
+  num_max_tile_parts = (OPJ_UINT32)get_num_max_tile_parts( cstr_info);
 
   if( j2klen > pow( 2, 32)){
     size_of_coding =  8;
@@ -99,47 +111,67 @@ int write_tpixfaix( int coff, int compno, opj_codestream_info_t cstr_info, int j
     version = num_max_tile_parts == 1 ? 0:2;
   }
 
-  lenp = cio_tell( cio);
-  cio_skip( cio, 4);              /* L [at the end]      */
-  cio_write( cio, JPIP_FAIX, 4);  /* FAIX                */ 
-  cio_write( cio, version, 1);     /* Version 0 = 4 bytes */
-
-  cio_write( cio, num_max_tile_parts, size_of_coding);                      /* NMAX           */
-  cio_write( cio, cstr_info.tw*cstr_info.th, size_of_coding);                               /* M              */
-  for (i = 0; i < cstr_info.tw*cstr_info.th; i++){
-    for (j = 0; j < cstr_info.tile[i].num_tps; j++){
+  lenp = opj_stream_tell(cio);
+  opj_stream_skip(cio, 4, p_manager);         /* L [at the end]      */
+  opj_write_bytes(l_data_header,JPIP_FAIX,4); /* FAIX */
+  opj_stream_write_data(cio,l_data_header,4,p_manager);
+  opj_write_bytes(l_data_header,version,1);   /* Version 0 = 4 bytes */
+  opj_stream_write_data(cio,l_data_header,1,p_manager);
+
+  opj_write_bytes(l_data_header,num_max_tile_parts,size_of_coding);         /* NMAX           */
+  opj_stream_write_data(cio,l_data_header,size_of_coding,p_manager);
+  opj_write_bytes(l_data_header,(OPJ_UINT32)(cstr_info.tw*cstr_info.th),size_of_coding);  /* M              */
+  opj_stream_write_data(cio,l_data_header,size_of_coding,p_manager);
+
+  for (i = 0; i < (OPJ_UINT32)(cstr_info.tw*cstr_info.th); i++)
+    {
+    for (j = 0; j < (OPJ_UINT32)cstr_info.tile[i].num_tps; j++)
+      {
       tp = cstr_info.tile[i].tp[j];
-      cio_write( cio, tp.tp_start_pos-coff, size_of_coding); /* start position */
-      cio_write( cio, tp.tp_end_pos-tp.tp_start_pos+1, size_of_coding);    /* length         */
-      if (version & 0x02){
-	if( cstr_info.tile[i].num_tps == 1 && cstr_info.numdecompos[compno] > 1)
-	  Aux = cstr_info.numdecompos[compno] + 1;
-	else
-	  Aux = j + 1;
-		  
-	cio_write( cio, Aux,4);
-	/*cio_write(img.tile[i].tile_parts[j].num_reso_AUX,4);*/ /* Aux_i,j : Auxiliary value */
-	/* fprintf(stderr,"AUX value %d\n",Aux);*/
-      }
+
+      opj_write_bytes(l_data_header,(OPJ_UINT32)(tp.tp_start_pos-coff),size_of_coding);            /* start position */
+      opj_stream_write_data(cio,l_data_header,size_of_coding,p_manager);
+      opj_write_bytes(l_data_header,(OPJ_UINT32)(tp.tp_end_pos-tp.tp_start_pos+1),size_of_coding); /* length         */
+      opj_stream_write_data(cio,l_data_header,size_of_coding,p_manager);
+
+      if (version & 0x02)
+        {
+        if( cstr_info.tile[i].num_tps == 1 && cstr_info.numdecompos[compno] > 1)
+          Aux = (OPJ_UINT32)(cstr_info.numdecompos[compno] + 1);
+        else
+          Aux = j + 1;
+
+        opj_write_bytes(l_data_header,Aux,4);
+        opj_stream_write_data(cio,l_data_header,4,p_manager);
+
+        /*cio_write(img.tile[i].tile_parts[j].num_reso_AUX,4);*/ /* Aux_i,j : Auxiliary value */
+        /* fprintf(stderr,"AUX value %d\n",Aux);*/
+        }
       /*cio_write(0,4);*/
-    }
+      }
     /* PADDING */
-    while (j < num_max_tile_parts){
-      cio_write( cio, 0, size_of_coding); /* start position            */
-      cio_write( cio, 0, size_of_coding); /* length                    */
+    while (j < num_max_tile_parts)
+      {
+
+          opj_write_bytes(l_data_header,0,size_of_coding);/* start position            */
+      opj_stream_write_data(cio,l_data_header,size_of_coding,p_manager);
+      opj_write_bytes(l_data_header,0,size_of_coding);/* length                    */
+      opj_stream_write_data(cio,l_data_header,size_of_coding,p_manager);
+
       if (version & 0x02)
-	cio_write( cio, 0,4);                  /* Aux_i,j : Auxiliary value */
+      opj_write_bytes(l_data_header,0,4);      /* Aux_i,j : Auxiliary value */
+      opj_stream_write_data(cio,l_data_header,4,p_manager);
       j++;
+      }
     }
-  }
   
-  len = cio_tell( cio)-lenp;
-  cio_seek( cio, lenp);
-  cio_write( cio, len, 4);        /* L  */
-  cio_seek( cio, lenp+len);
-
-  return len;
+  len = (OPJ_UINT32)(opj_stream_tell(cio)-lenp);
+  opj_stream_seek(cio, lenp,p_manager);
+  opj_write_bytes(l_data_header,len,4);/* L  */
+  opj_stream_write_data(cio,l_data_header,4,p_manager);
+  opj_stream_seek(cio, lenp+len,p_manager);
 
+  return (int)len;
 }
 
 int get_num_max_tile_parts( opj_codestream_info_t cstr_info)
diff --git a/source/blender/imbuf/intern/IMB_filetype.h b/source/blender/imbuf/intern/IMB_filetype.h
index 2bd7cbc..19d3787 100644
--- a/source/blender/imbuf/intern/IMB_filetype.h
+++ b/source/blender/imbuf/intern/IMB_filetype.h
@@ -82,8 +82,9 @@ int imb_saveiris(struct ImBuf *ibuf, const char *name, int flags);
 
 /* jp2 */
 int imb_is_a_jp2(const unsigned char *buf);
-struct ImBuf *imb_jp2_decode(const unsigned char *mem, size_t size, int flags, char colorspace[IM_MAX_SPACE]);
-int imb_savejp2(struct ImBuf *ibuf, const char *name, int flags);
+struct ImBuf *imb_load_jp2(const unsigned char *mem, size_t size, int flags, char colorspace[IM_MAX_SPACE]);
+struct ImBuf *imb_load_jp2_filepath(const char *name, int flags, char colorspace[IM_MAX_SPACE]);
+int imb_save_jp2(struct ImBuf *ibuf, const char *name, int flags);
 
 /* jpeg */
 int imb_is_a_jpeg(const unsigned char *mem);
diff --git a/source/blender/imbuf/intern/filetype.c b/source/blender/imbuf/intern/filetype.c
index 3d3e8a0..7ffb575 100644
--- a/source/blender/imbuf/intern/filetype.c
+++ b/source/blender/imbuf/intern/filetype.c
@@ -81,7 +81,7 @@ const ImFileType IMB_FILE_TYPES[] = {
 	{imb_initopenexr, NULL, imb_is_a_openexr, NULL, imb_ftype_default, imb_load_openexr, NULL, imb_save_openexr, NULL, IM_FTYPE_FLOAT, IMB_FTYPE_OPENEXR, COLOR_ROLE_DEFAULT_FLOAT},
 #endif
 #ifdef WITH_OPENJPEG
-	{NULL, NULL, imb_is_a_jp2, NULL, imb_ftype_default, imb_jp2_decode, NULL, imb_savejp2, NULL, IM_FTYPE_FLOAT, IMB_FTYPE_JP2, COLOR_ROLE_DEFAULT_BYTE},
+	{NULL, NULL, imb_is_a_jp2, NULL, imb_ftype_default, imb_load_jp2, imb_load_jp2_filepath, imb_save_jp2, NULL, IM_FTYPE_FLOAT, IMB_FTYPE_JP2, COLOR_ROLE_DEFAULT_BYTE},
 #endif
 #ifdef WITH_DDS
 	{NULL, NULL, imb_is_a_dds, NULL, imb_ftype_default, imb_load_dds, NULL, NULL, NULL, 0, IMB_FTYPE_DDS, COLOR_ROLE_DEFAULT_BYTE},
diff --git a/source/blender/imbuf/intern/jp2.c b/source/blender/imbuf/intern/jp2.c
index 388c273..aae16d3 100644
--- a/source/blender/imbuf/intern/jp2.c
+++ b/source/blender/imbuf/intern/jp2.c
@@ -38,7 +38,7 @@
 
 #include "openjpeg.h"
 
-// #define JP2_FILEHEADER_SIZE 14  /* UNUSED */
+#define JP2_FILEHEADER_SIZE 12
 
 static const char JP2_HEAD[] = {0x0, 0x0, 0x0, 0x0C, 0x6A, 0x50, 0x20, 0x20, 0x0D, 0x0A, 0x87, 0x0A};
 static const char J2K_HEAD[] = {0xFF, 0x4F, 0xFF, 0x51, 0x00};
@@ -73,6 +73,19 @@ static bool check_j2k(const unsigned char *mem) /* J2K_CFMT */
 	return memcmp(J2K_HEAD, mem, sizeof(J2K_HEAD)) ? 0 : 1;
 }
 
+static OPJ_CODEC_FORMAT format_from_header(const unsigned char mem[JP2_FILEHEADER_SIZE])
+{
+	if (check_jp2(mem)) {
+		return OPJ_CODEC_JP2;
+	}
+	else if (check_j2k(mem)) {
+		return OPJ_CODEC_J2K;
+	}
+	else {
+		return OPJ_CODEC_UNKNOWN;
+	}
+}
+
 int imb_is_a_jp2(const unsigned char *buf)
 {
 	return check_jp2(buf);
@@ -99,8 +112,8 @@ static void warning_callback(const char *msg, void *client_data)
  */
 static void info_callback(const char *msg, void *client_data)
 {
-	(void)client_data;
-	fprintf(stdout, "[INFO] %s", msg);
+	FILE *stream = (FILE *)client_data;
+	fprintf(stream, "[INFO] %s", msg);
 }
 
 #   define PIXEL_LOOPER_BEGIN(_rect)                                          \
@@ -121,8 +134,233 @@ static void info_callback(const char *msg, void *client_data)
 	} \
 	} (void)0 \
 
-struct ImBuf *imb_jp2_decode(const unsigned char *mem, size_t size, int flags, char colorspace[IM_MAX_SPACE])
+
+/** \name Buffer Stream
+ * \{ */
+
+struct BufInfo {
+	const unsigned char *buf;
+	const unsigned char *cur;
+	off_t len;
+};
+
+static void opj_read_from_buffer_free(void *UNUSED(p_user_data))
+{
+	/* nop */
+}
+
+static OPJ_SIZE_T opj_read_from_buffer(void *p_buffer, OPJ_SIZE_T p_nb_bytes, void *p_user_data)
+{
+	struct BufInfo *p_file = p_user_data;
+	OPJ_UINT32 l_nb_read;
+
+	if (p_file->cur + p_nb_bytes < p_file->buf + p_file->len ) {
+		l_nb_read = p_nb_bytes;
+	}
+	else {
+		l_nb_read = (OPJ_UINT32)(p_file->buf + p_file->len - p_file->cur);
+	}
+	memcpy(p_buffer, p_file->cur, l_nb_read);
+	p_file->cur += l_nb_read;
+
+	return l_nb_read ? l_nb_read : ((OPJ_SIZE_T)-1);
+}
+
+#if 0
+static OPJ_SIZE_T opj_write_from_buffer(void *p_buffer, OPJ_SIZE_T p_nb_bytes, void *p_user_data)
+{
+	struct BufInfo *p_file = p_user_data;
+	memcpy(p_file->cur, p_buffer, p_nb_bytes);
+	p_file->cur += p_nb_bytes;
+	p_file->len += p_nb_bytes;
+	return p_nb_bytes;
+}
+#endif
+
+static OPJ_OFF_T opj_skip_from_buffer(OPJ_OFF_T p_nb_bytes, void *p_user_data)
+{
+	struct BufInfo *p_file = p_user_data;
+	if (p_file->cur + p_nb_bytes < p_file->buf + p_file->len) {
+		p_file->cur += p_nb_bytes;
+		return p_nb_bytes;
+	}
+	p_file->cur = p_file->buf + p_file->len;
+	return (OPJ_OFF_T)-1;
+}
+
+static OPJ_BOOL opj_seek_from_buffer(OPJ_OFF_T p_nb_bytes, void *p_user_data)
+{
+	struct BufInfo *p_file = p_user_data;
+	if (p_file->cur + p_nb_bytes < p_file->buf + p_file->len) {
+		p_file->cur += p_nb_bytes;
+		return OPJ_TRUE;
+	}
+	p_file->cur = p_file->buf + p_file->len;
+	return OPJ_FALSE;
+}
+
+/**
+ * Stream wrapper for memory buffer
+ * (would be nice if this was supported by the API).
+ */
+
+static opj_stream_t *opj_stream_create_from_buffer(
+        struct BufInfo *p_file, OPJ_UINT32 p_size,
+        OPJ_BOOL p_is_read_stream)
+{
+	opj_stream_t *l_stream = opj_stream_create(p_size, p_is_read_stream);
+	if (l_stream == NULL) {
+		return NULL;
+	}
+	opj_stream_set_user_data(l_stream, p_file , opj_read_from_buffer_free);
+	opj_stream_set_user_data_length(l_stream, p_file->len);
+	opj_stream_set_read_function(l_stream,  opj_read_from_buffer);
+#if 0  /* UNUSED */
+	opj_stream_set_write_function(l_stream, opj_write_from_buffer);
+#endif
+	opj_stream_set_skip_function(l_stream, opj_skip_from_buffer);
+	opj_stream_set_seek_function(l_stream, opj_seek_from_buffer);
+
+	return l_stream;
+}
+
+/** \} */
+
+
+/** \name File Stream
+ * \{ */
+
+static void opj_free_from_file(void *p_user_data)
+{
+	FILE *f = p_user_data;
+	fclose(f);
+}
+
+static OPJ_UINT64 opj_get_data_length_from_file (void *p_user_data)
+{
+	FILE *p_file = p_user_data;
+	OPJ_OFF_T file_length = 0;
+
+	fseek(p_file, 0, SEEK_END);
+	file_length = ftell(p_file);
+	fseek(p_file, 0, SEEK_SET);
+
+	return (OPJ_UINT64)file_length;
+}
+
+static OPJ_SIZE_T opj_read_from_file(void *p_buffer, OPJ_SIZE_T p_nb_bytes, void *p_user_data)
+{
+	FILE *p_file = p_user_data;
+	OPJ_SIZE_T l_nb_read = fread(p_buffer, 1, p_nb_bytes, p_file);
+	return l_nb_read ? l_nb_read : (OPJ_SIZE_T)-1;
+}
+
+static OPJ_SIZE_T opj_write_from_file(void *p_buffer, OPJ_SIZE_T p_nb_bytes, void *p_user_data)
+{
+	FILE *p_file = p_user_data;
+	return fwrite(p_buffer, 1, p_nb_bytes, p_file);
+}
+
+static OPJ_OFF_T opj_skip_from_file(OPJ_OFF_T p_nb_bytes, void *p_user_data)
+{
+	FILE *p_file = p_user_data;
+	if (fseek(p_file, p_nb_bytes, SEEK_CUR)) {
+		return -1;
+	}
+	return p_nb_bytes;
+}
+
+static OPJ_BOOL opj_seek_from_file(OPJ_OFF_T p_nb_bytes, void *p_user_data)
+{
+	FILE *p_file = p_user_data;
+	if (fseek(p_file, p_nb_bytes, SEEK_SET)) {
+		return OPJ_FALSE;
+	}
+	return OPJ_TRUE;
+}
+
+/**
+ * Stream wrapper for memory file
+ * (would be nice if this was supported by the API).
+ */
+
+static opj_stream_t *opj_stream_create_from_file(
+        const char *filepath, OPJ_UINT32 p_size, OPJ_BOOL p_is_read_stream,
+        FILE **r_file)
+{
+	FILE *p_file = BLI_fopen(filepath, p_is_read_stream ? "rb" : "wb");
+	if (p_file == NULL) {
+		return NULL;
+	}
+
+	opj_stream_t *l_stream = opj_stream_create(p_size, p_is_read_stream);
+	if (l_stream == NULL) {
+		fclose(p_file);
+		return NULL;
+	}
+
+	opj_stream_set_user_data(l_stream, p_file, opj_free_from_file);
+	opj_stream_set_user_data_length(l_stream, opj_get_data_length_from_file(p_file));
+	opj_stream_set_write_function(l_stream, opj_write_from_file);
+	opj_stream_set_read_function(l_stream,  opj_read_from_file);
+	opj_stream_set_skip_function(l_stream, opj_skip_from_file);
+	opj_stream_set_seek_function(l_stream, opj_seek_from_file);
+
+	if (r_file) {
+		*r_file = p_file;
+	}
+	return l_stream;
+}
+
+/** \} */
+
+static ImBuf *imb_load_jp2_stream(
+        opj_stream_t stream, OPJ_CODEC_FORMAT p_format,
+        int flags, char colorspace[IM_MAX_SPACE]);
+
+ImBuf *imb_load_jp2(const unsigned char *mem, size_t size, int flags, char colorspace[IM_MAX_SPACE])
 {
+	const OPJ_CODEC_FORMAT format = (size > JP2_FILEHEADER_SIZE) ? format_from_header(mem) : OPJ_CODEC_UNKNOWN;
+	struct BufInfo buf_wrapper = { .buf = mem, .cur = mem, .len = size, };
+	opj_stream_t stream = opj_stream_create_from_buffer(&buf_wrapper, OPJ_J2K_STREAM_CHUNK_SIZE, true);
+	ImBuf *ibuf = imb_load_jp2_stream(stream, format, flags, colorspace);
+	opj_stream_destroy(stream);
+	return ibuf;
+}
+
+ImBuf *imb_load_jp2_filepath(const char *filepath, int flags, char colorspace[IM_MAX_SPACE])
+{
+	FILE *p_file = NULL;
+	unsigned char mem[JP2_FILEHEADER_SIZE];
+	opj_stream_t *stream = opj_stream_create_from_file(filepath, OPJ_J2K_STREAM_CHUNK_SIZE, false, &p_file);
+	if (stream) {
+		return NULL;
+	}
+	else {
+		if (fread(mem, sizeof(mem), 1, p_file) != sizeof(mem)) {
+			opj_stream_destroy(stream);
+			return NULL;
+		}
+		else {
+			fseek(p_file, 0, SEEK_SET);
+		}
+	}
+
+	const OPJ_CODEC_FORMAT format = format_from_header(mem);
+	ImBuf *ibuf = imb_load_jp2_stream(stream, format, flags, colorspace);
+	opj_stream_destroy(stream);
+	return ibuf;
+}
+
+
+static ImBuf *imb_load_jp2_stream(
+        opj_stream_t stream, const OPJ_CODEC_FORMAT format,
+        int flags, char colorspace[IM_MAX_SPACE])
+{
+	if (format == OPJ_CODEC_UNKNOWN) {
+		return NULL;
+	}
+
 	struct ImBuf *ibuf = NULL;
 	bool use_float = false; /* for precision higher then 8 use float */
 	bool use_alpha = false;
@@ -133,68 +371,49 @@ struct ImBuf *imb_jp2_decode(const unsigned char *mem, size_t size, int flags, c
 	unsigned int i, i_next, w, h, planes;
 	unsigned int y;
 	int *r, *g, *b, *a; /* matching 'opj_image_comp.data' type */
-	bool is_jp2, is_j2k;
 	
 	opj_dparameters_t parameters;   /* decompression parameters */
 	
-	opj_event_mgr_t event_mgr;      /* event manager */
 	opj_image_t *image = NULL;
-
-	opj_dinfo_t *dinfo = NULL;  /* handle to a decompressor */
-	opj_cio_t *cio = NULL;
-
-	is_jp2 = check_jp2(mem);
-	is_j2k = check_j2k(mem);
-
-	if (!is_jp2 && !is_j2k)
-		return(NULL);
+	opj_codec_t *codec = NULL;  /* handle to a decompressor */
 
 	/* both 8, 12 and 16 bit JP2Ks are default to standard byte colorspace */
 	colorspace_set_default_role(colorspace, IM_MAX_SPACE, COLOR_ROLE_DEFAULT_BYTE);
 
-	/* configure the event callbacks (not required) */
-	memset(&event_mgr, 0, sizeof(opj_event_mgr_t));
-	event_mgr.error_handler = error_callback;
-	event_mgr.warning_handler = warning_callback;
-	event_mgr.info_handler = info_callback;
-
-
 	/* set decoding parameters to default values */
 	opj_set_default_decoder_parameters(&parameters);
 
-
 	/* JPEG 2000 compressed image data */
 
 	/* get a decoder handle */
-	dinfo = opj_create_decompress(is_jp2 ? CODEC_JP2 : CODEC_J2K);
+	codec = opj_create_decompress(format);
 
-	/* catch events using our callbacks and give a local context */
-	opj_set_event_mgr((opj_common_ptr)dinfo, &event_mgr, stderr);
+	/* configure the event callbacks (not required) */
+	opj_set_error_handler(codec, error_callback, stderr);
+	opj_set_warning_handler(codec, warning_callback, stderr);
+#ifdef DEBUG  /* too noisy */
+	opj_set_info_handler(codec, info_callback, stderr);
+#endif
 
 	/* setup the decoder decoding parameters using the current image and user parameters */
-	opj_setup_decoder(dinfo, &parameters);
+	if (opj_setup_decoder(codec, &parameters) == false) {
+		goto finally;
+	}
 
-	/* open a byte stream */
-	/* note, we can't avoid removing 'const' cast here */
-	cio = opj_cio_open((opj_common_ptr)dinfo, (unsigned char *)mem, size);
+	if (opj_read_header(stream, codec, &image) == false) {
+		printf("OpenJPEG error: failed to read the header\n");
+		goto finally;
+	}
 
 	/* decode the stream and fill the image structure */
-	image = opj_decode(dinfo, cio);
-	
-	if (!image) {
+	if (opj_decode(codec, stream, image) == false) {
 		fprintf(stderr, "ERROR -> j2k_to_image: failed to decode image!\n");
-		opj_destroy_decompress(dinfo);
-		opj_cio_close(cio);
-		return NULL;
+		goto finally;
 	}
 
-	/* close the byte stream */
-	opj_cio_close(cio);
-
-
 	if ((image->numcomps * image->x1 * image->y1) == 0) {
 		fprintf(stderr, "\nError: invalid raw image parameters\n");
-		return NULL;
+		goto finally;
 	}
 	
 	w = image->comps[0].w;
@@ -232,16 +451,16 @@ struct ImBuf *imb_jp2_decode(const unsigned char *mem, size_t size, int flags, c
 	ibuf = IMB_allocImBuf(w, h, planes, use_float ? IB_rectfloat : IB_rect);
 	
 	if (ibuf == NULL) {
-		if (dinfo)
-			opj_destroy_decompress(dinfo);
-		return NULL;
+		goto finally;
 	}
 	
 	ibuf->ftype = IMB_FTYPE_JP2;
-	if (is_jp2)
+	if (1 /* is_jp2 */ ) {
 		ibuf->foptions.flag |= JP2_JP2;
-	else
+	}
+	else {
 		ibuf->foptions.flag |= JP2_J2K;
+	}
 	
 	if (use_float) {
 		float *rect_float = ibuf->rect_float;
@@ -347,19 +566,23 @@ struct ImBuf *imb_jp2_decode(const unsigned char *mem, size_t size, int flags, c
 		}
 	}
 	
-	/* free remaining structures */
-	if (dinfo) {
-		opj_destroy_decompress(dinfo);
-	}
-	
-	/* free image data structure */
-	opj_image_destroy(image);
-	
 	if (flags & IB_rect) {
 		IMB_rect_from_float(ibuf);
 	}
-	
-	return(ibuf);
+
+
+finally:
+
+	/* free remaining structures */
+	if (codec) {
+		opj_destroy_codec(codec);
+	}
+
+	if (image) {
+		opj_image_destroy(image);
+	}
+
+	return ibuf;
 }
 
 //static opj_image_t* rawtoimage(const char *filename, opj_cparameters_t *parameters, raw_cparameters_t *raw_cp)
@@ -422,14 +645,14 @@ static int initialise_4K_poc(opj_poc_t *POC, int numres)
 	POC[0].layno1  = 1;
 	POC[0].resno1  = numres - 1;
 	POC[0].compno1 = 3;
-	POC[0].prg1 = CPRL;
+	POC[0].prg1 = OPJ_CPRL;
 	POC[1].tile  = 1;
 	POC[1].resno0  = numres - 1;
 	POC[1].compno0 = 0;
 	POC[1].layno1  = 1;
 	POC[1].resno1  = numres;
 	POC[1].compno1 = 3;
-	POC[1].prg1 = CPRL;
+	POC[1].prg1 = OPJ_CPRL;
 	return 2;
 }
 
@@ -455,7 +678,7 @@ static void cinema_parameters(opj_cparameters_t *parameters)
 	parameters->csty |= 0x01;
 
 	/*The progression order shall be CPRL*/
-	parameters->prog_order = CPRL;
+	parameters->prog_order = OPJ_CPRL;
 
 	/* No ROI */
 	parameters->roi_compno = -1;
@@ -472,23 +695,23 @@ static void cinema_setup_encoder(opj_cparameters_t *parameters, opj_image_t *ima
 	float temp_rate;
 
 	switch (parameters->cp_cinema) {
-		case CINEMA2K_24:
-		case CINEMA2K_48:
+		case OPJ_CINEMA2K_24:
+		case OPJ_CINEMA2K_48:
 			if (parameters->numresolution > 6) {
 				parameters->numresolution = 6;
 			}
 			if (!((image->comps[0].w == 2048) || (image->comps[0].h == 1080))) {
-				fprintf(stdout, "Image coordinates %d x %d is not 2K compliant.\nJPEG Digital Cinema Profile-3 "
+				fprintf(stdout, "Image coordinates %u x %u is not 2K compliant.\nJPEG Digital Cinema Profile-3 "
 				        "(2K profile) compliance requires that at least one of coordinates match 2048 x 1080\n",
 				        image->comps[0].w, image->comps[0].h);
-				parameters->cp_rsiz = STD_RSIZ;
+				parameters->cp_rsiz = OPJ_STD_RSIZ;
 			}
 			else {
 				parameters->cp_rsiz = DCP_CINEMA2K;
 			}
 			break;
 	
-		case CINEMA4K_24:
+		case OPJ_CINEMA4K_24:
 			if (parameters->numresolution < 1) {
 				parameters->numresolution = 1;
 			}
@@ -496,24 +719,24 @@ static void cinema_setup_encoder(opj_cparameters_t *parameters, opj_image_t *ima
 				parameters->numresolution = 7;
 			}
 			if (!((image->comps[0].w == 4096) || (image->comps[0].h == 2160))) {
-				fprintf(stdout, "Image coordinates %d x %d is not 4K compliant.\nJPEG Digital Cinema Profile-4"
+				fprintf(stdout, "Image coordinates %u x %u is not 4K compliant.\nJPEG Digital Cinema Profile-4"
 				        "(4K profile) compliance requires that at least one of coordinates match 4096 x 2160\n",
 				        image->comps[0].w, image->comps[0].h);
-				parameters->cp_rsiz = STD_RSIZ;
+				parameters->cp_rsiz = OPJ_STD_RSIZ;
 			}
 			else {
 				parameters->cp_rsiz = DCP_CINEMA2K;
 			}
 			parameters->numpocs = initialise_4K_poc(parameters->POC, parameters->numresolution);
 			break;
-		case OFF:
+		case OPJ_OFF:
 			/* do nothing */
 			break;
 	}
 
 	switch (parameters->cp_cinema) {
-		case CINEMA2K_24:
-		case CINEMA4K_24:
+		case OPJ_CINEMA2K_24:
+		case OPJ_CINEMA4K_24:
 			for (i = 0; i < parameters->tcp_numlayers; i++) {
 				temp_rate = 0;
 				if (img_fol->rates[i] == 0) {
@@ -535,7 +758,7 @@ static void cinema_setup_encoder(opj_cparameters_t *parameters, opj_image_t *ima
 			parameters->max_comp_size = COMP_24_CS;
 			break;
 		
-		case CINEMA2K_48:
+		case OPJ_CINEMA2K_48:
 			for (i = 0; i < parameters->tcp_numlayers; i++) {
 				temp_rate = 0;
 				if (img_fol->rates[i] == 0) {
@@ -556,7 +779,7 @@ static void cinema_setup_encoder(opj_cparameters_t *parameters, opj_image_t *ima
 			}
 			parameters->max_comp_size = COMP_48_CS;
 			break;
-		case OFF:
+		case OPJ_OFF:
 			/* do nothing */
 			break;
 	}
@@ -600,13 +823,13 @@ static opj_image_t *ibuftoimage(ImBuf *ibuf, opj_cparameters_t *parameters)
 	if (ibuf->foptions.flag & JP2_CINE) {
 		
 		if (ibuf->x == 4096 || ibuf->y == 2160)
-			parameters->cp_cinema = CINEMA4K_24;
+			parameters->cp_cinema = OPJ_CINEMA4K_24;
 		else {
 			if (ibuf->foptions.flag & JP2_CINE_48FPS) {
-				parameters->cp_cinema = CINEMA2K_48;
+				parameters->cp_cinema = OPJ_CINEMA2K_48;
 			}
 			else {
-				parameters->cp_cinema = CINEMA2K_24;
+				parameters->cp_cinema = OPJ_CINEMA2K_24;
 			}
 		}
 		if (parameters->cp_cinema) {
@@ -617,13 +840,13 @@ static opj_image_t *ibuftoimage(ImBuf *ibuf, opj_cparameters_t *parameters)
 			cinema_parameters(parameters);
 		}
 		
-		color_space = (ibuf->foptions.flag & JP2_YCC) ? CLRSPC_SYCC : CLRSPC_SRGB;
+		color_space = (ibuf->foptions.flag & JP2_YCC) ? OPJ_CLRSPC_SYCC : OPJ_CLRSPC_SRGB;
 		prec = 12;
 		numcomps = 3;
 	}
 	else {
 		/* Get settings from the imbuf */
-		color_space = (ibuf->foptions.flag & JP2_YCC) ? CLRSPC_SYCC : CLRSPC_SRGB;
+		color_space = (ibuf->foptions.flag & JP2_YCC) ? OPJ_CLRSPC_SYCC : OPJ_CLRSPC_SRGB;
 		
 		if (ibuf->foptions.flag & JP2_16BIT) prec = 16;
 		else if (ibuf->foptions.flag & JP2_12BIT) prec = 12;
@@ -958,28 +1181,27 @@ static opj_image_t *ibuftoimage(ImBuf *ibuf, opj_cparameters_t *parameters)
 	return image;
 }
 
+int imb_save_jp2_stream(struct ImBuf *ibuf, opj_stream_t stream, int flags);
+
+int imb_save_jp2(struct ImBuf *ibuf, const char *filepath, int flags)
+{
+	opj_stream_t stream = opj_stream_create_from_file(filepath, OPJ_J2K_STREAM_CHUNK_SIZE, false, NULL);
+	if (stream == NULL) {
+		return 0;
+	}
+	int ret = imb_save_jp2_stream(ibuf, stream, flags);
+	opj_stream_destroy(stream);
+	return ret;
+}
 
 /* Found write info at http://users.ece.gatech.edu/~slabaugh/personal/c/bitmapUnix.c */
-int imb_savejp2(struct ImBuf *ibuf, const char *name, int flags)
+int imb_save_jp2_stream(struct ImBuf *ibuf, opj_stream_t stream, int UNUSED(flags))
 {
 	int quality = ibuf->foptions.quality;
 	
-	int bSuccess;
 	opj_cparameters_t parameters;   /* compression parameters */
-	opj_event_mgr_t event_mgr;      /* event manager */
 	opj_image_t *image = NULL;
 	
-	(void)flags; /* unused */
-	
-	/*
-	 * configure the event callbacks (not required)
-	 * setting of each callback is optional
-	 */
-	memset(&event_mgr, 0, sizeof(opj_event_mgr_t));
-	event_mgr.error_handler = error_callback;
-	event_mgr.warning_handler = warning_callback;
-	event_mgr.info_handler = info_callback;
-	
 	/* set encoding parameters to default values */
 	opj_set_default_encoder_parameters(&parameters);
 	
@@ -993,61 +1215,61 @@ int imb_savejp2(struct ImBuf *ibuf, const char *name, int flags)
 	parameters.cp_disto_alloc = 1;
 
 	image = ibuftoimage(ibuf, &parameters);
-	
-	
-	{   /* JP2 format output */
-		int codestream_length;
-		opj_cio_t *cio = NULL;
-		FILE *f = NULL;
-		opj_cinfo_t *cinfo = NULL;
 
+	opj_codec_t *codec = NULL;
+	int ok = false;
+	/* JP2 format output */
+	{
 		/* get a JP2 compressor handle */
-		if (ibuf->foptions.flag & JP2_JP2)
-			cinfo = opj_create_compress(CODEC_JP2);
-		else if (ibuf->foptions.flag & JP2_J2K)
-			cinfo = opj_create_compress(CODEC_J2K);
-		else
-			BLI_assert(!"Unsupported codec was specified in save settings");
-
-		/* catch events using our callbacks and give a local context */
-		opj_set_event_mgr((opj_common_ptr)cinfo, &event_mgr, stderr);
+		OPJ_CODEC_FORMAT format = OPJ_CODEC_JP2;
+		if (ibuf->foptions.flag & JP2_J2K) {
+			format = OPJ_CODEC_J2K;
+		}
+		else if (ibuf->foptions.flag & JP2_JP2) {
+			format = OPJ_CODEC_JP2;
+		}
 
-		/* setup the encoder parameters using the current image and using user parameters */
-		opj_setup_encoder(cinfo, &parameters, image);
+		codec = opj_create_compress(format);
 
-		/* open a byte stream for writing */
-		/* allocate memory for all tiles */
-		cio = opj_cio_open((opj_common_ptr)cinfo, NULL, 0);
+		/* configure the event callbacks (not required) */
+		opj_set_error_handler(codec, error_callback, stderr);
+		opj_set_warning_handler(codec, warning_callback, stderr);
+#ifdef DEBUG  /* too noisy */
+		opj_set_info_handler(codec, info_callback, stderr);
+#endif
 
-		/* encode the image */
-		bSuccess = opj_encode(cinfo, cio, image, NULL); /* last arg used to be parameters.index but this deprecated */
-		
-		if (!bSuccess) {
-			opj_cio_close(cio);
-			fprintf(stderr, "failed to encode image\n");
-			return 0;
+		/* setup the encoder parameters using the current image and using user parameters */
+		if (opj_setup_encoder(codec, &parameters, image) == false) {
+			goto finally;
 		}
-		codestream_length = cio_tell(cio);
 
-		/* write the buffer to disk */
-		f = BLI_fopen(name, "wb");
-		
-		if (!f) {
-			fprintf(stderr, "failed to open %s for writing\n", name);
-			return 1;
+		if (opj_start_compress(codec, image, stream) == false) {
+			goto finally;
 		}
-		fwrite(cio->buffer, 1, codestream_length, f);
-		fclose(f);
-		fprintf(stderr, "Generated outfile %s\n", name);
-		/* close and free the byte stream */
-		opj_cio_close(cio);
-		
-		/* free remaining compression structures */
-		opj_destroy_compress(cinfo);
+		if (opj_encode(codec, stream) == false) {
+			goto finally;
+		}
+		if (opj_end_compress(codec, stream) == false) {
+			goto finally;
+		}
+	}
+
+	ok = true;
+
+finally:
+	/* free remaining compression structures */
+	if (codec) {
+		opj_destroy_codec(codec);
 	}
 
 	/* free image data */
-	opj_image_destroy(image);
-	
-	return 1;
+	if (image) {
+		opj_image_destroy(image);
+	}
+
+	if (ok == false) {
+		fprintf(stderr, "failed to encode image\n");
+	}
+
+	return ok;
 }

