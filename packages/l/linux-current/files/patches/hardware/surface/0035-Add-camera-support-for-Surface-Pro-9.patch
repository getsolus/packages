From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Tooraj Taraz <tooraj.taraz@yahoo.com>
Date: Wed, 31 Dec 2025 00:35:50 +0100
Subject: [PATCH 35/40] Add camera support for Surface Pro 9

Experimental camera support for the Surface Pro 9.

Link: https://github.com/linux-surface/linux-surface/pull/1867
Patchset: cameras
---
 drivers/media/i2c/ov13858.c                   | 158 +++++++++++++++++-
 drivers/media/i2c/ov5693.c                    |   1 +
 drivers/media/pci/intel/ipu-bridge.c          |   4 +
 drivers/platform/x86/intel/int3472/discrete.c |  23 +++
 4 files changed, 184 insertions(+), 2 deletions(-)

diff --git a/drivers/media/i2c/ov13858.c b/drivers/media/i2c/ov13858.c
index 162b49046990a..85cd0c98af031 100644
--- a/drivers/media/i2c/ov13858.c
+++ b/drivers/media/i2c/ov13858.c
@@ -2,6 +2,7 @@
 // Copyright (c) 2017 Intel Corporation.
 
 #include <linux/acpi.h>
+#include <linux/delay.h>
 #include <linux/clk.h>
 #include <linux/i2c.h>
 #include <linux/module.h>
@@ -119,6 +120,14 @@ struct ov13858_mode {
 	struct ov13858_reg_list reg_list;
 };
 
+// Or use standard names that might be more correct:
+static const char * const ov13858_supply_names[] = {
+	"avdd",    // Analog voltage
+	"pwr1",    // Digital core voltage
+};
+
+#define OV13858_NUM_SUPPLIES ARRAY_SIZE(ov13858_supply_names)
+
 /* 4224x3136 needs 1080Mbps/lane, 4 lanes */
 static const struct ov13858_reg mipi_data_rate_1080mbps[] = {
 	/* PLL1 registers */
@@ -1046,12 +1055,126 @@ struct ov13858 {
 	/* Current mode */
 	const struct ov13858_mode *cur_mode;
 
+	struct regulator_bulk_data supplies[OV13858_NUM_SUPPLIES];
+	struct gpio_desc *reset;
+	struct clk *xvclk;
+
 	/* Mutex for serialized access */
 	struct mutex mutex;
 };
 
 #define to_ov13858(_sd)	container_of(_sd, struct ov13858, sd)
 
+
+static int ov13858_get_regulators(struct ov13858 *ov13858)
+{
+	unsigned int i;
+
+	for (i = 0; i < OV13858_NUM_SUPPLIES; i++)
+		ov13858->supplies[i].supply = ov13858_supply_names[i];
+
+	return devm_regulator_bulk_get(ov13858->dev, OV13858_NUM_SUPPLIES,
+				       ov13858->supplies);
+}
+
+static int ov13858_sensor_powerup(struct ov13858 *ov13858)
+{
+	int ret;
+
+	dev_info(ov13858->dev, "Powering up sensor\n");
+
+	/* Assert reset */
+	gpiod_set_value_cansleep(ov13858->reset, 1);
+
+	/* Enable clock FIRST - sensor needs clock to communicate */
+	ret = clk_prepare_enable(ov13858->xvclk);
+	if (ret) {
+		dev_err(ov13858->dev, "Failed to enable clock: %d\n", ret);
+		return ret;
+	}
+	dev_info(ov13858->dev, "Clock enabled\n");
+
+	/* Enable regulators */
+	ret = regulator_bulk_enable(OV13858_NUM_SUPPLIES, ov13858->supplies);
+	if (ret) {
+		dev_err(ov13858->dev, "Failed to enable regulators: %d\n", ret);
+		clk_disable_unprepare(ov13858->xvclk);
+		return ret;
+	}
+
+	dev_info(ov13858->dev, "Regulators enabled\n");
+
+	/* Wait for power to stabilize */
+	usleep_range(5000, 10000);
+
+	/* De-assert reset */
+	gpiod_set_value_cansleep(ov13858->reset, 0);
+
+	/* Wait for sensor to boot */
+	msleep(20);
+
+	dev_info(ov13858->dev, "Reset de-asserted, sensor should be ready\n");
+
+	return 0;
+}
+
+static void ov13858_sensor_powerdown(struct ov13858 *ov13858)
+{
+	dev_info(ov13858->dev, "Powering down sensor\n");
+
+	/* Assert reset to put sensor in reset state */
+	gpiod_set_value_cansleep(ov13858->reset, 1);
+
+	/* Disable regulators */
+	regulator_bulk_disable(OV13858_NUM_SUPPLIES, ov13858->supplies);
+	dev_info(ov13858->dev, "Regulators disabled\n");
+
+	/* Disable clock */
+	clk_disable_unprepare(ov13858->xvclk);
+	dev_info(ov13858->dev, "Clock disabled\n");
+}
+
+static int __maybe_unused ov13858_suspend(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov13858 *ov13858 = to_ov13858(sd);
+
+	ov13858_sensor_powerdown(ov13858);
+
+	return 0;
+}
+
+static int __maybe_unused ov13858_resume(struct device *dev)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct v4l2_subdev *sd = i2c_get_clientdata(client);
+	struct ov13858 *ov13858 = to_ov13858(sd);
+	int ret;
+
+	ret = ov13858_sensor_powerup(ov13858);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+static const struct dev_pm_ops ov13858_pm_ops = {
+	SET_RUNTIME_PM_OPS(ov13858_suspend, ov13858_resume, NULL)
+};
+
+static int ov13858_get_gpios(struct ov13858 *ov13858)
+{
+	ov13858->reset = devm_gpiod_get_optional(ov13858->dev, "reset",
+	                                         GPIOD_OUT_HIGH);
+	if (IS_ERR(ov13858->reset)) {
+		dev_err(ov13858->dev, "Error fetching reset GPIO\n");
+		return PTR_ERR(ov13858->reset);
+	}
+
+	return 0;
+}
+
 /* Read registers up to 4 at a time */
 static int ov13858_read_reg(struct ov13858 *ov13858, u16 reg, u32 len,
 			    u32 *val)
@@ -1498,8 +1621,11 @@ static int ov13858_identify_module(struct ov13858 *ov13858)
 	int ret;
 	u32 val;
 
+	dev_info(ov13858->dev, "Attempting to read chip ID from register 0x300a\n");
 	ret = ov13858_read_reg(ov13858, OV13858_REG_CHIP_ID,
 			       OV13858_REG_VALUE_24BIT, &val);
+	dev_info(ov13858->dev, "Chip ID read result: ret=%d, val=0x%06x (expected 0x%06x)\n",
+	         ret, val, OV13858_CHIP_ID);
 	if (ret)
 		return ret;
 
@@ -1509,6 +1635,7 @@ static int ov13858_identify_module(struct ov13858 *ov13858)
 		return -EIO;
 	}
 
+	dev_info(ov13858->dev, "Chip ID verified successfully!\n");
 	return 0;
 }
 
@@ -1678,14 +1805,33 @@ static int ov13858_probe(struct i2c_client *client)
 				     "external clock %lu is not supported\n",
 				     freq);
 
+	/* Get the external clock */
+	ov13858->xvclk = devm_clk_get_optional(ov13858->dev, "xvclk");
+	if (IS_ERR(ov13858->xvclk))
+		return dev_err_probe(ov13858->dev, PTR_ERR(ov13858->xvclk),
+		       "failed to get xvclk\n");
+
 	/* Initialize subdev */
 	v4l2_i2c_subdev_init(&ov13858->sd, client, &ov13858_subdev_ops);
 
+	ret = ov13858_get_regulators(ov13858);
+	if (ret)
+		return dev_err_probe(ov13858->dev, ret,
+		       "Error fetching regulators\n");
+
+	ret = ov13858_get_gpios(ov13858);
+	if (ret)
+		return ret;
+
+	ret = ov13858_sensor_powerup(ov13858);
+	if (ret)
+		return ret;  // No cleanup needed yet, devm handles GPIOs/regulators
+
 	/* Check module identity */
 	ret = ov13858_identify_module(ov13858);
 	if (ret) {
 		dev_err(ov13858->dev, "failed to find sensor: %d\n", ret);
-		return ret;
+		goto error_power_off;  // Now we need to power down
 	}
 
 	/* Set default mode to max resolution */
@@ -1693,7 +1839,7 @@ static int ov13858_probe(struct i2c_client *client)
 
 	ret = ov13858_init_controls(ov13858);
 	if (ret)
-		return ret;
+		goto error_power_off;
 
 	/* Initialize subdev */
 	ov13858->sd.internal_ops = &ov13858_internal_ops;
@@ -1729,6 +1875,10 @@ static int ov13858_probe(struct i2c_client *client)
 
 error_handler_free:
 	ov13858_free_controls(ov13858);
+
+error_power_off:
+	ov13858_sensor_powerdown(ov13858);
+
 	dev_err(ov13858->dev, "%s failed:%d\n", __func__, ret);
 
 	return ret;
@@ -1744,6 +1894,9 @@ static void ov13858_remove(struct i2c_client *client)
 	ov13858_free_controls(ov13858);
 
 	pm_runtime_disable(ov13858->dev);
+	if (!pm_runtime_status_suspended(ov13858->dev))
+		ov13858_sensor_powerdown(ov13858);
+	pm_runtime_set_suspended(ov13858->dev);
 }
 
 static const struct i2c_device_id ov13858_id_table[] = {
@@ -1765,6 +1918,7 @@ MODULE_DEVICE_TABLE(acpi, ov13858_acpi_ids);
 static struct i2c_driver ov13858_i2c_driver = {
 	.driver = {
 		.name = "ov13858",
+		.pm = &ov13858_pm_ops,
 		.acpi_match_table = ACPI_PTR(ov13858_acpi_ids),
 	},
 	.probe = ov13858_probe,
diff --git a/drivers/media/i2c/ov5693.c b/drivers/media/i2c/ov5693.c
index d294477f9dd30..46bc6c5b77580 100644
--- a/drivers/media/i2c/ov5693.c
+++ b/drivers/media/i2c/ov5693.c
@@ -1396,6 +1396,7 @@ static const struct dev_pm_ops ov5693_pm_ops = {
 
 static const struct acpi_device_id ov5693_acpi_match[] = {
 	{"INT33BE"},
+	{"OVTI5693"},
 	{},
 };
 MODULE_DEVICE_TABLE(acpi, ov5693_acpi_match);
diff --git a/drivers/media/pci/intel/ipu-bridge.c b/drivers/media/pci/intel/ipu-bridge.c
index 4e579352ab2c0..ac637207b6444 100644
--- a/drivers/media/pci/intel/ipu-bridge.c
+++ b/drivers/media/pci/intel/ipu-bridge.c
@@ -60,6 +60,10 @@ static const struct ipu_sensor_config ipu_supported_sensors[] = {
 	IPU_SENSOR_CONFIG("INT33BE", 1, 419200000),
 	/* Onsemi MT9M114 */
 	IPU_SENSOR_CONFIG("INT33F0", 1, 384000000),
+	/* Omnivision OV5693 - Surface Pro 9 */
+	IPU_SENSOR_CONFIG("OVTI5693", 1, 419200000),
+	/* Omnivision OV13858 - Surface Pro 9 */
+	IPU_SENSOR_CONFIG("OVTID858", 4, 540000000),
 	/* Omnivision OV2740 */
 	IPU_SENSOR_CONFIG("INT3474", 1, 180000000),
 	/* Omnivision OV5670 */
diff --git a/drivers/platform/x86/intel/int3472/discrete.c b/drivers/platform/x86/intel/int3472/discrete.c
index 1505fc3ef7a85..20962e8acb263 100644
--- a/drivers/platform/x86/intel/int3472/discrete.c
+++ b/drivers/platform/x86/intel/int3472/discrete.c
@@ -229,6 +229,14 @@ static void int3472_get_con_id_and_polarity(struct int3472_discrete_device *int3
 		/* Setups using a handshake pin need 25 ms enable delay */
 		*enable_time_us = 25 * USEC_PER_MSEC;
 		break;
+	case 0x08:  /* Surface Pro 9 - additional power rail */
+		*con_id = "pwr1";
+		*gpio_flags = GPIO_ACTIVE_HIGH;
+		break;
+	case 0x10:  /* Surface Pro 9 - secondary power rail */
+		*con_id = "pwr2";
+		*gpio_flags = GPIO_ACTIVE_HIGH;
+		break;
 	default:
 		*con_id = "unknown";
 		*gpio_flags = GPIO_ACTIVE_HIGH;
@@ -333,6 +341,8 @@ static int skl_int3472_handle_gpio_resources(struct acpi_resource *ares,
 	case INT3472_GPIO_TYPE_PRIVACY_LED:
 	case INT3472_GPIO_TYPE_POWER_ENABLE:
 	case INT3472_GPIO_TYPE_HANDSHAKE:
+	case 0x08:  /* Surface Pro 9 power rails */
+	case 0x10:
 		gpio = skl_int3472_gpiod_get_from_temp_lookup(int3472, agpio, con_id, gpio_flags);
 		if (IS_ERR(gpio)) {
 			ret = PTR_ERR(gpio);
@@ -363,6 +373,19 @@ static int skl_int3472_handle_gpio_resources(struct acpi_resource *ares,
 				err_msg = "Failed to register regulator\n";
 
 			break;
+		case 0x08:  /* Surface Pro 9 - treat as power*/
+		    dev_info(int3472->dev, "GPIO type 0x%02x detected on pin 0x%02x\n", type, agpio->pin_table[0]);
+		    dev_info(int3472->dev, "  con_id=%s, flags=0x%x\n", con_id, gpio_flags);
+		    ret = skl_int3472_register_regulator(int3472, gpio,
+			 GPIO_REGULATOR_ENABLE_TIME,
+			 con_id, NULL);
+		    dev_info(int3472->dev, "  register_regulator returned: %d\n", ret);
+		    if (ret) {
+			dev_err(int3472->dev, "Failed to register type 0x02x: %d\n", type, ret);
+		    }
+		    break;
+		case 0x10:
+		    break;
 		default: /* Never reached */
 			ret = -EINVAL;
 			break;
